using System.CodeDom.Compiler;
using System.Collections.ObjectModel;
using Mono.Cecil;

static class WriterExtensions
{
    public static void WriteBlankLine(this IndentedTextWriter w) => w.WriteLineNoTabs(null);

    public static void WriteLicense(this IndentedTextWriter w, string singleLineComment = "//") =>
        w.WriteLine(
            $"{singleLineComment} WARNING: Please don't edit this file. It was generated by Python/WinRT v{PyWinRT.VersionString}"
        );

    public static void WriteFileIfChanged(this StringWriter w, DirectoryInfo path, string fileName)
    {
        var filePath = Path.Combine(path.FullName, fileName);
        var newContent = w.ToString();

        // don't write the file if it hasn't changed, otherwise it
        // triggers any file watches and may cause unnecessary rebuilds
        if (File.Exists(filePath))
        {
            var oldContent = File.ReadAllText(filePath);

            if (oldContent == newContent)
            {
                return;
            }
        }
        else
        {
            Directory.CreateDirectory(path.FullName);
        }

        File.WriteAllText(filePath, newContent);
    }

    public static void WriteBlock(this IndentedTextWriter w, Action writeInner, string suffix = "")
    {
        w.WriteLine("{");
        w.Indent++;
        writeInner();
        w.Indent--;
        w.WriteLine($"}}{suffix}");
    }

    public static void WriteInspectableType(
        this IndentedTextWriter w,
        ProjectedType type,
        bool componentDlls,
        string moduleSuffix
    )
    {
        var category = type.Category.ToString().ToLowerInvariant();

        w.WriteLine($"// ----- {type.Name} {category} --------------------");

        if (type.HasComposableFactory)
        {
            w.WriteBlankLine();
            w.WriteComposableTypeImpl(type);
        }

        w.WriteNewFunction(type);
        w.WriteDeallocFunction(type);
        w.WriteMethodFunctions(type, componentDlls);
        w.WriteMethodTable(type);
        w.WriteGetSetTable(type);
        w.WriteTypeSlotTable(type);
        w.WriteTypeSpec(type, moduleSuffix);

        if (type.PyRequiresMetaclass)
        {
            w.WriteMetaclass(type, moduleSuffix);
        }
    }

    public static void WriteMetaclass(
        this IndentedTextWriter w,
        ProjectedType type,
        string moduleSuffix
    )
    {
        w.WriteMetaclassPropertyGetsetTable(type);
        w.WriteMetaclassMethodTable(type);

        w.WriteBlankLine();
        w.WriteLine($"static PyType_Slot type_slots_{type.Name}_Static[] = ");
        w.WriteBlock(
            () =>
            {
                w.WriteLine("{ Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },");
                w.WriteLine(
                    $"{{ Py_tp_getset, reinterpret_cast<void*>(getset_{type.Name}_Static) }},"
                );
                w.WriteLine(
                    $"{{ Py_tp_methods, reinterpret_cast<void*>(methods_{type.Name}_Static) }},"
                );
                w.WriteLine("{ }");
            },
            ";"
        );

        w.WriteBlankLine();
        w.WriteLine($"static PyType_Spec type_spec_{type.Name}_Static = {{");
        w.Indent++;
        w.WriteLine(
            $"\"winrt.{type.PyExtModuleName}{moduleSuffix}.{type.PyWrapperTypeName}_Static\","
        );
        w.WriteLine("static_cast<int>(PyType_Type.tp_basicsize),");
        w.WriteLine("static_cast<int>(PyType_Type.tp_itemsize),");
        w.WriteLine($"Py_TPFLAGS_DEFAULT{(type.IsComposable ? " | Py_TPFLAGS_BASETYPE" : "")},");
        w.WriteLine($"type_slots_{type.Name}_Static}};");
        w.Indent--;
    }

    static void WriteMetaclassPropertyGetsetTable(this IndentedTextWriter w, ProjectedType type)
    {
        var typeName = type.Name.ToNonGeneric();

        w.WriteBlankLine();
        w.WriteLine($"static PyGetSetDef getset_{typeName}_Static[] = {{");
        w.Indent++;
        foreach (var prop in type.Properties.Where(p => p.IsStatic))
        {
            var setter = prop.SetMethod is null
                ? "nullptr"
                : $"reinterpret_cast<setter>({type.Name}_put_{prop.Name})";

            w.WriteLine(
                $"{{ \"{prop.Name.ToPythonIdentifier(isTypeMethod: true)}\", reinterpret_cast<getter>({typeName}_get_{prop.Name}), {setter}, nullptr, nullptr }},"
            );
        }

        if (type.Type.IsCustomNumeric())
        {
            w.WriteNumberCommonValuesGetSetDefs(type);
        }

        w.WriteLine("{ }};");
        w.Indent--;
    }

    static void WriteMetaclassMethodTable(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();
        w.WriteLine($"static PyMethodDef methods_{type.Name}_Static[] = {{");
        w.Indent++;

        foreach (var method in type.Methods.Where(m => m.IsStatic).DistinctBy(m => m.Name))
        {
            w.WriteLine(
                $"{{ \"{method.PyName}\", reinterpret_cast<PyCFunction>({type.Name}_{method.Name}), METH_VARARGS, nullptr }},"
            );
        }

        foreach (var @event in type.Events.Where(e => e.IsStatic))
        {
            w.WriteLine(
                $"{{ \"{@event.AddMethod.PyName}\", reinterpret_cast<PyCFunction>({type.Name}_{@event.AddMethod.Name}), METH_O, nullptr }},"
            );
            w.WriteLine(
                $"{{ \"{@event.RemoveMethod.PyName}\", reinterpret_cast<PyCFunction>({type.Name}_{@event.RemoveMethod.Name}), METH_O, nullptr }},"
            );
        }

        if (type.Type.IsCustomNumeric())
        {
            w.WriteNumberFactoryFunctionDefs(type);
        }

        w.WriteLine("{ }};");
        w.Indent--;
    }

    public static void WriteTypeSpec(
        this IndentedTextWriter w,
        ProjectedType type,
        string moduleSuffix
    )
    {
        w.WriteBlankLine();
        w.WriteLine($"static PyType_Spec type_spec_{type.Name} = {{");
        w.Indent++;
        w.WriteLine($"\"winrt.{type.PyExtModuleName}{moduleSuffix}.{type.PyWrapperTypeName}\",");

        if (type.IsStatic)
        {
            w.WriteLine("0,");
        }
        else
        {
            w.WriteLine($"sizeof({type.CppPyWrapperType}),");
        }

        w.WriteLine("0,");
        w.WriteLine($"Py_TPFLAGS_DEFAULT{(type.IsComposable ? " | Py_TPFLAGS_BASETYPE" : "")},");
        w.WriteLine($"_type_slots_{type.Name}}};");
        w.Indent--;
    }

    public static void WriteTypeSlotTable(this IndentedTextWriter w, ProjectedType type)
    {
        var name = type.Name.ToNonGeneric();

        w.WriteBlankLine();
        w.WriteLine($"static PyType_Slot _type_slots_{name}[] = {{");
        w.Indent++;
        w.WriteLine($"{{ Py_tp_new, reinterpret_cast<void*>(_new_{name}) }},");

        if (!type.IsStatic)
        {
            w.WriteLine($"{{ Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_{name}) }},");
        }

        w.WriteLine($"{{ Py_tp_methods, reinterpret_cast<void*>(_methods_{name}) }},");
        w.WriteLine($"{{ Py_tp_getset, reinterpret_cast<void*>(_getset_{name}) }},");

        if (type.Type.IsCustomNumeric() && type.Name != "Plane")
        {
            w.WriteNumberSlots(type);
        }

        if (type.Category == Category.Struct)
        {
            w.WriteLine($"{{ Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_{name}) }},");
            w.WriteLine($"{{ Py_tp_repr, reinterpret_cast<void*>(_repr_{name}) }},");
        }

        if (type.IsPyBuffer)
        {
            w.WriteLine($"{{ Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_{name}) }},");
        }

        if (type.IsPyStringable)
        {
            w.WriteLine($"{{ Py_tp_str, reinterpret_cast<void*>(_str_{name}) }},");
        }

        if (type.IsPyAwaitable)
        {
            w.WriteLine($"{{ Py_am_await, reinterpret_cast<void*>(_await_{name}) }},");
        }

        if (type.IsPyIterable)
        {
            w.WriteLine($"{{ Py_tp_iter, reinterpret_cast<void*>(_iterator_{name}) }},");
        }

        if (type.IsPyIterator)
        {
            w.WriteLine($"{{ Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_{name}) }},");
        }

        if (type.IsPySequence)
        {
            w.WriteLine($"{{ Py_sq_length, reinterpret_cast<void*>(_seq_length_{name}) }},");
            w.WriteLine($"{{ Py_sq_item, reinterpret_cast<void*>(_seq_item_{name}) }},");
            w.WriteLine($"{{ Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_{name}) }},");

            if (type.IsPyMutableSequence)
            {
                w.WriteLine($"{{ Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_{name}) }},");
            }
        }

        if (type.IsPyMapping)
        {
            w.WriteLine($"{{ Py_sq_contains, reinterpret_cast<void*>(_map_contains_{name}) }},");
            w.WriteLine($"{{ Py_mp_length, reinterpret_cast<void*>(_map_length_{name}) }},");
            w.WriteLine($"{{ Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_{name}) }},");

            if (type.IsPyMutableMapping)
            {
                w.WriteLine(
                    $"{{ Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_{name}) }},"
                );
            }
        }

        w.WriteLine("{ }};");
        w.Indent--;
    }

    public static void WriteGetSetTable(this IndentedTextWriter w, ProjectedType type)
    {
        void writeRow(string fieldName, string getterName, string? setterName)
        {
            var setter = string.IsNullOrEmpty(setterName)
                ? "nullptr"
                : $"reinterpret_cast<setter>({type.Name}_{setterName})";

            w.WriteLine(
                $"{{ \"{fieldName.ToPythonIdentifier()}\", reinterpret_cast<getter>({type.Name}_{getterName}), {setter}, nullptr, nullptr }},"
            );
        }

        w.WriteBlankLine();
        w.WriteLine($"static PyGetSetDef _getset_{type.Name}[] = {{");
        w.Indent++;

        if (type.Category == Category.Struct)
        {
            foreach (var field in type.Type.Fields)
            {
                writeRow(field.Name, $"get_{field.Name}", null);
            }
        }
        else if (type.Category == Category.Class || type.Category == Category.Interface)
        {
            // static properties are implemented in the metaclass
            foreach (var prop in type.Properties.Where(p => !p.IsStatic))
            {
                writeRow(prop.Name, prop.GetMethod.Name, prop.SetMethod?.Name ?? "");
            }
        }

        w.WriteLine("{ }};");
        w.Indent--;
    }

    public static void WriteMethodTable(this IndentedTextWriter w, ProjectedType type)
    {
        static string getArgumentConventionFlag(ProjectedMethod method) =>
            method.Method.GetArgumentConvention() switch
            {
                ArgumentConvention.None => "METH_NOARGS",
                ArgumentConvention.Single => "METH_O",
                ArgumentConvention.Variable => "METH_VARARGS",
                _ => throw new NotImplementedException(),
            };

        void writeRow(ProjectedMethod method)
        {
            var argumentConventionFlag = getArgumentConventionFlag(method);

            w.WriteLine(
                $"{{ \"{method.PyName}\", reinterpret_cast<PyCFunction>({type.Name}_{method.Name}), {argumentConventionFlag}, nullptr }},"
            );
        }

        w.WriteBlankLine();
        w.WriteLine($"static PyMethodDef _methods_{type.Name}[] = {{");
        w.Indent++;

        foreach (var method in type.Methods.Where(m => !m.IsStatic).DistinctBy(m => m.Name))
        {
            writeRow(method);
        }

        if (type.Type.IsCustomNumeric())
        {
            w.WriteNumberMethodDefs(type);
        }

        foreach (var evt in type.Events.Where(e => !e.IsStatic))
        {
            writeRow(evt.AddMethod);
            writeRow(evt.RemoveMethod);
        }

        if (type.Category != Category.Interface && !(type.IsGeneric || type.IsStatic))
        {
            w.WriteLine(
                $"{{ \"_assign_array_\", _assign_array_{type.Name}, METH_O | METH_STATIC, nullptr }},"
            );
        }

        // TODO: support _from for generic types

        if (type.Category == Category.Class && !(type.IsGeneric || type.IsStatic))
        {
            w.WriteLine(
                $"{{ \"_from\", reinterpret_cast<PyCFunction>(_from_{type.Name}), METH_O | METH_STATIC, nullptr }},"
            );
        }

        if (type.IsPyCloseable)
        {
            w.WriteLine(
                $"{{ \"__enter__\", reinterpret_cast<PyCFunction>(_enter_{type.Name}), METH_NOARGS, nullptr }},"
            );
            w.WriteLine(
                $"{{ \"__exit__\", reinterpret_cast<PyCFunction>(_exit_{type.Name}), METH_VARARGS, nullptr }},"
            );
        }

        if (type.IsGeneric)
        {
            w.WriteLine(
                $"{{ \"__class_getitem__\", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR(\"See PEP 585\") }},"
            );
        }

        w.WriteLine("{ }};");
        w.Indent--;
    }

    static void WriteNewFunction(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();

        if (type.Category == Category.Interface)
        {
            w.WriteLine(
                $"static PyObject* _new_{type.Name}(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept"
            );
            w.WriteBlock(() =>
            {
                w.WriteLine(
                    $"static_assert(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);"
                );
                w.WriteLine(
                    $"py::set_invalid_activation_error(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);"
                );
                w.WriteLine("return nullptr;");
            });
        }
        else if (type.Category == Category.Class)
        {
            w.WriteClassNewFunction(type);
        }
    }

    public static void WriteDeallocFunction(this IndentedTextWriter w, ProjectedType type)
    {
        if (type.Category == Category.Class && type.IsStatic)
        {
            return;
        }

        w.WriteBlankLine();
        w.WriteLine($"static void _dealloc_{type.Name}({type.CppPyWrapperType}* self) noexcept");
        w.WriteBlock(() =>
        {
            w.WriteLine("auto tp = Py_TYPE(self);");
            w.WriteLine("std::destroy_at(&self->obj);");

            if (type.IsGeneric)
            {
                w.WriteLine("std::destroy_at(&self->impl);");
            }

            w.WriteLine("tp->tp_free(self);");
            w.WriteLine("Py_DECREF(tp);");
        });
    }

    static void WriteMethodFunctions(
        this IndentedTextWriter w,
        ProjectedType type,
        bool componentDlls
    )
    {
        foreach (
            var (methodName, isStatic, isProtected) in type
                .Methods.Select(m => (m.Name, m.IsStatic, m.IsProtected || m.IsOverridable))
                .Distinct()
        )
        {
            var selfParam = type.GetMethodSelfParam(isStatic);

            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* {type.Name}_{methodName}({selfParam}, PyObject* args) noexcept"
            );
            w.WriteBlock(() =>
            {
                if (type.IsGeneric)
                {
                    w.WriteLine($"return self->impl->{methodName}(args);");
                }
                else
                {
                    w.WriteMethodOverloads(type, methodName, componentDlls);
                }
            });
        }

        foreach (var prop in type.Properties)
        {
            w.WritePropertyGetFunction(type, prop, componentDlls);

            if (prop.SetMethod is not null)
            {
                w.WritePropertySetFunction(type, prop, componentDlls);
            }
        }

        foreach (var evt in type.Events)
        {
            w.WriteEventFunction(type, evt.AddMethod, evt.Name, componentDlls);
            w.WriteEventFunction(type, evt.RemoveMethod, evt.Name, componentDlls);
        }

        if (type.Category != Category.Interface && !(type.IsGeneric || type.IsStatic))
        {
            w.WriteBlankLine();
            w.WriteAssignArrayMethod(type);
        }

        if (type.Category == Category.Class && !(type.IsGeneric || type.IsStatic))
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _from_{type.Name}(PyObject* /*unused*/, PyObject* arg) noexcept"
            );
            w.WriteBlock(
                () =>
                    w.WriteTryCatch(() =>
                    {
                        w.WriteLine(
                            $"auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);"
                        );
                        w.WriteLine($"return py::convert(return_value.as<{type.CppWinrtType}>());");
                    })
            );
        }

        if (type.IsPyCloseable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _enter_{type.Name}({type.CppPyWrapperType}* self, PyObject* /*unused*/) noexcept"
            );
            w.WriteBlock(() => w.WriteLine("return Py_NewRef(self);"));

            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _exit_{type.Name}({type.CppPyWrapperType}* self, PyObject* /*unused*/) noexcept"
            );
            w.WriteBlock(
                () =>
                    w.WriteTryCatch(() =>
                    {
                        var closeMethod = type.Methods.Single(m => m.Name == "Close");

                        w.WriteBlock(() =>
                        {
                            w.WriteLine("auto _gil = py::release_gil();");
                            w.WriteLine($"{type.GetMethodInvokeContext(closeMethod)}Close();");
                        });
                        w.WriteBlankLine();
                        w.WriteLine("Py_RETURN_FALSE;");
                    })
            );
        }

        if (type.IsPyBuffer)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static int _get_buffer_{type.Name}({type.CppPyWrapperType}* self, Py_buffer* view, int flags) noexcept"
            );
            w.WriteBlock(
                () =>
                    w.WriteTryCatch(
                        () =>
                            w.WriteLine(
                                $"return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.{type.PyBufferSize}()), 0, flags);"
                            ),
                        () =>
                        {
                            w.WriteLine("view->obj = nullptr;");
                            // TODO: attach C++ exception info to Python exception
                            w.WriteLine("PyErr_SetNone(PyExc_BufferError);");
                        },
                        "-1"
                    )
            );
        }

        if (type.IsPyStringable)
        {
            var method = type.Methods.Single(m => m.Name == "ToString");

            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _str_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            w.WriteBlock(
                () =>
                    w.WriteTryCatch(() =>
                    {
                        w.WriteLine("return py::convert([&]()");
                        w.WriteBlock(
                            () =>
                            {
                                w.WriteLine("auto _gil = py::release_gil();");
                                w.WriteLine(
                                    $"return {type.GetMethodInvokeContext(method)}ToString();"
                                );
                            },
                            "());"
                        );
                    })
            );
        }

        void writeBody(string methodCall, Action writeCType)
        {
            w.WriteBlock(() =>
            {
                if (type.IsGeneric)
                {
                    w.WriteLine($"return self->impl->{methodCall};");
                }
                else
                {
                    writeCType();
                }
            });
        }

        if (type.IsPyAwaitable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _await_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            writeBody("dunder_await()", () => w.WriteLine("return py::dunder_await(self->obj);"));
        }

        if (type.IsPyIterable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _iterator_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            writeBody("dunder_iter()", () => w.WriteDunderIterBody(type));
        }

        if (type.IsPyIterator)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _iterator_next_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            writeBody("dunder_iternext()", () => w.WriteDunderIterNextBody(type));
        }

        if (type.IsPySequence)
        {
            w.WriteSeqMethodFunctions(type, writeBody);
        }

        if (type.IsPyMapping)
        {
            w.WriteMapMethodFunctions(type, writeBody);
        }
    }

    static void WriteEventFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedMethod method,
        string evtName,
        bool componentDlls
    )
    {
        var self = method.IsStatic ? "PyObject* /*unused*/" : $"{type.CppPyWrapperType}* self";

        w.WriteBlankLine();
        w.WriteLine($"static PyObject* {type.Name}_{method.Name}({self}, PyObject* arg) noexcept");
        w.WriteBlock(
            () =>
                w.WriteTryCatch(() =>
                {
                    if (!componentDlls)
                    {
                        w.WriteLine("static std::optional<bool> is_event_present{};");
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_event_present.has_value())");
                        w.WriteBlock(
                            () =>
                                w.WriteLine(
                                    $"is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L\"{method.Method.DeclaringType.Namespace}.{method.Method.DeclaringType.Name}\", L\"{evtName}\");"
                                )
                        );
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_event_present.value())");
                        w.WriteBlock(() =>
                        {
                            w.WriteLine(
                                "PyErr_SetString(PyExc_AttributeError, \"event is not available in this version of Windows\");"
                            );
                            w.WriteLine("return nullptr;");
                        });
                        w.WriteBlankLine();
                    }

                    if (type.IsGeneric)
                    {
                        w.WriteLine($"return self->impl->{method.Name}(arg);");
                    }
                    else
                    {
                        w.WriteMethodBodyContents(type, method);
                    }
                })
        );
    }

    static void WritePropertyGetFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedProperty prop,
        bool componentDlls
    )
    {
        var self = type.GetMethodSelfParam(prop.IsStatic);

        w.WriteBlankLine();
        w.WriteLine(
            $"static PyObject* {type.Name}_{prop.GetMethod.Name}({self}, void* /*unused*/) noexcept"
        );
        w.WriteBlock(
            () =>
                w.WriteTryCatch(() =>
                {
                    if (!componentDlls)
                    {
                        w.WriteLine("static std::optional<bool> is_property_present{};");
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_property_present.has_value())");
                        w.WriteBlock(
                            () =>
                                w.WriteLine(
                                    $"is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L\"{prop.Property.DeclaringType.Namespace}.{prop.Property.DeclaringType.Name}\", L\"{prop.Name}\");"
                                )
                        );
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_property_present.value())");
                        w.WriteBlock(() =>
                        {
                            w.WriteLine(
                                "PyErr_SetString(PyExc_AttributeError, \"property is not available in this version of Windows\");"
                            );
                            w.WriteLine("return nullptr;");
                        });
                        w.WriteBlankLine();
                    }

                    if (type.IsGeneric)
                    {
                        w.WriteLine($"return self->impl->{prop.GetMethod.Name}();");
                    }
                    else
                    {
                        w.WriteMethodBodyContents(type, prop.GetMethod);
                    }
                })
        );
    }

    static void WritePropertySetFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedProperty prop,
        bool componentDlls
    )
    {
        if (prop.SetMethod is null)
        {
            throw new ArgumentException("Property has no setter.", nameof(prop));
        }

        var self = type.GetMethodSelfParam(prop.IsStatic);

        w.WriteBlankLine();
        w.WriteLine(
            $"static int {type.Name}_{prop.SetMethod.Name}({self}, PyObject* arg, void* /*unused*/) noexcept"
        );
        w.WriteBlock(() =>
        {
            w.WriteLine("if (!arg)");
            w.WriteBlock(() =>
            {
                w.WriteLine("PyErr_SetString(PyExc_AttributeError, \"can't delete attribute\");");
                w.WriteLine("return -1;");
            });
            w.WriteBlankLine();

            w.WriteTryCatch(
                () =>
                {
                    if (!componentDlls)
                    {
                        w.WriteLine("static std::optional<bool> is_property_present{};");
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_property_present.has_value())");
                        w.WriteBlock(() =>
                        {
                            w.WriteLine(
                                $"is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L\"{prop.Property.DeclaringType.Namespace}.{prop.Property.DeclaringType.Name}\", L\"{prop.Name}\");"
                            );
                        });
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_property_present.value())");
                        w.WriteBlock(() =>
                        {
                            w.WriteLine(
                                "PyErr_SetString(PyExc_AttributeError, \"property is not available in this version of Windows\");"
                            );
                            w.WriteLine("return -1;");
                        });
                        w.WriteBlankLine();
                    }

                    if (type.IsGeneric)
                    {
                        w.WriteLine($"return self->impl->{prop.SetMethod.Name}(arg);");
                    }
                    else
                    {
                        w.WriteMethodBodyContents(type, prop.SetMethod, isPropertySetter: true);
                    }
                },
                catchReturn: "-1"
            );
        });
    }

    public static void WriteAssignArrayMethod(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteLine(
            $"static PyObject* _assign_array_{type.Name}(PyObject* /*unused*/, PyObject* arg) noexcept"
        );
        w.WriteBlock(() =>
        {
            w.WriteLine($"auto array = std::make_unique<py::ComArray<{type.CppWinrtType}>>();");
            w.WriteLine("if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteLine("Py_RETURN_NONE;");
        });
    }

    public static void WriteMethodOverloads(
        this IndentedTextWriter w,
        ProjectedType type,
        string methodName,
        bool componentDlls
    )
    {
        w.WriteLine("auto arg_count = PyTuple_Size(args);");
        w.WriteBlankLine();

        foreach (
            var (i, method) in type
                .Methods.Where(m => m.Name == methodName)
                .Select((m, i) => (i, m))
        )
        {
            var pyInParamCount = method.Method.Parameters.Count(p => p.IsPythonInParam());
            var inParamCount = method.Method.Parameters.Count(p => p.IsInParam());
            var ns = type.Namespace;

            if (i > 0)
            {
                w.Write("else ");
            }

            w.WriteLine($"if (arg_count == {pyInParamCount})");
            w.WriteBlock(() =>
            {
                w.WriteTryCatch(() =>
                {
                    if (!componentDlls)
                    {
                        w.WriteLine("static std::optional<bool> is_overload_present{};");
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_overload_present.has_value())");
                        w.WriteBlock(
                            () =>
                                w.WriteLine(
                                    $"is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L\"{method.Method.DeclaringType.Namespace}.{method.Method.DeclaringType.Name}\", L\"{method.CppName}\", {inParamCount});"
                                )
                        );
                        w.WriteBlankLine();
                        w.WriteLine("if (!is_overload_present.value())");
                        w.WriteBlock(() =>
                        {
                            w.WriteLine($"py::set_arg_count_version_error({inParamCount});");
                            w.WriteLine("return nullptr;");
                        });
                        w.WriteBlankLine();
                    }

                    w.WriteMethodBodyContents(type, method);
                });
            });
        }

        w.WriteLine("else");
        w.WriteBlock(() =>
        {
            w.WriteLine("py::set_invalid_arg_count_error(arg_count);");
            w.WriteLine("return nullptr;");
        });
    }

    public static void WriteMethodBodyContents(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedMethod method,
        bool isPropertySetter = false
    )
    {
        if (method.IsConstructor)
        {
            throw new ArgumentException("Constructors are not allowed here.");
        }

        // instance property set methods are projected as Python setters,
        // thus return 0 to indicate success
        var voidReturn = isPropertySetter ? "return 0;" : "Py_RETURN_NONE;";

        // convert in params from Python -> C++
        foreach (var param in method.Method.Parameters)
        {
            w.WriteMethodParamDefinition(method, param);
        }

        if (method.Method.Parameters.Count > 0)
        {
            w.WriteBlankLine();
        }

        // Invoke member - simplified code path for methods w/ no out params
        if (!method.Method.Parameters.Any(p => p.IsPythonOutParam()))
        {
            var context = type.GetMethodInvokeContext(method);

            if (method.Method.ReturnType.FullName == "System.Void")
            {
                w.WriteBlock(() =>
                {
                    w.WriteLine("auto _gil = release_gil();");
                    w.WriteLine(
                        $"{context}{method.CppName}({method.Method.Parameters.ToParameterList()});"
                    );
                });
                w.WriteBlankLine();

                w.WriteLine(voidReturn);
            }
            else
            {
                var paramList = method.Method.Parameters.ToParameterList();

                w.WriteLine("return py::convert([&]()");
                w.WriteBlock(
                    () =>
                    {
                        w.WriteLine("auto _gil = release_gil();");
                        w.WriteLine($"return {context}{method.CppName}({paramList});");
                    },
                    "());"
                );
            }

            return;
        }

        // Invoke member - code path for methods w/ out params

        if (method.Method.ReturnType.FullName == "System.Void")
        {
            w.WriteBlock(() =>
            {
                w.WriteLine("auto _gil = release_gil();");
                w.WriteLine(
                    $"{type.GetMethodInvokeContext(method)}{method.CppName}({method.Method.Parameters.ToParameterList()});"
                );
            });
        }
        else
        {
            w.WriteLine($"auto return_value = [&]()");
            w.WriteBlock(
                () =>
                {
                    w.WriteLine("auto _gil = release_gil();");
                    w.WriteLine(
                        $"return {type.GetMethodInvokeContext(method)}{method.CppName}({method.Method.Parameters.ToParameterList()});"
                    );
                },
                "();"
            );
        }

        w.WriteBlankLine();

        // Convert return values and out parameters from C++ -> Python

        var returnValues = new List<string>();

        if (method.Method.ReturnType.FullName != "System.Void" || method.IsConstructor)
        {
            w.WriteLine($"py::pyobj_handle out_return_value{{ py::convert(return_value) }};");
            w.WriteLine("if (!out_return_value)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));

            returnValues.Add("out_return_value");
        }

        foreach (var param in method.Method.Parameters.Where(p => p.IsPythonOutParam()))
        {
            var outParam = $"out{param.Index}";

            w.WriteLine($"py::pyobj_handle {outParam}{{ py::convert({param.ToParamName()}) }};");
            w.WriteLine($"if (!{outParam})");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));

            returnValues.Add(outParam);
        }

        w.WriteBlankLine();

        // Return Python projected return/out params

        if (returnValues.Count == 0)
        {
            w.WriteLine(voidReturn);
        }
        else if (returnValues.Count == 1)
        {
            w.WriteLine($"return {returnValues[0]}.detach();");
        }
        else
        {
            w.WriteLine(
                $"return PyTuple_Pack({returnValues.Count}, {string.Join(", ", returnValues.Select(p => $"{p}.get()"))});"
            );
        }
    }

    static void WriteClassNewFunction(this IndentedTextWriter w, ProjectedType type)
    {
        if (type.IsStatic || type.Constructors.Count == 0)
        {
            w.WriteLine(
                $"static PyObject* _new_{type.Name}(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept"
            );
        }
        else
        {
            w.WriteLine(
                $"static PyObject* _new_{type.Name}(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept"
            );
        }

        w.WriteBlock(() =>
        {
            if (type.IsStatic || type.Constructors.Count == 0)
            {
                w.WriteLine(
                    $"static_assert(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);"
                );
                w.WriteLine(
                    $"py::set_invalid_activation_error(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);"
                );
                w.WriteLine("return nullptr;");
            }
            else
            {
                w.WriteLine("if (kwds)");
                w.WriteBlock(() =>
                {
                    w.WriteLine("py::set_invalid_kwd_args_error();");
                    w.WriteLine("return nullptr;");
                });
                w.WriteBlankLine();

                w.WriteLine("auto arg_count = PyTuple_Size(args);");

                if (type.IsComposable)
                {
                    w.WriteBlankLine();

                    w.WriteLine($"auto self_type = get_python_type_for<{type.CppWinrtType}>();");
                    w.WriteLine("if (!self_type)");
                    w.WriteBlock(() => w.WriteLine("return nullptr;"));
                    w.WriteBlankLine();
                }

                foreach (var (i, ctor) in type.Constructors.Select((c, i) => (i, c)))
                {
                    if (i > 0)
                    {
                        w.Write("else ");
                    }

                    w.WriteLine($"if (arg_count == {ctor.Method.Parameters.Count})");
                    w.WriteBlock(
                        () =>
                            w.WriteTryCatch(() =>
                            {
                                foreach (var param in ctor.Method.Parameters)
                                {
                                    w.WriteMethodParamDefinition(ctor, param);
                                }

                                if (ctor.Method.Parameters.Count > 0)
                                {
                                    w.WriteBlankLine();
                                }

                                if (type.IsComposable)
                                {
                                    w.WriteLine("if (type != self_type)");
                                    w.WriteBlock(() =>
                                    {
                                        if (type.HasComposableFactory)
                                        {
                                            w.WriteLine(
                                                $"py::pyobj_handle self{{type->tp_alloc(type, 0)}};"
                                            );
                                            w.WriteLine("if (!self)");
                                            w.WriteBlock(() => w.WriteLine("return nullptr;"));
                                            w.WriteBlankLine();

                                            string ctorParams =
                                                ctor.Method.Parameters.Count > 0
                                                    ? $"self.get(), {ctor.Method.Parameters.ToParameterList()}"
                                                    : "self.get()";

                                            // NB: doing construct_at with nullptr first in case of exception,
                                            // otherwise we will destruct an uninitialized value when pyobj_handle
                                            // goes out of scope
                                            w.WriteLine(
                                                $"std::construct_at(&reinterpret_cast<{type.CppPyWrapperType}*>(self.get())->obj, nullptr);"
                                            );
                                            w.WriteBlankLine();
                                            w.WriteLine(
                                                $"auto obj_impl = winrt::make_self<PyWinrt{type.Name}>({ctorParams});"
                                            );
                                            w.WriteBlankLine();
                                            w.WriteLine(
                                                $"auto obj = py::make_py_obj<PyWinrt{type.Name}>(obj_impl, type, self.get());"
                                            );
                                            w.WriteLine("if (!obj)");
                                            w.WriteBlock(() => w.WriteLine("return nullptr;"));
                                            w.WriteBlankLine();
                                            w.WriteLine(
                                                $"reinterpret_cast<{type.CppPyWrapperType}*>(self.get())->obj = std::move(obj);"
                                            );
                                            w.WriteBlankLine();

                                            w.WriteLine("return self.detach();");
                                        }
                                        else
                                        {
                                            w.WriteLine(
                                                "py::set_invalid_activation_error(type->tp_name);"
                                            );
                                            w.WriteLine("return nullptr;");
                                        }
                                    });
                                    w.WriteBlankLine();
                                }

                                w.WriteLine(
                                    $"{type.CppPyWrapperTemplateType} instance{{{ctor.Method.Parameters.ToParameterList()}}};"
                                );
                                w.WriteLine("return py::wrap(instance, type);");
                            })
                    );
                }

                w.WriteLine("else");
                w.WriteBlock(() =>
                {
                    w.WriteLine("py::set_invalid_arg_count_error(arg_count);");
                    w.WriteLine("return nullptr;");
                });
            }
        });
    }

    public static void WriteMethodParamDefinition(
        this IndentedTextWriter w,
        ProjectedMethod method,
        ParameterDefinition param
    )
    {
        var category = param.GetCategory();
        var paramName = param.ToParamName();
        var typeName = param.ParameterType.ToCppTypeName(method.GenericArgMap);
        var writeable = category == ParamCategory.FillArray ? "true" : "false";
        var args = method.Method.ToConvertToArgs();

        switch (category)
        {
            case ParamCategory.In:
                w.WriteLine($"auto {paramName} = py::convert_to<{typeName}>({args(param.Index)});");
                break;
            case ParamCategory.Out:
                var elementType = param.ParameterType.GetElementType();
                var value =
                    elementType.FullName == "System.String"
                    || elementType.FullName == "System.Object"
                    || elementType.IsValueType
                        ? ""
                        : "nullptr";
                w.WriteLine($"{typeName} {paramName}{{{value}}};");
                break;
            case ParamCategory.PassArray:
            case ParamCategory.FillArray:
                w.WriteLine(
                    $"auto {paramName} = py::convert_to<py::pybuf_view<{typeName}, {writeable}>>({args(param.Index)});"
                );
                break;
            case ParamCategory.ReceiveArray:
                w.WriteLine($"winrt::com_array<{typeName}> {paramName}{{}};");
                break;
            default:
                throw new ArgumentException("Invalid param category");
        }
    }

    public static void WriteNamespaceInitialization(
        this IndentedTextWriter w,
        string ns,
        string moduleSuffix
    )
    {
        w.WriteLine($"// ----- {ns} Initialization --------------------");
        w.WriteBlankLine();
        w.WriteLine($"PyDoc_STRVAR(module_doc, \"{ns}\");");
        w.WriteBlankLine();
        w.WriteLine("static PyModuleDef module_def = {");
        w.Indent++;
        w.WriteLine("PyModuleDef_HEAD_INIT,");
        w.WriteLine($"\"{ns.ToNsModuleName()}{moduleSuffix}\",");
        w.WriteLine("module_doc,");
        w.WriteLine("0,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr};");
        w.Indent--;
    }

    private class TypeReferenceEqualityComparer : IEqualityComparer<TypeReference>
    {
        public bool Equals(TypeReference? x, TypeReference? y) => x?.FullName == y?.FullName;

        public int GetHashCode(TypeReference obj) => obj.FullName.GetHashCode();
    }

    public static void WriteNamespaceModuleInitFunction(
        this IndentedTextWriter w,
        string ns,
        Members members,
        int dependencyDepth,
        string moduleSuffix
    )
    {
        w.WriteLine($"PyMODINIT_FUNC PyInit_{ns.ToNsModuleName()}{moduleSuffix}(void) noexcept");
        w.WriteBlock(() =>
        {
            w.WriteLine($"using namespace py::cpp::{ns.ToCppNamespace()};");
            w.WriteBlankLine();

            w.WriteLine("if (py::import_winrt_runtime() == -1)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();

            w.WriteLine("py::pyobj_handle module{PyModule_Create(&module_def)};");
            w.WriteBlankLine();

            w.WriteLine("if (!module)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();

            if (members.Classes.Count != 0 || members.Interfaces.Count != 0)
            {
                w.WriteLine("auto inspectable_meta_type = py::get_inspectable_meta_type();");
                w.WriteLine("if (!inspectable_meta_type)");
                w.WriteBlock(() => w.WriteLine("return nullptr;"));
                w.WriteBlankLine();
            }

            w.WriteLine("auto object_type = py::get_object_type();");
            w.WriteLine("if (!object_type)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();

            w.WriteLine("py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};");
            w.WriteBlankLine();
            w.WriteLine("if (!object_bases)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();

            foreach (
                var bts in members
                    .Classes.Where(c => c.CircularDependencyDepth == dependencyDepth)
                    .Select(c =>
                        (
                            c.Type.BaseType,
                            DependencyDepth: c.Type.BaseType.GetCircularDependencyDepth()
                        )
                    )
                    .Where(t =>
                        t.BaseType.Namespace != "System"
                        && (t.BaseType.Namespace != ns || t.DependencyDepth != dependencyDepth)
                    )
                    .GroupBy(t => (t.BaseType.Namespace, t.DependencyDepth))
            )
            {
                var (bns, bdd) = bts.Key;
                var suffix = bdd == 0 ? "" : $"_{bdd + 1}";

                w.WriteLine(
                    $"py::pyobj_handle {bns.ToPyModuleAlias()}{suffix}_module{{PyImport_ImportModule(\"winrt.{bns.ToNsModuleName()}{suffix}\")}};"
                );
                w.WriteLine($"if (!{bns.ToPyModuleAlias()}{suffix}_module)");
                w.WriteBlock(() => w.WriteLine("return nullptr;"));
                w.WriteBlankLine();

                foreach (
                    var bt in bts.Select(t => t.BaseType)
                        .Distinct(new TypeReferenceEqualityComparer())
                )
                {
                    w.WriteLine(
                        $"py::pyobj_handle {bns.ToPyModuleAlias()}_{bt.Name}_type{{PyObject_GetAttrString({bns.ToPyModuleAlias()}{suffix}_module.get(), \"{bt.Name}\")}};"
                    );
                    w.WriteLine($"if (!{bns.ToPyModuleAlias()}_{bt.Name}_type)");
                    w.WriteBlock(() => w.WriteLine("return nullptr;"));
                    w.WriteBlankLine();
                }
            }

            foreach (
                var t in members
                    .Classes.OrderByDependency()
                    .Concat(members.Interfaces)
                    .Concat(members.Structs.Where(s => !s.Type.IsCustomizedStruct()))
                    .Where(t => t.CircularDependencyDepth == dependencyDepth)
            )
            {
                w.WriteNamespaceInitPythonType(t);

                if (t.Category == Category.Struct)
                {
                    w.WriteLine(
                        $"py::pyobj_handle {t.Name}_from_tuple_capsule{{PyCapsule_New(reinterpret_cast<void*>({t.Name}_from_tuple),\"winrt.{t.PyExtModuleName}.{t.Name}_from_tuple\", nullptr)}};"
                    );
                    w.WriteLine($"if (!{t.Name}_from_tuple_capsule)");
                    w.WriteBlock(() => w.WriteLine("return nullptr;"));
                    w.WriteBlankLine();
                    w.WriteLine(
                        $"if (PyModule_AddObjectRef(module.get(), \"{t.Name}_from_tuple\", {t.Name}_from_tuple_capsule.get()) == -1)"
                    );
                    w.WriteBlock(() => w.WriteLine("return nullptr;"));
                }
            }

            w.WriteBlankLine();
            w.WriteLine("return module.detach();");
        });
    }

    /// <summary>
    /// Writes the type initialization for a binary extension Python type inside
    /// the module init function.
    /// </summary>
    static void WriteNamespaceInitPythonType(this IndentedTextWriter w, ProjectedType type)
    {
        var hasComposableBase =
            type.Type.BaseType is not null && type.Type.BaseType.Namespace != "System";

        var name = type.Name.ToNonGeneric();
        var metaclass = type.Category == Category.Class ? "inspectable_meta_type" : "nullptr";

        if (type.PyRequiresMetaclass)
        {
            if (type.Category == Category.Class)
            {
                var baseTypePtr = "inspectable_meta_type";

                if (hasComposableBase)
                {
                    var baseType = type.Type.BaseType!;
                    baseTypePtr = $"{baseType.Name}_type";

                    if (baseType.Namespace != type.Namespace)
                    {
                        baseTypePtr = $"{baseType.Namespace.ToPyModuleAlias()}_{baseTypePtr}";
                    }

                    baseTypePtr = $"Py_TYPE({baseTypePtr}.get())";
                }

                w.WriteLine(
                    $"py::pyobj_handle {name}_Static_bases{{PyTuple_Pack(1, reinterpret_cast<PyObject*>({baseTypePtr}))}};"
                );
                w.WriteLine($"if (!{name}_Static_bases)");
                w.WriteBlock(() => w.WriteLine("return nullptr;"));
                w.WriteBlankLine();

                w.WriteLine(
                    $"py::pyobj_handle type_{name}_Static{{PyType_FromSpecWithBases(&type_spec_{name}_Static, {name}_Static_bases.get())}};"
                );
            }
            else
            {
                w.WriteLine(
                    $"py::pyobj_handle type_{name}_Static{{PyType_FromSpec(&type_spec_{name}_Static)}};"
                );
            }

            w.WriteLine($"if (!type_{name}_Static)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();

            metaclass = $"reinterpret_cast<PyTypeObject*>(type_{name}_Static.get())";
        }

        if (hasComposableBase)
        {
            var baseType = type.Type.BaseType!;
            var baseName = baseType.Name;

            if (baseType.Namespace != type.Namespace)
            {
                baseName = $"{baseType.Namespace.ToPyModuleAlias()}_{baseName}";
            }

            w.WriteLine(
                $"py::pyobj_handle {name}_bases{{PyTuple_Pack(1, {baseName}_type.get())}};"
            );
            w.WriteLine($"if (!{name}_bases)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();
        }

        var bases = type.Category switch
        {
            Category.Class when hasComposableBase => $"{name}_bases.get()",
            Category.Class or Category.Interface => "object_bases.get()",
            _ => "nullptr"
        };

        w.WriteLine(
            $"py::pytype_handle {name}_type{{py::register_python_type(module.get(), &type_spec_{name}, {bases}, {metaclass})}};"
        );
        w.WriteLine($"if (!{name}_type)");
        w.WriteBlock(() => w.WriteLine("return nullptr;"));
        w.WriteBlankLine();

        if (type.Category == Category.Interface)
        {
            w.WriteLine(
                $"py::pytype_handle Implements{name}_type{{py::register_python_type(module.get(), &type_spec_Implements{name}, nullptr, inspectable_meta_type)}};"
            );
            w.WriteLine($"if (!Implements{name}_type)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();

            w.WriteLine($"if (PyModule_AddType(module.get(), Implements{name}_type.get()) == -1)");
            w.WriteBlock(() => w.WriteLine("return nullptr;"));
            w.WriteBlankLine();
        }
    }

    public static void WriteTryCatch(
        this IndentedTextWriter w,
        Action writeTryStatements,
        Action? writeCatchStatements = null,
        string catchReturn = "nullptr"
    )
    {
        w.WriteLine("try");
        w.WriteBlock(() => writeTryStatements());
        w.WriteLine("catch (...)");
        w.WriteBlock(() =>
        {
            if (writeCatchStatements is null)
            {
                w.WriteLine("py::to_PyErr();");
            }
            else
            {
                writeCatchStatements();
            }

            w.WriteLine($"return {catchReturn};");
        });
    }

    public static void WritePythonWrapperAlias(this IndentedTextWriter w, ProjectedType type)
    {
        var st =
            type.Category == Category.Class || type.Category == Category.Interface ? "" : "struct_";

        if (type.IsGeneric)
        {
            w.WriteLine(
                $"using {type.Name} = py::winrt_pinterface_wrapper<py::proj::{type.CppNamespace}::{type.Name}>;"
            );
        }
        else
        {
            w.WriteLine($"using {type.Name} = py::winrt_{st}wrapper<{type.CppWinrtType}>;");
        }
    }

    public static void WriteEnumBufferFormat(this IndentedTextWriter w, ProjectedType type)
    {
        var fmt = type.Type.HasFlagsAttribute() ? "I" : "i";

        w.WriteLine($"template<>");
        w.WriteLine(
            $"inline constexpr const char* buffer_format<{type.CppWinrtType}> = \"{fmt}\";"
        );
        w.WriteBlankLine();
    }

    public static void WritePyTypeSpecializationStruct(
        this IndentedTextWriter w,
        ProjectedType type
    )
    {
        w.WriteBlankLine();
        w.WriteLine($"template<>");
        w.WriteLine($"struct py_type<{type.CppPyWrapperTemplateType}>");
        w.WriteBlock(
            () =>
            {
                if (type.Category == Category.Struct)
                {
                    w.WriteLine(
                        $"static constexpr std::string_view from_tuple = \"winrt.{type.PyExtModuleName}.{type.Name}_from_tuple\";"
                    );
                }

                w.WriteLine(
                    $"static constexpr std::string_view qualified_name = \"{type.PyModuleName}.{type.PyWrapperTypeName}\";"
                );
                w.WriteLine($"static constexpr const char* module_name = \"{type.PyModuleName}\";");
                w.WriteLine(
                    $"static constexpr const char* type_name = \"{type.PyWrapperTypeName}\";"
                );
            },
            ";"
        );
    }

    public static void WritePythonMethodTyping(
        this IndentedTextWriter w,
        ProjectedMethod method,
        string ns,
        ReadOnlyDictionary<string, MethodNullabilityInfo> nullabilityMap,
        string self = "self",
        bool isAbstract = false
    )
    {
        var nullabilityInfo = nullabilityMap.GetValueOrDefault(
            method.Signature,
            new MethodNullabilityInfo(method.Method)
        );

        w.WriteLine($"# {method.Signature}");

        // REVISIT: can use @warning.deprecated in Python 3.13
        if (method.IsDeprecated)
        {
            w.WriteLine($"# @deprecated(\"{method.DeprecatedMessage}\")");
        }

        if (isAbstract)
        {
            w.WriteLine("@abstractmethod");
        }

        // HACK: There are a couple of problematic methods. Subclasses of
        // DependencyObject like to override SetValue with a different
        // parameter type. Subclasses of FlyoutBase like to override ShowAt.
        var typeIgnore = method.IsProblematicOverride() ? "  # type: ignore[misc,override]" : "";

        var paramList = "";

        if (method.Method.Parameters.Any(p => p.IsPythonInParam()))
        {
            paramList =
                $", {string.Join(", ", method.Method.Parameters.Where(p => p.IsPythonInParam()).Select(p => $"{p.Name.ToPythonIdentifier()}: {p.ToPyInParamTyping(ns, nullabilityInfo.Parameters[p.Index].Type, method.GenericArgMap)}"))}, /";
        }

        w.WriteLine(
            $"def {method.PyName}({self}{paramList}) -> {method.Method.ToPyReturnTyping(ns, nullabilityInfo, method.GenericArgMap)}: ...{typeIgnore}"
        );
    }

    public static void WritePythonPropertyTyping(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedProperty prop,
        string ns,
        ReadOnlyDictionary<string, MethodNullabilityInfo> nullabilityMap,
        string self = "self",
        bool isAbstract = false
    )
    {
        var name = prop.Name.ToPythonIdentifier(isTypeMethod: true);
        var getterNullabilityInfo = nullabilityMap.GetValueOrDefault(
            prop.GetMethod.Signature,
            new MethodNullabilityInfo(prop.GetMethod.Method)
        );
        var propType = prop.Property.PropertyType.ToPyTypeName(
            ns,
            getterNullabilityInfo.Return.Type
        );

        w.WriteLine($"# {prop.GetMethod.Signature}");

        // HACK: work around https://github.com/microsoft/cppwinrt/issues/1287
        // so far, this is the only case in the entire Windows SDK where
        // a property is entirely replaced with one of the same name
        string typeIgnore = type switch
        {
            { Namespace: "Windows.UI.Xaml.Controls.Maps", Name: "MapControl" }
                => prop switch
                {
                    { Name: "Style" } => "  # type: ignore[override]",
                    { Name: "StyleProperty" } => "  # type: ignore[misc]",
                    _ => "",
                },
            _ => "",
        };

        w.WriteLine($"@_property{typeIgnore}");

        if (type.IsComposable && prop.SetMethod == null)
        {
            w.WriteLine("@typing.final");
        }

        if (isAbstract)
        {
            w.WriteLine("@abstractmethod");
        }

        w.WriteLine($"def {name}({self}) -> {propType}: ...");

        if (prop.SetMethod is not null)
        {
            var setterNullabilityInfo = nullabilityMap.GetValueOrDefault(
                prop.SetMethod.Signature,
                new MethodNullabilityInfo(prop.SetMethod.Method)
            );
            var setType = prop
                .SetMethod.Method.Parameters[0]
                .ToPyInParamTyping(ns, setterNullabilityInfo.Parameters[0].Type);

            w.WriteLine($"# {prop.SetMethod.Signature}");

            w.WriteLine($"@{name}.setter");

            if (type.IsComposable)
            {
                w.WriteLine("@typing.final");
            }

            if (isAbstract)
            {
                w.WriteLine("@abstractmethod");
            }

            w.WriteLine($"def {name}({self}, value: {setType}) -> None: ...");
        }
    }
}
