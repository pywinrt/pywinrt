using System.CodeDom.Compiler;
using Mono.Cecil;
using Mono.Cecil.Rocks;

static class WriterExtensions
{
    public static void WriteBlankLine(this IndentedTextWriter w) => w.WriteLineNoTabs(null);

    public static void WriteLicense(this IndentedTextWriter w, string singleLineComment = "//") =>
        w.WriteLine(
            $"{singleLineComment} WARNING: Please don't edit this file. It was generated by Python/WinRT v{PyWinRT.VersionString}"
        );

    public static void WriteFileIfChanged(this StringWriter w, DirectoryInfo path, string fileName)
    {
        var filePath = Path.Combine(path.FullName, fileName);
        var newContent = w.ToString();

        // don't write the file if it hasn't changed, otherwise it
        // triggers any file watches and may cause unnecessary rebuilds
        if (File.Exists(filePath))
        {
            var oldContent = File.ReadAllText(filePath);

            if (oldContent == newContent)
            {
                return;
            }
        }
        else
        {
            Directory.CreateDirectory(path.FullName);
        }

        File.WriteAllText(filePath, newContent);
    }

    public static void WriteInspectableType(this IndentedTextWriter w, ProjectedType type)
    {
        var category = type.Category.ToString().ToLowerInvariant();

        w.WriteLine($"// ----- {type.Name} {category} --------------------");
        w.WriteNewFunction(type);
        w.WriteDeallocFunction(type);
        w.WriteMethodFunctions(type);
        w.WriteMethodTable(type);
        w.WriteGetSetTable(type);
        w.WriteTypeSlotTable(type);
        w.WriteTypeSpec(type);
        w.WriteMetaclass(type);
    }

    static void WriteMetaclass(this IndentedTextWriter w, ProjectedType type)
    {
        if (!type.PyRequiresMetaclass)
        {
            return;
        }

        w.WriteMetaclassPropertyGetsetTable(type);
        w.WriteMetaclassMethodTable(type);

        w.WriteBlankLine();
        w.WriteLine($"static PyType_Slot type_slots_{type.Name}_Static[] = ");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("{ Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },");
        w.WriteLine($"{{ Py_tp_getset, reinterpret_cast<void*>(getset_{type.Name}_Static) }},");
        w.WriteLine($"{{ Py_tp_methods, reinterpret_cast<void*>(methods_{type.Name}_Static) }},");
        w.WriteLine("{ }");
        w.Indent--;
        w.WriteLine("};");

        w.WriteBlankLine();
        w.WriteLine($"static PyType_Spec type_spec_{type.Name}_Static =");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine($"\"winrt.{type.Namespace.ToNsModuleName()}.{type.Name}_Static\",");
        w.WriteLine("static_cast<int>(PyType_Type.tp_basicsize),");
        w.WriteLine("static_cast<int>(PyType_Type.tp_itemsize),");
        w.WriteLine("Py_TPFLAGS_DEFAULT,");
        w.WriteLine($"type_slots_{type.Name}_Static");

        w.Indent--;
        w.WriteLine("};");
    }

    static void WriteMetaclassPropertyGetsetTable(this IndentedTextWriter w, ProjectedType type)
    {
        var typeName = type.Name.ToNonGeneric();

        w.WriteBlankLine();
        w.WriteLine($"static PyGetSetDef getset_{typeName}_Static[] = {{");
        w.Indent++;

        foreach (var prop in type.Properties.Where(p => p.IsStatic))
        {
            var setter = prop.SetMethod is null
                ? "nullptr"
                : $"reinterpret_cast<setter>({type.Name}_put_{prop.Name})";

            w.WriteLine(
                $"{{ \"{prop.Name.ToPythonIdentifier()}\", reinterpret_cast<getter>({typeName}_get_{prop.Name}), {setter}, nullptr, nullptr }},"
            );
        }

        w.WriteLine("{ }");
        w.Indent--;
        w.WriteLine("};");
    }

    static void WriteMetaclassMethodTable(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();
        w.WriteLine($"static PyMethodDef methods_{type.Name}_Static[] = {{");
        w.Indent++;

        foreach (var method in type.Methods.Where(m => m.IsStatic).DistinctBy(m => m.Name))
        {
            w.WriteLine(
                $"{{ \"{method.Name.ToPythonIdentifier()}\", reinterpret_cast<PyCFunction>({type.Name}_{method.Name}), METH_VARARGS, nullptr }},"
            );
        }

        w.WriteLine("{ }");
        w.Indent--;
        w.WriteLine("};");
    }

    static void WriteTypeSpec(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();
        w.WriteLine($"static PyType_Spec type_spec_{type.Name} = {{");
        w.Indent++;
        w.WriteLine($"\"winrt.{type.Namespace.ToNsModuleName()}.{type.Name}\",");

        if (type.IsStatic)
        {
            w.WriteLine("0,");
        }
        else
        {
            w.WriteLine($"sizeof({type.CppPyWrapperType}),");
        }

        w.WriteLine("0,");
        w.WriteLine("Py_TPFLAGS_DEFAULT,");
        w.WriteLine($"_type_slots_{type.Name}}};");
        w.Indent--;
    }

    static void WriteTypeSlotTable(this IndentedTextWriter w, ProjectedType type)
    {
        var name = type.Name.ToNonGeneric();

        w.WriteBlankLine();
        w.WriteLine($"static PyType_Slot _type_slots_{name}[] = ");
        // FIXME: move to previous line
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine($"{{ Py_tp_new, reinterpret_cast<void*>(_new_{name}) }},");
        if (type.Category == Category.Struct)
        {
            w.WriteLine($"{{ Py_tp_init, reinterpret_cast<void*>(_init_{name}) }},");
        }
        if (!type.IsStatic)
        {
            w.WriteLine($"{{ Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_{name}) }},");
        }

        w.WriteLine($"{{ Py_tp_methods, reinterpret_cast<void*>(_methods_{name}) }},");
        w.WriteLine($"{{ Py_tp_getset, reinterpret_cast<void*>(_getset_{name}) }},");

        if (type.IsPyBuffer)
        {
            w.WriteLine($"{{ Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_{name}) }},");
        }

        if (type.IsPyStringable)
        {
            w.WriteLine($"{{ Py_tp_str, reinterpret_cast<void*>(_str_{name}) }},");
        }

        if (type.IsPyAwaitable)
        {
            w.WriteLine($"{{ Py_am_await, reinterpret_cast<void*>(_await_{name}) }},");
        }

        if (type.IsPyIterable)
        {
            w.WriteLine($"{{ Py_tp_iter, reinterpret_cast<void*>(_iterator_{name}) }},");
        }

        if (type.IsPyIterator)
        {
            w.WriteLine($"{{ Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_{name}) }},");
        }

        if (type.IsPySequence)
        {
            w.WriteLine($"{{ Py_sq_length, reinterpret_cast<void*>(_seq_length_{name}) }},");
            w.WriteLine($"{{ Py_sq_item, reinterpret_cast<void*>(_seq_item_{name}) }},");
            w.WriteLine($"{{ Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_{name}) }},");

            if (type.IsPyMutableSequence)
            {
                w.WriteLine($"{{ Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_{name}) }},");
            }
        }

        if (type.IsPyMapping)
        {
            w.WriteLine($"{{ Py_sq_contains, reinterpret_cast<void*>(_map_contains_{name}) }},");
            w.WriteLine($"{{ Py_mp_length, reinterpret_cast<void*>(_map_length_{name}) }},");
            w.WriteLine($"{{ Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_{name}) }},");

            if (type.IsPyMutableMapping)
            {
                w.WriteLine(
                    $"{{ Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_{name}) }},"
                );
            }
        }

        // FIXME: remove trailing comma
        w.WriteLine("{ },");
        w.Indent--;
        w.WriteLine("};");
    }

    static void WriteGetSetTable(this IndentedTextWriter w, ProjectedType type)
    {
        void writeRow(string fieldName, string getterName, string? setterName)
        {
            var setter = string.IsNullOrEmpty(setterName)
                ? "nullptr"
                : $"reinterpret_cast<setter>({type.Name}_{setterName})";

            w.WriteLine(
                $"{{ \"{fieldName.ToPythonIdentifier()}\", reinterpret_cast<getter>({type.Name}_{getterName}), {setter}, nullptr, nullptr }},"
            );
        }

        w.WriteBlankLine();
        w.WriteLine($"static PyGetSetDef _getset_{type.Name}[] = {{");
        w.Indent++;

        if (type.Category == Category.Struct)
        {
            foreach (var field in type.Type.Fields)
            {
                writeRow(field.Name, $"get_{field.Name}", $"set_{field.Name}");
            }
        }
        else if (type.Category == Category.Class || type.Category == Category.Interface)
        {
            // static properties are implemented in the metaclass
            foreach (var prop in type.Properties.Where(p => !p.IsStatic))
            {
                writeRow(prop.Name, prop.GetMethod.Name, prop.SetMethod?.Name ?? "");
            }
        }

        w.WriteLine("{ }");
        w.Indent--;
        w.WriteLine("};");
    }

    static void WriteMethodTable(this IndentedTextWriter w, ProjectedType type)
    {
        static string getArgumentConventionFlag(ProjectedMethod method) =>
            method.Method.GetArgumentConvention() switch
            {
                ArgumentConvention.None => "METH_NOARGS",
                ArgumentConvention.Single => "METH_O",
                ArgumentConvention.Variable => "METH_VARARGS",
                _ => throw new NotImplementedException(),
            };

        void writeRow(ProjectedMethod method)
        {
            var argumentConventionFlag = getArgumentConventionFlag(method);
            var staticFlag = method.IsStatic || method.IsConstructor ? " | METH_STATIC" : "";

            w.WriteLine(
                $"{{ \"{method.Name.ToPythonIdentifier()}\", reinterpret_cast<PyCFunction>({type.Name}_{method.Name}), {argumentConventionFlag}{staticFlag}, nullptr }},"
            );
        }

        w.WriteBlankLine();
        w.WriteLine($"static PyMethodDef _methods_{type.Name}[] = {{");
        w.Indent++;

        foreach (var method in type.Methods.Where(m => !m.IsStatic).DistinctBy(m => m.Name))
        {
            writeRow(method);
        }

        // FIXME: this should only be non-static events
        foreach (var evt in type.Events)
        {
            writeRow(evt.AddMethod);
            writeRow(evt.RemoveMethod);
        }

        if (!(type.IsGeneric || type.IsStatic))
        {
            w.WriteLine(
                $"{{ \"_assign_array_\", _assign_array_{type.Name}, METH_O | METH_STATIC, nullptr }},"
            );
        }

        // TODO: support _from for generic types

        if (
            (type.Category == Category.Class || type.Category == Category.Interface)
            && !(type.IsGeneric || type.IsStatic)
        )
        {
            w.WriteLine(
                $"{{ \"_from\", reinterpret_cast<PyCFunction>(_from_{type.Name}), METH_O | METH_STATIC, nullptr }},"
            );
        }

        if (type.IsPyCloseable)
        {
            w.WriteLine(
                $"{{ \"__enter__\", reinterpret_cast<PyCFunction>(_enter_{type.Name}), METH_NOARGS, nullptr }},"
            );
            w.WriteLine(
                $"{{ \"__exit__\", reinterpret_cast<PyCFunction>(_exit_{type.Name}), METH_VARARGS, nullptr }},"
            );
        }

        if (type.IsGeneric)
        {
            w.WriteLine(
                $"{{ \"__class_getitem__\", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR(\"See PEP 585\") }},"
            );
        }

        w.WriteLine("{ }");
        w.Indent--;
        w.WriteLine("};");
    }

    static void WriteNewFunction(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();

        if (type.Category == Category.Interface)
        {
            w.WriteLine(
                $"static PyObject* _new_{type.Name}(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine($"static_assert(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);");
            w.WriteLine(
                $"py::set_invalid_activation_error(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);"
            );
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");
        }
        else if (type.Category == Category.Class)
        {
            w.WriteClassNewFunction(type);
        }
    }

    static void WriteDeallocFunction(this IndentedTextWriter w, ProjectedType type)
    {
        if (type.Category == Category.Class && type.IsStatic)
        {
            return;
        }

        w.WriteBlankLine();
        w.WriteLine($"static void _dealloc_{type.Name}({type.CppPyWrapperType}* self) noexcept");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine("auto tp = Py_TYPE(self);");
        w.WriteLine("std::destroy_at(&self->obj);");

        if (type.IsGeneric)
        {
            w.WriteLine("std::destroy_at(&self->impl);");
        }

        w.WriteLine("tp->tp_free(self);");
        w.WriteLine("Py_DECREF(tp);");

        w.Indent--;
        w.WriteLine("}");
    }

    static void WriteMethodFunctions(this IndentedTextWriter w, ProjectedType type)
    {
        foreach (
            var (methodName, isStatic) in type.Methods.Select(m => (m.Name, m.IsStatic)).Distinct()
        )
        {
            var selfParam = type.GetMethodSelfParam(isStatic);

            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* {type.Name}_{methodName}({selfParam}, PyObject* args) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;

            if (type.IsGeneric)
            {
                w.WriteLine($"return self->impl->{methodName}(args);");
            }
            else
            {
                w.WriteMethodOverloads(type, methodName);
            }

            w.Indent--;
            w.WriteLine("}");
        }

        foreach (var prop in type.Properties)
        {
            w.WritePropertyGetFunction(type, prop);

            if (prop.SetMethod is not null)
            {
                w.WritePropertySetFunction(type, prop);
            }
        }

        foreach (var evt in type.Events)
        {
            w.WriteEventFunction(type, evt.AddMethod, evt.Name);
            w.WriteEventFunction(type, evt.RemoveMethod, evt.Name);
        }

        if (!(type.IsGeneric || type.IsStatic))
        {
            w.WriteAssignArrayMethod(type);
        }

        if (
            (type.Category == Category.Class || type.Category == Category.Interface)
            && !(type.IsGeneric || type.IsStatic)
        )
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _from_{type.Name}(PyObject* /*unused*/, PyObject* arg) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() =>
            {
                w.WriteLine(
                    $"auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);"
                );
                w.WriteLine($"return py::convert(return_value.as<{type.CppWinrtType}>());");
            });
            w.Indent--;
            w.WriteLine("}");
        }

        if (type.IsPyCloseable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _enter_{type.Name}({type.CppPyWrapperType}* self, PyObject* /*unused*/) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine("return Py_NewRef(self);");
            w.Indent--;
            w.WriteLine("}");

            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _exit_{type.Name}({type.CppPyWrapperType}* self, PyObject* /*unused*/) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() =>
            {
                w.WriteLine("self->obj.Close();");
                w.WriteLine("Py_RETURN_FALSE;");
            });
            w.Indent--;
            w.WriteLine("}");
        }

        if (type.IsPyBuffer)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static int _get_buffer_{type.Name}({type.CppPyWrapperType}* self, Py_buffer* view, int flags) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(
                () =>
                    w.WriteLine(
                        $"return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.{type.PyBufferSize}()), 0, flags);"
                    ),
                () =>
                {
                    w.WriteLine("view->obj = nullptr;");
                    // TODO: attach C++ exception info to Python exception
                    w.WriteLine("PyErr_SetNone(PyExc_BufferError);");
                },
                "-1"
            );
            w.Indent--;
            w.WriteLine("}");
        }

        if (type.IsPyStringable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _str_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() => w.WriteLine("return py::convert(self->obj.ToString());"));
            w.Indent--;
            w.WriteLine("}");
        }

        void writeBody(string methodCall, Action writeCType)
        {
            w.WriteLine("{");
            w.Indent++;

            if (type.IsGeneric)
            {
                w.WriteLine($"return self->impl->{methodCall};");
            }
            else
            {
                writeCType();
            }

            w.Indent--;
            w.WriteLine("}");
        }

        if (type.IsPyAwaitable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _await_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            writeBody("dunder_await()", () => w.WriteLine("return py::dunder_await(self->obj);"));
        }

        if (type.IsPyIterable)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _iterator_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            writeBody("dunder_iter()", () => w.WriteDunderIterBody(type));
        }

        if (type.IsPyIterator)
        {
            w.WriteBlankLine();
            w.WriteLine(
                $"static PyObject* _iterator_next_{type.Name}({type.CppPyWrapperType}* self) noexcept"
            );
            writeBody("dunder_iternext()", () => w.WriteDunderIterNextBody(type));
        }

        if (type.IsPySequence)
        {
            w.WriteSeqMethodFunctions(type, writeBody);
        }

        if (type.IsPyMapping)
        {
            w.WriteMapMethodFunctions(type, writeBody);
        }
    }

    static void WriteEventFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedMethod method,
        string evtName
    )
    {
        var self = method.IsStatic ? "PyObject* /*unused*/" : $"{type.CppPyWrapperType}* self";

        w.WriteBlankLine();
        w.WriteLine($"static PyObject* {type.Name}_{method.Name}({self}, PyObject* arg) noexcept");
        w.WriteLine("{");
        w.Indent++;
        w.WriteTryCatch(() =>
        {
            w.WriteLine(
                $"if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L\"{method.Method.DeclaringType.Namespace}.{method.Method.DeclaringType.Name}\", L\"{evtName}\"))"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine(
                "PyErr_SetString(PyExc_AttributeError, \"event is not available in this version of Windows\");"
            );
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");
            w.WriteBlankLine();

            if (type.IsGeneric)
            {
                w.WriteLine($"return self->impl->{method.Name}(arg);");
            }
            else
            {
                w.WriteMethodBodyContents(type, method);
            }
        });
        w.Indent--;
        w.WriteLine("}");
    }

    static void WritePropertyGetFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedProperty prop
    )
    {
        var self = type.GetMethodSelfParam(prop.IsStatic);

        w.WriteBlankLine();
        w.WriteLine(
            $"static PyObject* {type.Name}_{prop.GetMethod.Name}({self}, void* /*unused*/) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteTryCatch(() =>
        {
            w.WriteLine(
                $"if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L\"{prop.Property.DeclaringType.Namespace}.{prop.Property.DeclaringType.Name}\", L\"{prop.Name}\"))"
            );
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine(
                "PyErr_SetString(PyExc_AttributeError, \"property is not available in this version of Windows\");"
            );
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");
            w.WriteBlankLine();

            if (type.IsGeneric)
            {
                w.WriteLine($"return self->impl->{prop.GetMethod.Name}();");
            }
            else
            {
                w.WriteMethodBodyContents(type, prop.GetMethod);
            }
        });
        w.Indent--;
        w.WriteLine("}");
    }

    static void WritePropertySetFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedProperty prop
    )
    {
        if (prop.SetMethod is null)
        {
            throw new ArgumentException("Property has no setter.", nameof(prop));
        }

        var self = type.GetMethodSelfParam(prop.IsStatic);

        w.WriteBlankLine();
        w.WriteLine(
            $"static int {type.Name}_{prop.SetMethod.Name}({self}, PyObject* arg, void* /*unused*/) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("if (arg == nullptr)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("PyErr_SetString(PyExc_AttributeError, \"can't delete attribute\");");
        w.WriteLine("return -1;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        w.WriteTryCatch(
            () =>
            {
                w.WriteLine(
                    $"if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L\"{prop.Property.DeclaringType.Namespace}.{prop.Property.DeclaringType.Name}\", L\"{prop.Name}\"))"
                );
                w.WriteLine("{");
                w.Indent++;
                w.WriteLine(
                    "PyErr_SetString(PyExc_AttributeError, \"property is not available in this version of Windows\");"
                );
                w.WriteLine("return -1;");
                w.Indent--;
                w.WriteLine("}");
                w.WriteBlankLine();

                if (type.IsGeneric)
                {
                    w.WriteLine($"return self->impl->{prop.SetMethod.Name}(arg);");
                }
                else
                {
                    w.WriteMethodBodyContents(type, prop.SetMethod, isPropertySetter: true);
                }
            },
            catchReturn: "-1"
        );
        w.Indent--;
        w.WriteLine("}");
    }

    static void WriteAssignArrayMethod(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();
        w.WriteLine(
            $"static PyObject* _assign_array_{type.Name}(PyObject* /*unused*/, PyObject* arg) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine($"auto array = std::make_unique<py::ComArray<{type.CppWinrtType}>>();");
        w.WriteLine("if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteLine("Py_RETURN_NONE;");
        w.Indent--;
        w.WriteLine("}");
    }

    static void WriteMethodOverloads(
        this IndentedTextWriter w,
        ProjectedType type,
        string methodName
    )
    {
        w.WriteLine("auto arg_count = PyTuple_Size(args);");
        w.WriteBlankLine();

        foreach (
            var (i, method) in type
                .Methods.Where(m => m.Name == methodName)
                .Select((m, i) => (i, m))
        )
        {
            var pyInParamCount = method.Method.Parameters.Count(p => p.IsPythonInParam());
            var inParamCount = method.Method.Parameters.Count(p => p.IsInParam());
            var ns = type.Namespace;

            if (i > 0)
            {
                w.Write("else ");
            }

            w.WriteLine($"if (arg_count == {pyInParamCount})");
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() =>
            {
                w.WriteLine(
                    $"if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L\"{method.Method.DeclaringType.Namespace}.{method.Method.DeclaringType.Name}\", L\"{methodName}\", {inParamCount}))"
                );
                w.WriteLine("{");
                w.Indent++;
                w.WriteLine($"py::set_arg_count_version_error({inParamCount});");
                w.WriteLine("return nullptr;");
                w.Indent--;
                w.WriteLine("}");
                w.WriteBlankLine();

                w.WriteMethodBodyContents(type, method);
            });
            w.Indent--;
            w.WriteLine("}");
        }

        w.WriteLine("else");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("py::set_invalid_arg_count_error(arg_count);");
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
    }

    static void WriteMethodBodyContents(
        this IndentedTextWriter w,
        ProjectedType type,
        ProjectedMethod method,
        bool isPropertySetter = false
    )
    {
        if (method.IsConstructor)
        {
            throw new ArgumentException("Constructors are not allowed here.");
        }

        // instance property set methods are projected as Python setters,
        // thus return 0 to indicate success
        var voidReturn = isPropertySetter ? "return 0;" : "Py_RETURN_NONE;";

        // convert in params from Python -> C++
        foreach (var param in method.Method.Parameters)
        {
            w.WriteMethodParamDefinition(method, param);
        }

        if (method.Method.Parameters.Count > 0)
        {
            w.WriteBlankLine();
        }

        // Invoke member - simplified code path for methods w/ no out params
        if (!method.Method.Parameters.Any(p => p.IsPythonOutParam()))
        {
            if (method.Method.ReturnType.FullName == "System.Void")
            {
                var invoke =
                    $"{type.GetMethodInvokeContext(method.Method)}{method.Method.ToCppMethodName()}({method.Method.Parameters.ToParameterList()});";

                // HACK: WinRT APIs are generally non-blocking, but some are
                // long-running and block other threads in the Python interpreter.
                // To avoid this, we release the GIL before invoking the method.
                // The known methods are just hard-coded here for now. We can
                // generalize this if we find more methods that need this treatment.
                // For the Application::Start methods though, what we really need
                // is an alternative that integrates with asyncio in Python.
                if (
                    (type.Namespace == "Windows.UI.Xaml" || type.Namespace == "Microsoft.UI.Xaml")
                    && type.Name == "Application"
                    && method.Name == "Start"
                )
                {
                    w.WriteLine("{");
                    w.Indent++;
                    w.WriteLine("auto ts = release_gil();");
                    w.WriteLine(invoke);
                    w.Indent--;
                    w.WriteLine("}");
                }
                else
                {
                    w.WriteLine(invoke);
                }

                w.WriteLine(voidReturn);
            }
            else
            {
                var context = type.GetMethodInvokeContext(method.Method);
                var cppMethod = method.Method.ToCppMethodName();
                var paramList = method.Method.Parameters.ToParameterList();

                w.WriteLine($"return py::convert({context}{cppMethod}({paramList}));");
            }

            return;
        }

        // Invoke member - code path for methods w/ out params

        if (method.Method.ReturnType.FullName != "System.Void")
        {
            w.Write($"auto return_value = ");
        }

        w.WriteLine(
            $"{type.GetMethodInvokeContext(method.Method)}{method.Method.ToCppMethodName()}({method.Method.Parameters.ToParameterList()});"
        );
        w.WriteBlankLine();

        // Convert return values and out parameters from C++ -> Python

        var returnValues = new List<string>();

        if (method.Method.ReturnType.FullName != "System.Void" || method.IsConstructor)
        {
            w.WriteLine($"py::pyobj_handle out_return_value{{ py::convert(return_value) }};");
            w.WriteLine("if (!out_return_value)");
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");

            returnValues.Add("out_return_value");
        }

        foreach (var param in method.Method.Parameters.Where(p => p.IsPythonOutParam()))
        {
            var outParam = $"out{param.Index}";

            w.WriteLine($"py::pyobj_handle {outParam}{{ py::convert({param.ToParamName()}) }};");
            w.WriteLine($"if (!{outParam})");
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");

            returnValues.Add(outParam);
        }

        // Return Python projected return/out params


        if (returnValues.Count == 0)
        {
            w.WriteLine(voidReturn);
        }
        else if (returnValues.Count == 1)
        {
            w.WriteLine($"return {returnValues[0]}.detach();");
        }
        else
        {
            w.WriteLine(
                $"return PyTuple_Pack({returnValues.Count}, {string.Join(", ", returnValues.Select(p => $"{p}.get()"))});"
            );
        }
    }

    static void WriteClassNewFunction(this IndentedTextWriter w, ProjectedType type)
    {
        if (type.IsStatic || type.Constructors.Count == 0)
        {
            w.WriteLine(
                $"static PyObject* _new_{type.Name}(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept"
            );
        }
        else
        {
            w.WriteLine(
                $"static PyObject* _new_{type.Name}(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept"
            );
        }

        w.WriteLine("{");
        w.Indent++;

        if (type.IsStatic || type.Constructors.Count == 0)
        {
            w.WriteLine($"static_assert(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);");
            w.WriteLine(
                $"py::set_invalid_activation_error(py::py_type<{type.CppPyWrapperTemplateType}>::type_name);"
            );
            w.WriteLine("return nullptr;");
        }
        else
        {
            w.WriteLine("if (kwds != nullptr)");
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine("py::set_invalid_kwd_args_error();");
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");
            w.WriteBlankLine();

            w.WriteLine("auto arg_count = PyTuple_Size(args);");

            foreach (var (i, ctor) in type.Constructors.Select((c, i) => (i, c)))
            {
                if (i > 0)
                {
                    w.Write("else ");
                }

                w.WriteLine($"if (arg_count == {ctor.Method.Parameters.Count})");
                w.WriteLine("{");
                w.Indent++;
                w.WriteTryCatch(() =>
                {
                    foreach (var param in ctor.Method.Parameters)
                    {
                        w.WriteMethodParamDefinition(ctor, param);
                    }

                    if (ctor.Method.Parameters.Count > 0)
                    {
                        w.WriteBlankLine();
                    }

                    w.WriteLine(
                        $"{type.CppPyWrapperTemplateType} instance{{ {ctor.Method.Parameters.ToParameterList()} }};"
                    );
                    w.WriteLine("return py::wrap(instance, type);");
                });
                w.Indent--;
                w.WriteLine("}");
            }

            w.WriteLine("else");
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine("py::set_invalid_arg_count_error(arg_count);");
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");
        }

        w.Indent--;
        w.WriteLine("}");
    }

    public static void WriteMethodParamDefinition(
        this IndentedTextWriter w,
        ProjectedMethod method,
        ParameterDefinition param
    )
    {
        var category = param.GetCategory();
        var paramName = param.ToParamName();
        var typeName = param.ParameterType.ToCppTypeName(method.GenericArgMap);
        var writeable = category == ParamCategory.FillArray ? "true" : "false";
        var args = method.Method.ToConvertToArgs();

        switch (category)
        {
            case ParamCategory.In:
                w.WriteLine($"auto {paramName} = py::convert_to<{typeName}>({args(param.Index)});");
                break;
            case ParamCategory.Out:
                var elementType = param.ParameterType.GetElementType();
                var value =
                    elementType.FullName == "System.String"
                    || elementType.FullName == "System.Object"
                    || elementType.IsValueType
                        ? ""
                        : "nullptr";
                w.WriteLine($"{typeName} {paramName}{{{value}}};");
                break;
            case ParamCategory.PassArray:
            case ParamCategory.FillArray:
                w.WriteLine(
                    $"auto {paramName} = py::convert_to<py::pybuf_view<{typeName}, {writeable}>>({args(param.Index)});"
                );
                break;
            case ParamCategory.ReceiveArray:
                w.WriteLine($"winrt::com_array<{typeName}> {paramName}{{}};");
                break;
            default:
                throw new ArgumentException("Invalid param category");
        }
    }

    public static void WriteStruct(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteLine($"// ----- {type.Name} struct --------------------");
        w.WriteStructConstructor(type);
        w.WriteDeallocFunction(type);
        w.WriteMethodFunctions(type);
        w.WriteMethodTable(type);
        foreach (var field in type.Type.Fields)
        {
            w.WriteStructGetSetFunction(type, field);
        }
        w.WriteGetSetTable(type);
        w.WriteTypeSlotTable(type);
        w.WriteTypeSpec(type);
    }

    static void WriteStructConstructor(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteBlankLine();
        w.WriteLine(
            $"winrt_struct_wrapper<{type.CppWinrtType}>* _new_{type.Name}(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine(
            $"auto self = reinterpret_cast<winrt_struct_wrapper<{type.CppWinrtType}>*>(subclass->tp_alloc(subclass, 0));"
        );
        w.WriteBlankLine();
        w.WriteLine("if (!self)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();
        w.WriteLine("std::construct_at(&self->obj);");
        w.WriteBlankLine();
        w.WriteLine("return self;");
        w.Indent--;
        w.WriteLine("}");

        w.WriteBlankLine();
        w.WriteLine(
            $"int _init_{type.Name}(winrt_struct_wrapper<{type.CppWinrtType}>* self, PyObject* args, PyObject* kwds) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("auto tuple_size = PyTuple_Size(args);");
        w.WriteBlankLine();
        w.WriteLine("if ((tuple_size == 0) && (kwds == nullptr))");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("self->obj = {};");
        w.WriteLine("return 0;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        foreach (var field in type.Type.Fields)
        {
            w.WriteLine($"{field.GetWrongFieldType().ToStructFieldType()} _{field.Name}{{}};");
        }

        w.WriteBlankLine();
        w.WriteLine(
            $"static const char* kwlist[] = {{{type.Type.ToStructFieldKeywordList()}nullptr}};"
        );
        w.WriteLine(
            $"if (!PyArg_ParseTupleAndKeywords(args, kwds, \"{type.Type.ToStructFieldFormat()}\", const_cast<char**>(kwlist){type.Type.ToStructFieldParseParameterList()}))"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return -1;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();
        w.WriteTryCatch(
            () =>
            {
                w.WriteLine(
                    $"self->obj = {{{string.Join(", ", type.Type.Fields.Select(f => f.ToStructFieldInitializer()))}}};"
                );
                w.WriteLine("return 0;");
            },
            catchReturn: "-1"
        );
        w.Indent--;
        w.WriteLine("}");
    }

    static void WriteStructGetSetFunction(
        this IndentedTextWriter w,
        ProjectedType type,
        FieldDefinition field
    )
    {
        w.WriteBlankLine();
        w.WriteLine(
            $"static PyObject* {type.Name}_get_{field.Name}({type.CppPyWrapperType}* self, void* /*unused*/) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;

        w.WriteTryCatch(() =>
        {
            if (type.Type.HasCustomConversion())
            {
                w.WriteLine($"return py::convert(custom_get(self->obj));");
            }
            else
            {
                w.WriteLine($"return py::convert(self->obj.{field.ToWinrtFieldName()});");
            }
        });

        w.Indent--;
        w.WriteLine("}");

        w.WriteBlankLine();
        w.WriteLine(
            $"static int {type.Name}_set_{field.Name}({type.CppPyWrapperType}* self, PyObject* arg, void* /*unused*/) noexcept"
        );
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine("if (arg == nullptr)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("PyErr_SetString(PyExc_AttributeError, \"can't delete attribute\");");
        w.WriteLine("return -1;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        w.WriteTryCatch(
            () =>
            {
                if (type.Type.HasCustomConversion())
                {
                    w.WriteLine(
                        $"custom_set(self->obj, py::converter<{field.FieldType.ToCppTypeName()}>::convert_to(arg));"
                    );
                }
                else
                {
                    w.WriteLine(
                        $"self->obj.{field.ToWinrtFieldName()} = py::converter<{field.FieldType.ToCppTypeName()}>::convert_to(arg);"
                    );
                }

                w.WriteLine("return 0;");
            },
            catchReturn: "-1"
        );

        w.Indent--;
        w.WriteLine("}");
    }

    public static void WriteNamespaceInitialization(this IndentedTextWriter w, string ns)
    {
        w.WriteLine($"// ----- {ns} Initialization --------------------");
        w.WriteBlankLine();
        w.WriteLine($"PyDoc_STRVAR(module_doc, \"{ns}\");");
        w.WriteBlankLine();
        w.WriteLine("static PyModuleDef module_def = {");
        w.Indent++;
        w.WriteLine("PyModuleDef_HEAD_INIT,");
        w.WriteLine($"\"{ns.ToNsModuleName()}\",");
        w.WriteLine("module_doc,");
        w.WriteLine("0,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr,");
        w.WriteLine("nullptr};");
        w.Indent--;
    }

    public static void WriteNamespaceModuleInitFunction(
        this IndentedTextWriter w,
        string ns,
        Members members
    )
    {
        w.WriteLine($"PyMODINIT_FUNC PyInit_{ns.ToNsModuleName()}(void) noexcept");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine($"using namespace py::cpp::{ns.ToCppNamespace()};");
        w.WriteBlankLine();

        w.WriteLine("if (py::import_winrt_runtime() == -1)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        w.WriteLine("py::pyobj_handle module{PyModule_Create(&module_def)};");
        w.WriteBlankLine();

        w.WriteLine("if (!module)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        w.WriteLine("auto object_type = py::get_object_type();");
        w.WriteLine("if (!object_type)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        w.WriteLine("py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};");
        w.WriteBlankLine();
        w.WriteLine("if (!object_bases)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();

        foreach (
            var t in members
                .Classes.Concat(members.Interfaces)
                .Concat(members.Structs.Where(s => !s.Type.IsCustomizedStruct()))
        )
        {
            w.WriteNamespaceInitPythonType(t);
        }

        w.WriteBlankLine();
        w.WriteLine("return module.detach();");
        w.Indent--;
        w.WriteLine("}");
    }

    /// <summary>
    /// Writes the type initialization for a binary extension Python type inside
    /// the module init function.
    /// </summary>
    static void WriteNamespaceInitPythonType(this IndentedTextWriter w, ProjectedType type)
    {
        var name = type.Name.ToNonGeneric();
        var metaclass = "nullptr";

        if (type.PyRequiresMetaclass)
        {
            w.WriteLine(
                $"py::pyobj_handle type_{name}_Static{{PyType_FromSpec(&type_spec_{name}_Static)}};"
            );

            w.WriteLine($"if (!type_{name}_Static)");
            w.WriteLine("{");
            w.Indent++;
            w.WriteLine("return nullptr;");
            w.Indent--;
            w.WriteLine("}");
            w.WriteBlankLine();

            metaclass = $"reinterpret_cast<PyTypeObject*>(type_{name}_Static.get())";
        }

        var baseType =
            type.Category == Category.Class || type.Category == Category.Interface
                ? "object_bases.get()"
                : "nullptr";

        w.WriteLine(
            $"if (py::register_python_type(module.get(), &type_spec_{name}, {baseType}, {metaclass}) == -1)"
        );
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("return nullptr;");
        w.Indent--;
        w.WriteLine("}");
        w.WriteBlankLine();
    }

    public static void WriteTryCatch(
        this IndentedTextWriter w,
        Action writeTryStatements,
        Action? writeCatchStatements = null,
        string catchReturn = "nullptr"
    )
    {
        w.WriteLine("try");
        w.WriteLine("{");
        w.Indent++;
        writeTryStatements();
        w.Indent--;
        w.WriteLine("}");
        w.WriteLine("catch (...)");
        w.WriteLine("{");
        w.Indent++;

        if (writeCatchStatements is null)
        {
            w.WriteLine("py::to_PyErr();");
        }
        else
        {
            writeCatchStatements();
        }

        w.WriteLine($"return {catchReturn};");
        w.Indent--;
        w.WriteLine("}");
    }

    public static void WriteGenericInterfaceDecl(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteLine($"struct {type.Name}");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine($"virtual ~{type.Name}() {{}};");

        foreach (var method in type.Methods.Select(m => m.Name).Distinct())
        {
            w.WriteLine($"virtual PyObject* {method}(PyObject*) noexcept = 0;");
        }

        foreach (var property in type.Properties)
        {
            w.WriteLine($"virtual PyObject* get_{property.Name}() noexcept = 0;");

            if (property.SetMethod is not null)
            {
                w.WriteLine($"virtual int put_{property.Name}(PyObject*) noexcept = 0;");
            }
        }

        foreach (var evt in type.Events)
        {
            w.WriteLine($"virtual PyObject* {evt.AddMethod.Name}(PyObject*) noexcept = 0;");
            w.WriteLine($"virtual PyObject* {evt.RemoveMethod.Name}(PyObject*) noexcept = 0;");
        }

        if (type.IsPyAwaitable)
        {
            w.WriteLine($"virtual PyObject* dunder_await() noexcept = 0;");
        }

        if (type.IsPyIterable)
        {
            w.WriteLine("virtual PyObject* dunder_iter() noexcept = 0;");
        }

        if (type.IsPyIterator)
        {
            w.WriteLine("virtual PyObject* dunder_iternext() noexcept = 0;");
        }

        if (type.IsPySequence)
        {
            w.WriteLine("virtual Py_ssize_t seq_length() noexcept = 0;");
            w.WriteLine("virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;");
            w.WriteLine("virtual PyObject* seq_subscript(PyObject* slice) noexcept = 0;");

            if (type.IsPyMutableSequence)
            {
                w.WriteLine("virtual int seq_assign(Py_ssize_t i, PyObject* value) noexcept = 0;");
            }
        }

        if (type.IsPyMapping)
        {
            w.WriteMapGenericInterfaceDecl(type);
        }

        w.Indent--;
        w.WriteLine("};");
    }

    public static void WriteDelegateCallableWrapper(this IndentedTextWriter w, ProjectedType type)
    {
        var invoke = type.Type.Methods.Single(m => m.IsSpecialName && m.Name == "Invoke");

        if (type.IsGeneric)
        {
            w.WriteLine(
                $"template <{string.Join(", ", type.Type.GenericParameters.Select(p => $"typename {p.Name}"))}>"
            );
        }

        w.WriteLine($"struct {type.Name}");
        w.WriteLine("{");
        w.Indent++;

        // TODO: include write_delegate_template_args
        w.WriteLine($"static {type.CppWinrtType} get(PyObject* callable)");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine("py::delegate_callable _delegate{ callable };");
        w.WriteBlankLine();
        w.WriteLine(
            $"return [delegate = std::move(_delegate)]({string.Join(", ", invoke.Parameters.Select(p => p.ToDelegateParam()))})"
        );
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine("auto gil = py::ensure_gil();");
        w.WriteBlankLine();

        foreach (var param in invoke.Parameters.Where(p => p.IsPythonInParam()))
        {
            w.WriteLine(
                $"py::pyobj_handle py_{param.ToParamName()}{{ py::convert({param.ToParamName()}) }};"
            );
            w.WriteBlankLine();
            w.WriteLine($"if (!py_{param.ToParamName()}) {{");
            w.Indent++;
            w.WriteLine("PyErr_WriteUnraisable(delegate.callable());");
            w.WriteLine($"throw std::invalid_argument(\"{param.ToParamName()}\");");
            w.Indent--;
            w.WriteLine("}");
            w.WriteBlankLine();
        }

        if (invoke.Parameters.Any(p => p.IsPythonInParam()))
        {
            w.WriteLine(
                $"py::pyobj_handle args{{ PyTuple_Pack({invoke.Parameters.Count(p => p.IsPythonInParam())}, {string.Join(", ", invoke.Parameters.Where(p => p.IsPythonInParam()).Select(p => $"py_{p.ToParamName()}.get()"))}) }};"
            );
            w.WriteBlankLine();
            w.WriteLine("if (!args) {");
            w.Indent++;
            w.WriteLine("PyErr_WriteUnraisable(delegate.callable());");
            w.WriteLine("throw winrt::hresult_error();");
            w.Indent--;
            w.WriteLine("}");
            w.WriteBlankLine();
        }
        else
        {
            w.WriteLine("py::pyobj_handle args{ nullptr };");
        }

        w.WriteLine(
            "py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };"
        );

        w.WriteBlankLine();
        w.WriteLine("if (!return_value)");
        w.WriteLine("{");
        w.Indent++;
        w.WriteLine("PyErr_WriteUnraisable(delegate.callable());");
        w.WriteLine("throw winrt::hresult_error();");
        w.Indent--;
        w.WriteLine("}");

        var i = invoke.ReturnType.FullName == "System.Void" ? 0 : 1;

        foreach (var param in invoke.Parameters.Where(p => p.IsPythonOutParam()))
        {
            switch (param.GetCategory())
            {
                case ParamCategory.Out:
                    w.WriteBlankLine();
                    w.WriteLine(
                        $"{param.ToParamName()} = py::convert_to<{param.ParameterType.ToCppTypeName()}>(return_value.get(), {i});"
                    );
                    break;
                case ParamCategory.ReceiveArray:
                    w.WriteBlankLine();
                    w.WriteLine(
                        $"auto {param.ToParamName()}_buf = py::convert_to<py::pybuf_view<{param.ParameterType.ToCppTypeName()}, false>>(return_value.get(), {i});"
                    );
                    w.WriteLine(
                        $"{param.ToParamName()} = winrt::com_array<{param.ParameterType.ToCppTypeName()}>{{{param.ToParamName()}_buf.begin(), {param.ToParamName()}_buf.end()}};"
                    );
                    break;
                default:
                    throw new ArgumentException("Invalid param category");
            }

            i++;
        }

        if (invoke.ReturnType.FullName != "System.Void")
        {
            var index = "";

            if (i > 1)
            {
                // delegate has out params and a return value so
                // the return value is the first item in the tuple
                index = ", 0";
            }

            w.WriteBlankLine();

            if (invoke.ReturnType.IsArray)
            {
                w.WriteLine(
                    $"auto return_buf = py::convert_to<py::pybuf_view<{invoke.ReturnType.ToCppTypeName()}, false>>(return_value.get(){index});"
                );
                w.WriteLine(
                    $"return winrt::com_array<{invoke.ReturnType.ToCppTypeName()}>{{return_buf.begin(), return_buf.end()}};"
                );
            }
            else
            {
                w.WriteLine(
                    $"return py::convert_to<{invoke.ReturnType.ToCppTypeName()}>(return_value.get(){index});"
                );
            }
        }

        w.Indent--;
        w.WriteLine("};");
        w.Indent--;
        w.WriteLine("};");
        w.Indent--;
        w.WriteLine("};");
    }

    public static void WriteGenericInterfaceImpl(this IndentedTextWriter w, ProjectedType type)
    {
        w.WriteLine(
            $"template<{string.Join(", ", type.Type.GenericParameters.Select(p => $"typename {p.Name}"))}>"
        );
        w.WriteLine($"struct {type.Name} : public py::proj::{type.CppNamespace}::{type.Name}");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine($"{type.Name}({type.CppWinrtType} o) : _obj(o) {{}}");

        foreach (var methodName in type.Methods.Select(m => m.Name).Distinct())
        {
            w.WriteLine($"PyObject* {methodName}(PyObject* args) noexcept override");
            w.WriteLine("{");
            w.Indent++;
            w.WriteMethodOverloads(type, methodName);
            w.Indent--;
            w.WriteLine("}");
        }

        foreach (var prop in type.Properties)
        {
            w.WriteLine($"PyObject* get_{prop.Name}() noexcept override");
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() => w.WriteMethodBodyContents(type, prop.GetMethod));
            w.Indent--;
            w.WriteLine("}");

            if (prop.SetMethod is not null)
            {
                w.WriteLine($"int put_{prop.Name}(PyObject* arg) noexcept override");
                w.WriteLine("{");
                w.Indent++;
                w.WriteLine("if (arg == nullptr)");
                w.WriteLine("{");
                w.Indent++;
                w.WriteLine("PyErr_SetString(PyExc_AttributeError, \"can't delete attribute\");");
                w.WriteLine("return -1;");
                w.Indent--;
                w.WriteLine("}");
                w.WriteBlankLine();
                w.WriteTryCatch(
                    () => w.WriteMethodBodyContents(type, prop.SetMethod, isPropertySetter: true),
                    catchReturn: "-1"
                );
                w.Indent--;
                w.WriteLine("}");
            }
        }

        foreach (var evt in type.Events)
        {
            w.WriteLine($"PyObject* {evt.AddMethod.Name}(PyObject* arg) noexcept override");
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() => w.WriteMethodBodyContents(type, evt.AddMethod));
            w.Indent--;
            w.WriteLine("}");

            w.WriteLine($"PyObject* {evt.RemoveMethod.Name}(PyObject* arg) noexcept override");
            w.WriteLine("{");
            w.Indent++;
            w.WriteTryCatch(() => w.WriteMethodBodyContents(type, evt.RemoveMethod));
            w.Indent--;
            w.WriteLine("}");
        }

        if (type.IsPyAwaitable)
        {
            w.WriteLine(
                "PyObject* dunder_await() noexcept override { return py::dunder_await(_obj); }"
            );
        }

        if (type.IsPyIterable)
        {
            w.WriteIterGenericInterfaceImpl(type);
        }

        if (type.IsPySequence)
        {
            w.WriteSeqGenericInterfaceImpl(type);
        }

        if (type.IsPyMapping)
        {
            w.WriteMapGenericInterfaceImpl(type);
        }

        w.WriteBlankLine();
        w.WriteLine($"{type.CppWinrtType} _obj{{ nullptr }};");

        w.Indent--;
        w.WriteLine("};");
    }

    public static void WritePythonWrapperAlias(this IndentedTextWriter w, ProjectedType type)
    {
        var st =
            type.Category == Category.Class || type.Category == Category.Interface ? "" : "struct_";

        if (type.IsGeneric)
        {
            w.WriteLine(
                $"using {type.Name} = py::winrt_pinterface_wrapper<py::proj::{type.CppNamespace}::{type.Name}>;"
            );
        }
        else
        {
            w.WriteLine($"using {type.Name} = py::winrt_{st}wrapper<{type.CppWinrtType}>;");
        }
    }

    public static void WriteEnumBufferFormat(this IndentedTextWriter w, ProjectedType type)
    {
        var fmt = type.Type.HasFlagsAttribute() ? "I" : "i";

        w.WriteLine($"template<>");
        w.WriteLine(
            $"inline constexpr const char* buffer_format<{type.CppWinrtType}> = \"{fmt}\";"
        );
        w.WriteBlankLine();
    }

    public static void WriteStructBufferFormat(this IndentedTextWriter w, ProjectedType type)
    {
        var fmt = string.Join(
            "",
            type.Type.Fields.Select(f =>
                $"{f.ToStructBufferFormat()}:{f.Name.ToPythonIdentifier()}:"
            )
        );

        w.WriteLine($"template<>");
        w.WriteLine(
            $"inline constexpr const char* buffer_format<{type.CppWinrtType}> = \"T{{{fmt}}}\";"
        );
        w.WriteBlankLine();
    }

    public static void WritePyTypeSpecializationStruct(
        this IndentedTextWriter w,
        ProjectedType type
    )
    {
        w.WriteBlankLine();
        w.WriteLine($"template<>");
        w.WriteLine($"struct py_type<{type.CppPyWrapperTemplateType}>");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine($"static constexpr const char* module_name = \"{type.PyModuleName}\";");
        w.WriteLine($"static constexpr const char* type_name = \"{type.Name}\";");

        w.Indent--;
        w.WriteLine("};");
    }

    public static void WriteGenericInterfaceTypeMapper(
        this IndentedTextWriter w,
        ProjectedType type
    )
    {
        w.WriteLine(
            $"template <{string.Join(", ", type.Type.GenericParameters.Select(p => $"typename {p.Name}"))}>"
        );
        w.WriteLine($"struct pinterface_python_type<{type.CppWinrtType}>");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine($"using abstract = py::proj::{type.CppNamespace}::{type.Name};");
        w.WriteLine(
            $"using concrete = py::impl::{type.CppNamespace}::{type.Name}<{string.Join(", ", type.Type.GenericParameters.Select(p => p.Name))}>;"
        );

        w.Indent--;
        w.WriteLine("};");
        w.WriteBlankLine();
    }

    public static void WriteDelegateTypeMapper(this IndentedTextWriter w, ProjectedType type)
    {
        var args = type.IsGeneric
            ? $"<{string.Join(", ", type.Type.GenericParameters.Select(p => p.Name))}>"
            : "";

        w.WriteLine(
            $"template <{string.Join(", ", type.Type.GenericParameters.Select(p => $"typename {p.Name}"))}>"
        );
        w.WriteLine($"struct delegate_python_type<{type.CppWinrtType}>");
        w.WriteLine("{");
        w.Indent++;

        w.WriteLine($"using type = py::impl::{type.CppNamespace}::{type.Name}{args};");

        w.Indent--;
        w.WriteLine("};");
        w.WriteBlankLine();
    }

    public static void WritePythonMethodTyping(
        this IndentedTextWriter w,
        ProjectedMethod method,
        string ns,
        string self = "self"
    )
    {
        var paramList = "";

        if (method.Method.Parameters.Any(p => p.IsPythonInParam()))
        {
            paramList =
                $", {string.Join(", ", method.Method.Parameters.Where(p => p.IsPythonInParam()).Select(p => $"{p.Name.ToPythonIdentifier()}: {p.ToPyInParamTyping(ns, method.GenericArgMap)}"))}, /";
        }

        w.WriteLine(
            $"def {method.Name.ToPythonIdentifier()}({self}{paramList}) -> {method.Method.ToPyReturnTyping(ns, method.GenericArgMap)}: ..."
        );
    }
}
