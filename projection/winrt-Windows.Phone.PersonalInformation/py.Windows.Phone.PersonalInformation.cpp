// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.Phone.PersonalInformation.h"

namespace py::cpp::Windows::Phone::PersonalInformation
{
    // ----- ContactAddress class --------------------

    static PyObject* _new_ContactAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Phone::PersonalInformation::ContactAddress instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAddress(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactAddress_get_StreetAddress(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"StreetAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreetAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_StreetAddress(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"StreetAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StreetAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Region(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Region");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Region(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Region");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_PostalCode(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"PostalCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_PostalCode(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"PostalCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Locality(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Locality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Locality(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Locality");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Locality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Country(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Country");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Country(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Country");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAddress[] = {
        { "_assign_array_", _assign_array_ContactAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAddress[] = {
        { "street_address", reinterpret_cast<getter>(ContactAddress_get_StreetAddress), reinterpret_cast<setter>(ContactAddress_put_StreetAddress), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(ContactAddress_get_Region), reinterpret_cast<setter>(ContactAddress_put_Region), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(ContactAddress_get_PostalCode), reinterpret_cast<setter>(ContactAddress_put_PostalCode), nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ContactAddress_get_Locality), reinterpret_cast<setter>(ContactAddress_put_Locality), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(ContactAddress_get_Country), reinterpret_cast<setter>(ContactAddress_put_Country), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAddress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactAddress) },
        { }
    };

    static PyType_Spec type_spec_ContactAddress = {
        "winrt._winrt_windows_phone_personalinformation.ContactAddress",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAddress};

    // ----- ContactChangeRecord class --------------------

    static PyObject* _new_ContactChangeRecord(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactChangeRecord(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChangeRecord_get_ChangeType(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"ChangeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChangeRecord_get_Id(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChangeRecord_get_RemoteId(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChangeRecord_get_RevisionNumber(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"RevisionNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RevisionNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChangeRecord(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChangeRecord(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeRecord[] = {
        { "_assign_array_", _assign_array_ContactChangeRecord, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangeRecord), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangeRecord[] = {
        { "change_type", reinterpret_cast<getter>(ContactChangeRecord_get_ChangeType), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactChangeRecord_get_Id), nullptr, nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ContactChangeRecord_get_RemoteId), nullptr, nullptr, nullptr },
        { "revision_number", reinterpret_cast<getter>(ContactChangeRecord_get_RevisionNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactChangeRecord[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChangeRecord) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChangeRecord) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChangeRecord) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChangeRecord) },
        { }
    };

    static PyType_Spec type_spec_ContactChangeRecord = {
        "winrt._winrt_windows_phone_personalinformation.ContactChangeRecord",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeRecord};

    // ----- ContactInformation class --------------------

    static PyObject* _new_ContactInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Phone::PersonalInformation::ContactInformation instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactInformation(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactInformation_GetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GetDisplayPictureAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDisplayPictureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_GetPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GetPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_ParseVcardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"ParseVcardAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(winrt::Windows::Phone::PersonalInformation::ContactInformation::ParseVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_SetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"SetDisplayPictureAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.SetDisplayPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_ToVcardAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"ToVcardAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToVcardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"ToVcardAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::VCardFormat>(args, 0);

                return py::convert(self->obj.ToVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificPrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_GivenName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_GivenName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_DisplayPicture(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"DisplayPicture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInformation[] = {
        { "get_display_picture_async", reinterpret_cast<PyCFunction>(ContactInformation_GetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(ContactInformation_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "set_display_picture_async", reinterpret_cast<PyCFunction>(ContactInformation_SetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "to_vcard_async", reinterpret_cast<PyCFunction>(ContactInformation_ToVcardAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactInformation[] = {
        { "honorific_suffix", reinterpret_cast<getter>(ContactInformation_get_HonorificSuffix), reinterpret_cast<setter>(ContactInformation_put_HonorificSuffix), nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(ContactInformation_get_HonorificPrefix), reinterpret_cast<setter>(ContactInformation_put_HonorificPrefix), nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(ContactInformation_get_GivenName), reinterpret_cast<setter>(ContactInformation_put_GivenName), nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(ContactInformation_get_FamilyName), reinterpret_cast<setter>(ContactInformation_put_FamilyName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ContactInformation_get_DisplayName), reinterpret_cast<setter>(ContactInformation_put_DisplayName), nullptr, nullptr },
        { "display_picture", reinterpret_cast<getter>(ContactInformation_get_DisplayPicture), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactInformation) },
        { }
    };

    static PyType_Spec type_spec_ContactInformation = {
        "winrt._winrt_windows_phone_personalinformation.ContactInformation",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInformation};

    static PyGetSetDef getset_ContactInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_ContactInformation_Static[] = {
        { "parse_vcard_async", reinterpret_cast<PyCFunction>(ContactInformation_ParseVcardAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContactInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContactInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContactInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_ContactInformation_Static =
    {
        "winrt._winrt_windows_phone_personalinformation.ContactInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContactInformation_Static
    };

    // ----- ContactQueryOptions class --------------------

    static PyObject* _new_ContactQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Phone::PersonalInformation::ContactQueryOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactQueryOptions(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactQueryOptions_get_OrderBy(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactQueryOptions", L"OrderBy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OrderBy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_OrderBy(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactQueryOptions", L"OrderBy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactQueryResultOrdering>(arg);

            self->obj.OrderBy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredFields(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactQueryOptions", L"DesiredFields");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryOptions[] = {
        { "_assign_array_", _assign_array_ContactQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryOptions[] = {
        { "order_by", reinterpret_cast<getter>(ContactQueryOptions_get_OrderBy), reinterpret_cast<setter>(ContactQueryOptions_put_OrderBy), nullptr, nullptr },
        { "desired_fields", reinterpret_cast<getter>(ContactQueryOptions_get_DesiredFields), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactQueryOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactQueryOptions) },
        { }
    };

    static PyType_Spec type_spec_ContactQueryOptions = {
        "winrt._winrt_windows_phone_personalinformation.ContactQueryOptions",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryOptions};

    // ----- ContactQueryResult class --------------------

    static PyObject* _new_ContactQueryResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactQueryResult(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactQueryResult_GetContactCountAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetContactCountAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetContactCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactQueryResult_GetContactsAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetContactsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetContactsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactQueryResult_GetCurrentQueryOptions(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetCurrentQueryOptions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentQueryOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryResult[] = {
        { "get_contact_count_async", reinterpret_cast<PyCFunction>(ContactQueryResult_GetContactCountAsync), METH_VARARGS, nullptr },
        { "get_contacts_async", reinterpret_cast<PyCFunction>(ContactQueryResult_GetContactsAsync), METH_VARARGS, nullptr },
        { "get_current_query_options", reinterpret_cast<PyCFunction>(ContactQueryResult_GetCurrentQueryOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryResult[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactQueryResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactQueryResult) },
        { }
    };

    static PyType_Spec type_spec_ContactQueryResult = {
        "winrt._winrt_windows_phone_personalinformation.ContactQueryResult",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryResult};

    // ----- ContactStore class --------------------

    static PyObject* _new_ContactStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::PersonalInformation::ContactStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::PersonalInformation::ContactStore>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactStore(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactStore_CreateContactQuery(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateContactQuery", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateContactQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateContactQuery", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.CreateContactQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_CreateMeContactAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateMeContactAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateMeContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_CreateOrOpenAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateOrOpenAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Phone::PersonalInformation::ContactStore::CreateOrOpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateOrOpenAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStoreSystemAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStoreApplicationAccessMode>(args, 1);

                return py::convert(winrt::Windows::Phone::PersonalInformation::ContactStore::CreateOrOpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_DeleteAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_DeleteContactAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"DeleteContactAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactByIdAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"FindContactByIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactByIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactByRemoteIdAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"FindContactByRemoteIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactByRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetChangesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"GetChangesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetChangesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_LoadExtendedPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"LoadExtendedPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.LoadExtendedPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_SaveExtendedPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"SaveExtendedPropertiesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);

                return py::convert(self->obj.SaveExtendedPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_RevisionNumber(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"RevisionNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RevisionNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStore[] = {
        { "create_contact_query", reinterpret_cast<PyCFunction>(ContactStore_CreateContactQuery), METH_VARARGS, nullptr },
        { "create_me_contact_async", reinterpret_cast<PyCFunction>(ContactStore_CreateMeContactAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(ContactStore_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_contact_async", reinterpret_cast<PyCFunction>(ContactStore_DeleteContactAsync), METH_VARARGS, nullptr },
        { "find_contact_by_id_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactByIdAsync), METH_VARARGS, nullptr },
        { "find_contact_by_remote_id_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_changes_async", reinterpret_cast<PyCFunction>(ContactStore_GetChangesAsync), METH_VARARGS, nullptr },
        { "load_extended_properties_async", reinterpret_cast<PyCFunction>(ContactStore_LoadExtendedPropertiesAsync), METH_VARARGS, nullptr },
        { "save_extended_properties_async", reinterpret_cast<PyCFunction>(ContactStore_SaveExtendedPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStore[] = {
        { "revision_number", reinterpret_cast<getter>(ContactStore_get_RevisionNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactStore) },
        { }
    };

    static PyType_Spec type_spec_ContactStore = {
        "winrt._winrt_windows_phone_personalinformation.ContactStore",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStore};

    static PyGetSetDef getset_ContactStore_Static[] = {
        { }
    };

    static PyMethodDef methods_ContactStore_Static[] = {
        { "create_or_open_async", reinterpret_cast<PyCFunction>(ContactStore_CreateOrOpenAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContactStore_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContactStore_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContactStore_Static) },
        { }
    };

    static PyType_Spec type_spec_ContactStore_Static =
    {
        "winrt._winrt_windows_phone_personalinformation.ContactStore_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContactStore_Static
    };

    // ----- KnownContactProperties class --------------------

    static PyObject* _new_KnownContactProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::PersonalInformation::KnownContactProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::PersonalInformation::KnownContactProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownContactProperties_get_AdditionalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AdditionalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AdditionalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Address(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_AlternateMobileTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AlternateMobileTelephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AlternateMobileTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_AlternateTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AlternateTelephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AlternateTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_AlternateWorkTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AlternateWorkTelephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AlternateWorkTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Anniversary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Anniversary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Anniversary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Birthdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Birthdate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Birthdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Children(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_CompanyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"CompanyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::CompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_CompanyTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"CompanyTelephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::CompanyTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_DisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Email(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Email");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Email());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_FamilyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_GivenName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_HomeFax(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"HomeFax");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::HomeFax());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_HonorificPrefix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_HonorificSuffix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_JobTitle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"JobTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::JobTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Manager(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Manager");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Manager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_MobileTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"MobileTelephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::MobileTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Nickname(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Nickname");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Notes(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Notes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Notes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_OfficeLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"OfficeLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::OfficeLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_OtherAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"OtherAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::OtherAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_OtherEmail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"OtherEmail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::OtherEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_SignificantOther(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"SignificantOther");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::SignificantOther());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Telephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Telephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Telephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Url(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Url");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Url());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkEmail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkEmail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkFax(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkFax");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkFax());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkTelephone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_YomiCompanyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"YomiCompanyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::YomiCompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_YomiFamilyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"YomiFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::YomiFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_YomiGivenName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"YomiGivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::YomiGivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownContactProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownContactProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownContactProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownContactProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownContactProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownContactProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownContactProperties = {
        "winrt._winrt_windows_phone_personalinformation.KnownContactProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownContactProperties};

    static PyGetSetDef getset_KnownContactProperties_Static[] = {
        { "additional_name", reinterpret_cast<getter>(KnownContactProperties_get_AdditionalName), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(KnownContactProperties_get_Address), nullptr, nullptr, nullptr },
        { "alternate_mobile_telephone", reinterpret_cast<getter>(KnownContactProperties_get_AlternateMobileTelephone), nullptr, nullptr, nullptr },
        { "alternate_telephone", reinterpret_cast<getter>(KnownContactProperties_get_AlternateTelephone), nullptr, nullptr, nullptr },
        { "alternate_work_telephone", reinterpret_cast<getter>(KnownContactProperties_get_AlternateWorkTelephone), nullptr, nullptr, nullptr },
        { "anniversary", reinterpret_cast<getter>(KnownContactProperties_get_Anniversary), nullptr, nullptr, nullptr },
        { "birthdate", reinterpret_cast<getter>(KnownContactProperties_get_Birthdate), nullptr, nullptr, nullptr },
        { "children", reinterpret_cast<getter>(KnownContactProperties_get_Children), nullptr, nullptr, nullptr },
        { "company_name", reinterpret_cast<getter>(KnownContactProperties_get_CompanyName), nullptr, nullptr, nullptr },
        { "company_telephone", reinterpret_cast<getter>(KnownContactProperties_get_CompanyTelephone), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(KnownContactProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "email", reinterpret_cast<getter>(KnownContactProperties_get_Email), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(KnownContactProperties_get_FamilyName), nullptr, nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(KnownContactProperties_get_GivenName), nullptr, nullptr, nullptr },
        { "home_fax", reinterpret_cast<getter>(KnownContactProperties_get_HomeFax), nullptr, nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(KnownContactProperties_get_HonorificPrefix), nullptr, nullptr, nullptr },
        { "honorific_suffix", reinterpret_cast<getter>(KnownContactProperties_get_HonorificSuffix), nullptr, nullptr, nullptr },
        { "job_title", reinterpret_cast<getter>(KnownContactProperties_get_JobTitle), nullptr, nullptr, nullptr },
        { "manager", reinterpret_cast<getter>(KnownContactProperties_get_Manager), nullptr, nullptr, nullptr },
        { "mobile_telephone", reinterpret_cast<getter>(KnownContactProperties_get_MobileTelephone), nullptr, nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(KnownContactProperties_get_Nickname), nullptr, nullptr, nullptr },
        { "notes", reinterpret_cast<getter>(KnownContactProperties_get_Notes), nullptr, nullptr, nullptr },
        { "office_location", reinterpret_cast<getter>(KnownContactProperties_get_OfficeLocation), nullptr, nullptr, nullptr },
        { "other_address", reinterpret_cast<getter>(KnownContactProperties_get_OtherAddress), nullptr, nullptr, nullptr },
        { "other_email", reinterpret_cast<getter>(KnownContactProperties_get_OtherEmail), nullptr, nullptr, nullptr },
        { "significant_other", reinterpret_cast<getter>(KnownContactProperties_get_SignificantOther), nullptr, nullptr, nullptr },
        { "telephone", reinterpret_cast<getter>(KnownContactProperties_get_Telephone), nullptr, nullptr, nullptr },
        { "url", reinterpret_cast<getter>(KnownContactProperties_get_Url), nullptr, nullptr, nullptr },
        { "work_address", reinterpret_cast<getter>(KnownContactProperties_get_WorkAddress), nullptr, nullptr, nullptr },
        { "work_email", reinterpret_cast<getter>(KnownContactProperties_get_WorkEmail), nullptr, nullptr, nullptr },
        { "work_fax", reinterpret_cast<getter>(KnownContactProperties_get_WorkFax), nullptr, nullptr, nullptr },
        { "work_telephone", reinterpret_cast<getter>(KnownContactProperties_get_WorkTelephone), nullptr, nullptr, nullptr },
        { "yomi_company_name", reinterpret_cast<getter>(KnownContactProperties_get_YomiCompanyName), nullptr, nullptr, nullptr },
        { "yomi_family_name", reinterpret_cast<getter>(KnownContactProperties_get_YomiFamilyName), nullptr, nullptr, nullptr },
        { "yomi_given_name", reinterpret_cast<getter>(KnownContactProperties_get_YomiGivenName), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownContactProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownContactProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownContactProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownContactProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownContactProperties_Static =
    {
        "winrt._winrt_windows_phone_personalinformation.KnownContactProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownContactProperties_Static
    };

    // ----- StoredContact class --------------------

    static PyObject* _new_StoredContact(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStore>(args, 0);

                winrt::Windows::Phone::PersonalInformation::StoredContact instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStore>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactInformation>(args, 1);

                winrt::Windows::Phone::PersonalInformation::StoredContact instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoredContact(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoredContact_GetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GetDisplayPictureAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDisplayPictureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_GetExtendedPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GetExtendedPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetExtendedPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_GetPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GetPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_ReplaceExistingContactAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"ReplaceExistingContactAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReplaceExistingContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_SaveAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"SaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_SetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"SetDisplayPictureAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.SetDisplayPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_ToVcardAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"ToVcardAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToVcardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"ToVcardAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::VCardFormat>(args, 0);

                return py::convert(self->obj.ToVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_get_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificPrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_GivenName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_GivenName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_DisplayPicture(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayPicture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoredContact_get_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayPictureDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayPictureDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayPictureDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_RemoteId(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_RemoteId(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_Id(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoredContact_get_Store(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"Store");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Store());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoredContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::StoredContact>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoredContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::StoredContact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoredContact[] = {
        { "get_display_picture_async", reinterpret_cast<PyCFunction>(StoredContact_GetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "get_extended_properties_async", reinterpret_cast<PyCFunction>(StoredContact_GetExtendedPropertiesAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(StoredContact_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "replace_existing_contact_async", reinterpret_cast<PyCFunction>(StoredContact_ReplaceExistingContactAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(StoredContact_SaveAsync), METH_VARARGS, nullptr },
        { "set_display_picture_async", reinterpret_cast<PyCFunction>(StoredContact_SetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "to_vcard_async", reinterpret_cast<PyCFunction>(StoredContact_ToVcardAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoredContact, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoredContact), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoredContact[] = {
        { "honorific_suffix", reinterpret_cast<getter>(StoredContact_get_HonorificSuffix), reinterpret_cast<setter>(StoredContact_put_HonorificSuffix), nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(StoredContact_get_HonorificPrefix), reinterpret_cast<setter>(StoredContact_put_HonorificPrefix), nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(StoredContact_get_GivenName), reinterpret_cast<setter>(StoredContact_put_GivenName), nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(StoredContact_get_FamilyName), reinterpret_cast<setter>(StoredContact_put_FamilyName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StoredContact_get_DisplayName), reinterpret_cast<setter>(StoredContact_put_DisplayName), nullptr, nullptr },
        { "display_picture", reinterpret_cast<getter>(StoredContact_get_DisplayPicture), nullptr, nullptr, nullptr },
        { "display_picture_date", reinterpret_cast<getter>(StoredContact_get_DisplayPictureDate), reinterpret_cast<setter>(StoredContact_put_DisplayPictureDate), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(StoredContact_get_RemoteId), reinterpret_cast<setter>(StoredContact_put_RemoteId), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StoredContact_get_Id), nullptr, nullptr, nullptr },
        { "store", reinterpret_cast<getter>(StoredContact_get_Store), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoredContact[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoredContact) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoredContact) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoredContact) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoredContact) },
        { }
    };

    static PyType_Spec type_spec_StoredContact = {
        "winrt._winrt_windows_phone_personalinformation.StoredContact",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::StoredContact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoredContact};

    // ----- IContactInformation interface --------------------

    static PyObject* _new_IContactInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::PersonalInformation::IContactInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::PersonalInformation::IContactInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactInformation(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactInformation_GetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GetDisplayPictureAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDisplayPictureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_GetPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GetPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_SetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"SetDisplayPictureAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.SetDisplayPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_ToVcardAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"ToVcardAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToVcardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"ToVcardAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::VCardFormat>(args, 0);

                return py::convert(self->obj.ToVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_get_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_DisplayPicture(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"DisplayPicture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactInformation_get_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"FamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_GivenName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_GivenName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GivenName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificPrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificPrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificSuffix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::IContactInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::IContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInformation[] = {
        { "get_display_picture_async", reinterpret_cast<PyCFunction>(IContactInformation_GetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(IContactInformation_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "set_display_picture_async", reinterpret_cast<PyCFunction>(IContactInformation_SetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "to_vcard_async", reinterpret_cast<PyCFunction>(IContactInformation_ToVcardAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContactInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactInformation[] = {
        { "display_name", reinterpret_cast<getter>(IContactInformation_get_DisplayName), reinterpret_cast<setter>(IContactInformation_put_DisplayName), nullptr, nullptr },
        { "display_picture", reinterpret_cast<getter>(IContactInformation_get_DisplayPicture), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(IContactInformation_get_FamilyName), reinterpret_cast<setter>(IContactInformation_put_FamilyName), nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(IContactInformation_get_GivenName), reinterpret_cast<setter>(IContactInformation_put_GivenName), nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(IContactInformation_get_HonorificPrefix), reinterpret_cast<setter>(IContactInformation_put_HonorificPrefix), nullptr, nullptr },
        { "honorific_suffix", reinterpret_cast<getter>(IContactInformation_get_HonorificSuffix), reinterpret_cast<setter>(IContactInformation_put_HonorificSuffix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactInformation) },
        { }
    };

    static PyType_Spec type_spec_IContactInformation = {
        "winrt._winrt_windows_phone_personalinformation.IContactInformation",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInformation};

    // ----- IContactInformation2 interface --------------------

    static PyObject* _new_IContactInformation2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::PersonalInformation::IContactInformation2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::PersonalInformation::IContactInformation2>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactInformation2(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactInformation2_get_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation2", L"DisplayPictureDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayPictureDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation2_put_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation2", L"DisplayPictureDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IContactInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::IContactInformation2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::IContactInformation2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInformation2[] = {
        { "_assign_array_", _assign_array_IContactInformation2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactInformation2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactInformation2[] = {
        { "display_picture_date", reinterpret_cast<getter>(IContactInformation2_get_DisplayPictureDate), reinterpret_cast<setter>(IContactInformation2_put_DisplayPictureDate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactInformation2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactInformation2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactInformation2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactInformation2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactInformation2) },
        { }
    };

    static PyType_Spec type_spec_IContactInformation2 = {
        "winrt._winrt_windows_phone_personalinformation.IContactInformation2",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInformation2};

    // ----- Windows.Phone.PersonalInformation Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Phone.PersonalInformation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_phone_personalinformation",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Phone::PersonalInformation

PyMODINIT_FUNC PyInit__winrt_windows_phone_personalinformation(void) noexcept
{
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle ContactAddress_type{py::register_python_type(module.get(), &type_spec_ContactAddress, object_bases.get(), nullptr)};
    if (!ContactAddress_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactChangeRecord_type{py::register_python_type(module.get(), &type_spec_ContactChangeRecord, object_bases.get(), nullptr)};
    if (!ContactChangeRecord_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContactInformation_Static{PyType_FromSpec(&type_spec_ContactInformation_Static)};
    if (!type_ContactInformation_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContactInformation_type{py::register_python_type(module.get(), &type_spec_ContactInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContactInformation_Static.get()))};
    if (!ContactInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactQueryOptions_type{py::register_python_type(module.get(), &type_spec_ContactQueryOptions, object_bases.get(), nullptr)};
    if (!ContactQueryOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle ContactQueryResult_type{py::register_python_type(module.get(), &type_spec_ContactQueryResult, object_bases.get(), nullptr)};
    if (!ContactQueryResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContactStore_Static{PyType_FromSpec(&type_spec_ContactStore_Static)};
    if (!type_ContactStore_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContactStore_type{py::register_python_type(module.get(), &type_spec_ContactStore, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContactStore_Static.get()))};
    if (!ContactStore_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownContactProperties_Static{PyType_FromSpec(&type_spec_KnownContactProperties_Static)};
    if (!type_KnownContactProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownContactProperties_type{py::register_python_type(module.get(), &type_spec_KnownContactProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownContactProperties_Static.get()))};
    if (!KnownContactProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle StoredContact_type{py::register_python_type(module.get(), &type_spec_StoredContact, object_bases.get(), nullptr)};
    if (!StoredContact_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactInformation_type{py::register_python_type(module.get(), &type_spec_IContactInformation, object_bases.get(), nullptr)};
    if (!IContactInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle IContactInformation2_type{py::register_python_type(module.get(), &type_spec_IContactInformation2, object_bases.get(), nullptr)};
    if (!IContactInformation2_type)
    {
        return nullptr;
    }


    return module.detach();
}
