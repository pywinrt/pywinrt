// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Composition.Interactions.h"


namespace py::cpp::Microsoft::UI::Composition::Interactions
{
    // ----- CompositionConditionalValue class --------------------

    static PyObject* _new_CompositionConditionalValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionConditionalValue(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionConditionalValue_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionConditionalValue_get_Value(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionConditionalValue_put_Value(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionConditionalValue_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Condition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionConditionalValue_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Condition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionConditionalValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionConditionalValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionConditionalValue[] = {
        { "_assign_array_", _assign_array_CompositionConditionalValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionConditionalValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionConditionalValue[] = {
        { "value", reinterpret_cast<getter>(CompositionConditionalValue_get_Value), reinterpret_cast<setter>(CompositionConditionalValue_put_Value), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(CompositionConditionalValue_get_Condition), reinterpret_cast<setter>(CompositionConditionalValue_put_Condition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionConditionalValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionConditionalValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionConditionalValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionConditionalValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionConditionalValue) },
        { },
    };

    static PyType_Spec type_spec_CompositionConditionalValue =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.CompositionConditionalValue",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionConditionalValue
    };

    static PyGetSetDef getset_CompositionConditionalValue_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionConditionalValue_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(CompositionConditionalValue_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CompositionConditionalValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionConditionalValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionConditionalValue_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionConditionalValue_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.CompositionConditionalValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositionConditionalValue_Static
    };

    // ----- CompositionInteractionSourceCollection class --------------------

    static PyObject* _new_CompositionInteractionSourceCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionInteractionSourceCollection(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionInteractionSourceCollection_Add(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"Add", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_First(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_Remove(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_RemoveAll(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"RemoveAll", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_get_Count(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"Count"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Count());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionInteractionSourceCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionInteractionSourceCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionInteractionSourceCollection(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionInteractionSourceCollection[] = {
        { "add", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_Add), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_First), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionInteractionSourceCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionInteractionSourceCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionInteractionSourceCollection[] = {
        { "count", reinterpret_cast<getter>(CompositionInteractionSourceCollection_get_Count), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionInteractionSourceCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionInteractionSourceCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionInteractionSourceCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionInteractionSourceCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionInteractionSourceCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionInteractionSourceCollection) },
        { },
    };

    static PyType_Spec type_spec_CompositionInteractionSourceCollection =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.CompositionInteractionSourceCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionInteractionSourceCollection
    };

    // ----- InteractionSourceConfiguration class --------------------

    static PyObject* _new_InteractionSourceConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionSourceConfiguration(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionSourceConfiguration_get_ScaleSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"ScaleSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleSourceMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionSourceConfiguration_put_ScaleSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"ScaleSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceRedirectionMode>(arg);

            self->obj.ScaleSourceMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionSourceConfiguration_get_PositionYSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionYSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionYSourceMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionSourceConfiguration_put_PositionYSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionYSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceRedirectionMode>(arg);

            self->obj.PositionYSourceMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionSourceConfiguration_get_PositionXSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionXSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionXSourceMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionSourceConfiguration_put_PositionXSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionXSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceRedirectionMode>(arg);

            self->obj.PositionXSourceMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionSourceConfiguration[] = {
        { "_assign_array_", _assign_array_InteractionSourceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionSourceConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionSourceConfiguration[] = {
        { "scale_source_mode", reinterpret_cast<getter>(InteractionSourceConfiguration_get_ScaleSourceMode), reinterpret_cast<setter>(InteractionSourceConfiguration_put_ScaleSourceMode), nullptr, nullptr },
        { "position_y_source_mode", reinterpret_cast<getter>(InteractionSourceConfiguration_get_PositionYSourceMode), reinterpret_cast<setter>(InteractionSourceConfiguration_put_PositionYSourceMode), nullptr, nullptr },
        { "position_x_source_mode", reinterpret_cast<getter>(InteractionSourceConfiguration_get_PositionXSourceMode), reinterpret_cast<setter>(InteractionSourceConfiguration_put_PositionXSourceMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionSourceConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionSourceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionSourceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionSourceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionSourceConfiguration) },
        { },
    };

    static PyType_Spec type_spec_InteractionSourceConfiguration =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionSourceConfiguration",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionSourceConfiguration
    };

    // ----- InteractionTracker class --------------------

    static PyObject* _new_InteractionTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTracker(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTracker_AdjustPositionXIfGreaterThanThreshold(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"AdjustPositionXIfGreaterThanThreshold", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.AdjustPositionXIfGreaterThanThreshold(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_AdjustPositionYIfGreaterThanThreshold(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"AdjustPositionYIfGreaterThanThreshold", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.AdjustPositionYIfGreaterThanThreshold(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureCenterPointXInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureCenterPointXInertiaModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureCenterPointXInertiaModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureCenterPointYInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureCenterPointYInertiaModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureCenterPointYInertiaModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigurePositionXInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigurePositionXInertiaModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>(args, 0);

                self->obj.ConfigurePositionXInertiaModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigurePositionYInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigurePositionYInertiaModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>(args, 0);

                self->obj.ConfigurePositionYInertiaModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureScaleInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureScaleInertiaModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>(args, 0);

                self->obj.ConfigureScaleInertiaModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureVector2PositionInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureVector2PositionInertiaModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>>(args, 0);

                self->obj.ConfigureVector2PositionInertiaModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_CreateWithOwner(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"CreateWithOwner", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>(args, 1);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::CreateWithOwner(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_GetBindingMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"GetBindingMode", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 1);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::GetBindingMode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_SetBindingMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"SetBindingMode", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionBindingAxisModes>(args, 2);

                winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::SetBindingMode(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert(self->obj.TryUpdatePosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePosition", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerClampingOption>(args, 1);

                return py::convert(self->obj.TryUpdatePosition(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePosition", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerClampingOption>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerPositionUpdateOption>(args, 2);

                return py::convert(self->obj.TryUpdatePosition(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionBy(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionBy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert(self->obj.TryUpdatePositionBy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionBy", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerClampingOption>(args, 1);

                return py::convert(self->obj.TryUpdatePositionBy(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionWithAdditionalVelocity(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionWithAdditionalVelocity", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert(self->obj.TryUpdatePositionWithAdditionalVelocity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionWithAnimation(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionWithAnimation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 0);

                return py::convert(self->obj.TryUpdatePositionWithAnimation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdateScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdateScale", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                return py::convert(self->obj.TryUpdateScale(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdateScaleWithAdditionalVelocity(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdateScaleWithAdditionalVelocity", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                return py::convert(self->obj.TryUpdateScaleWithAdditionalVelocity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdateScaleWithAnimation(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdateScaleWithAnimation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                return py::convert(self->obj.TryUpdateScaleWithAnimation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_ScaleInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ScaleInertiaDecayRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleInertiaDecayRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_ScaleInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ScaleInertiaDecayRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            self->obj.ScaleInertiaDecayRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_PositionInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"PositionInertiaDecayRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionInertiaDecayRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_PositionInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"PositionInertiaDecayRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float3>>(arg);

            self->obj.PositionInertiaDecayRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MinScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MinScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.MinScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MinPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MinPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.MinPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MaxScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MaxScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MaxPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MaxPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.MaxPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_InteractionSources(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"InteractionSources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_IsPositionRoundingSuggested(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"IsPositionRoundingSuggested"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPositionRoundingSuggested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_NaturalRestingPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"NaturalRestingPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalRestingPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_NaturalRestingScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"NaturalRestingScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalRestingScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_Owner(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Owner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Owner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_Position(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_PositionVelocityInPixelsPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"PositionVelocityInPixelsPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionVelocityInPixelsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_Scale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_ScaleVelocityInPercentPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ScaleVelocityInPercentPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleVelocityInPercentPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_IsInertiaFromImpulse(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"IsInertiaFromImpulse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInertiaFromImpulse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTracker[] = {
        { "adjust_position_x_if_greater_than_threshold", reinterpret_cast<PyCFunction>(InteractionTracker_AdjustPositionXIfGreaterThanThreshold), METH_VARARGS, nullptr },
        { "adjust_position_y_if_greater_than_threshold", reinterpret_cast<PyCFunction>(InteractionTracker_AdjustPositionYIfGreaterThanThreshold), METH_VARARGS, nullptr },
        { "configure_center_point_x_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureCenterPointXInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_center_point_y_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureCenterPointYInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_position_x_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigurePositionXInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_position_y_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigurePositionYInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_scale_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureScaleInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_vector2_position_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureVector2PositionInertiaModifiers), METH_VARARGS, nullptr },
        { "try_update_position", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePosition), METH_VARARGS, nullptr },
        { "try_update_position_by", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionBy), METH_VARARGS, nullptr },
        { "try_update_position_with_additional_velocity", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionWithAdditionalVelocity), METH_VARARGS, nullptr },
        { "try_update_position_with_animation", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionWithAnimation), METH_VARARGS, nullptr },
        { "try_update_scale", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdateScale), METH_VARARGS, nullptr },
        { "try_update_scale_with_additional_velocity", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdateScaleWithAdditionalVelocity), METH_VARARGS, nullptr },
        { "try_update_scale_with_animation", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdateScaleWithAnimation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InteractionTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTracker[] = {
        { "scale_inertia_decay_rate", reinterpret_cast<getter>(InteractionTracker_get_ScaleInertiaDecayRate), reinterpret_cast<setter>(InteractionTracker_put_ScaleInertiaDecayRate), nullptr, nullptr },
        { "position_inertia_decay_rate", reinterpret_cast<getter>(InteractionTracker_get_PositionInertiaDecayRate), reinterpret_cast<setter>(InteractionTracker_put_PositionInertiaDecayRate), nullptr, nullptr },
        { "min_scale", reinterpret_cast<getter>(InteractionTracker_get_MinScale), reinterpret_cast<setter>(InteractionTracker_put_MinScale), nullptr, nullptr },
        { "min_position", reinterpret_cast<getter>(InteractionTracker_get_MinPosition), reinterpret_cast<setter>(InteractionTracker_put_MinPosition), nullptr, nullptr },
        { "max_scale", reinterpret_cast<getter>(InteractionTracker_get_MaxScale), reinterpret_cast<setter>(InteractionTracker_put_MaxScale), nullptr, nullptr },
        { "max_position", reinterpret_cast<getter>(InteractionTracker_get_MaxPosition), reinterpret_cast<setter>(InteractionTracker_put_MaxPosition), nullptr, nullptr },
        { "interaction_sources", reinterpret_cast<getter>(InteractionTracker_get_InteractionSources), nullptr, nullptr, nullptr },
        { "is_position_rounding_suggested", reinterpret_cast<getter>(InteractionTracker_get_IsPositionRoundingSuggested), nullptr, nullptr, nullptr },
        { "natural_resting_position", reinterpret_cast<getter>(InteractionTracker_get_NaturalRestingPosition), nullptr, nullptr, nullptr },
        { "natural_resting_scale", reinterpret_cast<getter>(InteractionTracker_get_NaturalRestingScale), nullptr, nullptr, nullptr },
        { "owner", reinterpret_cast<getter>(InteractionTracker_get_Owner), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(InteractionTracker_get_Position), nullptr, nullptr, nullptr },
        { "position_velocity_in_pixels_per_second", reinterpret_cast<getter>(InteractionTracker_get_PositionVelocityInPixelsPerSecond), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(InteractionTracker_get_Scale), nullptr, nullptr, nullptr },
        { "scale_velocity_in_percent_per_second", reinterpret_cast<getter>(InteractionTracker_get_ScaleVelocityInPercentPerSecond), nullptr, nullptr, nullptr },
        { "is_inertia_from_impulse", reinterpret_cast<getter>(InteractionTracker_get_IsInertiaFromImpulse), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTracker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTracker) },
        { },
    };

    static PyType_Spec type_spec_InteractionTracker =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTracker",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTracker
    };

    static PyGetSetDef getset_InteractionTracker_Static[] = {
        { }
    };

    static PyMethodDef methods_InteractionTracker_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTracker_Create), METH_VARARGS, nullptr },
        { "create_with_owner", reinterpret_cast<PyCFunction>(InteractionTracker_CreateWithOwner), METH_VARARGS, nullptr },
        { "get_binding_mode", reinterpret_cast<PyCFunction>(InteractionTracker_GetBindingMode), METH_VARARGS, nullptr },
        { "set_binding_mode", reinterpret_cast<PyCFunction>(InteractionTracker_SetBindingMode), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InteractionTracker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTracker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTracker_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTracker_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTracker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTracker_Static
    };

    // ----- InteractionTrackerCustomAnimationStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerCustomAnimationStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerCustomAnimationStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerCustomAnimationStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerCustomAnimationStateEnteredArgs", L"RequestId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerCustomAnimationStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerCustomAnimationStateEnteredArgs", L"IsFromBinding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFromBinding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerCustomAnimationStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerCustomAnimationStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerCustomAnimationStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerCustomAnimationStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerCustomAnimationStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerCustomAnimationStateEnteredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerCustomAnimationStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerCustomAnimationStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerCustomAnimationStateEnteredArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerCustomAnimationStateEnteredArgs =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerCustomAnimationStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerCustomAnimationStateEnteredArgs
    };

    // ----- InteractionTrackerIdleStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerIdleStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerIdleStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerIdleStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerIdleStateEnteredArgs", L"RequestId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerIdleStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerIdleStateEnteredArgs", L"IsFromBinding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFromBinding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerIdleStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerIdleStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerIdleStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerIdleStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerIdleStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerIdleStateEnteredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerIdleStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerIdleStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerIdleStateEnteredArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerIdleStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerIdleStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerIdleStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerIdleStateEnteredArgs) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerIdleStateEnteredArgs =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerIdleStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerIdleStateEnteredArgs
    };

    // ----- InteractionTrackerInertiaModifier class --------------------

    static PyObject* _new_InteractionTrackerInertiaModifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaModifier(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InteractionTrackerInertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaModifier[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaModifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerInertiaModifier[] = {
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerInertiaModifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaModifier) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaModifier =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaModifier",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaModifier
    };

    // ----- InteractionTrackerInertiaMotion class --------------------

    static PyObject* _new_InteractionTrackerInertiaMotion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaMotion_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaMotion_get_Motion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Motion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Motion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaMotion_put_Motion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Motion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Motion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerInertiaMotion_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Condition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaMotion_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Condition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaMotion[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaMotion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaMotion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerInertiaMotion[] = {
        { "motion", reinterpret_cast<getter>(InteractionTrackerInertiaMotion_get_Motion), reinterpret_cast<setter>(InteractionTrackerInertiaMotion_put_Motion), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerInertiaMotion_get_Condition), reinterpret_cast<setter>(InteractionTrackerInertiaMotion_put_Condition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerInertiaMotion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaMotion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaMotion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaMotion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaMotion) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaMotion =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaMotion",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaMotion
    };

    static PyGetSetDef getset_InteractionTrackerInertiaMotion_Static[] = {
        { }
    };

    static PyMethodDef methods_InteractionTrackerInertiaMotion_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerInertiaMotion_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InteractionTrackerInertiaMotion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaMotion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaMotion_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaMotion_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaMotion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerInertiaMotion_Static
    };

    // ----- InteractionTrackerInertiaNaturalMotion class --------------------

    static PyObject* _new_InteractionTrackerInertiaNaturalMotion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaNaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaNaturalMotion_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaNaturalMotion_get_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"NaturalMotion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalMotion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaNaturalMotion_put_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"NaturalMotion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>(arg);

            self->obj.NaturalMotion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerInertiaNaturalMotion_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Condition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaNaturalMotion_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Condition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaNaturalMotion[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaNaturalMotion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaNaturalMotion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerInertiaNaturalMotion[] = {
        { "natural_motion", reinterpret_cast<getter>(InteractionTrackerInertiaNaturalMotion_get_NaturalMotion), reinterpret_cast<setter>(InteractionTrackerInertiaNaturalMotion_put_NaturalMotion), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerInertiaNaturalMotion_get_Condition), reinterpret_cast<setter>(InteractionTrackerInertiaNaturalMotion_put_Condition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerInertiaNaturalMotion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaNaturalMotion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaNaturalMotion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaNaturalMotion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaNaturalMotion) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaNaturalMotion =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaNaturalMotion",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaNaturalMotion
    };

    static PyGetSetDef getset_InteractionTrackerInertiaNaturalMotion_Static[] = {
        { }
    };

    static PyMethodDef methods_InteractionTrackerInertiaNaturalMotion_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerInertiaNaturalMotion_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InteractionTrackerInertiaNaturalMotion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaNaturalMotion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaNaturalMotion_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaNaturalMotion_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaNaturalMotion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerInertiaNaturalMotion_Static
    };

    // ----- InteractionTrackerInertiaRestingValue class --------------------

    static PyObject* _new_InteractionTrackerInertiaRestingValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaRestingValue(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaRestingValue_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaRestingValue_get_RestingValue(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"RestingValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RestingValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaRestingValue_put_RestingValue(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"RestingValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.RestingValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerInertiaRestingValue_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Condition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaRestingValue_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Condition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaRestingValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaRestingValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaRestingValue[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaRestingValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaRestingValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerInertiaRestingValue[] = {
        { "resting_value", reinterpret_cast<getter>(InteractionTrackerInertiaRestingValue_get_RestingValue), reinterpret_cast<setter>(InteractionTrackerInertiaRestingValue_put_RestingValue), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerInertiaRestingValue_get_Condition), reinterpret_cast<setter>(InteractionTrackerInertiaRestingValue_put_Condition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerInertiaRestingValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaRestingValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaRestingValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaRestingValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaRestingValue) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaRestingValue =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaRestingValue",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaRestingValue
    };

    static PyGetSetDef getset_InteractionTrackerInertiaRestingValue_Static[] = {
        { }
    };

    static PyMethodDef methods_InteractionTrackerInertiaRestingValue_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerInertiaRestingValue_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InteractionTrackerInertiaRestingValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaRestingValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaRestingValue_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaRestingValue_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaRestingValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerInertiaRestingValue_Static
    };

    // ----- InteractionTrackerInertiaStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerInertiaStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"ModifiedRestingPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModifiedRestingPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"ModifiedRestingScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModifiedRestingScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"NaturalRestingPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalRestingPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"NaturalRestingScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalRestingScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_PositionVelocityInPixelsPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"PositionVelocityInPixelsPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionVelocityInPixelsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"RequestId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_ScaleVelocityInPercentPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"ScaleVelocityInPercentPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleVelocityInPercentPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_IsInertiaFromImpulse(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"IsInertiaFromImpulse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInertiaFromImpulse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"IsFromBinding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFromBinding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerInertiaStateEnteredArgs[] = {
        { "modified_resting_position", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingPosition), nullptr, nullptr, nullptr },
        { "modified_resting_scale", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingScale), nullptr, nullptr, nullptr },
        { "natural_resting_position", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingPosition), nullptr, nullptr, nullptr },
        { "natural_resting_scale", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingScale), nullptr, nullptr, nullptr },
        { "position_velocity_in_pixels_per_second", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_PositionVelocityInPixelsPerSecond), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "scale_velocity_in_percent_per_second", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_ScaleVelocityInPercentPerSecond), nullptr, nullptr, nullptr },
        { "is_inertia_from_impulse", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_IsInertiaFromImpulse), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerInertiaStateEnteredArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaStateEnteredArgs) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaStateEnteredArgs =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInertiaStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaStateEnteredArgs
    };

    // ----- InteractionTrackerInteractingStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerInteractingStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInteractingStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInteractingStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInteractingStateEnteredArgs", L"RequestId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInteractingStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInteractingStateEnteredArgs", L"IsFromBinding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFromBinding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInteractingStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInteractingStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInteractingStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInteractingStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInteractingStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerInteractingStateEnteredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerInteractingStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerInteractingStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerInteractingStateEnteredArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInteractingStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInteractingStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInteractingStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInteractingStateEnteredArgs) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerInteractingStateEnteredArgs =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerInteractingStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInteractingStateEnteredArgs
    };

    // ----- InteractionTrackerRequestIgnoredArgs class --------------------

    static PyObject* _new_InteractionTrackerRequestIgnoredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerRequestIgnoredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerRequestIgnoredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerRequestIgnoredArgs", L"RequestId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerRequestIgnoredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerRequestIgnoredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerRequestIgnoredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerRequestIgnoredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerRequestIgnoredArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerRequestIgnoredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerRequestIgnoredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerRequestIgnoredArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerRequestIgnoredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerRequestIgnoredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerRequestIgnoredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerRequestIgnoredArgs) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerRequestIgnoredArgs =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerRequestIgnoredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerRequestIgnoredArgs
    };

    // ----- InteractionTrackerValuesChangedArgs class --------------------

    static PyObject* _new_InteractionTrackerValuesChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerValuesChangedArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerValuesChangedArgs_get_Position(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerValuesChangedArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerValuesChangedArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerValuesChangedArgs", L"RequestId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerValuesChangedArgs_get_Scale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerValuesChangedArgs", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerValuesChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerValuesChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerValuesChangedArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerValuesChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerValuesChangedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerValuesChangedArgs[] = {
        { "position", reinterpret_cast<getter>(InteractionTrackerValuesChangedArgs_get_Position), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(InteractionTrackerValuesChangedArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(InteractionTrackerValuesChangedArgs_get_Scale), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerValuesChangedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerValuesChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerValuesChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerValuesChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerValuesChangedArgs) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerValuesChangedArgs =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerValuesChangedArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerValuesChangedArgs
    };

    // ----- InteractionTrackerVector2InertiaModifier class --------------------

    static PyObject* _new_InteractionTrackerVector2InertiaModifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerVector2InertiaModifier(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InteractionTrackerVector2InertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerVector2InertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerVector2InertiaModifier[] = {
        { "_assign_array_", _assign_array_InteractionTrackerVector2InertiaModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerVector2InertiaModifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerVector2InertiaModifier[] = {
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerVector2InertiaModifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerVector2InertiaModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerVector2InertiaModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerVector2InertiaModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerVector2InertiaModifier) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaModifier =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaModifier",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerVector2InertiaModifier
    };

    // ----- InteractionTrackerVector2InertiaNaturalMotion class --------------------

    static PyObject* _new_InteractionTrackerVector2InertiaNaturalMotion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerVector2InertiaNaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerVector2InertiaNaturalMotion_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerVector2InertiaNaturalMotion_get_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"NaturalMotion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalMotion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerVector2InertiaNaturalMotion_put_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"NaturalMotion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>(arg);

            self->obj.NaturalMotion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerVector2InertiaNaturalMotion_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Condition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerVector2InertiaNaturalMotion_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"Condition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            self->obj.Condition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerVector2InertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerVector2InertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerVector2InertiaNaturalMotion[] = {
        { "_assign_array_", _assign_array_InteractionTrackerVector2InertiaNaturalMotion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerVector2InertiaNaturalMotion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InteractionTrackerVector2InertiaNaturalMotion[] = {
        { "natural_motion", reinterpret_cast<getter>(InteractionTrackerVector2InertiaNaturalMotion_get_NaturalMotion), reinterpret_cast<setter>(InteractionTrackerVector2InertiaNaturalMotion_put_NaturalMotion), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerVector2InertiaNaturalMotion_get_Condition), reinterpret_cast<setter>(InteractionTrackerVector2InertiaNaturalMotion_put_Condition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InteractionTrackerVector2InertiaNaturalMotion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerVector2InertiaNaturalMotion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerVector2InertiaNaturalMotion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerVector2InertiaNaturalMotion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerVector2InertiaNaturalMotion) },
        { },
    };

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaNaturalMotion =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaNaturalMotion",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerVector2InertiaNaturalMotion
    };

    static PyGetSetDef getset_InteractionTrackerVector2InertiaNaturalMotion_Static[] = {
        { }
    };

    static PyMethodDef methods_InteractionTrackerVector2InertiaNaturalMotion_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerVector2InertiaNaturalMotion_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InteractionTrackerVector2InertiaNaturalMotion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerVector2InertiaNaturalMotion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerVector2InertiaNaturalMotion_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaNaturalMotion_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaNaturalMotion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerVector2InertiaNaturalMotion_Static
    };

    // ----- VisualInteractionSource class --------------------

    static PyObject* _new_VisualInteractionSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualInteractionSource(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualInteractionSource_ConfigureCenterPointXModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureCenterPointXModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureCenterPointXModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureCenterPointYModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureCenterPointYModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureCenterPointYModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureDeltaPositionXModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureDeltaPositionXModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureDeltaPositionXModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureDeltaPositionYModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureDeltaPositionYModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureDeltaPositionYModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureDeltaScaleModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureDeltaScaleModifiers", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                self->obj.ConfigureDeltaScaleModifiers(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_CreateFromIVisualElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"CreateFromIVisualElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::IVisualElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource::CreateFromIVisualElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_TryRedirectForManipulation(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"TryRedirectForManipulation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                self->obj.TryRedirectForManipulation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_ScaleSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleSourceMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_ScaleSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceMode>(arg);

            self->obj.ScaleSourceMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_ScaleChainingMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleChainingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleChainingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_ScaleChainingMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleChainingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionChainingMode>(arg);

            self->obj.ScaleChainingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionYSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionYSourceMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionYSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceMode>(arg);

            self->obj.PositionYSourceMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionYChainingMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYChainingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionYChainingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionYChainingMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYChainingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionChainingMode>(arg);

            self->obj.PositionYChainingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionXSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionXSourceMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionXSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXSourceMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceMode>(arg);

            self->obj.PositionXSourceMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionXChainingMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXChainingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionXChainingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionXChainingMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXChainingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionChainingMode>(arg);

            self->obj.PositionXChainingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_ManipulationRedirectionMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ManipulationRedirectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ManipulationRedirectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_ManipulationRedirectionMode(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ManipulationRedirectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSourceRedirectionMode>(arg);

            self->obj.ManipulationRedirectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_IsPositionYRailsEnabled(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionYRailsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPositionYRailsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_IsPositionYRailsEnabled(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionYRailsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPositionYRailsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_IsPositionXRailsEnabled(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionXRailsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPositionXRailsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_IsPositionXRailsEnabled(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionXRailsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPositionXRailsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_Source(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_DeltaPosition(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"DeltaPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeltaPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_DeltaScale(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"DeltaScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeltaScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_Position(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionVelocity(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_Scale(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_ScaleVelocity(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_PointerWheelConfig(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PointerWheelConfig"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerWheelConfig());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualInteractionSource[] = {
        { "configure_center_point_x_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureCenterPointXModifiers), METH_VARARGS, nullptr },
        { "configure_center_point_y_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureCenterPointYModifiers), METH_VARARGS, nullptr },
        { "configure_delta_position_x_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureDeltaPositionXModifiers), METH_VARARGS, nullptr },
        { "configure_delta_position_y_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureDeltaPositionYModifiers), METH_VARARGS, nullptr },
        { "configure_delta_scale_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureDeltaScaleModifiers), METH_VARARGS, nullptr },
        { "try_redirect_for_manipulation", reinterpret_cast<PyCFunction>(VisualInteractionSource_TryRedirectForManipulation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualInteractionSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualInteractionSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualInteractionSource[] = {
        { "scale_source_mode", reinterpret_cast<getter>(VisualInteractionSource_get_ScaleSourceMode), reinterpret_cast<setter>(VisualInteractionSource_put_ScaleSourceMode), nullptr, nullptr },
        { "scale_chaining_mode", reinterpret_cast<getter>(VisualInteractionSource_get_ScaleChainingMode), reinterpret_cast<setter>(VisualInteractionSource_put_ScaleChainingMode), nullptr, nullptr },
        { "position_y_source_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionYSourceMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionYSourceMode), nullptr, nullptr },
        { "position_y_chaining_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionYChainingMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionYChainingMode), nullptr, nullptr },
        { "position_x_source_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionXSourceMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionXSourceMode), nullptr, nullptr },
        { "position_x_chaining_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionXChainingMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionXChainingMode), nullptr, nullptr },
        { "manipulation_redirection_mode", reinterpret_cast<getter>(VisualInteractionSource_get_ManipulationRedirectionMode), reinterpret_cast<setter>(VisualInteractionSource_put_ManipulationRedirectionMode), nullptr, nullptr },
        { "is_position_y_rails_enabled", reinterpret_cast<getter>(VisualInteractionSource_get_IsPositionYRailsEnabled), reinterpret_cast<setter>(VisualInteractionSource_put_IsPositionYRailsEnabled), nullptr, nullptr },
        { "is_position_x_rails_enabled", reinterpret_cast<getter>(VisualInteractionSource_get_IsPositionXRailsEnabled), reinterpret_cast<setter>(VisualInteractionSource_put_IsPositionXRailsEnabled), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(VisualInteractionSource_get_Source), nullptr, nullptr, nullptr },
        { "delta_position", reinterpret_cast<getter>(VisualInteractionSource_get_DeltaPosition), nullptr, nullptr, nullptr },
        { "delta_scale", reinterpret_cast<getter>(VisualInteractionSource_get_DeltaScale), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(VisualInteractionSource_get_Position), nullptr, nullptr, nullptr },
        { "position_velocity", reinterpret_cast<getter>(VisualInteractionSource_get_PositionVelocity), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(VisualInteractionSource_get_Scale), nullptr, nullptr, nullptr },
        { "scale_velocity", reinterpret_cast<getter>(VisualInteractionSource_get_ScaleVelocity), nullptr, nullptr, nullptr },
        { "pointer_wheel_config", reinterpret_cast<getter>(VisualInteractionSource_get_PointerWheelConfig), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualInteractionSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualInteractionSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualInteractionSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualInteractionSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualInteractionSource) },
        { },
    };

    static PyType_Spec type_spec_VisualInteractionSource =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.VisualInteractionSource",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::VisualInteractionSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualInteractionSource
    };

    static PyGetSetDef getset_VisualInteractionSource_Static[] = {
        { }
    };

    static PyMethodDef methods_VisualInteractionSource_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(VisualInteractionSource_Create), METH_VARARGS, nullptr },
        { "create_from_i_visual_element", reinterpret_cast<PyCFunction>(VisualInteractionSource_CreateFromIVisualElement), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VisualInteractionSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VisualInteractionSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VisualInteractionSource_Static) },
        { }
    };

    static PyType_Spec type_spec_VisualInteractionSource_Static =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.VisualInteractionSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VisualInteractionSource_Static
    };

    // ----- ICompositionInteractionSource interface --------------------

    static PyObject* _new_ICompositionInteractionSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>::type_name);
        return nullptr;
    }

    static void _dealloc_ICompositionInteractionSource(py::wrapper::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ICompositionInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICompositionInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICompositionInteractionSource[] = {
        { "_assign_array_", _assign_array_ICompositionInteractionSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICompositionInteractionSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICompositionInteractionSource[] = {
        { }
    };

    static PyType_Slot _type_slots_ICompositionInteractionSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICompositionInteractionSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICompositionInteractionSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICompositionInteractionSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICompositionInteractionSource) },
        { },
    };

    static PyType_Spec type_spec_ICompositionInteractionSource =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.ICompositionInteractionSource",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICompositionInteractionSource
    };

    // ----- IInteractionTrackerOwner interface --------------------

    static PyObject* _new_IInteractionTrackerOwner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>::type_name);
        return nullptr;
    }

    static void _dealloc_IInteractionTrackerOwner(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInteractionTrackerOwner_CustomAnimationStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"CustomAnimationStateEntered", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>(args, 1);

                self->obj.CustomAnimationStateEntered(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_IdleStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"IdleStateEntered", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>(args, 1);

                self->obj.IdleStateEntered(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_InertiaStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"InertiaStateEntered", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>(args, 1);

                self->obj.InertiaStateEntered(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_InteractingStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"InteractingStateEntered", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>(args, 1);

                self->obj.InteractingStateEntered(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_RequestIgnored(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"RequestIgnored", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>(args, 1);

                self->obj.RequestIgnored(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_ValuesChanged(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"ValuesChanged", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>(args, 1);

                self->obj.ValuesChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInteractionTrackerOwner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInteractionTrackerOwner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInteractionTrackerOwner[] = {
        { "custom_animation_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_CustomAnimationStateEntered), METH_VARARGS, nullptr },
        { "idle_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_IdleStateEntered), METH_VARARGS, nullptr },
        { "inertia_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_InertiaStateEntered), METH_VARARGS, nullptr },
        { "interacting_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_InteractingStateEntered), METH_VARARGS, nullptr },
        { "request_ignored", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_RequestIgnored), METH_VARARGS, nullptr },
        { "values_changed", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_ValuesChanged), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInteractionTrackerOwner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInteractionTrackerOwner), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInteractionTrackerOwner[] = {
        { }
    };

    static PyType_Slot _type_slots_IInteractionTrackerOwner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInteractionTrackerOwner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInteractionTrackerOwner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInteractionTrackerOwner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInteractionTrackerOwner) },
        { },
    };

    static PyType_Spec type_spec_IInteractionTrackerOwner =
    {
        "winrt._winrt_microsoft_ui_composition_interactions.IInteractionTrackerOwner",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInteractionTrackerOwner
    };

    // ----- Microsoft.UI.Composition.Interactions Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Composition::Interactions");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_composition_interactions",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Composition::Interactions

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_composition_interactions(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Composition::Interactions;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionConditionalValue_Static{PyType_FromSpec(&type_spec_CompositionConditionalValue_Static)};
    if (!type_CompositionConditionalValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompositionConditionalValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionConditionalValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompositionInteractionSourceCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionSourceConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTracker_Static{PyType_FromSpec(&type_spec_InteractionTracker_Static)};
    if (!type_InteractionTracker_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTracker, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTracker_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerCustomAnimationStateEnteredArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerIdleStateEnteredArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaModifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaMotion_Static{PyType_FromSpec(&type_spec_InteractionTrackerInertiaMotion_Static)};
    if (!type_InteractionTrackerInertiaMotion_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaMotion, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaMotion_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaNaturalMotion_Static{PyType_FromSpec(&type_spec_InteractionTrackerInertiaNaturalMotion_Static)};
    if (!type_InteractionTrackerInertiaNaturalMotion_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaNaturalMotion, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaNaturalMotion_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaRestingValue_Static{PyType_FromSpec(&type_spec_InteractionTrackerInertiaRestingValue_Static)};
    if (!type_InteractionTrackerInertiaRestingValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaRestingValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaRestingValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaStateEnteredArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerInteractingStateEnteredArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerRequestIgnoredArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerValuesChangedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerVector2InertiaModifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerVector2InertiaNaturalMotion_Static{PyType_FromSpec(&type_spec_InteractionTrackerVector2InertiaNaturalMotion_Static)};
    if (!type_InteractionTrackerVector2InertiaNaturalMotion_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InteractionTrackerVector2InertiaNaturalMotion, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerVector2InertiaNaturalMotion_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_VisualInteractionSource_Static{PyType_FromSpec(&type_spec_VisualInteractionSource_Static)};
    if (!type_VisualInteractionSource_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VisualInteractionSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VisualInteractionSource_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICompositionInteractionSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IInteractionTrackerOwner, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
