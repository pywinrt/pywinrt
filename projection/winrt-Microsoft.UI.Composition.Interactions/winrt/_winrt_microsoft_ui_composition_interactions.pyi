# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.composition
import winrt.microsoft.ui.input
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics

from winrt.microsoft.ui.composition.interactions import InteractionBindingAxisModes, InteractionChainingMode, InteractionSourceMode, InteractionSourceRedirectionMode, InteractionTrackerClampingOption, InteractionTrackerPositionUpdateOption, VisualInteractionSourceRedirectionMode

Self = typing.TypeVar('Self')

@typing.final
class CompositionConditionalValue_Static(type):
    def create(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], /) -> typing.Optional[CompositionConditionalValue]: ...

@typing.final
class CompositionConditionalValue(winrt.system.Object, metaclass=CompositionConditionalValue_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionConditionalValue: ...
    @_property
    def value(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @value.setter
    def value(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...
    @_property
    def condition(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @condition.setter
    def condition(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...

@typing.final
class CompositionInteractionSourceCollection(winrt.system.Object):
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[ICompositionInteractionSource]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionInteractionSourceCollection: ...
    def add(self, value: typing.Optional[ICompositionInteractionSource], /) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[ICompositionInteractionSource]]: ...
    def remove(self, value: typing.Optional[ICompositionInteractionSource], /) -> None: ...
    def remove_all(self) -> None: ...
    @_property
    def count(self) -> winrt.system.Int32: ...

@typing.final
class InteractionSourceConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionSourceConfiguration: ...
    @_property
    def scale_source_mode(self) -> InteractionSourceRedirectionMode: ...
    @scale_source_mode.setter
    def scale_source_mode(self, value: InteractionSourceRedirectionMode) -> None: ...
    @_property
    def position_y_source_mode(self) -> InteractionSourceRedirectionMode: ...
    @position_y_source_mode.setter
    def position_y_source_mode(self, value: InteractionSourceRedirectionMode) -> None: ...
    @_property
    def position_x_source_mode(self) -> InteractionSourceRedirectionMode: ...
    @position_x_source_mode.setter
    def position_x_source_mode(self, value: InteractionSourceRedirectionMode) -> None: ...

@typing.final
class InteractionTracker_Static(type):
    def create(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], /) -> typing.Optional[InteractionTracker]: ...
    def create_with_owner(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], owner: typing.Optional[IInteractionTrackerOwner], /) -> typing.Optional[InteractionTracker]: ...
    def get_binding_mode(cls, bound_tracker1: typing.Optional[InteractionTracker], bound_tracker2: typing.Optional[InteractionTracker], /) -> InteractionBindingAxisModes: ...
    def set_binding_mode(cls, bound_tracker1: typing.Optional[InteractionTracker], bound_tracker2: typing.Optional[InteractionTracker], axis_mode: InteractionBindingAxisModes, /) -> None: ...

@typing.final
class InteractionTracker(winrt.system.Object, metaclass=InteractionTracker_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTracker: ...
    def adjust_position_x_if_greater_than_threshold(self, adjustment: winrt.system.Single, position_threshold: winrt.system.Single, /) -> None: ...
    def adjust_position_y_if_greater_than_threshold(self, adjustment: winrt.system.Single, position_threshold: winrt.system.Single, /) -> None: ...
    def configure_center_point_x_inertia_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def configure_center_point_y_inertia_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def configure_position_x_inertia_modifiers(self, modifiers: typing.Iterable[InteractionTrackerInertiaModifier], /) -> None: ...
    def configure_position_y_inertia_modifiers(self, modifiers: typing.Iterable[InteractionTrackerInertiaModifier], /) -> None: ...
    def configure_scale_inertia_modifiers(self, modifiers: typing.Iterable[InteractionTrackerInertiaModifier], /) -> None: ...
    def configure_vector2_position_inertia_modifiers(self, modifiers: typing.Iterable[InteractionTrackerVector2InertiaModifier], /) -> None: ...
    @typing.overload
    def try_update_position(self, value: winrt.windows.foundation.numerics.Vector3, /) -> winrt.system.Int32: ...
    @typing.overload
    def try_update_position(self, value: winrt.windows.foundation.numerics.Vector3, option: InteractionTrackerClampingOption, /) -> winrt.system.Int32: ...
    @typing.overload
    def try_update_position(self, value: winrt.windows.foundation.numerics.Vector3, option: InteractionTrackerClampingOption, pos_update_option: InteractionTrackerPositionUpdateOption, /) -> winrt.system.Int32: ...
    @typing.overload
    def try_update_position_by(self, amount: winrt.windows.foundation.numerics.Vector3, /) -> winrt.system.Int32: ...
    @typing.overload
    def try_update_position_by(self, amount: winrt.windows.foundation.numerics.Vector3, option: InteractionTrackerClampingOption, /) -> winrt.system.Int32: ...
    def try_update_position_with_additional_velocity(self, velocity_in_pixels_per_second: winrt.windows.foundation.numerics.Vector3, /) -> winrt.system.Int32: ...
    def try_update_position_with_animation(self, animation: typing.Optional[winrt.microsoft.ui.composition.CompositionAnimation], /) -> winrt.system.Int32: ...
    def try_update_scale(self, value: winrt.system.Single, center_point: winrt.windows.foundation.numerics.Vector3, /) -> winrt.system.Int32: ...
    def try_update_scale_with_additional_velocity(self, velocity_in_percent_per_second: winrt.system.Single, center_point: winrt.windows.foundation.numerics.Vector3, /) -> winrt.system.Int32: ...
    def try_update_scale_with_animation(self, animation: typing.Optional[winrt.microsoft.ui.composition.CompositionAnimation], center_point: winrt.windows.foundation.numerics.Vector3, /) -> winrt.system.Int32: ...
    @_property
    def scale_inertia_decay_rate(self) -> typing.Optional[typing.Optional[winrt.system.Single]]: ...
    @scale_inertia_decay_rate.setter
    def scale_inertia_decay_rate(self, value: typing.Optional[typing.Optional[winrt.system.Single]]) -> None: ...
    @_property
    def position_inertia_decay_rate(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector3]]: ...
    @position_inertia_decay_rate.setter
    def position_inertia_decay_rate(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector3]]) -> None: ...
    @_property
    def min_scale(self) -> winrt.system.Single: ...
    @min_scale.setter
    def min_scale(self, value: winrt.system.Single) -> None: ...
    @_property
    def min_position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @min_position.setter
    def min_position(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def max_scale(self) -> winrt.system.Single: ...
    @max_scale.setter
    def max_scale(self, value: winrt.system.Single) -> None: ...
    @_property
    def max_position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @max_position.setter
    def max_position(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def interaction_sources(self) -> typing.Optional[CompositionInteractionSourceCollection]: ...
    @_property
    def is_position_rounding_suggested(self) -> bool: ...
    @_property
    def natural_resting_position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def natural_resting_scale(self) -> winrt.system.Single: ...
    @_property
    def owner(self) -> typing.Optional[IInteractionTrackerOwner]: ...
    @_property
    def position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def position_velocity_in_pixels_per_second(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def scale(self) -> winrt.system.Single: ...
    @_property
    def scale_velocity_in_percent_per_second(self) -> winrt.system.Single: ...
    @_property
    def is_inertia_from_impulse(self) -> bool: ...

@typing.final
class InteractionTrackerCustomAnimationStateEnteredArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerCustomAnimationStateEnteredArgs: ...
    @_property
    def request_id(self) -> winrt.system.Int32: ...
    @_property
    def is_from_binding(self) -> bool: ...

@typing.final
class InteractionTrackerIdleStateEnteredArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerIdleStateEnteredArgs: ...
    @_property
    def request_id(self) -> winrt.system.Int32: ...
    @_property
    def is_from_binding(self) -> bool: ...

@typing.final
class InteractionTrackerInertiaModifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerInertiaModifier: ...

@typing.final
class InteractionTrackerInertiaMotion_Static(type):
    def create(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], /) -> typing.Optional[InteractionTrackerInertiaMotion]: ...

@typing.final
class InteractionTrackerInertiaMotion(winrt.system.Object, metaclass=InteractionTrackerInertiaMotion_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerInertiaMotion: ...
    @_property
    def motion(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @motion.setter
    def motion(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...
    @_property
    def condition(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @condition.setter
    def condition(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...

@typing.final
class InteractionTrackerInertiaNaturalMotion_Static(type):
    def create(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], /) -> typing.Optional[InteractionTrackerInertiaNaturalMotion]: ...

@typing.final
class InteractionTrackerInertiaNaturalMotion(winrt.system.Object, metaclass=InteractionTrackerInertiaNaturalMotion_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerInertiaNaturalMotion: ...
    @_property
    def natural_motion(self) -> typing.Optional[winrt.microsoft.ui.composition.ScalarNaturalMotionAnimation]: ...
    @natural_motion.setter
    def natural_motion(self, value: typing.Optional[winrt.microsoft.ui.composition.ScalarNaturalMotionAnimation]) -> None: ...
    @_property
    def condition(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @condition.setter
    def condition(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...

@typing.final
class InteractionTrackerInertiaRestingValue_Static(type):
    def create(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], /) -> typing.Optional[InteractionTrackerInertiaRestingValue]: ...

@typing.final
class InteractionTrackerInertiaRestingValue(winrt.system.Object, metaclass=InteractionTrackerInertiaRestingValue_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerInertiaRestingValue: ...
    @_property
    def resting_value(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @resting_value.setter
    def resting_value(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...
    @_property
    def condition(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @condition.setter
    def condition(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...

@typing.final
class InteractionTrackerInertiaStateEnteredArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerInertiaStateEnteredArgs: ...
    @_property
    def modified_resting_position(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector3]]: ...
    @_property
    def modified_resting_scale(self) -> typing.Optional[typing.Optional[winrt.system.Single]]: ...
    @_property
    def natural_resting_position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def natural_resting_scale(self) -> winrt.system.Single: ...
    @_property
    def position_velocity_in_pixels_per_second(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def request_id(self) -> winrt.system.Int32: ...
    @_property
    def scale_velocity_in_percent_per_second(self) -> winrt.system.Single: ...
    @_property
    def is_inertia_from_impulse(self) -> bool: ...
    @_property
    def is_from_binding(self) -> bool: ...

@typing.final
class InteractionTrackerInteractingStateEnteredArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerInteractingStateEnteredArgs: ...
    @_property
    def request_id(self) -> winrt.system.Int32: ...
    @_property
    def is_from_binding(self) -> bool: ...

@typing.final
class InteractionTrackerRequestIgnoredArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerRequestIgnoredArgs: ...
    @_property
    def request_id(self) -> winrt.system.Int32: ...

@typing.final
class InteractionTrackerValuesChangedArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerValuesChangedArgs: ...
    @_property
    def position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def request_id(self) -> winrt.system.Int32: ...
    @_property
    def scale(self) -> winrt.system.Single: ...

@typing.final
class InteractionTrackerVector2InertiaModifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerVector2InertiaModifier: ...

@typing.final
class InteractionTrackerVector2InertiaNaturalMotion_Static(type):
    def create(cls, compositor: typing.Optional[winrt.microsoft.ui.composition.Compositor], /) -> typing.Optional[InteractionTrackerVector2InertiaNaturalMotion]: ...

@typing.final
class InteractionTrackerVector2InertiaNaturalMotion(winrt.system.Object, metaclass=InteractionTrackerVector2InertiaNaturalMotion_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InteractionTrackerVector2InertiaNaturalMotion: ...
    @_property
    def natural_motion(self) -> typing.Optional[winrt.microsoft.ui.composition.Vector2NaturalMotionAnimation]: ...
    @natural_motion.setter
    def natural_motion(self, value: typing.Optional[winrt.microsoft.ui.composition.Vector2NaturalMotionAnimation]) -> None: ...
    @_property
    def condition(self) -> typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]: ...
    @condition.setter
    def condition(self, value: typing.Optional[winrt.microsoft.ui.composition.ExpressionAnimation]) -> None: ...

@typing.final
class VisualInteractionSource_Static(type):
    def create(cls, source: typing.Optional[winrt.microsoft.ui.composition.Visual], /) -> typing.Optional[VisualInteractionSource]: ...
    def create_from_i_visual_element(cls, source: typing.Optional[winrt.microsoft.ui.composition.IVisualElement], /) -> typing.Optional[VisualInteractionSource]: ...

@typing.final
class VisualInteractionSource(winrt.system.Object, metaclass=VisualInteractionSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualInteractionSource: ...
    def configure_center_point_x_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def configure_center_point_y_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def configure_delta_position_x_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def configure_delta_position_y_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def configure_delta_scale_modifiers(self, conditional_values: typing.Iterable[CompositionConditionalValue], /) -> None: ...
    def try_redirect_for_manipulation(self, pointer_point: typing.Optional[winrt.microsoft.ui.input.PointerPoint], /) -> None: ...
    @_property
    def scale_source_mode(self) -> InteractionSourceMode: ...
    @scale_source_mode.setter
    def scale_source_mode(self, value: InteractionSourceMode) -> None: ...
    @_property
    def scale_chaining_mode(self) -> InteractionChainingMode: ...
    @scale_chaining_mode.setter
    def scale_chaining_mode(self, value: InteractionChainingMode) -> None: ...
    @_property
    def position_y_source_mode(self) -> InteractionSourceMode: ...
    @position_y_source_mode.setter
    def position_y_source_mode(self, value: InteractionSourceMode) -> None: ...
    @_property
    def position_y_chaining_mode(self) -> InteractionChainingMode: ...
    @position_y_chaining_mode.setter
    def position_y_chaining_mode(self, value: InteractionChainingMode) -> None: ...
    @_property
    def position_x_source_mode(self) -> InteractionSourceMode: ...
    @position_x_source_mode.setter
    def position_x_source_mode(self, value: InteractionSourceMode) -> None: ...
    @_property
    def position_x_chaining_mode(self) -> InteractionChainingMode: ...
    @position_x_chaining_mode.setter
    def position_x_chaining_mode(self, value: InteractionChainingMode) -> None: ...
    @_property
    def manipulation_redirection_mode(self) -> VisualInteractionSourceRedirectionMode: ...
    @manipulation_redirection_mode.setter
    def manipulation_redirection_mode(self, value: VisualInteractionSourceRedirectionMode) -> None: ...
    @_property
    def is_position_y_rails_enabled(self) -> bool: ...
    @is_position_y_rails_enabled.setter
    def is_position_y_rails_enabled(self, value: bool) -> None: ...
    @_property
    def is_position_x_rails_enabled(self) -> bool: ...
    @is_position_x_rails_enabled.setter
    def is_position_x_rails_enabled(self, value: bool) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.microsoft.ui.composition.Visual]: ...
    @_property
    def delta_position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def delta_scale(self) -> winrt.system.Single: ...
    @_property
    def position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def position_velocity(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def scale(self) -> winrt.system.Single: ...
    @_property
    def scale_velocity(self) -> winrt.system.Single: ...
    @_property
    def pointer_wheel_config(self) -> typing.Optional[InteractionSourceConfiguration]: ...

@typing.final
class ICompositionInteractionSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICompositionInteractionSource: ...

@typing.final
class IInteractionTrackerOwner(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInteractionTrackerOwner: ...
    def custom_animation_state_entered(self, sender: typing.Optional[InteractionTracker], args: typing.Optional[InteractionTrackerCustomAnimationStateEnteredArgs], /) -> None: ...
    def idle_state_entered(self, sender: typing.Optional[InteractionTracker], args: typing.Optional[InteractionTrackerIdleStateEnteredArgs], /) -> None: ...
    def inertia_state_entered(self, sender: typing.Optional[InteractionTracker], args: typing.Optional[InteractionTrackerInertiaStateEnteredArgs], /) -> None: ...
    def interacting_state_entered(self, sender: typing.Optional[InteractionTracker], args: typing.Optional[InteractionTrackerInteractingStateEnteredArgs], /) -> None: ...
    def request_ignored(self, sender: typing.Optional[InteractionTracker], args: typing.Optional[InteractionTrackerRequestIgnoredArgs], /) -> None: ...
    def values_changed(self, sender: typing.Optional[InteractionTracker], args: typing.Optional[InteractionTrackerValuesChangedArgs], /) -> None: ...

