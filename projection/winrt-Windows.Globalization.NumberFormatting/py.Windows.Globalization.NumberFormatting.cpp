// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Globalization.NumberFormatting.h"


namespace py::cpp::Windows::Globalization::NumberFormatting
{
    // ----- CurrencyFormatter class --------------------

    static PyObject* _new_CurrencyFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CurrencyFormatter(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CurrencyFormatter_ApplyRoundingForCurrency(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ApplyRoundingForCurrency", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::RoundingAlgorithm>(args, 0);

                self->obj.ApplyRoundingForCurrency(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_Format(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Format", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.Format(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FormatDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.FormatDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FormatInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.FormatInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FormatUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.FormatUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ParseDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ParseInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ParseUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_Currency(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Currency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Currency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_Currency(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Currency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Currency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_Mode(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Mode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_Mode(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Mode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::CurrencyFormatterMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGrouped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecimalPointAlwaysDisplayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecimalPointAlwaysDisplayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntegerDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IntegerDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FractionDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FractionDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"GeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ResolvedGeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedGeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrencyFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberRounder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            self->obj.NumberRounder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZeroSigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZeroSigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CurrencyFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignificantDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CurrencyFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.CurrencyFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SignificantDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CurrencyFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrencyFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::CurrencyFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrencyFormatter[] = {
        { "apply_rounding_for_currency", reinterpret_cast<PyCFunction>(CurrencyFormatter_ApplyRoundingForCurrency), METH_VARARGS, nullptr },
        { "format", reinterpret_cast<PyCFunction>(CurrencyFormatter_Format), METH_VARARGS, nullptr },
        { "format_double", reinterpret_cast<PyCFunction>(CurrencyFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(CurrencyFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(CurrencyFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(CurrencyFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(CurrencyFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(CurrencyFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CurrencyFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrencyFormatter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CurrencyFormatter[] = {
        { "currency", reinterpret_cast<getter>(CurrencyFormatter_get_Currency), reinterpret_cast<setter>(CurrencyFormatter_put_Currency), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(CurrencyFormatter_get_Mode), reinterpret_cast<setter>(CurrencyFormatter_put_Mode), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(CurrencyFormatter_get_NumeralSystem), reinterpret_cast<setter>(CurrencyFormatter_put_NumeralSystem), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(CurrencyFormatter_get_IsGrouped), reinterpret_cast<setter>(CurrencyFormatter_put_IsGrouped), nullptr, nullptr },
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(CurrencyFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(CurrencyFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(CurrencyFormatter_get_IntegerDigits), reinterpret_cast<setter>(CurrencyFormatter_put_IntegerDigits), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(CurrencyFormatter_get_FractionDigits), reinterpret_cast<setter>(CurrencyFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(CurrencyFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(CurrencyFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(CurrencyFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(CurrencyFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(CurrencyFormatter_get_NumberRounder), reinterpret_cast<setter>(CurrencyFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(CurrencyFormatter_get_IsZeroSigned), reinterpret_cast<setter>(CurrencyFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(CurrencyFormatter_get_SignificantDigits), reinterpret_cast<setter>(CurrencyFormatter_put_SignificantDigits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CurrencyFormatter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrencyFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrencyFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrencyFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrencyFormatter) },
        { },
    };

    static PyType_Spec type_spec_CurrencyFormatter =
    {
        "winrt._winrt_windows_globalization_numberformatting.CurrencyFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::CurrencyFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrencyFormatter
    };

    // ----- DecimalFormatter class --------------------

    static PyObject* _new_DecimalFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::NumberFormatting::DecimalFormatter instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::DecimalFormatter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DecimalFormatter(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DecimalFormatter_Format(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"Format", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.Format(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FormatDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.FormatDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FormatInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.FormatInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FormatUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.FormatUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ParseDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ParseInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ParseUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecimalPointAlwaysDisplayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecimalPointAlwaysDisplayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntegerDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IntegerDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGrouped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FractionDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FractionDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"GeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ResolvedGeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedGeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DecimalFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberRounder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            self->obj.NumberRounder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZeroSigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZeroSigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DecimalFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignificantDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DecimalFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.DecimalFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SignificantDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DecimalFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::DecimalFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DecimalFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::DecimalFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DecimalFormatter[] = {
        { "format", reinterpret_cast<PyCFunction>(DecimalFormatter_Format), METH_VARARGS, nullptr },
        { "format_double", reinterpret_cast<PyCFunction>(DecimalFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(DecimalFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(DecimalFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(DecimalFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(DecimalFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(DecimalFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DecimalFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DecimalFormatter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DecimalFormatter[] = {
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(DecimalFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(DecimalFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(DecimalFormatter_get_IntegerDigits), reinterpret_cast<setter>(DecimalFormatter_put_IntegerDigits), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(DecimalFormatter_get_IsGrouped), reinterpret_cast<setter>(DecimalFormatter_put_IsGrouped), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(DecimalFormatter_get_NumeralSystem), reinterpret_cast<setter>(DecimalFormatter_put_NumeralSystem), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(DecimalFormatter_get_FractionDigits), reinterpret_cast<setter>(DecimalFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(DecimalFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(DecimalFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(DecimalFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(DecimalFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(DecimalFormatter_get_NumberRounder), reinterpret_cast<setter>(DecimalFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(DecimalFormatter_get_IsZeroSigned), reinterpret_cast<setter>(DecimalFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(DecimalFormatter_get_SignificantDigits), reinterpret_cast<setter>(DecimalFormatter_put_SignificantDigits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DecimalFormatter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DecimalFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DecimalFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DecimalFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DecimalFormatter) },
        { },
    };

    static PyType_Spec type_spec_DecimalFormatter =
    {
        "winrt._winrt_windows_globalization_numberformatting.DecimalFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::DecimalFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DecimalFormatter
    };

    // ----- IncrementNumberRounder class --------------------

    static PyObject* _new_IncrementNumberRounder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::IncrementNumberRounder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_IncrementNumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IncrementNumberRounder_RoundDouble(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.RoundDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundInt32(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.RoundInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundInt64(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.RoundInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundSingle(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundSingle", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(self->obj.RoundSingle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundUInt32(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundUInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.RoundUInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_RoundUInt64(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundUInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.RoundUInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IncrementNumberRounder_get_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundingAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoundingAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IncrementNumberRounder_put_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"RoundingAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::RoundingAlgorithm>(arg);

            self->obj.RoundingAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IncrementNumberRounder_get_Increment(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"Increment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Increment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IncrementNumberRounder_put_Increment(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.IncrementNumberRounder", L"Increment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Increment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IncrementNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::IncrementNumberRounder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IncrementNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::IncrementNumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IncrementNumberRounder[] = {
        { "round_double", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundDouble), METH_VARARGS, nullptr },
        { "round_int32", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundInt32), METH_VARARGS, nullptr },
        { "round_int64", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundInt64), METH_VARARGS, nullptr },
        { "round_single", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundSingle), METH_VARARGS, nullptr },
        { "round_uint32", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundUInt32), METH_VARARGS, nullptr },
        { "round_uint64", reinterpret_cast<PyCFunction>(IncrementNumberRounder_RoundUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IncrementNumberRounder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IncrementNumberRounder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IncrementNumberRounder[] = {
        { "rounding_algorithm", reinterpret_cast<getter>(IncrementNumberRounder_get_RoundingAlgorithm), reinterpret_cast<setter>(IncrementNumberRounder_put_RoundingAlgorithm), nullptr, nullptr },
        { "increment", reinterpret_cast<getter>(IncrementNumberRounder_get_Increment), reinterpret_cast<setter>(IncrementNumberRounder_put_Increment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IncrementNumberRounder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IncrementNumberRounder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IncrementNumberRounder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IncrementNumberRounder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IncrementNumberRounder) },
        { },
    };

    static PyType_Spec type_spec_IncrementNumberRounder =
    {
        "winrt._winrt_windows_globalization_numberformatting.IncrementNumberRounder",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::IncrementNumberRounder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IncrementNumberRounder
    };

    // ----- NumeralSystemTranslator class --------------------

    static PyObject* _new_NumeralSystemTranslator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NumeralSystemTranslator(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NumeralSystemTranslator_TranslateNumerals(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"TranslateNumerals", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TranslateNumerals(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NumeralSystemTranslator_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NumeralSystemTranslator_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NumeralSystemTranslator_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NumeralSystemTranslator_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.NumeralSystemTranslator", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NumeralSystemTranslator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NumeralSystemTranslator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::NumeralSystemTranslator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumeralSystemTranslator[] = {
        { "translate_numerals", reinterpret_cast<PyCFunction>(NumeralSystemTranslator_TranslateNumerals), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NumeralSystemTranslator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NumeralSystemTranslator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NumeralSystemTranslator[] = {
        { "numeral_system", reinterpret_cast<getter>(NumeralSystemTranslator_get_NumeralSystem), reinterpret_cast<setter>(NumeralSystemTranslator_put_NumeralSystem), nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(NumeralSystemTranslator_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(NumeralSystemTranslator_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NumeralSystemTranslator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumeralSystemTranslator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NumeralSystemTranslator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumeralSystemTranslator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumeralSystemTranslator) },
        { },
    };

    static PyType_Spec type_spec_NumeralSystemTranslator =
    {
        "winrt._winrt_windows_globalization_numberformatting.NumeralSystemTranslator",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::NumeralSystemTranslator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NumeralSystemTranslator
    };

    // ----- PercentFormatter class --------------------

    static PyObject* _new_PercentFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::NumberFormatting::PercentFormatter instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::PercentFormatter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PercentFormatter(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PercentFormatter_Format(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"Format", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.Format(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FormatDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.FormatDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FormatInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.FormatInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FormatUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.FormatUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ParseDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ParseInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ParseUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecimalPointAlwaysDisplayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecimalPointAlwaysDisplayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntegerDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IntegerDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGrouped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FractionDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FractionDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"GeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ResolvedGeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedGeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PercentFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberRounder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            self->obj.NumberRounder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZeroSigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZeroSigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PercentFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignificantDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PercentFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PercentFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SignificantDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PercentFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::PercentFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PercentFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::PercentFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PercentFormatter[] = {
        { "format", reinterpret_cast<PyCFunction>(PercentFormatter_Format), METH_VARARGS, nullptr },
        { "format_double", reinterpret_cast<PyCFunction>(PercentFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(PercentFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(PercentFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(PercentFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(PercentFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(PercentFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PercentFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PercentFormatter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PercentFormatter[] = {
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(PercentFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(PercentFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(PercentFormatter_get_IntegerDigits), reinterpret_cast<setter>(PercentFormatter_put_IntegerDigits), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(PercentFormatter_get_IsGrouped), reinterpret_cast<setter>(PercentFormatter_put_IsGrouped), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(PercentFormatter_get_NumeralSystem), reinterpret_cast<setter>(PercentFormatter_put_NumeralSystem), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(PercentFormatter_get_FractionDigits), reinterpret_cast<setter>(PercentFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(PercentFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(PercentFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(PercentFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(PercentFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(PercentFormatter_get_NumberRounder), reinterpret_cast<setter>(PercentFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(PercentFormatter_get_IsZeroSigned), reinterpret_cast<setter>(PercentFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(PercentFormatter_get_SignificantDigits), reinterpret_cast<setter>(PercentFormatter_put_SignificantDigits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PercentFormatter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PercentFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PercentFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PercentFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PercentFormatter) },
        { },
    };

    static PyType_Spec type_spec_PercentFormatter =
    {
        "winrt._winrt_windows_globalization_numberformatting.PercentFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::PercentFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PercentFormatter
    };

    // ----- PermilleFormatter class --------------------

    static PyObject* _new_PermilleFormatter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Globalization::NumberFormatting::PermilleFormatter instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::PermilleFormatter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PermilleFormatter(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PermilleFormatter_Format(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"Format", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.Format(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FormatDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.FormatDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FormatInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.FormatInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FormatUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.FormatUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ParseDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ParseInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ParseUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecimalPointAlwaysDisplayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecimalPointAlwaysDisplayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntegerDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IntegerDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGrouped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FractionDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FractionDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"GeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ResolvedGeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedGeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PermilleFormatter_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberRounder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            self->obj.NumberRounder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZeroSigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZeroSigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PermilleFormatter_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignificantDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PermilleFormatter_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.PermilleFormatter", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SignificantDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PermilleFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::PermilleFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PermilleFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::PermilleFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PermilleFormatter[] = {
        { "format", reinterpret_cast<PyCFunction>(PermilleFormatter_Format), METH_VARARGS, nullptr },
        { "format_double", reinterpret_cast<PyCFunction>(PermilleFormatter_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(PermilleFormatter_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(PermilleFormatter_FormatUInt), METH_VARARGS, nullptr },
        { "parse_double", reinterpret_cast<PyCFunction>(PermilleFormatter_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(PermilleFormatter_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(PermilleFormatter_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PermilleFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PermilleFormatter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PermilleFormatter[] = {
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(PermilleFormatter_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(PermilleFormatter_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(PermilleFormatter_get_IntegerDigits), reinterpret_cast<setter>(PermilleFormatter_put_IntegerDigits), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(PermilleFormatter_get_IsGrouped), reinterpret_cast<setter>(PermilleFormatter_put_IsGrouped), nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(PermilleFormatter_get_NumeralSystem), reinterpret_cast<setter>(PermilleFormatter_put_NumeralSystem), nullptr, nullptr },
        { "fraction_digits", reinterpret_cast<getter>(PermilleFormatter_get_FractionDigits), reinterpret_cast<setter>(PermilleFormatter_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(PermilleFormatter_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(PermilleFormatter_get_Languages), nullptr, nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(PermilleFormatter_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(PermilleFormatter_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { "number_rounder", reinterpret_cast<getter>(PermilleFormatter_get_NumberRounder), reinterpret_cast<setter>(PermilleFormatter_put_NumberRounder), nullptr, nullptr },
        { "is_zero_signed", reinterpret_cast<getter>(PermilleFormatter_get_IsZeroSigned), reinterpret_cast<setter>(PermilleFormatter_put_IsZeroSigned), nullptr, nullptr },
        { "significant_digits", reinterpret_cast<getter>(PermilleFormatter_get_SignificantDigits), reinterpret_cast<setter>(PermilleFormatter_put_SignificantDigits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PermilleFormatter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PermilleFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PermilleFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PermilleFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PermilleFormatter) },
        { },
    };

    static PyType_Spec type_spec_PermilleFormatter =
    {
        "winrt._winrt_windows_globalization_numberformatting.PermilleFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::PermilleFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PermilleFormatter
    };

    // ----- SignificantDigitsNumberRounder class --------------------

    static PyObject* _new_SignificantDigitsNumberRounder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SignificantDigitsNumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SignificantDigitsNumberRounder_RoundDouble(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.RoundDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundInt32(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.RoundInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundInt64(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.RoundInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundSingle(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundSingle", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(self->obj.RoundSingle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundUInt32(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundUInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.RoundUInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_RoundUInt64(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundUInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.RoundUInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignificantDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SignificantDigitsNumberRounder_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SignificantDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SignificantDigitsNumberRounder_get_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundingAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoundingAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SignificantDigitsNumberRounder_put_RoundingAlgorithm(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.SignificantDigitsNumberRounder", L"RoundingAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::RoundingAlgorithm>(arg);

            self->obj.RoundingAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SignificantDigitsNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SignificantDigitsNumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SignificantDigitsNumberRounder[] = {
        { "round_double", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundDouble), METH_VARARGS, nullptr },
        { "round_int32", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundInt32), METH_VARARGS, nullptr },
        { "round_int64", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundInt64), METH_VARARGS, nullptr },
        { "round_single", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundSingle), METH_VARARGS, nullptr },
        { "round_uint32", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundUInt32), METH_VARARGS, nullptr },
        { "round_uint64", reinterpret_cast<PyCFunction>(SignificantDigitsNumberRounder_RoundUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SignificantDigitsNumberRounder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SignificantDigitsNumberRounder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SignificantDigitsNumberRounder[] = {
        { "significant_digits", reinterpret_cast<getter>(SignificantDigitsNumberRounder_get_SignificantDigits), reinterpret_cast<setter>(SignificantDigitsNumberRounder_put_SignificantDigits), nullptr, nullptr },
        { "rounding_algorithm", reinterpret_cast<getter>(SignificantDigitsNumberRounder_get_RoundingAlgorithm), reinterpret_cast<setter>(SignificantDigitsNumberRounder_put_RoundingAlgorithm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SignificantDigitsNumberRounder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SignificantDigitsNumberRounder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SignificantDigitsNumberRounder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SignificantDigitsNumberRounder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SignificantDigitsNumberRounder) },
        { },
    };

    static PyType_Spec type_spec_SignificantDigitsNumberRounder =
    {
        "winrt._winrt_windows_globalization_numberformatting.SignificantDigitsNumberRounder",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::SignificantDigitsNumberRounder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SignificantDigitsNumberRounder
    };

    // ----- INumberFormatter interface --------------------

    static PyObject* _new_INumberFormatter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>::type_name);
        return nullptr;
    }

    static void _dealloc_INumberFormatter(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberFormatter_Format(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter", L"Format", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.Format(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INumberFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberFormatter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberFormatter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberFormatter[] = {
        { "format", reinterpret_cast<PyCFunction>(INumberFormatter_Format), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INumberFormatter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberFormatter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INumberFormatter[] = {
        { }
    };

    static PyType_Slot _type_slots_INumberFormatter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberFormatter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberFormatter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberFormatter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberFormatter) },
        { },
    };

    static PyType_Spec type_spec_INumberFormatter =
    {
        "winrt._winrt_windows_globalization_numberformatting.INumberFormatter",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INumberFormatter
    };

    // ----- INumberFormatter2 interface --------------------

    static PyObject* _new_INumberFormatter2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>::type_name);
        return nullptr;
    }

    static void _dealloc_INumberFormatter2(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberFormatter2_FormatDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter2", L"FormatDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.FormatDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberFormatter2_FormatInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter2", L"FormatInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.FormatInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberFormatter2_FormatUInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberFormatter2", L"FormatUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.FormatUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INumberFormatter2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberFormatter2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberFormatter2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberFormatter2[] = {
        { "format_double", reinterpret_cast<PyCFunction>(INumberFormatter2_FormatDouble), METH_VARARGS, nullptr },
        { "format_int", reinterpret_cast<PyCFunction>(INumberFormatter2_FormatInt), METH_VARARGS, nullptr },
        { "format_uint", reinterpret_cast<PyCFunction>(INumberFormatter2_FormatUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INumberFormatter2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberFormatter2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INumberFormatter2[] = {
        { }
    };

    static PyType_Slot _type_slots_INumberFormatter2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberFormatter2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberFormatter2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberFormatter2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberFormatter2) },
        { },
    };

    static PyType_Spec type_spec_INumberFormatter2 =
    {
        "winrt._winrt_windows_globalization_numberformatting.INumberFormatter2",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatter2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INumberFormatter2
    };

    // ----- INumberFormatterOptions interface --------------------

    static PyObject* _new_INumberFormatterOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_INumberFormatterOptions(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberFormatterOptions_get_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FractionDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_FractionDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"FractionDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FractionDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_GeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"GeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INumberFormatterOptions_get_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntegerDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_IntegerDigits(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IntegerDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IntegerDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecimalPointAlwaysDisplayed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_IsDecimalPointAlwaysDisplayed(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsDecimalPointAlwaysDisplayed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecimalPointAlwaysDisplayed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_IsGrouped(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"IsGrouped"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGrouped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_Languages(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"Languages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Languages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INumberFormatterOptions_get_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumeralSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberFormatterOptions_put_NumeralSystem(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"NumeralSystem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NumeralSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INumberFormatterOptions_get_ResolvedGeographicRegion(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"ResolvedGeographicRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedGeographicRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INumberFormatterOptions_get_ResolvedLanguage(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberFormatterOptions", L"ResolvedLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResolvedLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INumberFormatterOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberFormatterOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberFormatterOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberFormatterOptions[] = {
        { "_assign_array_", _assign_array_INumberFormatterOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberFormatterOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INumberFormatterOptions[] = {
        { "fraction_digits", reinterpret_cast<getter>(INumberFormatterOptions_get_FractionDigits), reinterpret_cast<setter>(INumberFormatterOptions_put_FractionDigits), nullptr, nullptr },
        { "geographic_region", reinterpret_cast<getter>(INumberFormatterOptions_get_GeographicRegion), nullptr, nullptr, nullptr },
        { "integer_digits", reinterpret_cast<getter>(INumberFormatterOptions_get_IntegerDigits), reinterpret_cast<setter>(INumberFormatterOptions_put_IntegerDigits), nullptr, nullptr },
        { "is_decimal_point_always_displayed", reinterpret_cast<getter>(INumberFormatterOptions_get_IsDecimalPointAlwaysDisplayed), reinterpret_cast<setter>(INumberFormatterOptions_put_IsDecimalPointAlwaysDisplayed), nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(INumberFormatterOptions_get_IsGrouped), reinterpret_cast<setter>(INumberFormatterOptions_put_IsGrouped), nullptr, nullptr },
        { "languages", reinterpret_cast<getter>(INumberFormatterOptions_get_Languages), nullptr, nullptr, nullptr },
        { "numeral_system", reinterpret_cast<getter>(INumberFormatterOptions_get_NumeralSystem), reinterpret_cast<setter>(INumberFormatterOptions_put_NumeralSystem), nullptr, nullptr },
        { "resolved_geographic_region", reinterpret_cast<getter>(INumberFormatterOptions_get_ResolvedGeographicRegion), nullptr, nullptr, nullptr },
        { "resolved_language", reinterpret_cast<getter>(INumberFormatterOptions_get_ResolvedLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INumberFormatterOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberFormatterOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberFormatterOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberFormatterOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberFormatterOptions) },
        { },
    };

    static PyType_Spec type_spec_INumberFormatterOptions =
    {
        "winrt._winrt_windows_globalization_numberformatting.INumberFormatterOptions",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberFormatterOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INumberFormatterOptions
    };

    // ----- INumberParser interface --------------------

    static PyObject* _new_INumberParser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberParser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberParser>::type_name);
        return nullptr;
    }

    static void _dealloc_INumberParser(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberParser_ParseDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberParser", L"ParseDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberParser_ParseInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberParser", L"ParseInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberParser_ParseUInt(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberParser", L"ParseUInt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ParseUInt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INumberParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberParser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberParser[] = {
        { "parse_double", reinterpret_cast<PyCFunction>(INumberParser_ParseDouble), METH_VARARGS, nullptr },
        { "parse_int", reinterpret_cast<PyCFunction>(INumberParser_ParseInt), METH_VARARGS, nullptr },
        { "parse_uint", reinterpret_cast<PyCFunction>(INumberParser_ParseUInt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INumberParser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberParser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INumberParser[] = {
        { }
    };

    static PyType_Slot _type_slots_INumberParser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberParser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberParser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberParser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberParser) },
        { },
    };

    static PyType_Spec type_spec_INumberParser =
    {
        "winrt._winrt_windows_globalization_numberformatting.INumberParser",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberParser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INumberParser
    };

    // ----- INumberRounder interface --------------------

    static PyObject* _new_INumberRounder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounder>::type_name);
        return nullptr;
    }

    static void _dealloc_INumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberRounder_RoundDouble(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundDouble", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.RoundDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundInt32(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.RoundInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundInt64(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(self->obj.RoundInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundSingle(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundSingle", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(self->obj.RoundSingle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundUInt32(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundUInt32", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.RoundUInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INumberRounder_RoundUInt64(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Globalization.NumberFormatting.INumberRounder", L"RoundUInt64", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.RoundUInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_INumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberRounder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberRounder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberRounder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberRounder[] = {
        { "round_double", reinterpret_cast<PyCFunction>(INumberRounder_RoundDouble), METH_VARARGS, nullptr },
        { "round_int32", reinterpret_cast<PyCFunction>(INumberRounder_RoundInt32), METH_VARARGS, nullptr },
        { "round_int64", reinterpret_cast<PyCFunction>(INumberRounder_RoundInt64), METH_VARARGS, nullptr },
        { "round_single", reinterpret_cast<PyCFunction>(INumberRounder_RoundSingle), METH_VARARGS, nullptr },
        { "round_uint32", reinterpret_cast<PyCFunction>(INumberRounder_RoundUInt32), METH_VARARGS, nullptr },
        { "round_uint64", reinterpret_cast<PyCFunction>(INumberRounder_RoundUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_INumberRounder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberRounder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INumberRounder[] = {
        { }
    };

    static PyType_Slot _type_slots_INumberRounder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberRounder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberRounder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberRounder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberRounder) },
        { },
    };

    static PyType_Spec type_spec_INumberRounder =
    {
        "winrt._winrt_windows_globalization_numberformatting.INumberRounder",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INumberRounder
    };

    // ----- INumberRounderOption interface --------------------

    static PyObject* _new_INumberRounderOption(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>::type_name);
        return nullptr;
    }

    static void _dealloc_INumberRounderOption(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INumberRounderOption_get_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberRounderOption", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NumberRounder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INumberRounderOption_put_NumberRounder(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.INumberRounderOption", L"NumberRounder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Globalization::NumberFormatting::INumberRounder>(arg);

            self->obj.NumberRounder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_INumberRounderOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INumberRounderOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::INumberRounderOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INumberRounderOption[] = {
        { "_assign_array_", _assign_array_INumberRounderOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INumberRounderOption), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INumberRounderOption[] = {
        { "number_rounder", reinterpret_cast<getter>(INumberRounderOption_get_NumberRounder), reinterpret_cast<setter>(INumberRounderOption_put_NumberRounder), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_INumberRounderOption[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INumberRounderOption) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INumberRounderOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INumberRounderOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INumberRounderOption) },
        { },
    };

    static PyType_Spec type_spec_INumberRounderOption =
    {
        "winrt._winrt_windows_globalization_numberformatting.INumberRounderOption",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::INumberRounderOption),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INumberRounderOption
    };

    // ----- ISignedZeroOption interface --------------------

    static PyObject* _new_ISignedZeroOption(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>::type_name);
        return nullptr;
    }

    static void _dealloc_ISignedZeroOption(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISignedZeroOption_get_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignedZeroOption", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZeroSigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISignedZeroOption_put_IsZeroSigned(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignedZeroOption", L"IsZeroSigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZeroSigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ISignedZeroOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISignedZeroOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::ISignedZeroOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISignedZeroOption[] = {
        { "_assign_array_", _assign_array_ISignedZeroOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISignedZeroOption), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISignedZeroOption[] = {
        { "is_zero_signed", reinterpret_cast<getter>(ISignedZeroOption_get_IsZeroSigned), reinterpret_cast<setter>(ISignedZeroOption_put_IsZeroSigned), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISignedZeroOption[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISignedZeroOption) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISignedZeroOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISignedZeroOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISignedZeroOption) },
        { },
    };

    static PyType_Spec type_spec_ISignedZeroOption =
    {
        "winrt._winrt_windows_globalization_numberformatting.ISignedZeroOption",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::ISignedZeroOption),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISignedZeroOption
    };

    // ----- ISignificantDigitsOption interface --------------------

    static PyObject* _new_ISignificantDigitsOption(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>::type_name);
        return nullptr;
    }

    static void _dealloc_ISignificantDigitsOption(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISignificantDigitsOption_get_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignificantDigitsOption", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignificantDigits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISignificantDigitsOption_put_SignificantDigits(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Globalization.NumberFormatting.ISignificantDigitsOption", L"SignificantDigits"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SignificantDigits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ISignificantDigitsOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISignificantDigitsOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Globalization::NumberFormatting::ISignificantDigitsOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISignificantDigitsOption[] = {
        { "_assign_array_", _assign_array_ISignificantDigitsOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISignificantDigitsOption), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISignificantDigitsOption[] = {
        { "significant_digits", reinterpret_cast<getter>(ISignificantDigitsOption_get_SignificantDigits), reinterpret_cast<setter>(ISignificantDigitsOption_put_SignificantDigits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISignificantDigitsOption[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISignificantDigitsOption) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISignificantDigitsOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISignificantDigitsOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISignificantDigitsOption) },
        { },
    };

    static PyType_Spec type_spec_ISignificantDigitsOption =
    {
        "winrt._winrt_windows_globalization_numberformatting.ISignificantDigitsOption",
        sizeof(py::wrapper::Windows::Globalization::NumberFormatting::ISignificantDigitsOption),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISignificantDigitsOption
    };

    // ----- Windows.Globalization.NumberFormatting Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Globalization::NumberFormatting");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_globalization_numberformatting",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Globalization::NumberFormatting

PyMODINIT_FUNC PyInit__winrt_windows_globalization_numberformatting(void) noexcept
{
    using namespace py::cpp::Windows::Globalization::NumberFormatting;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CurrencyFormatter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DecimalFormatter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IncrementNumberRounder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NumeralSystemTranslator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PercentFormatter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PermilleFormatter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SignificantDigitsNumberRounder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INumberFormatter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INumberFormatter2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INumberFormatterOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INumberParser, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INumberRounder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INumberRounderOption, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISignedZeroOption, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISignificantDigitsOption, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
