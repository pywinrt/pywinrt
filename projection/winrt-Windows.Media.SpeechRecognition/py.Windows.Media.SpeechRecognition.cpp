// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Media.SpeechRecognition.h"


namespace py::cpp::Windows::Media::SpeechRecognition
{
    // ----- SpeechContinuousRecognitionCompletedEventArgs class --------------------

    static PyObject* _new_SpeechContinuousRecognitionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionCompletedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionCompletedEventArgs_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechContinuousRecognitionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(SpeechContinuousRecognitionCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechContinuousRecognitionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechContinuousRecognitionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechContinuousRecognitionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechContinuousRecognitionCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpeechContinuousRecognitionCompletedEventArgs =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechContinuousRecognitionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionCompletedEventArgs
    };

    // ----- SpeechContinuousRecognitionResultGeneratedEventArgs class --------------------

    static PyObject* _new_SpeechContinuousRecognitionResultGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechContinuousRecognitionResultGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionResultGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "result", reinterpret_cast<getter>(SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechContinuousRecognitionResultGeneratedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechContinuousRecognitionResultGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs
    };

    // ----- SpeechContinuousRecognitionSession class --------------------

    static PyObject* _new_SpeechContinuousRecognitionSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionSession_CancelAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"CancelAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_PauseAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"PauseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_Resume(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StartAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StartAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode>(args, 0);

                return py::convert(self->obj.StartAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StopAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StopAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"AutoStopSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoStopSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"AutoStopSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AutoStopSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"ResultGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>(arg);

            return py::convert(self->obj.ResultGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"ResultGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResultGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionSession[] = {
        { "cancel_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_CancelAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_Resume), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StopAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_Completed), METH_O, nullptr },
        { "add_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_ResultGenerated), METH_O, nullptr },
        { "remove_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_ResultGenerated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpeechContinuousRecognitionSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionSession[] = {
        { "auto_stop_silence_timeout", reinterpret_cast<getter>(SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout), reinterpret_cast<setter>(SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechContinuousRecognitionSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechContinuousRecognitionSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechContinuousRecognitionSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechContinuousRecognitionSession) },
        { },
    };

    static PyType_Spec type_spec_SpeechContinuousRecognitionSession =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechContinuousRecognitionSession",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionSession
    };

    // ----- SpeechRecognitionCompilationResult class --------------------

    static PyObject* _new_SpeechRecognitionCompilationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionCompilationResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionCompilationResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionCompilationResult[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionCompilationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionCompilationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionCompilationResult[] = {
        { "status", reinterpret_cast<getter>(SpeechRecognitionCompilationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionCompilationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionCompilationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionCompilationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionCompilationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionCompilationResult) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionCompilationResult =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionCompilationResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionCompilationResult
    };

    // ----- SpeechRecognitionGrammarFileConstraint class --------------------

    static PyObject* _new_SpeechRecognitionGrammarFileConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionGrammarFileConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_GrammarFile(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"GrammarFile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GrammarFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionGrammarFileConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionGrammarFileConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionGrammarFileConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionGrammarFileConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Type), nullptr, nullptr, nullptr },
        { "grammar_file", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_GrammarFile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionGrammarFileConstraint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionGrammarFileConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionGrammarFileConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionGrammarFileConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionGrammarFileConstraint) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionGrammarFileConstraint =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionGrammarFileConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionGrammarFileConstraint
    };

    // ----- SpeechRecognitionHypothesis class --------------------

    static PyObject* _new_SpeechRecognitionHypothesis(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionHypothesis_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesis[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionHypothesis, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesis), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesis[] = {
        { "text", reinterpret_cast<getter>(SpeechRecognitionHypothesis_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesis[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionHypothesis) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionHypothesis) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionHypothesis) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionHypothesis) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionHypothesis =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionHypothesis",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesis
    };

    // ----- SpeechRecognitionHypothesisGeneratedEventArgs class --------------------

    static PyObject* _new_SpeechRecognitionHypothesisGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs", L"Hypothesis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hypothesis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionHypothesisGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesisGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "hypothesis", reinterpret_cast<getter>(SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionHypothesisGeneratedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionHypothesisGeneratedEventArgs =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionHypothesisGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs
    };

    // ----- SpeechRecognitionListConstraint class --------------------

    static PyObject* _new_SpeechRecognitionListConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionListConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionListConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Commands(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Commands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionListConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionListConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionListConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionListConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Type), nullptr, nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Commands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionListConstraint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionListConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionListConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionListConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionListConstraint) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionListConstraint =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionListConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionListConstraint
    };

    // ----- SpeechRecognitionQualityDegradingEventArgs class --------------------

    static PyObject* _new_SpeechRecognitionQualityDegradingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionQualityDegradingEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionQualityDegradingEventArgs_get_Problem(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs", L"Problem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Problem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionQualityDegradingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionQualityDegradingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "problem", reinterpret_cast<getter>(SpeechRecognitionQualityDegradingEventArgs_get_Problem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionQualityDegradingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionQualityDegradingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionQualityDegradingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionQualityDegradingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionQualityDegradingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionQualityDegradingEventArgs =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionQualityDegradingEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionQualityDegradingEventArgs
    };

    // ----- SpeechRecognitionResult class --------------------

    static PyObject* _new_SpeechRecognitionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionResult_GetAlternates(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"GetAlternates", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Confidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Confidence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Constraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Constraint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Constraint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RawConfidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"RawConfidence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawConfidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RulePath(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"RulePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RulePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_SemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"SemanticInterpretation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SemanticInterpretation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseDuration(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"PhraseDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhraseDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseStartTime(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"PhraseStartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhraseStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionResult[] = {
        { "get_alternates", reinterpret_cast<PyCFunction>(SpeechRecognitionResult_GetAlternates), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpeechRecognitionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionResult[] = {
        { "confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_Confidence), nullptr, nullptr, nullptr },
        { "constraint", reinterpret_cast<getter>(SpeechRecognitionResult_get_Constraint), nullptr, nullptr, nullptr },
        { "raw_confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_RawConfidence), nullptr, nullptr, nullptr },
        { "rule_path", reinterpret_cast<getter>(SpeechRecognitionResult_get_RulePath), nullptr, nullptr, nullptr },
        { "semantic_interpretation", reinterpret_cast<getter>(SpeechRecognitionResult_get_SemanticInterpretation), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SpeechRecognitionResult_get_Status), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechRecognitionResult_get_Text), nullptr, nullptr, nullptr },
        { "phrase_duration", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseDuration), nullptr, nullptr, nullptr },
        { "phrase_start_time", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseStartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionResult) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionResult =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionResult
    };

    // ----- SpeechRecognitionSemanticInterpretation class --------------------

    static PyObject* _new_SpeechRecognitionSemanticInterpretation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionSemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionSemanticInterpretation_get_Properties(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionSemanticInterpretation[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionSemanticInterpretation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionSemanticInterpretation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionSemanticInterpretation[] = {
        { "properties", reinterpret_cast<getter>(SpeechRecognitionSemanticInterpretation_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionSemanticInterpretation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionSemanticInterpretation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionSemanticInterpretation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionSemanticInterpretation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionSemanticInterpretation) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionSemanticInterpretation =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionSemanticInterpretation",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionSemanticInterpretation
    };

    // ----- SpeechRecognitionTopicConstraint class --------------------

    static PyObject* _new_SpeechRecognitionTopicConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionTopicConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Scenario(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Scenario"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scenario());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_TopicHint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"TopicHint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TopicHint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionTopicConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionTopicConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionTopicConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionTopicConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Type), nullptr, nullptr, nullptr },
        { "scenario", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Scenario), nullptr, nullptr, nullptr },
        { "topic_hint", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_TopicHint), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionTopicConstraint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionTopicConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionTopicConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionTopicConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionTopicConstraint) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionTopicConstraint =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionTopicConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionTopicConstraint
    };

    // ----- SpeechRecognitionVoiceCommandDefinitionConstraint class --------------------

    static PyObject* _new_SpeechRecognitionVoiceCommandDefinitionConstraint(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "_assign_array_", _assign_array_SpeechRecognitionVoiceCommandDefinitionConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionVoiceCommandDefinitionConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognitionVoiceCommandDefinitionConstraint) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognitionVoiceCommandDefinitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint
    };

    // ----- SpeechRecognizer class --------------------

    static PyObject* _new_SpeechRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizer_Close(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_CompileConstraintsAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"CompileConstraintsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CompileConstraintsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognizeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RecognizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeWithUIAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognizeWithUIAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RecognizeWithUIAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_StopRecognitionAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StopRecognitionAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopRecognitionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_TrySetSystemSpeechLanguageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"TrySetSystemSpeechLanguageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::TrySetSystemSpeechLanguageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Constraints(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Constraints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Constraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_CurrentLanguage(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"CurrentLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Timeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Timeouts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timeouts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_UIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"UIOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UIOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_ContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"ContinuousRecognitionSession"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContinuousRecognitionSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedGrammarLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SupportedGrammarLanguages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedGrammarLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedTopicLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SupportedTopicLanguages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedTopicLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SystemSpeechLanguage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SystemSpeechLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SystemSpeechLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognitionQualityDegrading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>(arg);

            return py::convert(self->obj.RecognitionQualityDegrading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognitionQualityDegrading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionQualityDegrading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"HypothesisGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>(arg);

            return py::convert(self->obj.HypothesisGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"HypothesisGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HypothesisGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizer[] = {
        { "close", reinterpret_cast<PyCFunction>(SpeechRecognizer_Close), METH_VARARGS, nullptr },
        { "compile_constraints_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_CompileConstraintsAsync), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeAsync), METH_VARARGS, nullptr },
        { "recognize_with_u_i_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeWithUIAsync), METH_VARARGS, nullptr },
        { "stop_recognition_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_StopRecognitionAsync), METH_VARARGS, nullptr },
        { "add_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_RecognitionQualityDegrading), METH_O, nullptr },
        { "remove_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_RecognitionQualityDegrading), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_StateChanged), METH_O, nullptr },
        { "add_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_HypothesisGenerated), METH_O, nullptr },
        { "remove_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_HypothesisGenerated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpeechRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SpeechRecognizer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SpeechRecognizer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizer[] = {
        { "constraints", reinterpret_cast<getter>(SpeechRecognizer_get_Constraints), nullptr, nullptr, nullptr },
        { "current_language", reinterpret_cast<getter>(SpeechRecognizer_get_CurrentLanguage), nullptr, nullptr, nullptr },
        { "timeouts", reinterpret_cast<getter>(SpeechRecognizer_get_Timeouts), nullptr, nullptr, nullptr },
        { "u_i_options", reinterpret_cast<getter>(SpeechRecognizer_get_UIOptions), nullptr, nullptr, nullptr },
        { "continuous_recognition_session", reinterpret_cast<getter>(SpeechRecognizer_get_ContinuousRecognitionSession), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(SpeechRecognizer_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizer) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizer =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizer",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizer
    };

    static PyGetSetDef getset_SpeechRecognizer_Static[] = {
        { "supported_grammar_languages", reinterpret_cast<getter>(SpeechRecognizer_get_SupportedGrammarLanguages), nullptr, nullptr, nullptr },
        { "supported_topic_languages", reinterpret_cast<getter>(SpeechRecognizer_get_SupportedTopicLanguages), nullptr, nullptr, nullptr },
        { "system_speech_language", reinterpret_cast<getter>(SpeechRecognizer_get_SystemSpeechLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SpeechRecognizer_Static[] = {
        { "try_set_system_speech_language_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_TrySetSystemSpeechLanguageAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SpeechRecognizer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpeechRecognizer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpeechRecognizer_Static) },
        { }
    };

    static PyType_Spec type_spec_SpeechRecognizer_Static =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpeechRecognizer_Static
    };

    // ----- SpeechRecognizerStateChangedEventArgs class --------------------

    static PyObject* _new_SpeechRecognizerStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerStateChangedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerStateChangedEventArgs_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SpeechRecognizerStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(SpeechRecognizerStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizerStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizerStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizerStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizerStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizerStateChangedEventArgs =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizerStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerStateChangedEventArgs
    };

    // ----- SpeechRecognizerTimeouts class --------------------

    static PyObject* _new_SpeechRecognizerTimeouts(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerTimeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerTimeouts_get_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"InitialSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitialSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"InitialSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InitialSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"EndSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"EndSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EndSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"BabbleTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BabbleTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"BabbleTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BabbleTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerTimeouts[] = {
        { "_assign_array_", _assign_array_SpeechRecognizerTimeouts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerTimeouts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerTimeouts[] = {
        { "initial_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_InitialSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_InitialSilenceTimeout), nullptr, nullptr },
        { "end_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_EndSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_EndSilenceTimeout), nullptr, nullptr },
        { "babble_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_BabbleTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_BabbleTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerTimeouts[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizerTimeouts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizerTimeouts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizerTimeouts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizerTimeouts) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizerTimeouts =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizerTimeouts",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerTimeouts
    };

    // ----- SpeechRecognizerUIOptions class --------------------

    static PyObject* _new_SpeechRecognizerUIOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerUIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerUIOptions_get_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ShowConfirmation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowConfirmation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ShowConfirmation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowConfirmation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"IsReadBackEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadBackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"IsReadBackEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReadBackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ExampleText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExampleText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ExampleText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExampleText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"AudiblePrompt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudiblePrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"AudiblePrompt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudiblePrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerUIOptions[] = {
        { "_assign_array_", _assign_array_SpeechRecognizerUIOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerUIOptions[] = {
        { "show_confirmation", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ShowConfirmation), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ShowConfirmation), nullptr, nullptr },
        { "is_read_back_enabled", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_IsReadBackEnabled), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_IsReadBackEnabled), nullptr, nullptr },
        { "example_text", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ExampleText), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ExampleText), nullptr, nullptr },
        { "audible_prompt", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_AudiblePrompt), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_AudiblePrompt), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerUIOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeechRecognizerUIOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeechRecognizerUIOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeechRecognizerUIOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeechRecognizerUIOptions) },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizerUIOptions =
    {
        "winrt._winrt_windows_media_speechrecognition.SpeechRecognizerUIOptions",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerUIOptions
    };

    // ----- VoiceCommandManager class --------------------

    static PyObject* _new_VoiceCommandManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::VoiceCommandManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::VoiceCommandManager>::type_name);
        return nullptr;
    }

    static PyObject* VoiceCommandManager_InstallCommandSetsFromStorageFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.VoiceCommandManager", L"InstallCommandSetsFromStorageFileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::SpeechRecognition::VoiceCommandManager::InstallCommandSetsFromStorageFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoiceCommandManager_get_InstalledCommandSets(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.VoiceCommandManager", L"InstalledCommandSets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::VoiceCommandManager::InstalledCommandSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandManager[] = {
        { }
    };

    static PyGetSetDef _getset_VoiceCommandManager[] = {
        { }
    };

    static PyType_Slot _type_slots_VoiceCommandManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoiceCommandManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoiceCommandManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoiceCommandManager) },
        { },
    };

    static PyType_Spec type_spec_VoiceCommandManager =
    {
        "winrt._winrt_windows_media_speechrecognition.VoiceCommandManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandManager
    };

    static PyGetSetDef getset_VoiceCommandManager_Static[] = {
        { "installed_command_sets", reinterpret_cast<getter>(VoiceCommandManager_get_InstalledCommandSets), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_VoiceCommandManager_Static[] = {
        { "install_command_sets_from_storage_file_async", reinterpret_cast<PyCFunction>(VoiceCommandManager_InstallCommandSetsFromStorageFileAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VoiceCommandManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VoiceCommandManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VoiceCommandManager_Static) },
        { }
    };

    static PyType_Spec type_spec_VoiceCommandManager_Static =
    {
        "winrt._winrt_windows_media_speechrecognition.VoiceCommandManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VoiceCommandManager_Static
    };

    // ----- VoiceCommandSet class --------------------

    static PyObject* _new_VoiceCommandSet(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::VoiceCommandSet>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::VoiceCommandSet>::type_name);
        return nullptr;
    }

    static void _dealloc_VoiceCommandSet(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoiceCommandSet_SetPhraseListAsync(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.VoiceCommandSet", L"SetPhraseListAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.SetPhraseListAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoiceCommandSet_get_Language(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.VoiceCommandSet", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandSet_get_Name(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.VoiceCommandSet", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoiceCommandSet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::VoiceCommandSet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoiceCommandSet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::VoiceCommandSet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandSet[] = {
        { "set_phrase_list_async", reinterpret_cast<PyCFunction>(VoiceCommandSet_SetPhraseListAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VoiceCommandSet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoiceCommandSet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoiceCommandSet[] = {
        { "language", reinterpret_cast<getter>(VoiceCommandSet_get_Language), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VoiceCommandSet_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoiceCommandSet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoiceCommandSet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoiceCommandSet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoiceCommandSet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoiceCommandSet) },
        { },
    };

    static PyType_Spec type_spec_VoiceCommandSet =
    {
        "winrt._winrt_windows_media_speechrecognition.VoiceCommandSet",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandSet
    };

    // ----- ISpeechRecognitionConstraint interface --------------------

    static PyObject* _new_ISpeechRecognitionConstraint(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::type_name);
        return nullptr;
    }

    static void _dealloc_ISpeechRecognitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpeechRecognitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpeechRecognitionConstraint[] = {
        { "_assign_array_", _assign_array_ISpeechRecognitionConstraint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpeechRecognitionConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISpeechRecognitionConstraint[] = {
        { "is_enabled", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_IsEnabled), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Probability), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Probability), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Tag), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Tag), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISpeechRecognitionConstraint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISpeechRecognitionConstraint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISpeechRecognitionConstraint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISpeechRecognitionConstraint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISpeechRecognitionConstraint) },
        { },
    };

    static PyType_Spec type_spec_ISpeechRecognitionConstraint =
    {
        "winrt._winrt_windows_media_speechrecognition.ISpeechRecognitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpeechRecognitionConstraint
    };

    // ----- Windows.Media.SpeechRecognition Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::SpeechRecognition");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_speechrecognition",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::SpeechRecognition

PyMODINIT_FUNC PyInit__winrt_windows_media_speechrecognition(void) noexcept
{
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechContinuousRecognitionCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechContinuousRecognitionSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionCompilationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionGrammarFileConstraint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionHypothesis, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionHypothesisGeneratedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionListConstraint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionQualityDegradingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionSemanticInterpretation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionTopicConstraint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpeechRecognizer_Static{PyType_FromSpec(&type_spec_SpeechRecognizer_Static)};
    if (!type_SpeechRecognizer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognizer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpeechRecognizer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognizerStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognizerTimeouts, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeechRecognizerUIOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_VoiceCommandManager_Static{PyType_FromSpec(&type_spec_VoiceCommandManager_Static)};
    if (!type_VoiceCommandManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VoiceCommandManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VoiceCommandManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VoiceCommandSet, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISpeechRecognitionConstraint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
