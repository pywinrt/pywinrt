// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Input.h"

namespace py::cpp::Microsoft::UI::Input
{
    // ----- CharacterReceivedEventArgs class --------------------

    static PyObject* _new_CharacterReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::CharacterReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::CharacterReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CharacterReceivedEventArgs(py::wrapper::Microsoft::UI::Input::CharacterReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CharacterReceivedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Input::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CharacterReceivedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CharacterReceivedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Input::CharacterReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CharacterReceivedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CharacterReceivedEventArgs_get_KeyCode(py::wrapper::Microsoft::UI::Input::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CharacterReceivedEventArgs", L"KeyCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CharacterReceivedEventArgs_get_KeyStatus(py::wrapper::Microsoft::UI::Input::CharacterReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CharacterReceivedEventArgs", L"KeyStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CharacterReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::CharacterReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CharacterReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::CharacterReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CharacterReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_CharacterReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CharacterReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CharacterReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_Handled), reinterpret_cast<setter>(CharacterReceivedEventArgs_put_Handled), nullptr, nullptr },
        { "key_code", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_KeyCode), nullptr, nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(CharacterReceivedEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CharacterReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CharacterReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CharacterReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CharacterReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CharacterReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_CharacterReceivedEventArgs = {
        "winrt._winrt_microsoft_ui_input.CharacterReceivedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::CharacterReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CharacterReceivedEventArgs};

    // ----- ContextMenuKeyEventArgs class --------------------

    static PyObject* _new_ContextMenuKeyEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContextMenuKeyEventArgs(py::wrapper::Microsoft::UI::Input::ContextMenuKeyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContextMenuKeyEventArgs_get_Handled(py::wrapper::Microsoft::UI::Input::ContextMenuKeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ContextMenuKeyEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContextMenuKeyEventArgs_put_Handled(py::wrapper::Microsoft::UI::Input::ContextMenuKeyEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ContextMenuKeyEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContextMenuKeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContextMenuKeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContextMenuKeyEventArgs[] = {
        { "_assign_array_", _assign_array_ContextMenuKeyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContextMenuKeyEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContextMenuKeyEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContextMenuKeyEventArgs_get_Handled), reinterpret_cast<setter>(ContextMenuKeyEventArgs_put_Handled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContextMenuKeyEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContextMenuKeyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContextMenuKeyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContextMenuKeyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContextMenuKeyEventArgs) },
        { }};

    static PyType_Spec type_spec_ContextMenuKeyEventArgs = {
        "winrt._winrt_microsoft_ui_input.ContextMenuKeyEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::ContextMenuKeyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContextMenuKeyEventArgs};

    // ----- CrossSlidingEventArgs class --------------------

    static PyObject* _new_CrossSlidingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::CrossSlidingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::CrossSlidingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CrossSlidingEventArgs(py::wrapper::Microsoft::UI::Input::CrossSlidingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CrossSlidingEventArgs_get_CrossSlidingState(py::wrapper::Microsoft::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CrossSlidingEventArgs", L"CrossSlidingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlidingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CrossSlidingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.CrossSlidingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CrossSlidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::CrossSlidingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CrossSlidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::CrossSlidingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CrossSlidingEventArgs[] = {
        { "_assign_array_", _assign_array_CrossSlidingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CrossSlidingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CrossSlidingEventArgs[] = {
        { "cross_sliding_state", reinterpret_cast<getter>(CrossSlidingEventArgs_get_CrossSlidingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(CrossSlidingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(CrossSlidingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CrossSlidingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CrossSlidingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CrossSlidingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CrossSlidingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CrossSlidingEventArgs) },
        { }};

    static PyType_Spec type_spec_CrossSlidingEventArgs = {
        "winrt._winrt_microsoft_ui_input.CrossSlidingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::CrossSlidingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CrossSlidingEventArgs};

    // ----- DraggingEventArgs class --------------------

    static PyObject* _new_DraggingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::DraggingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::DraggingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DraggingEventArgs(py::wrapper::Microsoft::UI::Input::DraggingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DraggingEventArgs_get_DraggingState(py::wrapper::Microsoft::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.DraggingEventArgs", L"DraggingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DraggingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.DraggingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.DraggingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DraggingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::DraggingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DraggingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::DraggingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DraggingEventArgs[] = {
        { "_assign_array_", _assign_array_DraggingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DraggingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DraggingEventArgs[] = {
        { "dragging_state", reinterpret_cast<getter>(DraggingEventArgs_get_DraggingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(DraggingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(DraggingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DraggingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DraggingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DraggingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DraggingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DraggingEventArgs) },
        { }};

    static PyType_Spec type_spec_DraggingEventArgs = {
        "winrt._winrt_microsoft_ui_input.DraggingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::DraggingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DraggingEventArgs};

    // ----- EnteredMoveSizeEventArgs class --------------------

    static PyObject* _new_EnteredMoveSizeEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EnteredMoveSizeEventArgs(py::wrapper::Microsoft::UI::Input::EnteredMoveSizeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnteredMoveSizeEventArgs_get_MoveSizeOperation(py::wrapper::Microsoft::UI::Input::EnteredMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.EnteredMoveSizeEventArgs", L"MoveSizeOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveSizeOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnteredMoveSizeEventArgs_get_PointerScreenPoint(py::wrapper::Microsoft::UI::Input::EnteredMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.EnteredMoveSizeEventArgs", L"PointerScreenPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerScreenPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnteredMoveSizeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnteredMoveSizeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredMoveSizeEventArgs[] = {
        { "_assign_array_", _assign_array_EnteredMoveSizeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteredMoveSizeEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EnteredMoveSizeEventArgs[] = {
        { "move_size_operation", reinterpret_cast<getter>(EnteredMoveSizeEventArgs_get_MoveSizeOperation), nullptr, nullptr, nullptr },
        { "pointer_screen_point", reinterpret_cast<getter>(EnteredMoveSizeEventArgs_get_PointerScreenPoint), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EnteredMoveSizeEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnteredMoveSizeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnteredMoveSizeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnteredMoveSizeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnteredMoveSizeEventArgs) },
        { }};

    static PyType_Spec type_spec_EnteredMoveSizeEventArgs = {
        "winrt._winrt_microsoft_ui_input.EnteredMoveSizeEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::EnteredMoveSizeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredMoveSizeEventArgs};

    // ----- EnteringMoveSizeEventArgs class --------------------

    static PyObject* _new_EnteringMoveSizeEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EnteringMoveSizeEventArgs(py::wrapper::Microsoft::UI::Input::EnteringMoveSizeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnteringMoveSizeEventArgs_get_MoveSizeWindowId(py::wrapper::Microsoft::UI::Input::EnteringMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.EnteringMoveSizeEventArgs", L"MoveSizeWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveSizeWindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EnteringMoveSizeEventArgs_put_MoveSizeWindowId(py::wrapper::Microsoft::UI::Input::EnteringMoveSizeEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.EnteringMoveSizeEventArgs", L"MoveSizeWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(arg);

            {
                auto _gil = release_gil();
                self->obj.MoveSizeWindowId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EnteringMoveSizeEventArgs_get_MoveSizeOperation(py::wrapper::Microsoft::UI::Input::EnteringMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.EnteringMoveSizeEventArgs", L"MoveSizeOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveSizeOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnteringMoveSizeEventArgs_get_PointerScreenPoint(py::wrapper::Microsoft::UI::Input::EnteringMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.EnteringMoveSizeEventArgs", L"PointerScreenPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerScreenPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnteringMoveSizeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnteringMoveSizeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteringMoveSizeEventArgs[] = {
        { "_assign_array_", _assign_array_EnteringMoveSizeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteringMoveSizeEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EnteringMoveSizeEventArgs[] = {
        { "move_size_window_id", reinterpret_cast<getter>(EnteringMoveSizeEventArgs_get_MoveSizeWindowId), reinterpret_cast<setter>(EnteringMoveSizeEventArgs_put_MoveSizeWindowId), nullptr, nullptr },
        { "move_size_operation", reinterpret_cast<getter>(EnteringMoveSizeEventArgs_get_MoveSizeOperation), nullptr, nullptr, nullptr },
        { "pointer_screen_point", reinterpret_cast<getter>(EnteringMoveSizeEventArgs_get_PointerScreenPoint), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EnteringMoveSizeEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnteringMoveSizeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnteringMoveSizeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnteringMoveSizeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnteringMoveSizeEventArgs) },
        { }};

    static PyType_Spec type_spec_EnteringMoveSizeEventArgs = {
        "winrt._winrt_microsoft_ui_input.EnteringMoveSizeEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::EnteringMoveSizeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteringMoveSizeEventArgs};

    // ----- ExitedMoveSizeEventArgs class --------------------

    static PyObject* _new_ExitedMoveSizeEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ExitedMoveSizeEventArgs(py::wrapper::Microsoft::UI::Input::ExitedMoveSizeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExitedMoveSizeEventArgs_get_MoveSizeOperation(py::wrapper::Microsoft::UI::Input::ExitedMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ExitedMoveSizeEventArgs", L"MoveSizeOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveSizeOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExitedMoveSizeEventArgs_get_PointerScreenPoint(py::wrapper::Microsoft::UI::Input::ExitedMoveSizeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ExitedMoveSizeEventArgs", L"PointerScreenPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerScreenPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExitedMoveSizeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExitedMoveSizeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExitedMoveSizeEventArgs[] = {
        { "_assign_array_", _assign_array_ExitedMoveSizeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExitedMoveSizeEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ExitedMoveSizeEventArgs[] = {
        { "move_size_operation", reinterpret_cast<getter>(ExitedMoveSizeEventArgs_get_MoveSizeOperation), nullptr, nullptr, nullptr },
        { "pointer_screen_point", reinterpret_cast<getter>(ExitedMoveSizeEventArgs_get_PointerScreenPoint), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ExitedMoveSizeEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExitedMoveSizeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExitedMoveSizeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExitedMoveSizeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExitedMoveSizeEventArgs) },
        { }};

    static PyType_Spec type_spec_ExitedMoveSizeEventArgs = {
        "winrt._winrt_microsoft_ui_input.ExitedMoveSizeEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::ExitedMoveSizeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExitedMoveSizeEventArgs};

    // ----- FocusChangedEventArgs class --------------------

    static PyObject* _new_FocusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::FocusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::FocusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusChangedEventArgs(py::wrapper::Microsoft::UI::Input::FocusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusChangedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Input::FocusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusChangedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Input::FocusChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::FocusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::FocusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_FocusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(FocusChangedEventArgs_get_Handled), reinterpret_cast<setter>(FocusChangedEventArgs_put_Handled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_FocusChangedEventArgs = {
        "winrt._winrt_microsoft_ui_input.FocusChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::FocusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusChangedEventArgs};

    // ----- FocusNavigationRequest class --------------------

    static PyObject* _new_FocusNavigationRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::FocusNavigationRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::FocusNavigationRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusNavigationRequest(py::wrapper::Microsoft::UI::Input::FocusNavigationRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusNavigationRequest_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.FocusNavigationRequest", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::FocusNavigationReason>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::FocusNavigationRequest::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusNavigationRequest_CreateWithHintRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.FocusNavigationRequest", L"Create", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::FocusNavigationReason>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::FocusNavigationRequest::Create(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusNavigationRequest_CreateWithHintRectAndId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.FocusNavigationRequest", L"Create", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::FocusNavigationReason>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::FocusNavigationRequest::Create(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusNavigationRequest_get_CorrelationId(py::wrapper::Microsoft::UI::Input::FocusNavigationRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusNavigationRequest", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusNavigationRequest_get_HintRect(py::wrapper::Microsoft::UI::Input::FocusNavigationRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusNavigationRequest", L"HintRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HintRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusNavigationRequest_get_Reason(py::wrapper::Microsoft::UI::Input::FocusNavigationRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusNavigationRequest", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusNavigationRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::FocusNavigationRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusNavigationRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::FocusNavigationRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusNavigationRequest[] = {
        { "_assign_array_", _assign_array_FocusNavigationRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusNavigationRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusNavigationRequest[] = {
        { "correlation_id", reinterpret_cast<getter>(FocusNavigationRequest_get_CorrelationId), nullptr, nullptr, nullptr },
        { "hint_rect", reinterpret_cast<getter>(FocusNavigationRequest_get_HintRect), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(FocusNavigationRequest_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusNavigationRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusNavigationRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusNavigationRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusNavigationRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusNavigationRequest) },
        { }};

    static PyType_Spec type_spec_FocusNavigationRequest = {
        "winrt._winrt_microsoft_ui_input.FocusNavigationRequest",
        sizeof(py::wrapper::Microsoft::UI::Input::FocusNavigationRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusNavigationRequest};

    static PyGetSetDef getset_FocusNavigationRequest_Static[] = {
        { }};

    static PyMethodDef methods_FocusNavigationRequest_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(FocusNavigationRequest_Create), METH_VARARGS, nullptr },
        { "create_with_hint_rect", reinterpret_cast<PyCFunction>(FocusNavigationRequest_CreateWithHintRect), METH_VARARGS, nullptr },
        { "create_with_hint_rect_and_id", reinterpret_cast<PyCFunction>(FocusNavigationRequest_CreateWithHintRectAndId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_FocusNavigationRequest_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FocusNavigationRequest_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FocusNavigationRequest_Static) },
        { }
    };

    static PyType_Spec type_spec_FocusNavigationRequest_Static = {
        "winrt._winrt_microsoft_ui_input.FocusNavigationRequest_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FocusNavigationRequest_Static};

    // ----- FocusNavigationRequestEventArgs class --------------------

    static PyObject* _new_FocusNavigationRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusNavigationRequestEventArgs(py::wrapper::Microsoft::UI::Input::FocusNavigationRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusNavigationRequestEventArgs_get_Result(py::wrapper::Microsoft::UI::Input::FocusNavigationRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusNavigationRequestEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusNavigationRequestEventArgs_put_Result(py::wrapper::Microsoft::UI::Input::FocusNavigationRequestEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusNavigationRequestEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Input::FocusNavigationResult>(arg);

            {
                auto _gil = release_gil();
                self->obj.Result(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusNavigationRequestEventArgs_get_Request(py::wrapper::Microsoft::UI::Input::FocusNavigationRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.FocusNavigationRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusNavigationRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusNavigationRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusNavigationRequestEventArgs[] = {
        { "_assign_array_", _assign_array_FocusNavigationRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusNavigationRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FocusNavigationRequestEventArgs[] = {
        { "result", reinterpret_cast<getter>(FocusNavigationRequestEventArgs_get_Result), reinterpret_cast<setter>(FocusNavigationRequestEventArgs_put_Result), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(FocusNavigationRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FocusNavigationRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusNavigationRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusNavigationRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusNavigationRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusNavigationRequestEventArgs) },
        { }};

    static PyType_Spec type_spec_FocusNavigationRequestEventArgs = {
        "winrt._winrt_microsoft_ui_input.FocusNavigationRequestEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::FocusNavigationRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusNavigationRequestEventArgs};

    // ----- GestureRecognizer class --------------------

    static PyObject* _new_GestureRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Input::GestureRecognizer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GestureRecognizer(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GestureRecognizer_CanBeDoubleTap(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CanBeDoubleTap", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CanBeDoubleTap(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_CompleteGesture(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CompleteGesture", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.CompleteGesture();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessDownEvent(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ProcessDownEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessDownEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessInertia(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ProcessInertia", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ProcessInertia();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessMouseWheelEvent(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ProcessMouseWheelEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessMouseWheelEvent(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessMoveEvents(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ProcessMoveEvents", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Input::PointerPoint>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessMoveEvents(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessUpEvent(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ProcessUpEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessUpEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_ShowGestureFeedback(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ShowGestureFeedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowGestureFeedback();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_ShowGestureFeedback(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ShowGestureFeedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowGestureFeedback(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_PivotRadius(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"PivotRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PivotRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_PivotRadius(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"PivotRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.PivotRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_PivotCenter(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"PivotCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PivotCenter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_PivotCenter(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"PivotCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.PivotCenter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_ManipulationExact(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationExact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_ManipulationExact(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationExact(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaTranslationDisplacement(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaTranslationDisplacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaTranslationDisplacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaTranslationDisplacement(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaTranslationDisplacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaTranslationDisplacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaTranslationDeceleration(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaTranslationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaTranslationDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaTranslationDeceleration(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaTranslationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaTranslationDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaRotationDeceleration(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaRotationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaRotationDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaRotationDeceleration(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaRotationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaRotationDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaRotationAngle(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaRotationAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaRotationAngle(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaRotationAngle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaExpansionDeceleration(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaExpansionDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaExpansionDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaExpansionDeceleration(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaExpansionDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaExpansionDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaExpansion(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaExpansion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaExpansion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaExpansion(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"InertiaExpansion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaExpansion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_GestureSettings(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GestureSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_GestureSettings(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Input::GestureSettings>(arg);

            {
                auto _gil = release_gil();
                self->obj.GestureSettings(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideThresholds(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSlideThresholds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlideThresholds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideThresholds(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSlideThresholds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Input::CrossSlideThresholds>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSlideThresholds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideHorizontally(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSlideHorizontally");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlideHorizontally();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideHorizontally(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSlideHorizontally");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSlideHorizontally(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideExact(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSlideExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlideExact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideExact(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSlideExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSlideExact(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_AutoProcessInertia(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"AutoProcessInertia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutoProcessInertia();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_AutoProcessInertia(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"AutoProcessInertia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutoProcessInertia(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_IsActive(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_IsInertial(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"IsInertial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInertial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_MouseWheelParameters(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.GestureRecognizer", L"MouseWheelParameters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MouseWheelParameters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_CrossSliding(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSliding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::CrossSlidingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSliding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_CrossSliding(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"CrossSliding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSliding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Dragging(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"Dragging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::DraggingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Dragging(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Dragging(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"Dragging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Dragging(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Holding(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"Holding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::HoldingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Holding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Holding(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"Holding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Holding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationCompleted(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationCompleted(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationInertiaStarting(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationInertiaStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationInertiaStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationInertiaStarting(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationInertiaStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationInertiaStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationStarted(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationStartedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationStarted(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationUpdated(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationUpdated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationUpdated(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationUpdated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_RightTapped(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"RightTapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::RightTappedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RightTapped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_RightTapped(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"RightTapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RightTapped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Tapped(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::TappedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tapped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Tapped(py::wrapper::Microsoft::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.GestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tapped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::GestureRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::GestureRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GestureRecognizer[] = {
        { "can_be_double_tap", reinterpret_cast<PyCFunction>(GestureRecognizer_CanBeDoubleTap), METH_VARARGS, nullptr },
        { "complete_gesture", reinterpret_cast<PyCFunction>(GestureRecognizer_CompleteGesture), METH_VARARGS, nullptr },
        { "process_down_event", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessDownEvent), METH_VARARGS, nullptr },
        { "process_inertia", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessInertia), METH_VARARGS, nullptr },
        { "process_mouse_wheel_event", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessMouseWheelEvent), METH_VARARGS, nullptr },
        { "process_move_events", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessMoveEvents), METH_VARARGS, nullptr },
        { "process_up_event", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessUpEvent), METH_VARARGS, nullptr },
        { "add_cross_sliding", reinterpret_cast<PyCFunction>(GestureRecognizer_add_CrossSliding), METH_O, nullptr },
        { "remove_cross_sliding", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_CrossSliding), METH_O, nullptr },
        { "add_dragging", reinterpret_cast<PyCFunction>(GestureRecognizer_add_Dragging), METH_O, nullptr },
        { "remove_dragging", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_Dragging), METH_O, nullptr },
        { "add_holding", reinterpret_cast<PyCFunction>(GestureRecognizer_add_Holding), METH_O, nullptr },
        { "remove_holding", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_Holding), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationInertiaStarting), METH_O, nullptr },
        { "remove_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationInertiaStarting), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_updated", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationUpdated), METH_O, nullptr },
        { "remove_manipulation_updated", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationUpdated), METH_O, nullptr },
        { "add_right_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_add_RightTapped), METH_O, nullptr },
        { "remove_right_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_RightTapped), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_Tapped), METH_O, nullptr },
        { "_assign_array_", _assign_array_GestureRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GestureRecognizer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GestureRecognizer[] = {
        { "show_gesture_feedback", reinterpret_cast<getter>(GestureRecognizer_get_ShowGestureFeedback), reinterpret_cast<setter>(GestureRecognizer_put_ShowGestureFeedback), nullptr, nullptr },
        { "pivot_radius", reinterpret_cast<getter>(GestureRecognizer_get_PivotRadius), reinterpret_cast<setter>(GestureRecognizer_put_PivotRadius), nullptr, nullptr },
        { "pivot_center", reinterpret_cast<getter>(GestureRecognizer_get_PivotCenter), reinterpret_cast<setter>(GestureRecognizer_put_PivotCenter), nullptr, nullptr },
        { "manipulation_exact", reinterpret_cast<getter>(GestureRecognizer_get_ManipulationExact), reinterpret_cast<setter>(GestureRecognizer_put_ManipulationExact), nullptr, nullptr },
        { "inertia_translation_displacement", reinterpret_cast<getter>(GestureRecognizer_get_InertiaTranslationDisplacement), reinterpret_cast<setter>(GestureRecognizer_put_InertiaTranslationDisplacement), nullptr, nullptr },
        { "inertia_translation_deceleration", reinterpret_cast<getter>(GestureRecognizer_get_InertiaTranslationDeceleration), reinterpret_cast<setter>(GestureRecognizer_put_InertiaTranslationDeceleration), nullptr, nullptr },
        { "inertia_rotation_deceleration", reinterpret_cast<getter>(GestureRecognizer_get_InertiaRotationDeceleration), reinterpret_cast<setter>(GestureRecognizer_put_InertiaRotationDeceleration), nullptr, nullptr },
        { "inertia_rotation_angle", reinterpret_cast<getter>(GestureRecognizer_get_InertiaRotationAngle), reinterpret_cast<setter>(GestureRecognizer_put_InertiaRotationAngle), nullptr, nullptr },
        { "inertia_expansion_deceleration", reinterpret_cast<getter>(GestureRecognizer_get_InertiaExpansionDeceleration), reinterpret_cast<setter>(GestureRecognizer_put_InertiaExpansionDeceleration), nullptr, nullptr },
        { "inertia_expansion", reinterpret_cast<getter>(GestureRecognizer_get_InertiaExpansion), reinterpret_cast<setter>(GestureRecognizer_put_InertiaExpansion), nullptr, nullptr },
        { "gesture_settings", reinterpret_cast<getter>(GestureRecognizer_get_GestureSettings), reinterpret_cast<setter>(GestureRecognizer_put_GestureSettings), nullptr, nullptr },
        { "cross_slide_thresholds", reinterpret_cast<getter>(GestureRecognizer_get_CrossSlideThresholds), reinterpret_cast<setter>(GestureRecognizer_put_CrossSlideThresholds), nullptr, nullptr },
        { "cross_slide_horizontally", reinterpret_cast<getter>(GestureRecognizer_get_CrossSlideHorizontally), reinterpret_cast<setter>(GestureRecognizer_put_CrossSlideHorizontally), nullptr, nullptr },
        { "cross_slide_exact", reinterpret_cast<getter>(GestureRecognizer_get_CrossSlideExact), reinterpret_cast<setter>(GestureRecognizer_put_CrossSlideExact), nullptr, nullptr },
        { "auto_process_inertia", reinterpret_cast<getter>(GestureRecognizer_get_AutoProcessInertia), reinterpret_cast<setter>(GestureRecognizer_put_AutoProcessInertia), nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(GestureRecognizer_get_IsActive), nullptr, nullptr, nullptr },
        { "is_inertial", reinterpret_cast<getter>(GestureRecognizer_get_IsInertial), nullptr, nullptr, nullptr },
        { "mouse_wheel_parameters", reinterpret_cast<getter>(GestureRecognizer_get_MouseWheelParameters), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GestureRecognizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GestureRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GestureRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GestureRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GestureRecognizer) },
        { }};

    static PyType_Spec type_spec_GestureRecognizer = {
        "winrt._winrt_microsoft_ui_input.GestureRecognizer",
        sizeof(py::wrapper::Microsoft::UI::Input::GestureRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GestureRecognizer};

    // ----- HoldingEventArgs class --------------------

    static PyObject* _new_HoldingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::HoldingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::HoldingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HoldingEventArgs(py::wrapper::Microsoft::UI::Input::HoldingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HoldingEventArgs_get_HoldingState(py::wrapper::Microsoft::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.HoldingEventArgs", L"HoldingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.HoldingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.HoldingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::HoldingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::HoldingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HoldingEventArgs[] = {
        { "_assign_array_", _assign_array_HoldingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HoldingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HoldingEventArgs[] = {
        { "holding_state", reinterpret_cast<getter>(HoldingEventArgs_get_HoldingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(HoldingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(HoldingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HoldingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HoldingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HoldingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HoldingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HoldingEventArgs) },
        { }};

    static PyType_Spec type_spec_HoldingEventArgs = {
        "winrt._winrt_microsoft_ui_input.HoldingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::HoldingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HoldingEventArgs};

    // ----- InputActivationListener class --------------------

    static PyObject* _new_InputActivationListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputActivationListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputActivationListener>::type_name);
        return nullptr;
    }

    static void _dealloc_InputActivationListener(py::wrapper::Microsoft::UI::Input::InputActivationListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputActivationListener_GetForIsland(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputActivationListener", L"GetForIsland", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputActivationListener::GetForIsland(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_GetForWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputActivationListener", L"GetForWindowId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputActivationListener::GetForWindowId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_get_State(py::wrapper::Microsoft::UI::Input::InputActivationListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputActivationListener", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_add_InputActivationChanged(py::wrapper::Microsoft::UI::Input::InputActivationListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputActivationListener", L"InputActivationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputActivationListener, winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputActivationChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_remove_InputActivationChanged(py::wrapper::Microsoft::UI::Input::InputActivationListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputActivationListener", L"InputActivationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputActivationChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputActivationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputActivationListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputActivationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputActivationListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputActivationListener[] = {
        { "add_input_activation_changed", reinterpret_cast<PyCFunction>(InputActivationListener_add_InputActivationChanged), METH_O, nullptr },
        { "remove_input_activation_changed", reinterpret_cast<PyCFunction>(InputActivationListener_remove_InputActivationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputActivationListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputActivationListener), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputActivationListener[] = {
        { "state", reinterpret_cast<getter>(InputActivationListener_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputActivationListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputActivationListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputActivationListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputActivationListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputActivationListener) },
        { }};

    static PyType_Spec type_spec_InputActivationListener = {
        "winrt._winrt_microsoft_ui_input.InputActivationListener",
        sizeof(py::wrapper::Microsoft::UI::Input::InputActivationListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputActivationListener};

    static PyGetSetDef getset_InputActivationListener_Static[] = {
        { }};

    static PyMethodDef methods_InputActivationListener_Static[] = {
        { "get_for_island", reinterpret_cast<PyCFunction>(InputActivationListener_GetForIsland), METH_VARARGS, nullptr },
        { "get_for_window_id", reinterpret_cast<PyCFunction>(InputActivationListener_GetForWindowId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputActivationListener_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputActivationListener_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputActivationListener_Static) },
        { }
    };

    static PyType_Spec type_spec_InputActivationListener_Static = {
        "winrt._winrt_microsoft_ui_input.InputActivationListener_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputActivationListener_Static};

    // ----- InputActivationListenerActivationChangedEventArgs class --------------------

    static PyObject* _new_InputActivationListenerActivationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InputActivationListenerActivationChangedEventArgs(py::wrapper::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InputActivationListenerActivationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputActivationListenerActivationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputActivationListenerActivationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_InputActivationListenerActivationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputActivationListenerActivationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputActivationListenerActivationChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_InputActivationListenerActivationChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputActivationListenerActivationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputActivationListenerActivationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputActivationListenerActivationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputActivationListenerActivationChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_InputActivationListenerActivationChangedEventArgs = {
        "winrt._winrt_microsoft_ui_input.InputActivationListenerActivationChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputActivationListenerActivationChangedEventArgs};

    // ----- InputCursor class --------------------

    static PyObject* _new_InputCursor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputCursor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputCursor>::type_name);
        return nullptr;
    }

    static void _dealloc_InputCursor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputCursor_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputCursor", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Input::InputCursor>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputCursor_CreateFromCoreCursor(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputCursor", L"CreateFromCoreCursor", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreCursor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputCursor::CreateFromCoreCursor(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_InputCursor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_InputCursor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Input::InputCursor>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputCursor[] = {
        { "close", reinterpret_cast<PyCFunction>(InputCursor_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InputCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputCursor), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_InputCursor), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_InputCursor), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_InputCursor[] = {
        { }};

    static PyType_Slot _type_slots_InputCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputCursor) },
        { }};

    static PyType_Spec type_spec_InputCursor = {
        "winrt._winrt_microsoft_ui_input.InputCursor",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InputCursor};

    static PyGetSetDef getset_InputCursor_Static[] = {
        { }};

    static PyMethodDef methods_InputCursor_Static[] = {
        { "create_from_core_cursor", reinterpret_cast<PyCFunction>(InputCursor_CreateFromCoreCursor), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputCursor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputCursor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputCursor_Static) },
        { }
    };

    static PyType_Spec type_spec_InputCursor_Static = {
        "winrt._winrt_microsoft_ui_input.InputCursor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InputCursor_Static};

    // ----- InputCustomCursor class --------------------

    static PyObject* _new_InputCustomCursor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputCustomCursor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputCustomCursor>::type_name);
        return nullptr;
    }

    static void _dealloc_InputCustomCursor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InputCustomCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputCustomCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputCustomCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputCustomCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputCustomCursor[] = {
        { "_assign_array_", _assign_array_InputCustomCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputCustomCursor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputCustomCursor[] = {
        { }};

    static PyType_Slot _type_slots_InputCustomCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputCustomCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputCustomCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputCustomCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputCustomCursor) },
        { }};

    static PyType_Spec type_spec_InputCustomCursor = {
        "winrt._winrt_microsoft_ui_input.InputCustomCursor",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InputCustomCursor};

    static PyGetSetDef getset_InputCustomCursor_Static[] = {
        { }};

    static PyMethodDef methods_InputCustomCursor_Static[] = {
        { }};

    static PyType_Slot type_slots_InputCustomCursor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputCustomCursor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputCustomCursor_Static) },
        { }
    };

    static PyType_Spec type_spec_InputCustomCursor_Static = {
        "winrt._winrt_microsoft_ui_input.InputCustomCursor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InputCustomCursor_Static};

    // ----- InputDesktopNamedResourceCursor class --------------------

    static PyObject* _new_InputDesktopNamedResourceCursor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>::type_name);
        return nullptr;
    }

    static void _dealloc_InputDesktopNamedResourceCursor(py::wrapper::Microsoft::UI::Input::InputDesktopNamedResourceCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputDesktopNamedResourceCursor_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputDesktopNamedResourceCursor", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputDesktopNamedResourceCursor_CreateFromModule(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputDesktopNamedResourceCursor", L"CreateFromModule", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor::CreateFromModule(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputDesktopNamedResourceCursor_get_ModuleName(py::wrapper::Microsoft::UI::Input::InputDesktopNamedResourceCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputDesktopNamedResourceCursor", L"ModuleName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModuleName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputDesktopNamedResourceCursor_get_ResourceName(py::wrapper::Microsoft::UI::Input::InputDesktopNamedResourceCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputDesktopNamedResourceCursor", L"ResourceName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResourceName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputDesktopNamedResourceCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputDesktopNamedResourceCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputDesktopNamedResourceCursor[] = {
        { "_assign_array_", _assign_array_InputDesktopNamedResourceCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputDesktopNamedResourceCursor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputDesktopNamedResourceCursor[] = {
        { "module_name", reinterpret_cast<getter>(InputDesktopNamedResourceCursor_get_ModuleName), nullptr, nullptr, nullptr },
        { "resource_name", reinterpret_cast<getter>(InputDesktopNamedResourceCursor_get_ResourceName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputDesktopNamedResourceCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputDesktopNamedResourceCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputDesktopNamedResourceCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputDesktopNamedResourceCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputDesktopNamedResourceCursor) },
        { }};

    static PyType_Spec type_spec_InputDesktopNamedResourceCursor = {
        "winrt._winrt_microsoft_ui_input.InputDesktopNamedResourceCursor",
        sizeof(py::wrapper::Microsoft::UI::Input::InputDesktopNamedResourceCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputDesktopNamedResourceCursor};

    static PyGetSetDef getset_InputDesktopNamedResourceCursor_Static[] = {
        { }};

    static PyMethodDef methods_InputDesktopNamedResourceCursor_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InputDesktopNamedResourceCursor_Create), METH_VARARGS, nullptr },
        { "create_from_module", reinterpret_cast<PyCFunction>(InputDesktopNamedResourceCursor_CreateFromModule), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputDesktopNamedResourceCursor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputDesktopNamedResourceCursor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputDesktopNamedResourceCursor_Static) },
        { }
    };

    static PyType_Spec type_spec_InputDesktopNamedResourceCursor_Static = {
        "winrt._winrt_microsoft_ui_input.InputDesktopNamedResourceCursor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputDesktopNamedResourceCursor_Static};

    // ----- InputDesktopResourceCursor class --------------------

    static PyObject* _new_InputDesktopResourceCursor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>::type_name);
        return nullptr;
    }

    static void _dealloc_InputDesktopResourceCursor(py::wrapper::Microsoft::UI::Input::InputDesktopResourceCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputDesktopResourceCursor_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputDesktopResourceCursor", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputDesktopResourceCursor::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputDesktopResourceCursor_CreateFromModule(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputDesktopResourceCursor", L"CreateFromModule", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputDesktopResourceCursor::CreateFromModule(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputDesktopResourceCursor_get_ModuleName(py::wrapper::Microsoft::UI::Input::InputDesktopResourceCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputDesktopResourceCursor", L"ModuleName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModuleName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputDesktopResourceCursor_get_ResourceId(py::wrapper::Microsoft::UI::Input::InputDesktopResourceCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputDesktopResourceCursor", L"ResourceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResourceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputDesktopResourceCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputDesktopResourceCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputDesktopResourceCursor[] = {
        { "_assign_array_", _assign_array_InputDesktopResourceCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputDesktopResourceCursor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputDesktopResourceCursor[] = {
        { "module_name", reinterpret_cast<getter>(InputDesktopResourceCursor_get_ModuleName), nullptr, nullptr, nullptr },
        { "resource_id", reinterpret_cast<getter>(InputDesktopResourceCursor_get_ResourceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputDesktopResourceCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputDesktopResourceCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputDesktopResourceCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputDesktopResourceCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputDesktopResourceCursor) },
        { }};

    static PyType_Spec type_spec_InputDesktopResourceCursor = {
        "winrt._winrt_microsoft_ui_input.InputDesktopResourceCursor",
        sizeof(py::wrapper::Microsoft::UI::Input::InputDesktopResourceCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputDesktopResourceCursor};

    static PyGetSetDef getset_InputDesktopResourceCursor_Static[] = {
        { }};

    static PyMethodDef methods_InputDesktopResourceCursor_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InputDesktopResourceCursor_Create), METH_VARARGS, nullptr },
        { "create_from_module", reinterpret_cast<PyCFunction>(InputDesktopResourceCursor_CreateFromModule), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputDesktopResourceCursor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputDesktopResourceCursor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputDesktopResourceCursor_Static) },
        { }
    };

    static PyType_Spec type_spec_InputDesktopResourceCursor_Static = {
        "winrt._winrt_microsoft_ui_input.InputDesktopResourceCursor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputDesktopResourceCursor_Static};

    // ----- InputFocusController class --------------------

    static PyObject* _new_InputFocusController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputFocusController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputFocusController>::type_name);
        return nullptr;
    }

    static void _dealloc_InputFocusController(py::wrapper::Microsoft::UI::Input::InputFocusController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputFocusController_DepartFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputFocusController", L"DepartFocus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::FocusNavigationRequest>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DepartFocus(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputFocusController_GetForIsland(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputFocusController", L"GetForIsland", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputFocusController::GetForIsland(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputFocusController_TrySetFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputFocusController", L"TrySetFocus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySetFocus();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputFocusController_get_HasFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputFocusController", L"HasFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasFocus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusController_add_GotFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusController", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GotFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusController_remove_GotFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusController", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.GotFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusController_add_LostFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusController", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LostFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusController_remove_LostFocus(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusController", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LostFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusController_add_NavigateFocusRequested(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusController", L"NavigateFocusRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigateFocusRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusController_remove_NavigateFocusRequested(py::wrapper::Microsoft::UI::Input::InputFocusController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusController", L"NavigateFocusRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NavigateFocusRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputFocusController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputFocusController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputFocusController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputFocusController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputFocusController[] = {
        { "depart_focus", reinterpret_cast<PyCFunction>(InputFocusController_DepartFocus), METH_VARARGS, nullptr },
        { "try_set_focus", reinterpret_cast<PyCFunction>(InputFocusController_TrySetFocus), METH_VARARGS, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(InputFocusController_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(InputFocusController_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(InputFocusController_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(InputFocusController_remove_LostFocus), METH_O, nullptr },
        { "add_navigate_focus_requested", reinterpret_cast<PyCFunction>(InputFocusController_add_NavigateFocusRequested), METH_O, nullptr },
        { "remove_navigate_focus_requested", reinterpret_cast<PyCFunction>(InputFocusController_remove_NavigateFocusRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputFocusController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputFocusController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputFocusController[] = {
        { "has_focus", reinterpret_cast<getter>(InputFocusController_get_HasFocus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputFocusController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputFocusController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputFocusController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputFocusController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputFocusController) },
        { }};

    static PyType_Spec type_spec_InputFocusController = {
        "winrt._winrt_microsoft_ui_input.InputFocusController",
        sizeof(py::wrapper::Microsoft::UI::Input::InputFocusController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputFocusController};

    static PyGetSetDef getset_InputFocusController_Static[] = {
        { }};

    static PyMethodDef methods_InputFocusController_Static[] = {
        { "get_for_island", reinterpret_cast<PyCFunction>(InputFocusController_GetForIsland), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputFocusController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputFocusController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputFocusController_Static) },
        { }
    };

    static PyType_Spec type_spec_InputFocusController_Static = {
        "winrt._winrt_microsoft_ui_input.InputFocusController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputFocusController_Static};

    // ----- InputFocusNavigationHost class --------------------

    static PyObject* _new_InputFocusNavigationHost(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputFocusNavigationHost>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputFocusNavigationHost>::type_name);
        return nullptr;
    }

    static void _dealloc_InputFocusNavigationHost(py::wrapper::Microsoft::UI::Input::InputFocusNavigationHost* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputFocusNavigationHost_GetForSiteBridge(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputFocusNavigationHost", L"GetForSiteBridge", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::IContentSiteBridge>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputFocusNavigationHost::GetForSiteBridge(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputFocusNavigationHost_NavigateFocus(py::wrapper::Microsoft::UI::Input::InputFocusNavigationHost* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputFocusNavigationHost", L"NavigateFocus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::FocusNavigationRequest>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.NavigateFocus(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputFocusNavigationHost_get_ContainsFocus(py::wrapper::Microsoft::UI::Input::InputFocusNavigationHost* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputFocusNavigationHost", L"ContainsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainsFocus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusNavigationHost_add_DepartFocusRequested(py::wrapper::Microsoft::UI::Input::InputFocusNavigationHost* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusNavigationHost", L"DepartFocusRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusNavigationHost, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DepartFocusRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputFocusNavigationHost_remove_DepartFocusRequested(py::wrapper::Microsoft::UI::Input::InputFocusNavigationHost* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputFocusNavigationHost", L"DepartFocusRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DepartFocusRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputFocusNavigationHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputFocusNavigationHost>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputFocusNavigationHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputFocusNavigationHost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputFocusNavigationHost[] = {
        { "navigate_focus", reinterpret_cast<PyCFunction>(InputFocusNavigationHost_NavigateFocus), METH_VARARGS, nullptr },
        { "add_depart_focus_requested", reinterpret_cast<PyCFunction>(InputFocusNavigationHost_add_DepartFocusRequested), METH_O, nullptr },
        { "remove_depart_focus_requested", reinterpret_cast<PyCFunction>(InputFocusNavigationHost_remove_DepartFocusRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputFocusNavigationHost, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputFocusNavigationHost), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputFocusNavigationHost[] = {
        { "contains_focus", reinterpret_cast<getter>(InputFocusNavigationHost_get_ContainsFocus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputFocusNavigationHost[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputFocusNavigationHost) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputFocusNavigationHost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputFocusNavigationHost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputFocusNavigationHost) },
        { }};

    static PyType_Spec type_spec_InputFocusNavigationHost = {
        "winrt._winrt_microsoft_ui_input.InputFocusNavigationHost",
        sizeof(py::wrapper::Microsoft::UI::Input::InputFocusNavigationHost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputFocusNavigationHost};

    static PyGetSetDef getset_InputFocusNavigationHost_Static[] = {
        { }};

    static PyMethodDef methods_InputFocusNavigationHost_Static[] = {
        { "get_for_site_bridge", reinterpret_cast<PyCFunction>(InputFocusNavigationHost_GetForSiteBridge), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputFocusNavigationHost_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputFocusNavigationHost_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputFocusNavigationHost_Static) },
        { }
    };

    static PyType_Spec type_spec_InputFocusNavigationHost_Static = {
        "winrt._winrt_microsoft_ui_input.InputFocusNavigationHost_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputFocusNavigationHost_Static};

    // ----- InputKeyboardSource class --------------------

    static PyObject* _new_InputKeyboardSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputKeyboardSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputKeyboardSource>::type_name);
        return nullptr;
    }

    static void _dealloc_InputKeyboardSource(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputKeyboardSource_GetCurrentKeyState(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"GetCurrentKeyState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentKeyState(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_GetForIsland(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"GetForIsland", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputKeyboardSource::GetForIsland(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_GetKeyState(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"GetKeyState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetKeyState(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_GetKeyStateForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"GetKeyStateForCurrentThread", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::VirtualKey>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputKeyboardSource::GetKeyStateForCurrentThread(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_add_CharacterReceived(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"CharacterReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::CharacterReceivedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CharacterReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_remove_CharacterReceived(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"CharacterReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CharacterReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_add_ContextMenuKey(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"ContextMenuKey");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContextMenuKey(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_remove_ContextMenuKey(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"ContextMenuKey");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContextMenuKey(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_add_KeyDown(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"KeyDown");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyDown(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_remove_KeyDown(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"KeyDown");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.KeyDown(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_add_KeyUp(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"KeyUp");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyUp(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_remove_KeyUp(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"KeyUp");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.KeyUp(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_add_SystemKeyDown(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"SystemKeyDown");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemKeyDown(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_remove_SystemKeyDown(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"SystemKeyDown");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemKeyDown(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_add_SystemKeyUp(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"SystemKeyUp");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemKeyUp(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputKeyboardSource_remove_SystemKeyUp(py::wrapper::Microsoft::UI::Input::InputKeyboardSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputKeyboardSource", L"SystemKeyUp");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemKeyUp(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputKeyboardSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputKeyboardSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputKeyboardSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputKeyboardSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputKeyboardSource[] = {
        { "get_current_key_state", reinterpret_cast<PyCFunction>(InputKeyboardSource_GetCurrentKeyState), METH_VARARGS, nullptr },
        { "get_key_state", reinterpret_cast<PyCFunction>(InputKeyboardSource_GetKeyState), METH_VARARGS, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(InputKeyboardSource_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(InputKeyboardSource_remove_CharacterReceived), METH_O, nullptr },
        { "add_context_menu_key", reinterpret_cast<PyCFunction>(InputKeyboardSource_add_ContextMenuKey), METH_O, nullptr },
        { "remove_context_menu_key", reinterpret_cast<PyCFunction>(InputKeyboardSource_remove_ContextMenuKey), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(InputKeyboardSource_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(InputKeyboardSource_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(InputKeyboardSource_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(InputKeyboardSource_remove_KeyUp), METH_O, nullptr },
        { "add_system_key_down", reinterpret_cast<PyCFunction>(InputKeyboardSource_add_SystemKeyDown), METH_O, nullptr },
        { "remove_system_key_down", reinterpret_cast<PyCFunction>(InputKeyboardSource_remove_SystemKeyDown), METH_O, nullptr },
        { "add_system_key_up", reinterpret_cast<PyCFunction>(InputKeyboardSource_add_SystemKeyUp), METH_O, nullptr },
        { "remove_system_key_up", reinterpret_cast<PyCFunction>(InputKeyboardSource_remove_SystemKeyUp), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputKeyboardSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputKeyboardSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputKeyboardSource[] = {
        { }};

    static PyType_Slot _type_slots_InputKeyboardSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputKeyboardSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputKeyboardSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputKeyboardSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputKeyboardSource) },
        { }};

    static PyType_Spec type_spec_InputKeyboardSource = {
        "winrt._winrt_microsoft_ui_input.InputKeyboardSource",
        sizeof(py::wrapper::Microsoft::UI::Input::InputKeyboardSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputKeyboardSource};

    static PyGetSetDef getset_InputKeyboardSource_Static[] = {
        { }};

    static PyMethodDef methods_InputKeyboardSource_Static[] = {
        { "get_for_island", reinterpret_cast<PyCFunction>(InputKeyboardSource_GetForIsland), METH_VARARGS, nullptr },
        { "get_key_state_for_current_thread", reinterpret_cast<PyCFunction>(InputKeyboardSource_GetKeyStateForCurrentThread), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputKeyboardSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputKeyboardSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputKeyboardSource_Static) },
        { }
    };

    static PyType_Spec type_spec_InputKeyboardSource_Static = {
        "winrt._winrt_microsoft_ui_input.InputKeyboardSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputKeyboardSource_Static};

    // ----- InputLightDismissAction class --------------------

    static PyObject* _new_InputLightDismissAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputLightDismissAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputLightDismissAction>::type_name);
        return nullptr;
    }

    static void _dealloc_InputLightDismissAction(py::wrapper::Microsoft::UI::Input::InputLightDismissAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputLightDismissAction_GetForWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputLightDismissAction", L"GetForWindowId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputLightDismissAction::GetForWindowId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputLightDismissAction_add_Dismissed(py::wrapper::Microsoft::UI::Input::InputLightDismissAction* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputLightDismissAction", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputLightDismissAction, winrt::Microsoft::UI::Input::InputLightDismissEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Dismissed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputLightDismissAction_remove_Dismissed(py::wrapper::Microsoft::UI::Input::InputLightDismissAction* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputLightDismissAction", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Dismissed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputLightDismissAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputLightDismissAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputLightDismissAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputLightDismissAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputLightDismissAction[] = {
        { "add_dismissed", reinterpret_cast<PyCFunction>(InputLightDismissAction_add_Dismissed), METH_O, nullptr },
        { "remove_dismissed", reinterpret_cast<PyCFunction>(InputLightDismissAction_remove_Dismissed), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputLightDismissAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputLightDismissAction), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputLightDismissAction[] = {
        { }};

    static PyType_Slot _type_slots_InputLightDismissAction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputLightDismissAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputLightDismissAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputLightDismissAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputLightDismissAction) },
        { }};

    static PyType_Spec type_spec_InputLightDismissAction = {
        "winrt._winrt_microsoft_ui_input.InputLightDismissAction",
        sizeof(py::wrapper::Microsoft::UI::Input::InputLightDismissAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputLightDismissAction};

    static PyGetSetDef getset_InputLightDismissAction_Static[] = {
        { }};

    static PyMethodDef methods_InputLightDismissAction_Static[] = {
        { "get_for_window_id", reinterpret_cast<PyCFunction>(InputLightDismissAction_GetForWindowId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputLightDismissAction_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputLightDismissAction_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputLightDismissAction_Static) },
        { }
    };

    static PyType_Spec type_spec_InputLightDismissAction_Static = {
        "winrt._winrt_microsoft_ui_input.InputLightDismissAction_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputLightDismissAction_Static};

    // ----- InputLightDismissEventArgs class --------------------

    static PyObject* _new_InputLightDismissEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputLightDismissEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputLightDismissEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InputLightDismissEventArgs(py::wrapper::Microsoft::UI::Input::InputLightDismissEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InputLightDismissEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputLightDismissEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputLightDismissEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputLightDismissEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputLightDismissEventArgs[] = {
        { "_assign_array_", _assign_array_InputLightDismissEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputLightDismissEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputLightDismissEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_InputLightDismissEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputLightDismissEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputLightDismissEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputLightDismissEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputLightDismissEventArgs) },
        { }};

    static PyType_Spec type_spec_InputLightDismissEventArgs = {
        "winrt._winrt_microsoft_ui_input.InputLightDismissEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::InputLightDismissEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputLightDismissEventArgs};

    // ----- InputNonClientPointerSource class --------------------

    static PyObject* _new_InputNonClientPointerSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputNonClientPointerSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputNonClientPointerSource>::type_name);
        return nullptr;
    }

    static void _dealloc_InputNonClientPointerSource(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputNonClientPointerSource_ClearAllRegionRects(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"ClearAllRegionRects", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ClearAllRegionRects();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_ClearRegionRects(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"ClearRegionRects", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::NonClientRegionKind>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ClearRegionRects(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_GetForWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"GetForWindowId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputNonClientPointerSource::GetForWindowId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_GetRegionRects(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"GetRegionRects", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::NonClientRegionKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRegionRects(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_SetRegionRects(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"SetRegionRects", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::NonClientRegionKind>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Graphics::RectInt32, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetRegionRects(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_get_DispatcherQueue(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_CaptionTapped(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"CaptionTapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CaptionTapped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_CaptionTapped(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"CaptionTapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CaptionTapped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_PointerEntered(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerEntered(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_PointerEntered(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerEntered(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_PointerExited(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerExited(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_PointerExited(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerExited(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_PointerMoved(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerMoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_PointerMoved(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerMoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_PointerPressed(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_PointerPressed(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_PointerReleased(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerReleased(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_PointerReleased(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerReleased(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_RegionsChanged(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"RegionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RegionsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_RegionsChanged(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"RegionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RegionsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_EnteredMoveSize(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"EnteredMoveSize");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnteredMoveSize(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_EnteredMoveSize(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"EnteredMoveSize");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.EnteredMoveSize(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_EnteringMoveSize(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"EnteringMoveSize");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnteringMoveSize(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_EnteringMoveSize(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"EnteringMoveSize");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.EnteringMoveSize(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_ExitedMoveSize(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"ExitedMoveSize");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExitedMoveSize(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_ExitedMoveSize(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"ExitedMoveSize");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExitedMoveSize(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_WindowRectChanged(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"WindowRectChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WindowRectChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_WindowRectChanged(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"WindowRectChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.WindowRectChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_add_WindowRectChanging(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"WindowRectChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WindowRectChanging(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputNonClientPointerSource_remove_WindowRectChanging(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputNonClientPointerSource", L"WindowRectChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.WindowRectChanging(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputNonClientPointerSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputNonClientPointerSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputNonClientPointerSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputNonClientPointerSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputNonClientPointerSource[] = {
        { "clear_all_region_rects", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_ClearAllRegionRects), METH_VARARGS, nullptr },
        { "clear_region_rects", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_ClearRegionRects), METH_VARARGS, nullptr },
        { "get_region_rects", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_GetRegionRects), METH_VARARGS, nullptr },
        { "set_region_rects", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_SetRegionRects), METH_VARARGS, nullptr },
        { "add_caption_tapped", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_CaptionTapped), METH_O, nullptr },
        { "remove_caption_tapped", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_CaptionTapped), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_PointerReleased), METH_O, nullptr },
        { "add_regions_changed", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_RegionsChanged), METH_O, nullptr },
        { "remove_regions_changed", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_RegionsChanged), METH_O, nullptr },
        { "add_entered_move_size", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_EnteredMoveSize), METH_O, nullptr },
        { "remove_entered_move_size", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_EnteredMoveSize), METH_O, nullptr },
        { "add_entering_move_size", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_EnteringMoveSize), METH_O, nullptr },
        { "remove_entering_move_size", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_EnteringMoveSize), METH_O, nullptr },
        { "add_exited_move_size", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_ExitedMoveSize), METH_O, nullptr },
        { "remove_exited_move_size", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_ExitedMoveSize), METH_O, nullptr },
        { "add_window_rect_changed", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_WindowRectChanged), METH_O, nullptr },
        { "remove_window_rect_changed", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_WindowRectChanged), METH_O, nullptr },
        { "add_window_rect_changing", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_add_WindowRectChanging), METH_O, nullptr },
        { "remove_window_rect_changing", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_remove_WindowRectChanging), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputNonClientPointerSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputNonClientPointerSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputNonClientPointerSource[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(InputNonClientPointerSource_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputNonClientPointerSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputNonClientPointerSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputNonClientPointerSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputNonClientPointerSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputNonClientPointerSource) },
        { }};

    static PyType_Spec type_spec_InputNonClientPointerSource = {
        "winrt._winrt_microsoft_ui_input.InputNonClientPointerSource",
        sizeof(py::wrapper::Microsoft::UI::Input::InputNonClientPointerSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputNonClientPointerSource};

    static PyGetSetDef getset_InputNonClientPointerSource_Static[] = {
        { }};

    static PyMethodDef methods_InputNonClientPointerSource_Static[] = {
        { "get_for_window_id", reinterpret_cast<PyCFunction>(InputNonClientPointerSource_GetForWindowId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputNonClientPointerSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputNonClientPointerSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputNonClientPointerSource_Static) },
        { }
    };

    static PyType_Spec type_spec_InputNonClientPointerSource_Static = {
        "winrt._winrt_microsoft_ui_input.InputNonClientPointerSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputNonClientPointerSource_Static};

    // ----- InputObject class --------------------

    static PyObject* _new_InputObject(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputObject>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputObject>::type_name);
        return nullptr;
    }

    static void _dealloc_InputObject(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputObject_get_DispatcherQueue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputObject", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Input::InputObject>().DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputObject[] = {
        { "_assign_array_", _assign_array_InputObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputObject), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputObject[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(InputObject_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputObject[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputObject) },
        { }};

    static PyType_Spec type_spec_InputObject = {
        "winrt._winrt_microsoft_ui_input.InputObject",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InputObject};

    static PyGetSetDef getset_InputObject_Static[] = {
        { }};

    static PyMethodDef methods_InputObject_Static[] = {
        { }};

    static PyType_Slot type_slots_InputObject_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputObject_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputObject_Static) },
        { }
    };

    static PyType_Spec type_spec_InputObject_Static = {
        "winrt._winrt_microsoft_ui_input.InputObject_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InputObject_Static};

    // ----- InputPointerSource class --------------------

    static PyObject* _new_InputPointerSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputPointerSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputPointerSource>::type_name);
        return nullptr;
    }

    static void _dealloc_InputPointerSource(py::wrapper::Microsoft::UI::Input::InputPointerSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputPointerSource_GetForIsland(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputPointerSource", L"GetForIsland", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputPointerSource::GetForIsland(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_get_Cursor(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputPointerSource", L"Cursor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cursor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputPointerSource_put_Cursor(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputPointerSource", L"Cursor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Input::InputCursor>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cursor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputPointerSource_get_DeviceKinds(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputPointerSource", L"DeviceKinds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceKinds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerCaptureLost(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerCaptureLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerCaptureLost(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerCaptureLost(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerCaptureLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerCaptureLost(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerEntered(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerEntered(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerEntered(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerEntered(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerExited(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerExited(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerExited(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerExited(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerMoved(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerMoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerMoved(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerMoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerPressed(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerPressed(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerReleased(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerReleased(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerReleased(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerReleased(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerRoutedAway(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerRoutedAway");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerRoutedAway(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerRoutedAway(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerRoutedAway");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerRoutedAway(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerRoutedReleased(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerRoutedReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerRoutedReleased(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerRoutedReleased(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerRoutedReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerRoutedReleased(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerRoutedTo(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerRoutedTo");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerRoutedTo(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerRoutedTo(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerRoutedTo");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerRoutedTo(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_add_PointerWheelChanged(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerWheelChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerWheelChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPointerSource_remove_PointerWheelChanged(py::wrapper::Microsoft::UI::Input::InputPointerSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Input.InputPointerSource", L"PointerWheelChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerWheelChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputPointerSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputPointerSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputPointerSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputPointerSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputPointerSource[] = {
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_routed_away", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerRoutedAway), METH_O, nullptr },
        { "remove_pointer_routed_away", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerRoutedAway), METH_O, nullptr },
        { "add_pointer_routed_released", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerRoutedReleased), METH_O, nullptr },
        { "remove_pointer_routed_released", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerRoutedReleased), METH_O, nullptr },
        { "add_pointer_routed_to", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerRoutedTo), METH_O, nullptr },
        { "remove_pointer_routed_to", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerRoutedTo), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(InputPointerSource_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(InputPointerSource_remove_PointerWheelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputPointerSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputPointerSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputPointerSource[] = {
        { "cursor", reinterpret_cast<getter>(InputPointerSource_get_Cursor), reinterpret_cast<setter>(InputPointerSource_put_Cursor), nullptr, nullptr },
        { "device_kinds", reinterpret_cast<getter>(InputPointerSource_get_DeviceKinds), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputPointerSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputPointerSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputPointerSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputPointerSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputPointerSource) },
        { }};

    static PyType_Spec type_spec_InputPointerSource = {
        "winrt._winrt_microsoft_ui_input.InputPointerSource",
        sizeof(py::wrapper::Microsoft::UI::Input::InputPointerSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputPointerSource};

    static PyGetSetDef getset_InputPointerSource_Static[] = {
        { }};

    static PyMethodDef methods_InputPointerSource_Static[] = {
        { "get_for_island", reinterpret_cast<PyCFunction>(InputPointerSource_GetForIsland), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputPointerSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputPointerSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputPointerSource_Static) },
        { }
    };

    static PyType_Spec type_spec_InputPointerSource_Static = {
        "winrt._winrt_microsoft_ui_input.InputPointerSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputPointerSource_Static};

    // ----- InputPreTranslateKeyboardSource class --------------------

    static PyObject* _new_InputPreTranslateKeyboardSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>::type_name);
        return nullptr;
    }

    static void _dealloc_InputPreTranslateKeyboardSource(py::wrapper::Microsoft::UI::Input::InputPreTranslateKeyboardSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputPreTranslateKeyboardSource_GetForIsland(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputPreTranslateKeyboardSource", L"GetForIsland", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource::GetForIsland(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputPreTranslateKeyboardSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputPreTranslateKeyboardSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputPreTranslateKeyboardSource[] = {
        { "_assign_array_", _assign_array_InputPreTranslateKeyboardSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputPreTranslateKeyboardSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputPreTranslateKeyboardSource[] = {
        { }};

    static PyType_Slot _type_slots_InputPreTranslateKeyboardSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputPreTranslateKeyboardSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputPreTranslateKeyboardSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputPreTranslateKeyboardSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputPreTranslateKeyboardSource) },
        { }};

    static PyType_Spec type_spec_InputPreTranslateKeyboardSource = {
        "winrt._winrt_microsoft_ui_input.InputPreTranslateKeyboardSource",
        sizeof(py::wrapper::Microsoft::UI::Input::InputPreTranslateKeyboardSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputPreTranslateKeyboardSource};

    static PyGetSetDef getset_InputPreTranslateKeyboardSource_Static[] = {
        { }};

    static PyMethodDef methods_InputPreTranslateKeyboardSource_Static[] = {
        { "get_for_island", reinterpret_cast<PyCFunction>(InputPreTranslateKeyboardSource_GetForIsland), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputPreTranslateKeyboardSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputPreTranslateKeyboardSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputPreTranslateKeyboardSource_Static) },
        { }
    };

    static PyType_Spec type_spec_InputPreTranslateKeyboardSource_Static = {
        "winrt._winrt_microsoft_ui_input.InputPreTranslateKeyboardSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputPreTranslateKeyboardSource_Static};

    // ----- InputSystemCursor class --------------------

    static PyObject* _new_InputSystemCursor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::InputSystemCursor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::InputSystemCursor>::type_name);
        return nullptr;
    }

    static void _dealloc_InputSystemCursor(py::wrapper::Microsoft::UI::Input::InputSystemCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputSystemCursor_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.InputSystemCursor", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::InputSystemCursorShape>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::InputSystemCursor::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputSystemCursor_get_CursorShape(py::wrapper::Microsoft::UI::Input::InputSystemCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.InputSystemCursor", L"CursorShape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CursorShape();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputSystemCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::InputSystemCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputSystemCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::InputSystemCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputSystemCursor[] = {
        { "_assign_array_", _assign_array_InputSystemCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputSystemCursor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputSystemCursor[] = {
        { "cursor_shape", reinterpret_cast<getter>(InputSystemCursor_get_CursorShape), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputSystemCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputSystemCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputSystemCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputSystemCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputSystemCursor) },
        { }};

    static PyType_Spec type_spec_InputSystemCursor = {
        "winrt._winrt_microsoft_ui_input.InputSystemCursor",
        sizeof(py::wrapper::Microsoft::UI::Input::InputSystemCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputSystemCursor};

    static PyGetSetDef getset_InputSystemCursor_Static[] = {
        { }};

    static PyMethodDef methods_InputSystemCursor_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InputSystemCursor_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InputSystemCursor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputSystemCursor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputSystemCursor_Static) },
        { }
    };

    static PyType_Spec type_spec_InputSystemCursor_Static = {
        "winrt._winrt_microsoft_ui_input.InputSystemCursor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputSystemCursor_Static};

    // ----- KeyEventArgs class --------------------

    static PyObject* _new_KeyEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::KeyEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::KeyEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyEventArgs(py::wrapper::Microsoft::UI::Input::KeyEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyEventArgs_get_Handled(py::wrapper::Microsoft::UI::Input::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.KeyEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyEventArgs_put_Handled(py::wrapper::Microsoft::UI::Input::KeyEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.KeyEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyEventArgs_get_KeyStatus(py::wrapper::Microsoft::UI::Input::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.KeyEventArgs", L"KeyStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyEventArgs_get_Timestamp(py::wrapper::Microsoft::UI::Input::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.KeyEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyEventArgs_get_VirtualKey(py::wrapper::Microsoft::UI::Input::KeyEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.KeyEventArgs", L"VirtualKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VirtualKey();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::KeyEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::KeyEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyEventArgs[] = {
        { "_assign_array_", _assign_array_KeyEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_KeyEventArgs[] = {
        { "handled", reinterpret_cast<getter>(KeyEventArgs_get_Handled), reinterpret_cast<setter>(KeyEventArgs_put_Handled), nullptr, nullptr },
        { "key_status", reinterpret_cast<getter>(KeyEventArgs_get_KeyStatus), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(KeyEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(KeyEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_KeyEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyEventArgs) },
        { }};

    static PyType_Spec type_spec_KeyEventArgs = {
        "winrt._winrt_microsoft_ui_input.KeyEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::KeyEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyEventArgs};

    // ----- ManipulationCompletedEventArgs class --------------------

    static PyObject* _new_ManipulationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationCompletedEventArgs(py::wrapper::Microsoft::UI::Input::ManipulationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationCompletedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationCompletedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationCompletedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationCompletedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_Velocities(py::wrapper::Microsoft::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationCompletedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationCompletedEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationCompletedEventArgs = {
        "winrt._winrt_microsoft_ui_input.ManipulationCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::ManipulationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationCompletedEventArgs};

    // ----- ManipulationInertiaStartingEventArgs class --------------------

    static PyObject* _new_ManipulationInertiaStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationInertiaStartingEventArgs(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationInertiaStartingEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Delta(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationInertiaStartingEventArgs", L"Delta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationInertiaStartingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationInertiaStartingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Velocities(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationInertiaStartingEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationInertiaStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationInertiaStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationInertiaStartingEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationInertiaStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationInertiaStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationInertiaStartingEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationInertiaStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationInertiaStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationInertiaStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationInertiaStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationInertiaStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationInertiaStartingEventArgs = {
        "winrt._winrt_microsoft_ui_input.ManipulationInertiaStartingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationInertiaStartingEventArgs};

    // ----- ManipulationStartedEventArgs class --------------------

    static PyObject* _new_ManipulationStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::ManipulationStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::ManipulationStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationStartedEventArgs(py::wrapper::Microsoft::UI::Input::ManipulationStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationStartedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationStartedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationStartedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationStartedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ManipulationStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::ManipulationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationStartedEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationStartedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationStartedEventArgs = {
        "winrt._winrt_microsoft_ui_input.ManipulationStartedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::ManipulationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationStartedEventArgs};

    // ----- ManipulationUpdatedEventArgs class --------------------

    static PyObject* _new_ManipulationUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationUpdatedEventArgs(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Cumulative(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationUpdatedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Delta(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationUpdatedEventArgs", L"Delta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationUpdatedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationUpdatedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Velocities(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.ManipulationUpdatedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationUpdatedEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationUpdatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationUpdatedEventArgs = {
        "winrt._winrt_microsoft_ui_input.ManipulationUpdatedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::ManipulationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationUpdatedEventArgs};

    // ----- MouseWheelParameters class --------------------

    static PyObject* _new_MouseWheelParameters(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::MouseWheelParameters>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::MouseWheelParameters>::type_name);
        return nullptr;
    }

    static void _dealloc_MouseWheelParameters(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseWheelParameters_get_PageTranslation(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"PageTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PageTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_PageTranslation(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"PageTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.PageTranslation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_DeltaScale(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"DeltaScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeltaScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_DeltaScale(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"DeltaScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.DeltaScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_DeltaRotationAngle(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"DeltaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeltaRotationAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_DeltaRotationAngle(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"DeltaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.DeltaRotationAngle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_CharTranslation(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"CharTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CharTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_CharTranslation(py::wrapper::Microsoft::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.MouseWheelParameters", L"CharTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.CharTranslation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MouseWheelParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::MouseWheelParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseWheelParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::MouseWheelParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseWheelParameters[] = {
        { "_assign_array_", _assign_array_MouseWheelParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseWheelParameters), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MouseWheelParameters[] = {
        { "page_translation", reinterpret_cast<getter>(MouseWheelParameters_get_PageTranslation), reinterpret_cast<setter>(MouseWheelParameters_put_PageTranslation), nullptr, nullptr },
        { "delta_scale", reinterpret_cast<getter>(MouseWheelParameters_get_DeltaScale), reinterpret_cast<setter>(MouseWheelParameters_put_DeltaScale), nullptr, nullptr },
        { "delta_rotation_angle", reinterpret_cast<getter>(MouseWheelParameters_get_DeltaRotationAngle), reinterpret_cast<setter>(MouseWheelParameters_put_DeltaRotationAngle), nullptr, nullptr },
        { "char_translation", reinterpret_cast<getter>(MouseWheelParameters_get_CharTranslation), reinterpret_cast<setter>(MouseWheelParameters_put_CharTranslation), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MouseWheelParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseWheelParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseWheelParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseWheelParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseWheelParameters) },
        { }};

    static PyType_Spec type_spec_MouseWheelParameters = {
        "winrt._winrt_microsoft_ui_input.MouseWheelParameters",
        sizeof(py::wrapper::Microsoft::UI::Input::MouseWheelParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseWheelParameters};

    // ----- NonClientCaptionTappedEventArgs class --------------------

    static PyObject* _new_NonClientCaptionTappedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NonClientCaptionTappedEventArgs(py::wrapper::Microsoft::UI::Input::NonClientCaptionTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NonClientCaptionTappedEventArgs_get_Point(py::wrapper::Microsoft::UI::Input::NonClientCaptionTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientCaptionTappedEventArgs", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Point();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NonClientCaptionTappedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::NonClientCaptionTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientCaptionTappedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NonClientCaptionTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NonClientCaptionTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NonClientCaptionTappedEventArgs[] = {
        { "_assign_array_", _assign_array_NonClientCaptionTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NonClientCaptionTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NonClientCaptionTappedEventArgs[] = {
        { "point", reinterpret_cast<getter>(NonClientCaptionTappedEventArgs_get_Point), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(NonClientCaptionTappedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NonClientCaptionTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonClientCaptionTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonClientCaptionTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonClientCaptionTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonClientCaptionTappedEventArgs) },
        { }};

    static PyType_Spec type_spec_NonClientCaptionTappedEventArgs = {
        "winrt._winrt_microsoft_ui_input.NonClientCaptionTappedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::NonClientCaptionTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NonClientCaptionTappedEventArgs};

    // ----- NonClientPointerEventArgs class --------------------

    static PyObject* _new_NonClientPointerEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::NonClientPointerEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::NonClientPointerEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NonClientPointerEventArgs(py::wrapper::Microsoft::UI::Input::NonClientPointerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NonClientPointerEventArgs_get_IsPointInRegion(py::wrapper::Microsoft::UI::Input::NonClientPointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientPointerEventArgs", L"IsPointInRegion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPointInRegion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NonClientPointerEventArgs_get_Point(py::wrapper::Microsoft::UI::Input::NonClientPointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientPointerEventArgs", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Point();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NonClientPointerEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::NonClientPointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientPointerEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NonClientPointerEventArgs_get_RegionKind(py::wrapper::Microsoft::UI::Input::NonClientPointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientPointerEventArgs", L"RegionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RegionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NonClientPointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::NonClientPointerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NonClientPointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::NonClientPointerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NonClientPointerEventArgs[] = {
        { "_assign_array_", _assign_array_NonClientPointerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NonClientPointerEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NonClientPointerEventArgs[] = {
        { "is_point_in_region", reinterpret_cast<getter>(NonClientPointerEventArgs_get_IsPointInRegion), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(NonClientPointerEventArgs_get_Point), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(NonClientPointerEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "region_kind", reinterpret_cast<getter>(NonClientPointerEventArgs_get_RegionKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NonClientPointerEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonClientPointerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonClientPointerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonClientPointerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonClientPointerEventArgs) },
        { }};

    static PyType_Spec type_spec_NonClientPointerEventArgs = {
        "winrt._winrt_microsoft_ui_input.NonClientPointerEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::NonClientPointerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NonClientPointerEventArgs};

    // ----- NonClientRegionsChangedEventArgs class --------------------

    static PyObject* _new_NonClientRegionsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NonClientRegionsChangedEventArgs(py::wrapper::Microsoft::UI::Input::NonClientRegionsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NonClientRegionsChangedEventArgs_get_ChangedRegions(py::wrapper::Microsoft::UI::Input::NonClientRegionsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.NonClientRegionsChangedEventArgs", L"ChangedRegions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangedRegions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NonClientRegionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NonClientRegionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NonClientRegionsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_NonClientRegionsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NonClientRegionsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NonClientRegionsChangedEventArgs[] = {
        { "changed_regions", reinterpret_cast<getter>(NonClientRegionsChangedEventArgs_get_ChangedRegions), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NonClientRegionsChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NonClientRegionsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NonClientRegionsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NonClientRegionsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NonClientRegionsChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_NonClientRegionsChangedEventArgs = {
        "winrt._winrt_microsoft_ui_input.NonClientRegionsChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::NonClientRegionsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NonClientRegionsChangedEventArgs};

    // ----- PointerEventArgs class --------------------

    static PyObject* _new_PointerEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::PointerEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::PointerEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerEventArgs(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerEventArgs_GetIntermediatePoints(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.PointerEventArgs", L"GetIntermediatePoints", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIntermediatePoints();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_GetIntermediateTransformedPoints(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.PointerEventArgs", L"GetIntermediateTransformedPoints", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::IPointerPointTransform>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIntermediateTransformedPoints(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_get_Handled(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerEventArgs_put_Handled(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerEventArgs_get_CurrentPoint(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerEventArgs", L"CurrentPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerEventArgs_get_KeyModifiers(py::wrapper::Microsoft::UI::Input::PointerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerEventArgs", L"KeyModifiers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyModifiers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::PointerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::PointerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerEventArgs[] = {
        { "get_intermediate_points", reinterpret_cast<PyCFunction>(PointerEventArgs_GetIntermediatePoints), METH_VARARGS, nullptr },
        { "get_intermediate_transformed_points", reinterpret_cast<PyCFunction>(PointerEventArgs_GetIntermediateTransformedPoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerEventArgs[] = {
        { "handled", reinterpret_cast<getter>(PointerEventArgs_get_Handled), reinterpret_cast<setter>(PointerEventArgs_put_Handled), nullptr, nullptr },
        { "current_point", reinterpret_cast<getter>(PointerEventArgs_get_CurrentPoint), nullptr, nullptr, nullptr },
        { "key_modifiers", reinterpret_cast<getter>(PointerEventArgs_get_KeyModifiers), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerEventArgs) },
        { }};

    static PyType_Spec type_spec_PointerEventArgs = {
        "winrt._winrt_microsoft_ui_input.PointerEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::PointerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerEventArgs};

    // ----- PointerPoint class --------------------

    static PyObject* _new_PointerPoint(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::PointerPoint>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::PointerPoint>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerPoint(py::wrapper::Microsoft::UI::Input::PointerPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerPoint_GetTransformedPoint(py::wrapper::Microsoft::UI::Input::PointerPoint* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.PointerPoint", L"GetTransformedPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::IPointerPointTransform>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTransformedPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_FrameId(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"FrameId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_IsInContact(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"IsInContact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInContact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PointerId(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"PointerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Position(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Properties(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Timestamp(py::wrapper::Microsoft::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPoint", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::PointerPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::PointerPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPoint[] = {
        { "get_transformed_point", reinterpret_cast<PyCFunction>(PointerPoint_GetTransformedPoint), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerPoint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerPoint[] = {
        { "frame_id", reinterpret_cast<getter>(PointerPoint_get_FrameId), nullptr, nullptr, nullptr },
        { "is_in_contact", reinterpret_cast<getter>(PointerPoint_get_IsInContact), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(PointerPoint_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(PointerPoint_get_PointerId), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(PointerPoint_get_Position), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PointerPoint_get_Properties), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(PointerPoint_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerPoint) },
        { }};

    static PyType_Spec type_spec_PointerPoint = {
        "winrt._winrt_microsoft_ui_input.PointerPoint",
        sizeof(py::wrapper::Microsoft::UI::Input::PointerPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPoint};

    // ----- PointerPointProperties class --------------------

    static PyObject* _new_PointerPointProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::PointerPointProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::PointerPointProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerPointProperties(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerPointProperties_get_ContactRect(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"ContactRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsBarrelButtonPressed(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsBarrelButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsBarrelButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsCanceled(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsEraser(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsEraser");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEraser();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsHorizontalMouseWheel(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsHorizontalMouseWheel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsHorizontalMouseWheel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsInRange(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsInRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsInverted(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsInverted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInverted();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsLeftButtonPressed(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsLeftButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLeftButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsMiddleButtonPressed(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsMiddleButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMiddleButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsPrimary(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsPrimary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPrimary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsRightButtonPressed(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsRightButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRightButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsXButton1Pressed(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsXButton1Pressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsXButton1Pressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsXButton2Pressed(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"IsXButton2Pressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsXButton2Pressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_MouseWheelDelta(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"MouseWheelDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MouseWheelDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Orientation(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_PointerUpdateKind(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"PointerUpdateKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerUpdateKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Pressure(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"Pressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pressure();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_TouchConfidence(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"TouchConfidence");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TouchConfidence();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Twist(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"Twist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Twist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_XTilt(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"XTilt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XTilt();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_YTilt(py::wrapper::Microsoft::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPointProperties", L"YTilt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.YTilt();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerPointProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::PointerPointProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerPointProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::PointerPointProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPointProperties[] = {
        { "_assign_array_", _assign_array_PointerPointProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerPointProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerPointProperties[] = {
        { "contact_rect", reinterpret_cast<getter>(PointerPointProperties_get_ContactRect), nullptr, nullptr, nullptr },
        { "is_barrel_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsBarrelButtonPressed), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(PointerPointProperties_get_IsCanceled), nullptr, nullptr, nullptr },
        { "is_eraser", reinterpret_cast<getter>(PointerPointProperties_get_IsEraser), nullptr, nullptr, nullptr },
        { "is_horizontal_mouse_wheel", reinterpret_cast<getter>(PointerPointProperties_get_IsHorizontalMouseWheel), nullptr, nullptr, nullptr },
        { "is_in_range", reinterpret_cast<getter>(PointerPointProperties_get_IsInRange), nullptr, nullptr, nullptr },
        { "is_inverted", reinterpret_cast<getter>(PointerPointProperties_get_IsInverted), nullptr, nullptr, nullptr },
        { "is_left_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsLeftButtonPressed), nullptr, nullptr, nullptr },
        { "is_middle_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsMiddleButtonPressed), nullptr, nullptr, nullptr },
        { "is_primary", reinterpret_cast<getter>(PointerPointProperties_get_IsPrimary), nullptr, nullptr, nullptr },
        { "is_right_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsRightButtonPressed), nullptr, nullptr, nullptr },
        { "is_x_button1_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsXButton1Pressed), nullptr, nullptr, nullptr },
        { "is_x_button2_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsXButton2Pressed), nullptr, nullptr, nullptr },
        { "mouse_wheel_delta", reinterpret_cast<getter>(PointerPointProperties_get_MouseWheelDelta), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(PointerPointProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "pointer_update_kind", reinterpret_cast<getter>(PointerPointProperties_get_PointerUpdateKind), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(PointerPointProperties_get_Pressure), nullptr, nullptr, nullptr },
        { "touch_confidence", reinterpret_cast<getter>(PointerPointProperties_get_TouchConfidence), nullptr, nullptr, nullptr },
        { "twist", reinterpret_cast<getter>(PointerPointProperties_get_Twist), nullptr, nullptr, nullptr },
        { "x_tilt", reinterpret_cast<getter>(PointerPointProperties_get_XTilt), nullptr, nullptr, nullptr },
        { "y_tilt", reinterpret_cast<getter>(PointerPointProperties_get_YTilt), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerPointProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerPointProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerPointProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerPointProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerPointProperties) },
        { }};

    static PyType_Spec type_spec_PointerPointProperties = {
        "winrt._winrt_microsoft_ui_input.PointerPointProperties",
        sizeof(py::wrapper::Microsoft::UI::Input::PointerPointProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPointProperties};

    // ----- PointerPredictor class --------------------

    static PyObject* _new_PointerPredictor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::PointerPredictor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::PointerPredictor>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerPredictor(py::wrapper::Microsoft::UI::Input::PointerPredictor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerPredictor_Close(py::wrapper::Microsoft::UI::Input::PointerPredictor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.PointerPredictor", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPredictor_CreateForInputPointerSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.PointerPredictor", L"CreateForInputPointerSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::InputPointerSource>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Input::PointerPredictor::CreateForInputPointerSource(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPredictor_GetPredictedPoints(py::wrapper::Microsoft::UI::Input::PointerPredictor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.PointerPredictor", L"GetPredictedPoints", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPredictedPoints(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPredictor_get_PredictionTime(py::wrapper::Microsoft::UI::Input::PointerPredictor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPredictor", L"PredictionTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PredictionTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerPredictor_put_PredictionTime(py::wrapper::Microsoft::UI::Input::PointerPredictor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.PointerPredictor", L"PredictionTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.PredictionTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PointerPredictor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::PointerPredictor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerPredictor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::PointerPredictor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PointerPredictor(py::wrapper::Microsoft::UI::Input::PointerPredictor* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PointerPredictor(py::wrapper::Microsoft::UI::Input::PointerPredictor* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPredictor[] = {
        { "close", reinterpret_cast<PyCFunction>(PointerPredictor_Close), METH_VARARGS, nullptr },
        { "get_predicted_points", reinterpret_cast<PyCFunction>(PointerPredictor_GetPredictedPoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerPredictor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerPredictor), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PointerPredictor), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PointerPredictor), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_PointerPredictor[] = {
        { "prediction_time", reinterpret_cast<getter>(PointerPredictor_get_PredictionTime), reinterpret_cast<setter>(PointerPredictor_put_PredictionTime), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerPredictor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerPredictor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerPredictor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerPredictor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerPredictor) },
        { }};

    static PyType_Spec type_spec_PointerPredictor = {
        "winrt._winrt_microsoft_ui_input.PointerPredictor",
        sizeof(py::wrapper::Microsoft::UI::Input::PointerPredictor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPredictor};

    static PyGetSetDef getset_PointerPredictor_Static[] = {
        { }};

    static PyMethodDef methods_PointerPredictor_Static[] = {
        { "create_for_input_pointer_source", reinterpret_cast<PyCFunction>(PointerPredictor_CreateForInputPointerSource), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PointerPredictor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerPredictor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PointerPredictor_Static) },
        { }
    };

    static PyType_Spec type_spec_PointerPredictor_Static = {
        "winrt._winrt_microsoft_ui_input.PointerPredictor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerPredictor_Static};

    // ----- RightTappedEventArgs class --------------------

    static PyObject* _new_RightTappedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::RightTappedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::RightTappedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RightTappedEventArgs(py::wrapper::Microsoft::UI::Input::RightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RightTappedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.RightTappedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RightTappedEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.RightTappedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::RightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::RightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_RightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RightTappedEventArgs[] = {
        { "pointer_device_type", reinterpret_cast<getter>(RightTappedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(RightTappedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RightTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RightTappedEventArgs) },
        { }};

    static PyType_Spec type_spec_RightTappedEventArgs = {
        "winrt._winrt_microsoft_ui_input.RightTappedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::RightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RightTappedEventArgs};

    // ----- TappedEventArgs class --------------------

    static PyObject* _new_TappedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::TappedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::TappedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TappedEventArgs(py::wrapper::Microsoft::UI::Input::TappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TappedEventArgs_get_PointerDeviceType(py::wrapper::Microsoft::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.TappedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_Position(py::wrapper::Microsoft::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.TappedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_TapCount(py::wrapper::Microsoft::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.TappedEventArgs", L"TapCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TapCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::TappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::TappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TappedEventArgs[] = {
        { "_assign_array_", _assign_array_TappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TappedEventArgs[] = {
        { "pointer_device_type", reinterpret_cast<getter>(TappedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TappedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "tap_count", reinterpret_cast<getter>(TappedEventArgs_get_TapCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TappedEventArgs) },
        { }};

    static PyType_Spec type_spec_TappedEventArgs = {
        "winrt._winrt_microsoft_ui_input.TappedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::TappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TappedEventArgs};

    // ----- WindowRectChangedEventArgs class --------------------

    static PyObject* _new_WindowRectChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::WindowRectChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::WindowRectChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowRectChangedEventArgs(py::wrapper::Microsoft::UI::Input::WindowRectChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowRectChangedEventArgs_get_MoveSizeOperation(py::wrapper::Microsoft::UI::Input::WindowRectChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangedEventArgs", L"MoveSizeOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveSizeOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowRectChangedEventArgs_get_NewWindowRect(py::wrapper::Microsoft::UI::Input::WindowRectChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangedEventArgs", L"NewWindowRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewWindowRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowRectChangedEventArgs_get_OldWindowRect(py::wrapper::Microsoft::UI::Input::WindowRectChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangedEventArgs", L"OldWindowRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldWindowRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowRectChangedEventArgs_get_PointerScreenPoint(py::wrapper::Microsoft::UI::Input::WindowRectChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangedEventArgs", L"PointerScreenPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerScreenPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowRectChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::WindowRectChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowRectChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::WindowRectChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowRectChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowRectChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowRectChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowRectChangedEventArgs[] = {
        { "move_size_operation", reinterpret_cast<getter>(WindowRectChangedEventArgs_get_MoveSizeOperation), nullptr, nullptr, nullptr },
        { "new_window_rect", reinterpret_cast<getter>(WindowRectChangedEventArgs_get_NewWindowRect), nullptr, nullptr, nullptr },
        { "old_window_rect", reinterpret_cast<getter>(WindowRectChangedEventArgs_get_OldWindowRect), nullptr, nullptr, nullptr },
        { "pointer_screen_point", reinterpret_cast<getter>(WindowRectChangedEventArgs_get_PointerScreenPoint), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowRectChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowRectChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowRectChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowRectChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowRectChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowRectChangedEventArgs = {
        "winrt._winrt_microsoft_ui_input.WindowRectChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::WindowRectChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowRectChangedEventArgs};

    // ----- WindowRectChangingEventArgs class --------------------

    static PyObject* _new_WindowRectChangingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::WindowRectChangingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::WindowRectChangingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowRectChangingEventArgs(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowRectChangingEventArgs_get_ShowWindow(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"ShowWindow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowWindow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowRectChangingEventArgs_put_ShowWindow(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"ShowWindow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowWindow(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowRectChangingEventArgs_get_NewWindowRect(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"NewWindowRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewWindowRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowRectChangingEventArgs_put_NewWindowRect(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"NewWindowRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(arg);

            {
                auto _gil = release_gil();
                self->obj.NewWindowRect(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowRectChangingEventArgs_get_AllowRectChange(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"AllowRectChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowRectChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowRectChangingEventArgs_put_AllowRectChange(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"AllowRectChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowRectChange(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowRectChangingEventArgs_get_MoveSizeOperation(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"MoveSizeOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoveSizeOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowRectChangingEventArgs_get_OldWindowRect(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"OldWindowRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldWindowRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowRectChangingEventArgs_get_PointerScreenPoint(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.WindowRectChangingEventArgs", L"PointerScreenPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerScreenPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowRectChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::WindowRectChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowRectChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::WindowRectChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowRectChangingEventArgs[] = {
        { "_assign_array_", _assign_array_WindowRectChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowRectChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowRectChangingEventArgs[] = {
        { "show_window", reinterpret_cast<getter>(WindowRectChangingEventArgs_get_ShowWindow), reinterpret_cast<setter>(WindowRectChangingEventArgs_put_ShowWindow), nullptr, nullptr },
        { "new_window_rect", reinterpret_cast<getter>(WindowRectChangingEventArgs_get_NewWindowRect), reinterpret_cast<setter>(WindowRectChangingEventArgs_put_NewWindowRect), nullptr, nullptr },
        { "allow_rect_change", reinterpret_cast<getter>(WindowRectChangingEventArgs_get_AllowRectChange), reinterpret_cast<setter>(WindowRectChangingEventArgs_put_AllowRectChange), nullptr, nullptr },
        { "move_size_operation", reinterpret_cast<getter>(WindowRectChangingEventArgs_get_MoveSizeOperation), nullptr, nullptr, nullptr },
        { "old_window_rect", reinterpret_cast<getter>(WindowRectChangingEventArgs_get_OldWindowRect), nullptr, nullptr, nullptr },
        { "pointer_screen_point", reinterpret_cast<getter>(WindowRectChangingEventArgs_get_PointerScreenPoint), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowRectChangingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowRectChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowRectChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowRectChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowRectChangingEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowRectChangingEventArgs = {
        "winrt._winrt_microsoft_ui_input.WindowRectChangingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Input::WindowRectChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowRectChangingEventArgs};

    // ----- IPointerPointTransform interface --------------------

    static PyObject* _new_IPointerPointTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Input::IPointerPointTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Input::IPointerPointTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_IPointerPointTransform(py::wrapper::Microsoft::UI::Input::IPointerPointTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPointerPointTransform_TryTransform(py::wrapper::Microsoft::UI::Input::IPointerPointTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.IPointerPointTransform", L"TryTransform", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Foundation::Point param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryTransform(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPointerPointTransform_TryTransformBounds(py::wrapper::Microsoft::UI::Input::IPointerPointTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Input.IPointerPointTransform", L"TryTransformBounds", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                winrt::Windows::Foundation::Rect param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryTransformBounds(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPointerPointTransform_get_Inverse(py::wrapper::Microsoft::UI::Input::IPointerPointTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Input.IPointerPointTransform", L"Inverse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Inverse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPointerPointTransform[] = {
        { "try_transform", reinterpret_cast<PyCFunction>(IPointerPointTransform_TryTransform), METH_VARARGS, nullptr },
        { "try_transform_bounds", reinterpret_cast<PyCFunction>(IPointerPointTransform_TryTransformBounds), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPointerPointTransform[] = {
        { "inverse", reinterpret_cast<getter>(IPointerPointTransform_get_Inverse), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPointerPointTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPointerPointTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPointerPointTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPointerPointTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPointerPointTransform) },
        { }};

    static PyType_Spec type_spec_IPointerPointTransform = {
        "winrt._winrt_microsoft_ui_input._IPointerPointTransform",
        sizeof(py::wrapper::Microsoft::UI::Input::IPointerPointTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPointerPointTransform};

    struct ImplementsIPointerPointTransform : py::ImplementsInterfaceT<ImplementsIPointerPointTransform, winrt::Microsoft::UI::Input::IPointerPointTransform>
    {
        ImplementsIPointerPointTransform() = delete;
        ImplementsIPointerPointTransform(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPointerPointTransform, winrt::Microsoft::UI::Input::IPointerPointTransform>(py_obj, runtime_class)
        {
        }

        auto TryTransform(winrt::Windows::Foundation::Point param0, winrt::Windows::Foundation::Point& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_transform")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::Point>(return_value.get(), 1);

                return py::convert_to<bool>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TryTransformBounds(winrt::Windows::Foundation::Rect param0, winrt::Windows::Foundation::Rect& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_transform_bounds")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::Rect>(return_value.get(), 1);

                return py::convert_to<bool>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Inverse()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "inverse")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Input::IPointerPointTransform>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPointerPointTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::IPointerPointTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPointerPointTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Input::IPointerPointTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPointerPointTransform(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Input::IPointerPointTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPointerPointTransform(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPointerPointTransform>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPointerPointTransform[] = {
        { "_assign_array_", _assign_array_IPointerPointTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPointerPointTransform), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPointerPointTransform), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPointerPointTransform), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPointerPointTransform[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPointerPointTransform) },
        { }};

    static PyType_Spec type_spec_ImplementsIPointerPointTransform = {
        "winrt._winrt_microsoft_ui_input.IPointerPointTransform",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPointerPointTransform};

    // ----- CrossSlideThresholds struct --------------------

    winrt::Microsoft::UI::Input::CrossSlideThresholds CrossSlideThresholds_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Microsoft::UI::Input::CrossSlideThresholds result{};

        result.SelectionStart = py::convert_to<float>(tuple, 0);
        result.SpeedBumpStart = py::convert_to<float>(tuple, 1);
        result.SpeedBumpEnd = py::convert_to<float>(tuple, 2);
        result.RearrangeStart = py::convert_to<float>(tuple, 3);

        return result;
    }

    PyObject* _new_CrossSlideThresholds(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Input::CrossSlideThresholds>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _SelectionStart{};
        float _SpeedBumpStart{};
        float _SpeedBumpEnd{};
        float _RearrangeStart{};

        static const char* kwlist[] = {"selection_start", "speed_bump_start", "speed_bump_end", "rearrange_start", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ffff", const_cast<char**>(kwlist), &_SelectionStart, &_SpeedBumpStart, &_SpeedBumpEnd, &_RearrangeStart))
        {
            return nullptr;
        }

        try
        {
            self->obj.SelectionStart = _SelectionStart;
            self->obj.SpeedBumpStart = _SpeedBumpStart;
            self->obj.SpeedBumpEnd = _SpeedBumpEnd;
            self->obj.RearrangeStart = _RearrangeStart;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CrossSlideThresholds(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CrossSlideThresholds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::CrossSlideThresholds>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_CrossSlideThresholds(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            float _SelectionStart{self->obj.SelectionStart};
            float _SpeedBumpStart{self->obj.SpeedBumpStart};
            float _SpeedBumpEnd{self->obj.SpeedBumpEnd};
            float _RearrangeStart{self->obj.RearrangeStart};

            static const char* kwlist[] = {"selection_start", "speed_bump_start", "speed_bump_end", "rearrange_start", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ffff", const_cast<char**>(kwlist), &_SelectionStart, &_SpeedBumpStart, &_SpeedBumpEnd, &_RearrangeStart))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.SelectionStart = _SelectionStart;
            copy.SpeedBumpStart = _SpeedBumpStart;
            copy.SpeedBumpEnd = _SpeedBumpEnd;
            copy.RearrangeStart = _RearrangeStart;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CrossSlideThresholds[] = {
        { "_assign_array_", _assign_array_CrossSlideThresholds, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_CrossSlideThresholds), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* CrossSlideThresholds_get_SelectionStart(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlideThresholds_get_SpeedBumpStart(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedBumpStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlideThresholds_get_SpeedBumpEnd(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedBumpEnd);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlideThresholds_get_RearrangeStart(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RearrangeStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_CrossSlideThresholds[] = {
        { "selection_start", reinterpret_cast<getter>(CrossSlideThresholds_get_SelectionStart), nullptr, nullptr, nullptr },
        { "speed_bump_start", reinterpret_cast<getter>(CrossSlideThresholds_get_SpeedBumpStart), nullptr, nullptr, nullptr },
        { "speed_bump_end", reinterpret_cast<getter>(CrossSlideThresholds_get_SpeedBumpEnd), nullptr, nullptr, nullptr },
        { "rearrange_start", reinterpret_cast<getter>(CrossSlideThresholds_get_RearrangeStart), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_CrossSlideThresholds(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Input::CrossSlideThresholds>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_CrossSlideThresholds(PyObject* self) noexcept
    {
        py::pyobj_handle SelectionStart{PyObject_GetAttrString(self, "selection_start")};
        if (!SelectionStart)
        {
            return nullptr;
        }

        py::pyobj_handle SpeedBumpStart{PyObject_GetAttrString(self, "speed_bump_start")};
        if (!SpeedBumpStart)
        {
            return nullptr;
        }

        py::pyobj_handle SpeedBumpEnd{PyObject_GetAttrString(self, "speed_bump_end")};
        if (!SpeedBumpEnd)
        {
            return nullptr;
        }

        py::pyobj_handle RearrangeStart{PyObject_GetAttrString(self, "rearrange_start")};
        if (!RearrangeStart)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("CrossSlideThresholds(selection_start=%R, speed_bump_start=%R, speed_bump_end=%R, rearrange_start=%R)", SelectionStart.get(), SpeedBumpStart.get(), SpeedBumpEnd.get(), RearrangeStart.get());
    }

    static PyType_Slot _type_slots_CrossSlideThresholds[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CrossSlideThresholds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CrossSlideThresholds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CrossSlideThresholds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CrossSlideThresholds) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_CrossSlideThresholds) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_CrossSlideThresholds) },
        { }};

    static PyType_Spec type_spec_CrossSlideThresholds = {
        "winrt._winrt_microsoft_ui_input.CrossSlideThresholds",
        sizeof(py::wrapper::Microsoft::UI::Input::CrossSlideThresholds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CrossSlideThresholds};

    // ----- ManipulationDelta struct --------------------

    winrt::Microsoft::UI::Input::ManipulationDelta ManipulationDelta_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Microsoft::UI::Input::ManipulationDelta result{};

        result.Translation = py::convert_to<winrt::Windows::Foundation::Point>(tuple, 0);
        result.Scale = py::convert_to<float>(tuple, 1);
        result.Rotation = py::convert_to<float>(tuple, 2);
        result.Expansion = py::convert_to<float>(tuple, 3);

        return result;
    }

    PyObject* _new_ManipulationDelta(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Input::ManipulationDelta>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        PyObject* _Translation{};
        float _Scale{};
        float _Rotation{};
        float _Expansion{};

        static const char* kwlist[] = {"translation", "scale", "rotation", "expansion", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Offf", const_cast<char**>(kwlist), &_Translation, &_Scale, &_Rotation, &_Expansion))
        {
            return nullptr;
        }

        try
        {
            self->obj.Translation = _Translation ? py::convert_to<winrt::Windows::Foundation::Point>(_Translation) : winrt::Windows::Foundation::Point{};
            self->obj.Scale = _Scale;
            self->obj.Rotation = _Rotation;
            self->obj.Expansion = _Expansion;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ManipulationDelta(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ManipulationDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ManipulationDelta>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_ManipulationDelta(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            PyObject* _Translation{};
            float _Scale{self->obj.Scale};
            float _Rotation{self->obj.Rotation};
            float _Expansion{self->obj.Expansion};

            static const char* kwlist[] = {"translation", "scale", "rotation", "expansion", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$Offf", const_cast<char**>(kwlist), &_Translation, &_Scale, &_Rotation, &_Expansion))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Translation = _Translation ? py::convert_to<winrt::Windows::Foundation::Point>(_Translation) : self->obj.Translation;
            copy.Scale = _Scale;
            copy.Rotation = _Rotation;
            copy.Expansion = _Expansion;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationDelta[] = {
        { "_assign_array_", _assign_array_ManipulationDelta, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_ManipulationDelta), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* ManipulationDelta_get_Translation(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Translation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDelta_get_Scale(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scale);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDelta_get_Rotation(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDelta_get_Expansion(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expansion);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_ManipulationDelta[] = {
        { "translation", reinterpret_cast<getter>(ManipulationDelta_get_Translation), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(ManipulationDelta_get_Scale), nullptr, nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(ManipulationDelta_get_Rotation), nullptr, nullptr, nullptr },
        { "expansion", reinterpret_cast<getter>(ManipulationDelta_get_Expansion), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_ManipulationDelta(py::wrapper::Microsoft::UI::Input::ManipulationDelta* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Input::ManipulationDelta>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_ManipulationDelta(PyObject* self) noexcept
    {
        py::pyobj_handle Translation{PyObject_GetAttrString(self, "translation")};
        if (!Translation)
        {
            return nullptr;
        }

        py::pyobj_handle Scale{PyObject_GetAttrString(self, "scale")};
        if (!Scale)
        {
            return nullptr;
        }

        py::pyobj_handle Rotation{PyObject_GetAttrString(self, "rotation")};
        if (!Rotation)
        {
            return nullptr;
        }

        py::pyobj_handle Expansion{PyObject_GetAttrString(self, "expansion")};
        if (!Expansion)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("ManipulationDelta(translation=%R, scale=%R, rotation=%R, expansion=%R)", Translation.get(), Scale.get(), Rotation.get(), Expansion.get());
    }

    static PyType_Slot _type_slots_ManipulationDelta[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationDelta) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationDelta) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_ManipulationDelta) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_ManipulationDelta) },
        { }};

    static PyType_Spec type_spec_ManipulationDelta = {
        "winrt._winrt_microsoft_ui_input.ManipulationDelta",
        sizeof(py::wrapper::Microsoft::UI::Input::ManipulationDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationDelta};

    // ----- ManipulationVelocities struct --------------------

    winrt::Microsoft::UI::Input::ManipulationVelocities ManipulationVelocities_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 3)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Microsoft::UI::Input::ManipulationVelocities result{};

        result.Linear = py::convert_to<winrt::Windows::Foundation::Point>(tuple, 0);
        result.Angular = py::convert_to<float>(tuple, 1);
        result.Expansion = py::convert_to<float>(tuple, 2);

        return result;
    }

    PyObject* _new_ManipulationVelocities(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Input::ManipulationVelocities>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        PyObject* _Linear{};
        float _Angular{};
        float _Expansion{};

        static const char* kwlist[] = {"linear", "angular", "expansion", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Off", const_cast<char**>(kwlist), &_Linear, &_Angular, &_Expansion))
        {
            return nullptr;
        }

        try
        {
            self->obj.Linear = _Linear ? py::convert_to<winrt::Windows::Foundation::Point>(_Linear) : winrt::Windows::Foundation::Point{};
            self->obj.Angular = _Angular;
            self->obj.Expansion = _Expansion;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ManipulationVelocities(py::wrapper::Microsoft::UI::Input::ManipulationVelocities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ManipulationVelocities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::ManipulationVelocities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_ManipulationVelocities(py::wrapper::Microsoft::UI::Input::ManipulationVelocities* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            PyObject* _Linear{};
            float _Angular{self->obj.Angular};
            float _Expansion{self->obj.Expansion};

            static const char* kwlist[] = {"linear", "angular", "expansion", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$Off", const_cast<char**>(kwlist), &_Linear, &_Angular, &_Expansion))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Linear = _Linear ? py::convert_to<winrt::Windows::Foundation::Point>(_Linear) : self->obj.Linear;
            copy.Angular = _Angular;
            copy.Expansion = _Expansion;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationVelocities[] = {
        { "_assign_array_", _assign_array_ManipulationVelocities, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_ManipulationVelocities), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* ManipulationVelocities_get_Linear(py::wrapper::Microsoft::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Linear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationVelocities_get_Angular(py::wrapper::Microsoft::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Angular);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationVelocities_get_Expansion(py::wrapper::Microsoft::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expansion);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_ManipulationVelocities[] = {
        { "linear", reinterpret_cast<getter>(ManipulationVelocities_get_Linear), nullptr, nullptr, nullptr },
        { "angular", reinterpret_cast<getter>(ManipulationVelocities_get_Angular), nullptr, nullptr, nullptr },
        { "expansion", reinterpret_cast<getter>(ManipulationVelocities_get_Expansion), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_ManipulationVelocities(py::wrapper::Microsoft::UI::Input::ManipulationVelocities* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Input::ManipulationVelocities>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_ManipulationVelocities(PyObject* self) noexcept
    {
        py::pyobj_handle Linear{PyObject_GetAttrString(self, "linear")};
        if (!Linear)
        {
            return nullptr;
        }

        py::pyobj_handle Angular{PyObject_GetAttrString(self, "angular")};
        if (!Angular)
        {
            return nullptr;
        }

        py::pyobj_handle Expansion{PyObject_GetAttrString(self, "expansion")};
        if (!Expansion)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("ManipulationVelocities(linear=%R, angular=%R, expansion=%R)", Linear.get(), Angular.get(), Expansion.get());
    }

    static PyType_Slot _type_slots_ManipulationVelocities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationVelocities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationVelocities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationVelocities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationVelocities) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_ManipulationVelocities) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_ManipulationVelocities) },
        { }};

    static PyType_Spec type_spec_ManipulationVelocities = {
        "winrt._winrt_microsoft_ui_input.ManipulationVelocities",
        sizeof(py::wrapper::Microsoft::UI::Input::ManipulationVelocities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationVelocities};

    // ----- PhysicalKeyStatus struct --------------------

    winrt::Microsoft::UI::Input::PhysicalKeyStatus PhysicalKeyStatus_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 6)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Microsoft::UI::Input::PhysicalKeyStatus result{};

        result.RepeatCount = py::convert_to<uint32_t>(tuple, 0);
        result.ScanCode = py::convert_to<uint32_t>(tuple, 1);
        result.IsExtendedKey = py::convert_to<bool>(tuple, 2);
        result.IsMenuKeyDown = py::convert_to<bool>(tuple, 3);
        result.WasKeyDown = py::convert_to<bool>(tuple, 4);
        result.IsKeyReleased = py::convert_to<bool>(tuple, 5);

        return result;
    }

    PyObject* _new_PhysicalKeyStatus(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Input::PhysicalKeyStatus>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _RepeatCount{};
        uint32_t _ScanCode{};
        int _IsExtendedKey{};
        int _IsMenuKeyDown{};
        int _WasKeyDown{};
        int _IsKeyReleased{};

        static const char* kwlist[] = {"repeat_count", "scan_code", "is_extended_key", "is_menu_key_down", "was_key_down", "is_key_released", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|IIpppp", const_cast<char**>(kwlist), &_RepeatCount, &_ScanCode, &_IsExtendedKey, &_IsMenuKeyDown, &_WasKeyDown, &_IsKeyReleased))
        {
            return nullptr;
        }

        try
        {
            self->obj.RepeatCount = _RepeatCount;
            self->obj.ScanCode = _ScanCode;
            self->obj.IsExtendedKey = _IsExtendedKey;
            self->obj.IsMenuKeyDown = _IsMenuKeyDown;
            self->obj.WasKeyDown = _WasKeyDown;
            self->obj.IsKeyReleased = _IsKeyReleased;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PhysicalKeyStatus(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PhysicalKeyStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Input::PhysicalKeyStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_PhysicalKeyStatus(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _RepeatCount{self->obj.RepeatCount};
            uint32_t _ScanCode{self->obj.ScanCode};
            int _IsExtendedKey{self->obj.IsExtendedKey};
            int _IsMenuKeyDown{self->obj.IsMenuKeyDown};
            int _WasKeyDown{self->obj.WasKeyDown};
            int _IsKeyReleased{self->obj.IsKeyReleased};

            static const char* kwlist[] = {"repeat_count", "scan_code", "is_extended_key", "is_menu_key_down", "was_key_down", "is_key_released", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$IIpppp", const_cast<char**>(kwlist), &_RepeatCount, &_ScanCode, &_IsExtendedKey, &_IsMenuKeyDown, &_WasKeyDown, &_IsKeyReleased))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.RepeatCount = _RepeatCount;
            copy.ScanCode = _ScanCode;
            copy.IsExtendedKey = _IsExtendedKey;
            copy.IsMenuKeyDown = _IsMenuKeyDown;
            copy.WasKeyDown = _WasKeyDown;
            copy.IsKeyReleased = _IsKeyReleased;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhysicalKeyStatus[] = {
        { "_assign_array_", _assign_array_PhysicalKeyStatus, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_PhysicalKeyStatus), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* PhysicalKeyStatus_get_RepeatCount(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepeatCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalKeyStatus_get_ScanCode(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanCode);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalKeyStatus_get_IsExtendedKey(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExtendedKey);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalKeyStatus_get_IsMenuKeyDown(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMenuKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalKeyStatus_get_WasKeyDown(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalKeyStatus_get_IsKeyReleased(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsKeyReleased);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_PhysicalKeyStatus[] = {
        { "repeat_count", reinterpret_cast<getter>(PhysicalKeyStatus_get_RepeatCount), nullptr, nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(PhysicalKeyStatus_get_ScanCode), nullptr, nullptr, nullptr },
        { "is_extended_key", reinterpret_cast<getter>(PhysicalKeyStatus_get_IsExtendedKey), nullptr, nullptr, nullptr },
        { "is_menu_key_down", reinterpret_cast<getter>(PhysicalKeyStatus_get_IsMenuKeyDown), nullptr, nullptr, nullptr },
        { "was_key_down", reinterpret_cast<getter>(PhysicalKeyStatus_get_WasKeyDown), nullptr, nullptr, nullptr },
        { "is_key_released", reinterpret_cast<getter>(PhysicalKeyStatus_get_IsKeyReleased), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_PhysicalKeyStatus(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PhysicalKeyStatus(PyObject* self) noexcept
    {
        py::pyobj_handle RepeatCount{PyObject_GetAttrString(self, "repeat_count")};
        if (!RepeatCount)
        {
            return nullptr;
        }

        py::pyobj_handle ScanCode{PyObject_GetAttrString(self, "scan_code")};
        if (!ScanCode)
        {
            return nullptr;
        }

        py::pyobj_handle IsExtendedKey{PyObject_GetAttrString(self, "is_extended_key")};
        if (!IsExtendedKey)
        {
            return nullptr;
        }

        py::pyobj_handle IsMenuKeyDown{PyObject_GetAttrString(self, "is_menu_key_down")};
        if (!IsMenuKeyDown)
        {
            return nullptr;
        }

        py::pyobj_handle WasKeyDown{PyObject_GetAttrString(self, "was_key_down")};
        if (!WasKeyDown)
        {
            return nullptr;
        }

        py::pyobj_handle IsKeyReleased{PyObject_GetAttrString(self, "is_key_released")};
        if (!IsKeyReleased)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PhysicalKeyStatus(repeat_count=%R, scan_code=%R, is_extended_key=%R, is_menu_key_down=%R, was_key_down=%R, is_key_released=%R)", RepeatCount.get(), ScanCode.get(), IsExtendedKey.get(), IsMenuKeyDown.get(), WasKeyDown.get(), IsKeyReleased.get());
    }

    static PyType_Slot _type_slots_PhysicalKeyStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhysicalKeyStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhysicalKeyStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhysicalKeyStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhysicalKeyStatus) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PhysicalKeyStatus) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PhysicalKeyStatus) },
        { }};

    static PyType_Spec type_spec_PhysicalKeyStatus = {
        "winrt._winrt_microsoft_ui_input.PhysicalKeyStatus",
        sizeof(py::wrapper::Microsoft::UI::Input::PhysicalKeyStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhysicalKeyStatus};

    // ----- Microsoft.UI.Input Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_input",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Input

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_input(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CharacterReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_CharacterReceivedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CharacterReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContextMenuKeyEventArgs_type{py::register_python_type(module.get(), &type_spec_ContextMenuKeyEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ContextMenuKeyEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CrossSlidingEventArgs_type{py::register_python_type(module.get(), &type_spec_CrossSlidingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CrossSlidingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DraggingEventArgs_type{py::register_python_type(module.get(), &type_spec_DraggingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!DraggingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EnteredMoveSizeEventArgs_type{py::register_python_type(module.get(), &type_spec_EnteredMoveSizeEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!EnteredMoveSizeEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EnteringMoveSizeEventArgs_type{py::register_python_type(module.get(), &type_spec_EnteringMoveSizeEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!EnteringMoveSizeEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ExitedMoveSizeEventArgs_type{py::register_python_type(module.get(), &type_spec_ExitedMoveSizeEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ExitedMoveSizeEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle FocusChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_FocusChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FocusChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle FocusNavigationRequest_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!FocusNavigationRequest_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FocusNavigationRequest_Static{PyType_FromSpecWithBases(&type_spec_FocusNavigationRequest_Static, FocusNavigationRequest_Static_bases.get())};
    if (!type_FocusNavigationRequest_Static)
    {
        return nullptr;
    }

    py::pytype_handle FocusNavigationRequest_type{py::register_python_type(module.get(), &type_spec_FocusNavigationRequest, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FocusNavigationRequest_Static.get()))};
    if (!FocusNavigationRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle FocusNavigationRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_FocusNavigationRequestEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!FocusNavigationRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle GestureRecognizer_type{py::register_python_type(module.get(), &type_spec_GestureRecognizer, object_bases.get(), inspectable_meta_type)};
    if (!GestureRecognizer_type)
    {
        return nullptr;
    }

    py::pytype_handle HoldingEventArgs_type{py::register_python_type(module.get(), &type_spec_HoldingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!HoldingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputObject_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!InputObject_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputObject_Static{PyType_FromSpecWithBases(&type_spec_InputObject_Static, InputObject_Static_bases.get())};
    if (!type_InputObject_Static)
    {
        return nullptr;
    }

    py::pytype_handle InputObject_type{py::register_python_type(module.get(), &type_spec_InputObject, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputObject_Static.get()))};
    if (!InputObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputActivationListener_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputActivationListener_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputActivationListener_Static{PyType_FromSpecWithBases(&type_spec_InputActivationListener_Static, InputActivationListener_Static_bases.get())};
    if (!type_InputActivationListener_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputActivationListener_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputActivationListener_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputActivationListener_type{py::register_python_type(module.get(), &type_spec_InputActivationListener, InputActivationListener_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputActivationListener_Static.get()))};
    if (!InputActivationListener_type)
    {
        return nullptr;
    }

    py::pytype_handle InputActivationListenerActivationChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_InputActivationListenerActivationChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!InputActivationListenerActivationChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputCursor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!InputCursor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputCursor_Static{PyType_FromSpecWithBases(&type_spec_InputCursor_Static, InputCursor_Static_bases.get())};
    if (!type_InputCursor_Static)
    {
        return nullptr;
    }

    py::pytype_handle InputCursor_type{py::register_python_type(module.get(), &type_spec_InputCursor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputCursor_Static.get()))};
    if (!InputCursor_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputCustomCursor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputCursor_type.get())))};
    if (!InputCustomCursor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputCustomCursor_Static{PyType_FromSpecWithBases(&type_spec_InputCustomCursor_Static, InputCustomCursor_Static_bases.get())};
    if (!type_InputCustomCursor_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputCustomCursor_bases{PyTuple_Pack(1, InputCursor_type.get())};
    if (!InputCustomCursor_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputCustomCursor_type{py::register_python_type(module.get(), &type_spec_InputCustomCursor, InputCustomCursor_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputCustomCursor_Static.get()))};
    if (!InputCustomCursor_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputDesktopNamedResourceCursor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputCursor_type.get())))};
    if (!InputDesktopNamedResourceCursor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputDesktopNamedResourceCursor_Static{PyType_FromSpecWithBases(&type_spec_InputDesktopNamedResourceCursor_Static, InputDesktopNamedResourceCursor_Static_bases.get())};
    if (!type_InputDesktopNamedResourceCursor_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputDesktopNamedResourceCursor_bases{PyTuple_Pack(1, InputCursor_type.get())};
    if (!InputDesktopNamedResourceCursor_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputDesktopNamedResourceCursor_type{py::register_python_type(module.get(), &type_spec_InputDesktopNamedResourceCursor, InputDesktopNamedResourceCursor_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputDesktopNamedResourceCursor_Static.get()))};
    if (!InputDesktopNamedResourceCursor_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputDesktopResourceCursor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputCursor_type.get())))};
    if (!InputDesktopResourceCursor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputDesktopResourceCursor_Static{PyType_FromSpecWithBases(&type_spec_InputDesktopResourceCursor_Static, InputDesktopResourceCursor_Static_bases.get())};
    if (!type_InputDesktopResourceCursor_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputDesktopResourceCursor_bases{PyTuple_Pack(1, InputCursor_type.get())};
    if (!InputDesktopResourceCursor_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputDesktopResourceCursor_type{py::register_python_type(module.get(), &type_spec_InputDesktopResourceCursor, InputDesktopResourceCursor_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputDesktopResourceCursor_Static.get()))};
    if (!InputDesktopResourceCursor_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputFocusController_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputFocusController_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputFocusController_Static{PyType_FromSpecWithBases(&type_spec_InputFocusController_Static, InputFocusController_Static_bases.get())};
    if (!type_InputFocusController_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputFocusController_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputFocusController_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputFocusController_type{py::register_python_type(module.get(), &type_spec_InputFocusController, InputFocusController_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputFocusController_Static.get()))};
    if (!InputFocusController_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputFocusNavigationHost_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputFocusNavigationHost_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputFocusNavigationHost_Static{PyType_FromSpecWithBases(&type_spec_InputFocusNavigationHost_Static, InputFocusNavigationHost_Static_bases.get())};
    if (!type_InputFocusNavigationHost_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputFocusNavigationHost_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputFocusNavigationHost_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputFocusNavigationHost_type{py::register_python_type(module.get(), &type_spec_InputFocusNavigationHost, InputFocusNavigationHost_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputFocusNavigationHost_Static.get()))};
    if (!InputFocusNavigationHost_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputKeyboardSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputKeyboardSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputKeyboardSource_Static{PyType_FromSpecWithBases(&type_spec_InputKeyboardSource_Static, InputKeyboardSource_Static_bases.get())};
    if (!type_InputKeyboardSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputKeyboardSource_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputKeyboardSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputKeyboardSource_type{py::register_python_type(module.get(), &type_spec_InputKeyboardSource, InputKeyboardSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputKeyboardSource_Static.get()))};
    if (!InputKeyboardSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputLightDismissAction_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputLightDismissAction_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputLightDismissAction_Static{PyType_FromSpecWithBases(&type_spec_InputLightDismissAction_Static, InputLightDismissAction_Static_bases.get())};
    if (!type_InputLightDismissAction_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputLightDismissAction_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputLightDismissAction_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputLightDismissAction_type{py::register_python_type(module.get(), &type_spec_InputLightDismissAction, InputLightDismissAction_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputLightDismissAction_Static.get()))};
    if (!InputLightDismissAction_type)
    {
        return nullptr;
    }

    py::pytype_handle InputLightDismissEventArgs_type{py::register_python_type(module.get(), &type_spec_InputLightDismissEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!InputLightDismissEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputNonClientPointerSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!InputNonClientPointerSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputNonClientPointerSource_Static{PyType_FromSpecWithBases(&type_spec_InputNonClientPointerSource_Static, InputNonClientPointerSource_Static_bases.get())};
    if (!type_InputNonClientPointerSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle InputNonClientPointerSource_type{py::register_python_type(module.get(), &type_spec_InputNonClientPointerSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputNonClientPointerSource_Static.get()))};
    if (!InputNonClientPointerSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputPointerSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputPointerSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputPointerSource_Static{PyType_FromSpecWithBases(&type_spec_InputPointerSource_Static, InputPointerSource_Static_bases.get())};
    if (!type_InputPointerSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputPointerSource_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputPointerSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputPointerSource_type{py::register_python_type(module.get(), &type_spec_InputPointerSource, InputPointerSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputPointerSource_Static.get()))};
    if (!InputPointerSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputPreTranslateKeyboardSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputObject_type.get())))};
    if (!InputPreTranslateKeyboardSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputPreTranslateKeyboardSource_Static{PyType_FromSpecWithBases(&type_spec_InputPreTranslateKeyboardSource_Static, InputPreTranslateKeyboardSource_Static_bases.get())};
    if (!type_InputPreTranslateKeyboardSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputPreTranslateKeyboardSource_bases{PyTuple_Pack(1, InputObject_type.get())};
    if (!InputPreTranslateKeyboardSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputPreTranslateKeyboardSource_type{py::register_python_type(module.get(), &type_spec_InputPreTranslateKeyboardSource, InputPreTranslateKeyboardSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputPreTranslateKeyboardSource_Static.get()))};
    if (!InputPreTranslateKeyboardSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputSystemCursor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InputCursor_type.get())))};
    if (!InputSystemCursor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputSystemCursor_Static{PyType_FromSpecWithBases(&type_spec_InputSystemCursor_Static, InputSystemCursor_Static_bases.get())};
    if (!type_InputSystemCursor_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InputSystemCursor_bases{PyTuple_Pack(1, InputCursor_type.get())};
    if (!InputSystemCursor_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputSystemCursor_type{py::register_python_type(module.get(), &type_spec_InputSystemCursor, InputSystemCursor_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputSystemCursor_Static.get()))};
    if (!InputSystemCursor_type)
    {
        return nullptr;
    }

    py::pytype_handle KeyEventArgs_type{py::register_python_type(module.get(), &type_spec_KeyEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!KeyEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationInertiaStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationInertiaStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationInertiaStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationStartedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationUpdatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationUpdatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationUpdatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MouseWheelParameters_type{py::register_python_type(module.get(), &type_spec_MouseWheelParameters, object_bases.get(), inspectable_meta_type)};
    if (!MouseWheelParameters_type)
    {
        return nullptr;
    }

    py::pytype_handle NonClientCaptionTappedEventArgs_type{py::register_python_type(module.get(), &type_spec_NonClientCaptionTappedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NonClientCaptionTappedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle NonClientPointerEventArgs_type{py::register_python_type(module.get(), &type_spec_NonClientPointerEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NonClientPointerEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle NonClientRegionsChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_NonClientRegionsChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!NonClientRegionsChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PointerEventArgs_type{py::register_python_type(module.get(), &type_spec_PointerEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PointerEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PointerPoint_type{py::register_python_type(module.get(), &type_spec_PointerPoint, object_bases.get(), inspectable_meta_type)};
    if (!PointerPoint_type)
    {
        return nullptr;
    }

    py::pytype_handle PointerPointProperties_type{py::register_python_type(module.get(), &type_spec_PointerPointProperties, object_bases.get(), inspectable_meta_type)};
    if (!PointerPointProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointerPredictor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PointerPredictor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerPredictor_Static{PyType_FromSpecWithBases(&type_spec_PointerPredictor_Static, PointerPredictor_Static_bases.get())};
    if (!type_PointerPredictor_Static)
    {
        return nullptr;
    }

    py::pytype_handle PointerPredictor_type{py::register_python_type(module.get(), &type_spec_PointerPredictor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerPredictor_Static.get()))};
    if (!PointerPredictor_type)
    {
        return nullptr;
    }

    py::pytype_handle RightTappedEventArgs_type{py::register_python_type(module.get(), &type_spec_RightTappedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RightTappedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TappedEventArgs_type{py::register_python_type(module.get(), &type_spec_TappedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TappedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowRectChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowRectChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowRectChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowRectChangingEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowRectChangingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowRectChangingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPointerPointTransform_type{py::register_python_type(module.get(), &type_spec_IPointerPointTransform, object_bases.get(), nullptr)};
    if (!IPointerPointTransform_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPointerPointTransform_type{py::register_python_type(module.get(), &type_spec_ImplementsIPointerPointTransform, nullptr, inspectable_meta_type)};
    if (!ImplementsIPointerPointTransform_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPointerPointTransform_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle CrossSlideThresholds_type{py::register_python_type(module.get(), &type_spec_CrossSlideThresholds, nullptr, nullptr)};
    if (!CrossSlideThresholds_type)
    {
        return nullptr;
    }

    py::pyobj_handle CrossSlideThresholds_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(CrossSlideThresholds_from_tuple),"winrt._winrt_microsoft_ui_input.CrossSlideThresholds_from_tuple", nullptr)};
    if (!CrossSlideThresholds_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "CrossSlideThresholds_from_tuple", CrossSlideThresholds_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle ManipulationDelta_type{py::register_python_type(module.get(), &type_spec_ManipulationDelta, nullptr, nullptr)};
    if (!ManipulationDelta_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationDelta_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(ManipulationDelta_from_tuple),"winrt._winrt_microsoft_ui_input.ManipulationDelta_from_tuple", nullptr)};
    if (!ManipulationDelta_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "ManipulationDelta_from_tuple", ManipulationDelta_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle ManipulationVelocities_type{py::register_python_type(module.get(), &type_spec_ManipulationVelocities, nullptr, nullptr)};
    if (!ManipulationVelocities_type)
    {
        return nullptr;
    }

    py::pyobj_handle ManipulationVelocities_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(ManipulationVelocities_from_tuple),"winrt._winrt_microsoft_ui_input.ManipulationVelocities_from_tuple", nullptr)};
    if (!ManipulationVelocities_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "ManipulationVelocities_from_tuple", ManipulationVelocities_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle PhysicalKeyStatus_type{py::register_python_type(module.get(), &type_spec_PhysicalKeyStatus, nullptr, nullptr)};
    if (!PhysicalKeyStatus_type)
    {
        return nullptr;
    }

    py::pyobj_handle PhysicalKeyStatus_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(PhysicalKeyStatus_from_tuple),"winrt._winrt_microsoft_ui_input.PhysicalKeyStatus_from_tuple", nullptr)};
    if (!PhysicalKeyStatus_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "PhysicalKeyStatus_from_tuple", PhysicalKeyStatus_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
