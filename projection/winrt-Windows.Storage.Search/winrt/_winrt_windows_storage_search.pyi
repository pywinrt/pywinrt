# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.data.text
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage
import winrt.windows.storage.fileproperties
import winrt.windows.storage.streams

from winrt.windows.storage.search import CommonFileQuery, CommonFolderQuery, DateStackOption, FolderDepth, IndexedState, IndexerOption

Self = typing.TypeVar('Self')

@typing.final
class SortEntry:
    property_name: str
    ascending_order: bool
    def __init__(self, property_name: str, ascending_order: bool) -> None: ...

@typing.final
class ContentIndexer_Static(type):
    @typing.overload
    def get_indexer(cls) -> typing.Optional[ContentIndexer]: ...
    @typing.overload
    def get_indexer(cls, index_name: str, /) -> typing.Optional[ContentIndexer]: ...

@typing.final
class ContentIndexer(winrt.system.Object, metaclass=ContentIndexer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentIndexer: ...
    def add_async(self, indexable_content: typing.Optional[IIndexableContent], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def create_query(self, search_filter: str, properties_to_retrieve: typing.Iterable[str], /) -> typing.Optional[ContentIndexerQuery]: ...
    @typing.overload
    def create_query(self, search_filter: str, properties_to_retrieve: typing.Iterable[str], sort_order: typing.Iterable[SortEntry], /) -> typing.Optional[ContentIndexerQuery]: ...
    @typing.overload
    def create_query(self, search_filter: str, properties_to_retrieve: typing.Iterable[str], sort_order: typing.Iterable[SortEntry], search_filter_language: str, /) -> typing.Optional[ContentIndexerQuery]: ...
    def delete_all_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def delete_async(self, content_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def delete_multiple_async(self, content_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def retrieve_properties_async(self, content_id: str, properties_to_retrieve: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    def update_async(self, indexable_content: typing.Optional[IIndexableContent], /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def revision(self) -> winrt.system.UInt64: ...

@typing.final
class ContentIndexerQuery(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentIndexerQuery: ...
    @typing.overload
    def get_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IIndexableContent]]: ...
    @typing.overload
    def get_async(self, start_index: winrt.system.UInt32, max_items: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IIndexableContent]]: ...
    def get_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    @typing.overload
    def get_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]]: ...
    @typing.overload
    def get_properties_async(self, start_index: winrt.system.UInt32, max_items: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]]: ...
    @_property
    def query_folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

@typing.final
class IndexableContent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IndexableContent: ...
    def __new__(cls: typing.Type[IndexableContent]) -> IndexableContent:...
    @_property
    def stream_content_type(self) -> str: ...
    @stream_content_type.setter
    def stream_content_type(self, value: str) -> None: ...
    @_property
    def stream(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]: ...
    @stream.setter
    def stream(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, winrt.system.Object]]: ...

@typing.final
class QueryOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QueryOptions: ...
    @typing.overload
    def __new__(cls: typing.Type[QueryOptions], query: CommonFileQuery, file_type_filter: typing.Iterable[str]) -> QueryOptions:...
    @typing.overload
    def __new__(cls: typing.Type[QueryOptions], query: CommonFolderQuery) -> QueryOptions:...
    @typing.overload
    def __new__(cls: typing.Type[QueryOptions]) -> QueryOptions:...
    def load_from_string(self, value: str, /) -> None: ...
    def save_to_string(self) -> str: ...
    def set_property_prefetch(self, options: winrt.windows.storage.fileproperties.PropertyPrefetchOptions, properties_to_retrieve: typing.Iterable[str], /) -> None: ...
    def set_thumbnail_prefetch(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> None: ...
    @_property
    def user_search_filter(self) -> str: ...
    @user_search_filter.setter
    def user_search_filter(self, value: str) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...
    @_property
    def indexer_option(self) -> IndexerOption: ...
    @indexer_option.setter
    def indexer_option(self, value: IndexerOption) -> None: ...
    @_property
    def folder_depth(self) -> FolderDepth: ...
    @folder_depth.setter
    def folder_depth(self, value: FolderDepth) -> None: ...
    @_property
    def application_search_filter(self) -> str: ...
    @application_search_filter.setter
    def application_search_filter(self, value: str) -> None: ...
    @_property
    def date_stack_option(self) -> DateStackOption: ...
    @_property
    def file_type_filter(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def group_property_name(self) -> str: ...
    @_property
    def sort_order(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[SortEntry]]: ...
    @_property
    def storage_provider_id_filter(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class SortEntryVector(winrt.system.Object, winrt._winrt.MutableSequence[SortEntry]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[SortEntry]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> SortEntry: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SortEntry]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: SortEntry) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SortEntry]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SortEntryVector: ...
    def append(self, value: SortEntry, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SortEntry]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> SortEntry: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SortEntry], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SortEntry]]: ...
    def index_of(self, value: SortEntry, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: SortEntry, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SortEntry], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: SortEntry, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class StorageFileQueryResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFileQueryResult: ...
    def apply_new_query_options(self, new_query_options: typing.Optional[QueryOptions], /) -> None: ...
    def find_start_index_async(self, value: typing.Optional[winrt.system.Object], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_current_query_options(self) -> typing.Optional[QueryOptions]: ...
    @typing.overload
    def get_files_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFile]]: ...
    @typing.overload
    def get_files_async(self, start_index: winrt.system.UInt32, max_number_of_items: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFile]]: ...
    def get_item_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_matching_properties_with_ranges(self, file: typing.Optional[winrt.windows.storage.StorageFile], /) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, winrt.windows.foundation.collections.IVectorView[winrt.windows.data.text.TextSegment]]]: ...
    def add_contents_changed(self, handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_contents_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_options_changed(self, changed_handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_options_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

@typing.final
class StorageFolderQueryResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFolderQueryResult: ...
    def apply_new_query_options(self, new_query_options: typing.Optional[QueryOptions], /) -> None: ...
    def find_start_index_async(self, value: typing.Optional[winrt.system.Object], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_current_query_options(self) -> typing.Optional[QueryOptions]: ...
    @typing.overload
    def get_folders_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, start_index: winrt.system.UInt32, max_number_of_items: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFolder]]: ...
    def get_item_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def add_contents_changed(self, handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_contents_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_options_changed(self, changed_handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_options_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

@typing.final
class StorageItemQueryResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageItemQueryResult: ...
    def apply_new_query_options(self, new_query_options: typing.Optional[QueryOptions], /) -> None: ...
    def find_start_index_async(self, value: typing.Optional[winrt.system.Object], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_current_query_options(self) -> typing.Optional[QueryOptions]: ...
    def get_item_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    @typing.overload
    def get_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.IStorageItem]]: ...
    @typing.overload
    def get_items_async(self, start_index: winrt.system.UInt32, max_number_of_items: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.IStorageItem]]: ...
    def add_contents_changed(self, handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_contents_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_options_changed(self, changed_handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_options_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

@typing.final
class StorageLibraryChangeTrackerTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTrackerTriggerDetails: ...
    @_property
    def change_tracker(self) -> typing.Optional[winrt.windows.storage.StorageLibraryChangeTracker]: ...
    @_property
    def folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

@typing.final
class StorageLibraryContentChangedTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryContentChangedTriggerDetails: ...
    def create_modified_since_query(self, last_query_time: datetime.datetime, /) -> typing.Optional[StorageItemQueryResult]: ...
    @_property
    def folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

@typing.final
class ValueAndLanguage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ValueAndLanguage: ...
    def __new__(cls: typing.Type[ValueAndLanguage]) -> ValueAndLanguage:...
    @_property
    def value(self) -> typing.Optional[winrt.system.Object]: ...
    @value.setter
    def value(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def language(self) -> str: ...
    @language.setter
    def language(self, value: str) -> None: ...

@typing.final
class IIndexableContent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IIndexableContent: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, winrt.system.Object]]: ...
    @_property
    def stream(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]: ...
    @stream.setter
    def stream(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]) -> None: ...
    @_property
    def stream_content_type(self) -> str: ...
    @stream_content_type.setter
    def stream_content_type(self, value: str) -> None: ...

@typing.final
class IStorageFolderQueryOperations(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolderQueryOperations: ...
    def are_query_options_supported(self, query_options: typing.Optional[QueryOptions], /) -> bool: ...
    @typing.overload
    def create_file_query(self) -> typing.Optional[StorageFileQueryResult]: ...
    @typing.overload
    def create_file_query(self, query: CommonFileQuery, /) -> typing.Optional[StorageFileQueryResult]: ...
    def create_file_query_with_options(self, query_options: typing.Optional[QueryOptions], /) -> typing.Optional[StorageFileQueryResult]: ...
    @typing.overload
    def create_folder_query(self) -> typing.Optional[StorageFolderQueryResult]: ...
    @typing.overload
    def create_folder_query(self, query: CommonFolderQuery, /) -> typing.Optional[StorageFolderQueryResult]: ...
    def create_folder_query_with_options(self, query_options: typing.Optional[QueryOptions], /) -> typing.Optional[StorageFolderQueryResult]: ...
    def create_item_query(self) -> typing.Optional[StorageItemQueryResult]: ...
    def create_item_query_with_options(self, query_options: typing.Optional[QueryOptions], /) -> typing.Optional[StorageItemQueryResult]: ...
    @typing.overload
    def get_files_async(self, query: CommonFileQuery, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: CommonFileQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFile]]: ...
    @typing.overload
    def get_folders_async(self, query: CommonFolderQuery, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: CommonFolderQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.StorageFolder]]: ...
    def get_indexed_state_async(self) -> winrt.windows.foundation.IAsyncOperation[IndexedState]: ...
    def get_items_async(self, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.IStorageItem]]: ...
    def is_common_file_query_supported(self, query: CommonFileQuery, /) -> bool: ...
    def is_common_folder_query_supported(self, query: CommonFolderQuery, /) -> bool: ...

@typing.final
class IStorageQueryResultBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageQueryResultBase: ...
    def apply_new_query_options(self, new_query_options: typing.Optional[QueryOptions], /) -> None: ...
    def find_start_index_async(self, value: typing.Optional[winrt.system.Object], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_current_query_options(self) -> typing.Optional[QueryOptions]: ...
    def get_item_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def add_contents_changed(self, handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_contents_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_options_changed(self, changed_handler: winrt.windows.foundation.TypedEventHandler[IStorageQueryResultBase, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_options_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def folder(self) -> typing.Optional[winrt.windows.storage.StorageFolder]: ...

