// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.1

#include "py.Windows.Media.Playback.h"


namespace py::cpp::Windows::Media::Playback
{
    // ----- BackgroundMediaPlayer class --------------------

    static PyObject* _new_BackgroundMediaPlayer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::BackgroundMediaPlayer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::BackgroundMediaPlayer>::type_name);
        return nullptr;
    }

    static PyObject* BackgroundMediaPlayer_IsMediaPlaying(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"IsMediaPlaying", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::IsMediaPlaying());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_SendMessageToBackground(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"SendMessageToBackground", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                winrt::Windows::Media::Playback::BackgroundMediaPlayer::SendMessageToBackground(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_SendMessageToForeground(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"SendMessageToForeground", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                winrt::Windows::Media::Playback::BackgroundMediaPlayer::SendMessageToForeground(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_Shutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"Shutdown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Media::Playback::BackgroundMediaPlayer::Shutdown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_add_MessageReceivedFromBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"MessageReceivedFromBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromBackground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_remove_MessageReceivedFromBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"MessageReceivedFromBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromBackground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_add_MessageReceivedFromForeground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"MessageReceivedFromForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromForeground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_remove_MessageReceivedFromForeground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.BackgroundMediaPlayer", L"MessageReceivedFromForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromForeground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundMediaPlayer[] = {
        { "add_message_received_from_background", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_add_MessageReceivedFromBackground), METH_O | METH_STATIC, nullptr },
        { "remove_message_received_from_background", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_remove_MessageReceivedFromBackground), METH_O | METH_STATIC, nullptr },
        { "add_message_received_from_foreground", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_add_MessageReceivedFromForeground), METH_O | METH_STATIC, nullptr },
        { "remove_message_received_from_foreground", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_remove_MessageReceivedFromForeground), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundMediaPlayer[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundMediaPlayer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundMediaPlayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundMediaPlayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundMediaPlayer) },
        { },
    };

    static PyType_Spec type_spec_BackgroundMediaPlayer =
    {
        "winrt._winrt_windows_media_playback.BackgroundMediaPlayer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundMediaPlayer
    };

    static PyGetSetDef getset_BackgroundMediaPlayer_Static[] = {
        { "current", reinterpret_cast<getter>(BackgroundMediaPlayer_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BackgroundMediaPlayer_Static[] = {
        { "is_media_playing", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_IsMediaPlaying), METH_VARARGS, nullptr },
        { "send_message_to_background", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_SendMessageToBackground), METH_VARARGS, nullptr },
        { "send_message_to_foreground", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_SendMessageToForeground), METH_VARARGS, nullptr },
        { "shutdown", reinterpret_cast<PyCFunction>(BackgroundMediaPlayer_Shutdown), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundMediaPlayer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundMediaPlayer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundMediaPlayer_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundMediaPlayer_Static =
    {
        "winrt._winrt_windows_media_playback.BackgroundMediaPlayer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundMediaPlayer_Static
    };

    // ----- CurrentMediaPlaybackItemChangedEventArgs class --------------------

    static PyObject* _new_CurrentMediaPlaybackItemChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CurrentMediaPlaybackItemChangedEventArgs(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CurrentMediaPlaybackItemChangedEventArgs_get_NewItem(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs", L"NewItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrentMediaPlaybackItemChangedEventArgs_get_OldItem(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs", L"OldItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrentMediaPlaybackItemChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CurrentMediaPlaybackItemChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrentMediaPlaybackItemChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentMediaPlaybackItemChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CurrentMediaPlaybackItemChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrentMediaPlaybackItemChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CurrentMediaPlaybackItemChangedEventArgs[] = {
        { "new_item", reinterpret_cast<getter>(CurrentMediaPlaybackItemChangedEventArgs_get_NewItem), nullptr, nullptr, nullptr },
        { "old_item", reinterpret_cast<getter>(CurrentMediaPlaybackItemChangedEventArgs_get_OldItem), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(CurrentMediaPlaybackItemChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CurrentMediaPlaybackItemChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrentMediaPlaybackItemChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrentMediaPlaybackItemChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrentMediaPlaybackItemChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrentMediaPlaybackItemChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CurrentMediaPlaybackItemChangedEventArgs =
    {
        "winrt._winrt_windows_media_playback.CurrentMediaPlaybackItemChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentMediaPlaybackItemChangedEventArgs
    };

    // ----- MediaBreak class --------------------

    static PyObject* _new_MediaBreak(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreakInsertionMethod>(args, 0);

                winrt::Windows::Media::Playback::MediaBreak instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreakInsertionMethod>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Media::Playback::MediaBreak instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreak* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreak_get_CanStart(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreak", L"CanStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBreak_put_CanStart(py::wrapper::Windows::Media::Playback::MediaBreak* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreak", L"CanStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBreak_get_CustomProperties(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreak", L"CustomProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreak_get_InsertionMethod(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreak", L"InsertionMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InsertionMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreak_get_PlaybackList(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreak", L"PlaybackList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreak_get_PresentationPosition(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreak", L"PresentationPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentationPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreak>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreak>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreak[] = {
        { "_assign_array_", _assign_array_MediaBreak, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreak), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreak[] = {
        { "can_start", reinterpret_cast<getter>(MediaBreak_get_CanStart), reinterpret_cast<setter>(MediaBreak_put_CanStart), nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(MediaBreak_get_CustomProperties), nullptr, nullptr, nullptr },
        { "insertion_method", reinterpret_cast<getter>(MediaBreak_get_InsertionMethod), nullptr, nullptr, nullptr },
        { "playback_list", reinterpret_cast<getter>(MediaBreak_get_PlaybackList), nullptr, nullptr, nullptr },
        { "presentation_position", reinterpret_cast<getter>(MediaBreak_get_PresentationPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreak[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreak) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreak) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreak) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreak) },
        { },
    };

    static PyType_Spec type_spec_MediaBreak =
    {
        "winrt._winrt_windows_media_playback.MediaBreak",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreak),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreak
    };

    // ----- MediaBreakEndedEventArgs class --------------------

    static PyObject* _new_MediaBreakEndedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBreakEndedEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakEndedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreakEndedEventArgs_get_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreakEndedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakEndedEventArgs", L"MediaBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreakEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreakEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakEndedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaBreakEndedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreakEndedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreakEndedEventArgs[] = {
        { "media_break", reinterpret_cast<getter>(MediaBreakEndedEventArgs_get_MediaBreak), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreakEndedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreakEndedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreakEndedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreakEndedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreakEndedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaBreakEndedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaBreakEndedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakEndedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakEndedEventArgs
    };

    // ----- MediaBreakManager class --------------------

    static PyObject* _new_MediaBreakManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaBreakManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaBreakManager>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBreakManager(py::wrapper::Windows::Media::Playback::MediaBreakManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreakManager_PlayBreak(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaBreakManager", L"PlayBreak", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(args, 0);

                self->obj.PlayBreak(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_SkipCurrentBreak(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaBreakManager", L"SkipCurrentBreak", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SkipCurrentBreak();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_get_CurrentBreak(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakManager", L"CurrentBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_get_PlaybackSession(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakManager", L"PlaybackSession"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreakEnded(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreakEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>>(arg);

            return py::convert(self->obj.BreakEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreakEnded(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreakEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreakEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreakSkipped(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreakSkipped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>>(arg);

            return py::convert(self->obj.BreakSkipped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreakSkipped(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreakSkipped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreakSkipped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreakStarted(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreakStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>>(arg);

            return py::convert(self->obj.BreakStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreakStarted(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreakStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreakStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreaksSeekedOver(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreaksSeekedOver"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>>(arg);

            return py::convert(self->obj.BreaksSeekedOver(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreaksSeekedOver(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakManager", L"BreaksSeekedOver"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreaksSeekedOver(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreakManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreakManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreakManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakManager[] = {
        { "play_break", reinterpret_cast<PyCFunction>(MediaBreakManager_PlayBreak), METH_VARARGS, nullptr },
        { "skip_current_break", reinterpret_cast<PyCFunction>(MediaBreakManager_SkipCurrentBreak), METH_VARARGS, nullptr },
        { "add_break_ended", reinterpret_cast<PyCFunction>(MediaBreakManager_add_BreakEnded), METH_O, nullptr },
        { "remove_break_ended", reinterpret_cast<PyCFunction>(MediaBreakManager_remove_BreakEnded), METH_O, nullptr },
        { "add_break_skipped", reinterpret_cast<PyCFunction>(MediaBreakManager_add_BreakSkipped), METH_O, nullptr },
        { "remove_break_skipped", reinterpret_cast<PyCFunction>(MediaBreakManager_remove_BreakSkipped), METH_O, nullptr },
        { "add_break_started", reinterpret_cast<PyCFunction>(MediaBreakManager_add_BreakStarted), METH_O, nullptr },
        { "remove_break_started", reinterpret_cast<PyCFunction>(MediaBreakManager_remove_BreakStarted), METH_O, nullptr },
        { "add_breaks_seeked_over", reinterpret_cast<PyCFunction>(MediaBreakManager_add_BreaksSeekedOver), METH_O, nullptr },
        { "remove_breaks_seeked_over", reinterpret_cast<PyCFunction>(MediaBreakManager_remove_BreaksSeekedOver), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaBreakManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreakManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreakManager[] = {
        { "current_break", reinterpret_cast<getter>(MediaBreakManager_get_CurrentBreak), nullptr, nullptr, nullptr },
        { "playback_session", reinterpret_cast<getter>(MediaBreakManager_get_PlaybackSession), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreakManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreakManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreakManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreakManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreakManager) },
        { },
    };

    static PyType_Spec type_spec_MediaBreakManager =
    {
        "winrt._winrt_windows_media_playback.MediaBreakManager",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakManager
    };

    // ----- MediaBreakSchedule class --------------------

    static PyObject* _new_MediaBreakSchedule(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaBreakSchedule>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaBreakSchedule>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBreakSchedule(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreakSchedule_InsertMidrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"InsertMidrollBreak", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(args, 0);

                self->obj.InsertMidrollBreak(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_RemoveMidrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"RemoveMidrollBreak", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(args, 0);

                self->obj.RemoveMidrollBreak(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_get_PrerollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"PrerollBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrerollBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBreakSchedule_put_PrerollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"PrerollBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(arg);

            self->obj.PrerollBreak(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBreakSchedule_get_PostrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"PostrollBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostrollBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBreakSchedule_put_PostrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"PostrollBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(arg);

            self->obj.PostrollBreak(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBreakSchedule_get_MidrollBreaks(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"MidrollBreaks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MidrollBreaks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_get_PlaybackItem(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"PlaybackItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_add_ScheduleChanged(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"ScheduleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakSchedule, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ScheduleChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_remove_ScheduleChanged(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaBreakSchedule", L"ScheduleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScheduleChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreakSchedule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreakSchedule>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreakSchedule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakSchedule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakSchedule[] = {
        { "insert_midroll_break", reinterpret_cast<PyCFunction>(MediaBreakSchedule_InsertMidrollBreak), METH_VARARGS, nullptr },
        { "remove_midroll_break", reinterpret_cast<PyCFunction>(MediaBreakSchedule_RemoveMidrollBreak), METH_VARARGS, nullptr },
        { "add_schedule_changed", reinterpret_cast<PyCFunction>(MediaBreakSchedule_add_ScheduleChanged), METH_O, nullptr },
        { "remove_schedule_changed", reinterpret_cast<PyCFunction>(MediaBreakSchedule_remove_ScheduleChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaBreakSchedule, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreakSchedule), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreakSchedule[] = {
        { "preroll_break", reinterpret_cast<getter>(MediaBreakSchedule_get_PrerollBreak), reinterpret_cast<setter>(MediaBreakSchedule_put_PrerollBreak), nullptr, nullptr },
        { "postroll_break", reinterpret_cast<getter>(MediaBreakSchedule_get_PostrollBreak), reinterpret_cast<setter>(MediaBreakSchedule_put_PostrollBreak), nullptr, nullptr },
        { "midroll_breaks", reinterpret_cast<getter>(MediaBreakSchedule_get_MidrollBreaks), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(MediaBreakSchedule_get_PlaybackItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreakSchedule[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreakSchedule) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreakSchedule) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreakSchedule) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreakSchedule) },
        { },
    };

    static PyType_Spec type_spec_MediaBreakSchedule =
    {
        "winrt._winrt_windows_media_playback.MediaBreakSchedule",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakSchedule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakSchedule
    };

    // ----- MediaBreakSeekedOverEventArgs class --------------------

    static PyObject* _new_MediaBreakSeekedOverEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBreakSeekedOverEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreakSeekedOverEventArgs_get_NewPosition(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSeekedOverEventArgs", L"NewPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSeekedOverEventArgs_get_OldPosition(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSeekedOverEventArgs", L"OldPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSeekedOverEventArgs_get_SeekedOverBreaks(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSeekedOverEventArgs", L"SeekedOverBreaks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SeekedOverBreaks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreakSeekedOverEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreakSeekedOverEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakSeekedOverEventArgs[] = {
        { "_assign_array_", _assign_array_MediaBreakSeekedOverEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreakSeekedOverEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreakSeekedOverEventArgs[] = {
        { "new_position", reinterpret_cast<getter>(MediaBreakSeekedOverEventArgs_get_NewPosition), nullptr, nullptr, nullptr },
        { "old_position", reinterpret_cast<getter>(MediaBreakSeekedOverEventArgs_get_OldPosition), nullptr, nullptr, nullptr },
        { "seeked_over_breaks", reinterpret_cast<getter>(MediaBreakSeekedOverEventArgs_get_SeekedOverBreaks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreakSeekedOverEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreakSeekedOverEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreakSeekedOverEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreakSeekedOverEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreakSeekedOverEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaBreakSeekedOverEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaBreakSeekedOverEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakSeekedOverEventArgs
    };

    // ----- MediaBreakSkippedEventArgs class --------------------

    static PyObject* _new_MediaBreakSkippedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBreakSkippedEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakSkippedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreakSkippedEventArgs_get_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreakSkippedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakSkippedEventArgs", L"MediaBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreakSkippedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreakSkippedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakSkippedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaBreakSkippedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreakSkippedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreakSkippedEventArgs[] = {
        { "media_break", reinterpret_cast<getter>(MediaBreakSkippedEventArgs_get_MediaBreak), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreakSkippedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreakSkippedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreakSkippedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreakSkippedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreakSkippedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaBreakSkippedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaBreakSkippedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakSkippedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakSkippedEventArgs
    };

    // ----- MediaBreakStartedEventArgs class --------------------

    static PyObject* _new_MediaBreakStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaBreakStartedEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBreakStartedEventArgs_get_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreakStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaBreakStartedEventArgs", L"MediaBreak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaBreakStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaBreakStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakStartedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaBreakStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBreakStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBreakStartedEventArgs[] = {
        { "media_break", reinterpret_cast<getter>(MediaBreakStartedEventArgs_get_MediaBreak), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBreakStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaBreakStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaBreakStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaBreakStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaBreakStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaBreakStartedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaBreakStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakStartedEventArgs
    };

    // ----- MediaItemDisplayProperties class --------------------

    static PyObject* _new_MediaItemDisplayProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaItemDisplayProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaItemDisplayProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaItemDisplayProperties(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaItemDisplayProperties_ClearAll(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"ClearAll", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClearAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_Type(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaItemDisplayProperties_put_Type(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_Thumbnail(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaItemDisplayProperties_put_Thumbnail(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_MusicProperties(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"MusicProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_VideoProperties(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaItemDisplayProperties", L"VideoProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaItemDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaItemDisplayProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaItemDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaItemDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaItemDisplayProperties[] = {
        { "clear_all", reinterpret_cast<PyCFunction>(MediaItemDisplayProperties_ClearAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaItemDisplayProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaItemDisplayProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaItemDisplayProperties[] = {
        { "type", reinterpret_cast<getter>(MediaItemDisplayProperties_get_Type), reinterpret_cast<setter>(MediaItemDisplayProperties_put_Type), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(MediaItemDisplayProperties_get_Thumbnail), reinterpret_cast<setter>(MediaItemDisplayProperties_put_Thumbnail), nullptr, nullptr },
        { "music_properties", reinterpret_cast<getter>(MediaItemDisplayProperties_get_MusicProperties), nullptr, nullptr, nullptr },
        { "video_properties", reinterpret_cast<getter>(MediaItemDisplayProperties_get_VideoProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaItemDisplayProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaItemDisplayProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaItemDisplayProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaItemDisplayProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaItemDisplayProperties) },
        { },
    };

    static PyType_Spec type_spec_MediaItemDisplayProperties =
    {
        "winrt._winrt_windows_media_playback.MediaItemDisplayProperties",
        sizeof(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaItemDisplayProperties
    };

    // ----- MediaPlaybackAudioTrackList class --------------------

    static PyObject* _new_MediaPlaybackAudioTrackList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackAudioTrackList_First(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_GetAt(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_GetMany(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Core::AudioTrack, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_IndexOf(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::AudioTrack>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_get_Size(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackAudioTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"SelectedIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackAudioTrackList", L"SelectedIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackAudioTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackAudioTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_MediaPlaybackAudioTrackList(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Media::Core::AudioTrack> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Media::Core::AudioTrack>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackAudioTrackList[] = {
        { "first", reinterpret_cast<PyCFunction>(MediaPlaybackAudioTrackList_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(MediaPlaybackAudioTrackList_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(MediaPlaybackAudioTrackList_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(MediaPlaybackAudioTrackList_IndexOf), METH_VARARGS, nullptr },
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(MediaPlaybackAudioTrackList_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(MediaPlaybackAudioTrackList_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackAudioTrackList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackAudioTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackAudioTrackList[] = {
        { "size", reinterpret_cast<getter>(MediaPlaybackAudioTrackList_get_Size), nullptr, nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(MediaPlaybackAudioTrackList_get_SelectedIndex), reinterpret_cast<setter>(MediaPlaybackAudioTrackList_put_SelectedIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackAudioTrackList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackAudioTrackList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackAudioTrackList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackAudioTrackList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackAudioTrackList) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaPlaybackAudioTrackList) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_MediaPlaybackAudioTrackList) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_MediaPlaybackAudioTrackList) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_MediaPlaybackAudioTrackList) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackAudioTrackList =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackAudioTrackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackAudioTrackList
    };

    // ----- MediaPlaybackCommandManager class --------------------

    static PyObject* _new_MediaPlaybackCommandManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManager(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManager_get_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManager_put_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_AutoRepeatModeBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"AutoRepeatModeBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoRepeatModeBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_FastForwardBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"FastForwardBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FastForwardBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"MediaPlayer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_NextBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"NextBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NextBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PauseBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PauseBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PauseBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PlayBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PlayBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlayBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PositionBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PositionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PreviousBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PreviousBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_RateBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"RateBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RateBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_RewindBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"RewindBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RewindBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_ShuffleBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"ShuffleBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShuffleBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_AutoRepeatModeReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"AutoRepeatModeReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>>(arg);

            return py::convert(self->obj.AutoRepeatModeReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_AutoRepeatModeReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"AutoRepeatModeReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutoRepeatModeReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_FastForwardReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"FastForwardReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>>(arg);

            return py::convert(self->obj.FastForwardReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_FastForwardReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"FastForwardReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FastForwardReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_NextReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"NextReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>>(arg);

            return py::convert(self->obj.NextReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_NextReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"NextReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NextReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PauseReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PauseReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>>(arg);

            return py::convert(self->obj.PauseReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PauseReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PauseReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PauseReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PlayReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PlayReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>>(arg);

            return py::convert(self->obj.PlayReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PlayReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PlayReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlayReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PositionReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PositionReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>>(arg);

            return py::convert(self->obj.PositionReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PositionReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PositionReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PreviousReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PreviousReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>>(arg);

            return py::convert(self->obj.PreviousReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PreviousReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"PreviousReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviousReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_RateReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"RateReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>>(arg);

            return py::convert(self->obj.RateReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_RateReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"RateReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RateReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_RewindReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"RewindReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>>(arg);

            return py::convert(self->obj.RewindReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_RewindReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"RewindReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RewindReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_ShuffleReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"ShuffleReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>>(arg);

            return py::convert(self->obj.ShuffleReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_ShuffleReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManager", L"ShuffleReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShuffleReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManager[] = {
        { "add_auto_repeat_mode_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_AutoRepeatModeReceived), METH_O, nullptr },
        { "remove_auto_repeat_mode_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_AutoRepeatModeReceived), METH_O, nullptr },
        { "add_fast_forward_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_FastForwardReceived), METH_O, nullptr },
        { "remove_fast_forward_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_FastForwardReceived), METH_O, nullptr },
        { "add_next_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_NextReceived), METH_O, nullptr },
        { "remove_next_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_NextReceived), METH_O, nullptr },
        { "add_pause_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_PauseReceived), METH_O, nullptr },
        { "remove_pause_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_PauseReceived), METH_O, nullptr },
        { "add_play_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_PlayReceived), METH_O, nullptr },
        { "remove_play_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_PlayReceived), METH_O, nullptr },
        { "add_position_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_PositionReceived), METH_O, nullptr },
        { "remove_position_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_PositionReceived), METH_O, nullptr },
        { "add_previous_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_PreviousReceived), METH_O, nullptr },
        { "remove_previous_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_PreviousReceived), METH_O, nullptr },
        { "add_rate_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_RateReceived), METH_O, nullptr },
        { "remove_rate_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_RateReceived), METH_O, nullptr },
        { "add_rewind_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_RewindReceived), METH_O, nullptr },
        { "remove_rewind_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_RewindReceived), METH_O, nullptr },
        { "add_shuffle_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_add_ShuffleReceived), METH_O, nullptr },
        { "remove_shuffle_received", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManager_remove_ShuffleReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManager[] = {
        { "is_enabled", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_IsEnabled), reinterpret_cast<setter>(MediaPlaybackCommandManager_put_IsEnabled), nullptr, nullptr },
        { "auto_repeat_mode_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_AutoRepeatModeBehavior), nullptr, nullptr, nullptr },
        { "fast_forward_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_FastForwardBehavior), nullptr, nullptr, nullptr },
        { "media_player", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_MediaPlayer), nullptr, nullptr, nullptr },
        { "next_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_NextBehavior), nullptr, nullptr, nullptr },
        { "pause_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_PauseBehavior), nullptr, nullptr, nullptr },
        { "play_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_PlayBehavior), nullptr, nullptr, nullptr },
        { "position_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_PositionBehavior), nullptr, nullptr, nullptr },
        { "previous_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_PreviousBehavior), nullptr, nullptr, nullptr },
        { "rate_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_RateBehavior), nullptr, nullptr, nullptr },
        { "rewind_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_RewindBehavior), nullptr, nullptr, nullptr },
        { "shuffle_behavior", reinterpret_cast<getter>(MediaPlaybackCommandManager_get_ShuffleBehavior), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManager) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManager =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManager",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManager
    };

    // ----- MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_AutoRepeatMode(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs", L"AutoRepeatMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_put_Handled), nullptr, nullptr },
        { "auto_repeat_mode", reinterpret_cast<getter>(MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_AutoRepeatMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerCommandBehavior class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerCommandBehavior(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerCommandBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_get_EnablingRule(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerCommandBehavior", L"EnablingRule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnablingRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerCommandBehavior_put_EnablingRule(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerCommandBehavior", L"EnablingRule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaCommandEnablingRule>(arg);

            self->obj.EnablingRule(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_get_CommandManager(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerCommandBehavior", L"CommandManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_get_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerCommandBehavior", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_add_IsEnabledChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerCommandBehavior", L"IsEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_remove_IsEnabledChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerCommandBehavior", L"IsEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerCommandBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerCommandBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerCommandBehavior[] = {
        { "add_is_enabled_changed", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerCommandBehavior_add_IsEnabledChanged), METH_O, nullptr },
        { "remove_is_enabled_changed", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerCommandBehavior_remove_IsEnabledChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerCommandBehavior, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerCommandBehavior), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerCommandBehavior[] = {
        { "enabling_rule", reinterpret_cast<getter>(MediaPlaybackCommandManagerCommandBehavior_get_EnablingRule), reinterpret_cast<setter>(MediaPlaybackCommandManagerCommandBehavior_put_EnablingRule), nullptr, nullptr },
        { "command_manager", reinterpret_cast<getter>(MediaPlaybackCommandManagerCommandBehavior_get_CommandManager), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MediaPlaybackCommandManagerCommandBehavior_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerCommandBehavior[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerCommandBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerCommandBehavior) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerCommandBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerCommandBehavior) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerCommandBehavior =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerCommandBehavior",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerCommandBehavior
    };

    // ----- MediaPlaybackCommandManagerFastForwardReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerFastForwardReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerFastForwardReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerFastForwardReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerFastForwardReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerFastForwardReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerFastForwardReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerFastForwardReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerFastForwardReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerFastForwardReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerFastForwardReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerFastForwardReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerFastForwardReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerFastForwardReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerFastForwardReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerFastForwardReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerFastForwardReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerFastForwardReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerFastForwardReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerFastForwardReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerFastForwardReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerFastForwardReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerNextReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerNextReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerNextReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerNextReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerNextReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerNextReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerNextReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerNextReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerNextReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerNextReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerNextReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerNextReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerNextReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerNextReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerNextReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerNextReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerNextReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerNextReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerNextReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerNextReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerNextReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerNextReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerNextReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerNextReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerNextReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerNextReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPauseReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerPauseReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPauseReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerPauseReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPauseReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPauseReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPauseReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPauseReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPauseReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerPauseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerPauseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPauseReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerPauseReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerPauseReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerPauseReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPauseReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerPauseReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerPauseReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPauseReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerPauseReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerPauseReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerPauseReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerPauseReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerPauseReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerPauseReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPauseReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPlayReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerPlayReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPlayReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerPlayReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPlayReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPlayReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPlayReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPlayReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPlayReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerPlayReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerPlayReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPlayReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerPlayReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerPlayReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerPlayReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPlayReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerPlayReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerPlayReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPlayReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerPlayReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerPlayReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerPlayReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerPlayReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerPlayReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerPlayReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPlayReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPositionReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerPositionReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPositionReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerPositionReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPositionReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPositionReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPositionReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPositionReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Position(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPositionReceivedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerPositionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerPositionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPositionReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerPositionReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerPositionReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerPositionReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPositionReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerPositionReceivedEventArgs_put_Handled), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPositionReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerPositionReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerPositionReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerPositionReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerPositionReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerPositionReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerPositionReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPositionReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPreviousReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerPreviousReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPreviousReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerPreviousReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPreviousReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPreviousReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPreviousReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPreviousReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerPreviousReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerPreviousReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerPreviousReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPreviousReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerPreviousReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerPreviousReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerPreviousReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPreviousReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerPreviousReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerPreviousReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPreviousReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerPreviousReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerPreviousReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerPreviousReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerPreviousReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerPreviousReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerPreviousReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPreviousReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerRateReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerRateReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerRateReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerRateReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRateReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerRateReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRateReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerRateReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRateReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerRateReceivedEventArgs_get_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRateReceivedEventArgs", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerRateReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerRateReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerRateReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerRateReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerRateReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerRateReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerRateReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerRateReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerRateReceivedEventArgs_put_Handled), nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(MediaPlaybackCommandManagerRateReceivedEventArgs_get_PlaybackRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerRateReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerRateReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerRateReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerRateReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerRateReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerRateReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerRateReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerRateReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerRewindReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerRewindReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerRewindReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerRewindReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRewindReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerRewindReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRewindReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerRewindReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerRewindReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerRewindReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerRewindReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerRewindReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerRewindReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerRewindReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerRewindReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerRewindReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerRewindReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerRewindReceivedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerRewindReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerRewindReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerRewindReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerRewindReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerRewindReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerRewindReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerRewindReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerRewindReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerShuffleReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackCommandManagerShuffleReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerShuffleReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackCommandManagerShuffleReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerShuffleReceivedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerShuffleReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerShuffleReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerShuffleReceivedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_IsShuffleRequested(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackCommandManagerShuffleReceivedEventArgs", L"IsShuffleRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsShuffleRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackCommandManagerShuffleReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackCommandManagerShuffleReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerShuffleReceivedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaPlaybackCommandManagerShuffleReceivedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackCommandManagerShuffleReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackCommandManagerShuffleReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerShuffleReceivedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_Handled), reinterpret_cast<setter>(MediaPlaybackCommandManagerShuffleReceivedEventArgs_put_Handled), nullptr, nullptr },
        { "is_shuffle_requested", reinterpret_cast<getter>(MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_IsShuffleRequested), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerShuffleReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackCommandManagerShuffleReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackCommandManagerShuffleReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackCommandManagerShuffleReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackCommandManagerShuffleReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackCommandManagerShuffleReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackCommandManagerShuffleReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerShuffleReceivedEventArgs
    };

    // ----- MediaPlaybackItem class --------------------

    static PyObject* _new_MediaPlaybackItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Media::Playback::MediaPlaybackItem instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                winrt::Windows::Media::Playback::MediaPlaybackItem instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                winrt::Windows::Media::Playback::MediaPlaybackItem instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlaybackItem(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackItem_ApplyDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"ApplyDisplayProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaItemDisplayProperties>(args, 0);

                self->obj.ApplyDisplayProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_FindFromMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"FindFromMediaSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Playback::MediaPlaybackItem::FindFromMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_GetDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"GetDisplayProperties", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDisplayProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_AudioTracks(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"AudioTracks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_Source(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_TimedMetadataTracks(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"TimedMetadataTracks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_VideoTracks(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"VideoTracks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_CanSkip(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"CanSkip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSkip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackItem_put_CanSkip(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"CanSkip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSkip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackItem_get_BreakSchedule(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"BreakSchedule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BreakSchedule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_DurationLimit(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"DurationLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DurationLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_StartTime(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_IsDisabledInPlaybackList(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"IsDisabledInPlaybackList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisabledInPlaybackList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackItem_put_IsDisabledInPlaybackList(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"IsDisabledInPlaybackList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledInPlaybackList(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackItem_get_AutoLoadedDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"AutoLoadedDisplayProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoLoadedDisplayProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackItem_put_AutoLoadedDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"AutoLoadedDisplayProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::AutoLoadedDisplayPropertyKind>(arg);

            self->obj.AutoLoadedDisplayProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackItem_get_TotalDownloadProgress(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"TotalDownloadProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalDownloadProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_add_AudioTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"AudioTracksChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackItem, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert(self->obj.AudioTracksChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_remove_AudioTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"AudioTracksChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioTracksChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_add_TimedMetadataTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"TimedMetadataTracksChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackItem, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert(self->obj.TimedMetadataTracksChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_remove_TimedMetadataTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"TimedMetadataTracksChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimedMetadataTracksChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_add_VideoTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"VideoTracksChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackItem, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert(self->obj.VideoTracksChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_remove_VideoTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackItem", L"VideoTracksChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoTracksChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItem[] = {
        { "apply_display_properties", reinterpret_cast<PyCFunction>(MediaPlaybackItem_ApplyDisplayProperties), METH_VARARGS, nullptr },
        { "get_display_properties", reinterpret_cast<PyCFunction>(MediaPlaybackItem_GetDisplayProperties), METH_VARARGS, nullptr },
        { "add_audio_tracks_changed", reinterpret_cast<PyCFunction>(MediaPlaybackItem_add_AudioTracksChanged), METH_O, nullptr },
        { "remove_audio_tracks_changed", reinterpret_cast<PyCFunction>(MediaPlaybackItem_remove_AudioTracksChanged), METH_O, nullptr },
        { "add_timed_metadata_tracks_changed", reinterpret_cast<PyCFunction>(MediaPlaybackItem_add_TimedMetadataTracksChanged), METH_O, nullptr },
        { "remove_timed_metadata_tracks_changed", reinterpret_cast<PyCFunction>(MediaPlaybackItem_remove_TimedMetadataTracksChanged), METH_O, nullptr },
        { "add_video_tracks_changed", reinterpret_cast<PyCFunction>(MediaPlaybackItem_add_VideoTracksChanged), METH_O, nullptr },
        { "remove_video_tracks_changed", reinterpret_cast<PyCFunction>(MediaPlaybackItem_remove_VideoTracksChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackItem[] = {
        { "audio_tracks", reinterpret_cast<getter>(MediaPlaybackItem_get_AudioTracks), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(MediaPlaybackItem_get_Source), nullptr, nullptr, nullptr },
        { "timed_metadata_tracks", reinterpret_cast<getter>(MediaPlaybackItem_get_TimedMetadataTracks), nullptr, nullptr, nullptr },
        { "video_tracks", reinterpret_cast<getter>(MediaPlaybackItem_get_VideoTracks), nullptr, nullptr, nullptr },
        { "can_skip", reinterpret_cast<getter>(MediaPlaybackItem_get_CanSkip), reinterpret_cast<setter>(MediaPlaybackItem_put_CanSkip), nullptr, nullptr },
        { "break_schedule", reinterpret_cast<getter>(MediaPlaybackItem_get_BreakSchedule), nullptr, nullptr, nullptr },
        { "duration_limit", reinterpret_cast<getter>(MediaPlaybackItem_get_DurationLimit), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(MediaPlaybackItem_get_StartTime), nullptr, nullptr, nullptr },
        { "is_disabled_in_playback_list", reinterpret_cast<getter>(MediaPlaybackItem_get_IsDisabledInPlaybackList), reinterpret_cast<setter>(MediaPlaybackItem_put_IsDisabledInPlaybackList), nullptr, nullptr },
        { "auto_loaded_display_properties", reinterpret_cast<getter>(MediaPlaybackItem_get_AutoLoadedDisplayProperties), reinterpret_cast<setter>(MediaPlaybackItem_put_AutoLoadedDisplayProperties), nullptr, nullptr },
        { "total_download_progress", reinterpret_cast<getter>(MediaPlaybackItem_get_TotalDownloadProgress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackItem) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackItem =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackItem",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItem
    };

    static PyGetSetDef getset_MediaPlaybackItem_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaPlaybackItem_Static[] = {
        { "find_from_media_source", reinterpret_cast<PyCFunction>(MediaPlaybackItem_FindFromMediaSource), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaPlaybackItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaPlaybackItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaPlaybackItem_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaPlaybackItem_Static =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaPlaybackItem_Static
    };

    // ----- MediaPlaybackItemError class --------------------

    static PyObject* _new_MediaPlaybackItemError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackItemError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackItemError>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackItemError(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackItemError_get_ErrorCode(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItemError", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItemError_get_ExtendedError(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItemError", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackItemError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackItemError>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackItemError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItemError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItemError[] = {
        { "_assign_array_", _assign_array_MediaPlaybackItemError, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackItemError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackItemError[] = {
        { "error_code", reinterpret_cast<getter>(MediaPlaybackItemError_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(MediaPlaybackItemError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackItemError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackItemError) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackItemError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackItemError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackItemError) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackItemError =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackItemError",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItemError
    };

    // ----- MediaPlaybackItemFailedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackItemFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackItemFailedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackItemFailedEventArgs_get_Error(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItemFailedEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItemFailedEventArgs_get_Item(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItemFailedEventArgs", L"Item"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackItemFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackItemFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItemFailedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPlaybackItemFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackItemFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackItemFailedEventArgs[] = {
        { "error", reinterpret_cast<getter>(MediaPlaybackItemFailedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "item", reinterpret_cast<getter>(MediaPlaybackItemFailedEventArgs_get_Item), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackItemFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackItemFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackItemFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackItemFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackItemFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackItemFailedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackItemFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItemFailedEventArgs
    };

    // ----- MediaPlaybackItemOpenedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackItemOpenedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackItemOpenedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackItemOpenedEventArgs_get_Item(py::wrapper::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackItemOpenedEventArgs", L"Item"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackItemOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackItemOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItemOpenedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPlaybackItemOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackItemOpenedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackItemOpenedEventArgs[] = {
        { "item", reinterpret_cast<getter>(MediaPlaybackItemOpenedEventArgs_get_Item), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackItemOpenedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackItemOpenedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackItemOpenedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackItemOpenedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackItemOpenedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackItemOpenedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackItemOpenedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItemOpenedEventArgs
    };

    // ----- MediaPlaybackList class --------------------

    static PyObject* _new_MediaPlaybackList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Playback::MediaPlaybackList instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlaybackList(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackList_MoveNext(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MoveNext", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_MovePrevious(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MovePrevious", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MovePrevious());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_MoveTo(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MoveTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.MoveTo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_SetShuffledItems(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackList", L"SetShuffledItems", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Playback::MediaPlaybackItem>>(args, 0);

                self->obj.SetShuffledItems(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_ShuffleEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ShuffleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_ShuffleEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ShuffleEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShuffleEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_AutoRepeatEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"AutoRepeatEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoRepeatEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_AutoRepeatEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"AutoRepeatEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoRepeatEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_CurrentItem(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"CurrentItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_CurrentItemIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"CurrentItemIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentItemIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_Items(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_StartingItem(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"StartingItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartingItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_StartingItem(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"StartingItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaPlaybackItem>(arg);

            self->obj.StartingItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_MaxPrefetchTime(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MaxPrefetchTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPrefetchTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_MaxPrefetchTime(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MaxPrefetchTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MaxPrefetchTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_ShuffledItems(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ShuffledItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShuffledItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_MaxPlayedItemsToKeepOpen(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MaxPlayedItemsToKeepOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPlayedItemsToKeepOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_MaxPlayedItemsToKeepOpen(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackList", L"MaxPlayedItemsToKeepOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.MaxPlayedItemsToKeepOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_add_CurrentItemChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackList", L"CurrentItemChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackList, winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>>(arg);

            return py::convert(self->obj.CurrentItemChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_remove_CurrentItemChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackList", L"CurrentItemChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentItemChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_add_ItemFailed(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ItemFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackList, winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>>(arg);

            return py::convert(self->obj.ItemFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_remove_ItemFailed(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ItemFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_add_ItemOpened(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ItemOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackList, winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>>(arg);

            return py::convert(self->obj.ItemOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_remove_ItemOpened(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackList", L"ItemOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackList[] = {
        { "move_next", reinterpret_cast<PyCFunction>(MediaPlaybackList_MoveNext), METH_VARARGS, nullptr },
        { "move_previous", reinterpret_cast<PyCFunction>(MediaPlaybackList_MovePrevious), METH_VARARGS, nullptr },
        { "move_to", reinterpret_cast<PyCFunction>(MediaPlaybackList_MoveTo), METH_VARARGS, nullptr },
        { "set_shuffled_items", reinterpret_cast<PyCFunction>(MediaPlaybackList_SetShuffledItems), METH_VARARGS, nullptr },
        { "add_current_item_changed", reinterpret_cast<PyCFunction>(MediaPlaybackList_add_CurrentItemChanged), METH_O, nullptr },
        { "remove_current_item_changed", reinterpret_cast<PyCFunction>(MediaPlaybackList_remove_CurrentItemChanged), METH_O, nullptr },
        { "add_item_failed", reinterpret_cast<PyCFunction>(MediaPlaybackList_add_ItemFailed), METH_O, nullptr },
        { "remove_item_failed", reinterpret_cast<PyCFunction>(MediaPlaybackList_remove_ItemFailed), METH_O, nullptr },
        { "add_item_opened", reinterpret_cast<PyCFunction>(MediaPlaybackList_add_ItemOpened), METH_O, nullptr },
        { "remove_item_opened", reinterpret_cast<PyCFunction>(MediaPlaybackList_remove_ItemOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackList[] = {
        { "shuffle_enabled", reinterpret_cast<getter>(MediaPlaybackList_get_ShuffleEnabled), reinterpret_cast<setter>(MediaPlaybackList_put_ShuffleEnabled), nullptr, nullptr },
        { "auto_repeat_enabled", reinterpret_cast<getter>(MediaPlaybackList_get_AutoRepeatEnabled), reinterpret_cast<setter>(MediaPlaybackList_put_AutoRepeatEnabled), nullptr, nullptr },
        { "current_item", reinterpret_cast<getter>(MediaPlaybackList_get_CurrentItem), nullptr, nullptr, nullptr },
        { "current_item_index", reinterpret_cast<getter>(MediaPlaybackList_get_CurrentItemIndex), nullptr, nullptr, nullptr },
        { "items", reinterpret_cast<getter>(MediaPlaybackList_get_Items), nullptr, nullptr, nullptr },
        { "starting_item", reinterpret_cast<getter>(MediaPlaybackList_get_StartingItem), reinterpret_cast<setter>(MediaPlaybackList_put_StartingItem), nullptr, nullptr },
        { "max_prefetch_time", reinterpret_cast<getter>(MediaPlaybackList_get_MaxPrefetchTime), reinterpret_cast<setter>(MediaPlaybackList_put_MaxPrefetchTime), nullptr, nullptr },
        { "shuffled_items", reinterpret_cast<getter>(MediaPlaybackList_get_ShuffledItems), nullptr, nullptr, nullptr },
        { "max_played_items_to_keep_open", reinterpret_cast<getter>(MediaPlaybackList_get_MaxPlayedItemsToKeepOpen), reinterpret_cast<setter>(MediaPlaybackList_put_MaxPlayedItemsToKeepOpen), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackList) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackList =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackList
    };

    // ----- MediaPlaybackSession class --------------------

    static PyObject* _new_MediaPlaybackSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSession>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSession(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackSession_GetBufferedRanges(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"GetBufferedRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetBufferedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_GetOutputDegradationPolicyState(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"GetOutputDegradationPolicyState", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetOutputDegradationPolicyState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_GetPlayedRanges(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"GetPlayedRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPlayedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_GetSeekableRanges(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"GetSeekableRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSeekableRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_IsSupportedPlaybackRateRange(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"IsSupportedPlaybackRateRange", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.IsSupportedPlaybackRateRange(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"StereoscopicVideoPackingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StereoscopicVideoPackingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"StereoscopicVideoPackingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::StereoscopicVideoPackingMode>(arg);

            self->obj.StereoscopicVideoPackingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_Position(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_Position(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_NormalizedSourceRect(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NormalizedSourceRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedSourceRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_NormalizedSourceRect(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NormalizedSourceRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.NormalizedSourceRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_BufferingProgress(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BufferingProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_CanPause(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"CanPause"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanPause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_CanSeek(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"CanSeek"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_DownloadProgress(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"DownloadProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DownloadProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_IsProtected(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"IsProtected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"MediaPlayer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_NaturalDuration(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_NaturalVideoHeight(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalVideoHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalVideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_NaturalVideoWidth(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalVideoWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalVideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_PlaybackState(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_IsMirroring(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"IsMirroring"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMirroring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_IsMirroring(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"IsMirroring"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMirroring(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_SphericalVideoProjection(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SphericalVideoProjection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SphericalVideoProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_PlaybackRotation(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackRotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackRotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_PlaybackRotation(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackRotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaRotation>(arg);

            self->obj.PlaybackRotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferingProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingProgressChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingProgressChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferingProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingProgressChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingProgressChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferingStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_DownloadProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"DownloadProgressChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DownloadProgressChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_DownloadProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"DownloadProgressChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadProgressChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_NaturalDurationChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalDurationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NaturalDurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_NaturalDurationChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalDurationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NaturalDurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_NaturalVideoSizeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalVideoSizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NaturalVideoSizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_NaturalVideoSizeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"NaturalVideoSizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NaturalVideoSizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PlaybackRateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackRateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlaybackRateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PlaybackRateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackRateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackRateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PlaybackStateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlaybackStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PlaybackStateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlaybackStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PositionChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PositionChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SeekCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SeekCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SeekCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SeekCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferedRangesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferedRangesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"BufferedRangesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferedRangesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PlayedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlayedRangesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlayedRangesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PlayedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"PlayedRangesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlayedRangesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_SeekableRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SeekableRangesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SeekableRangesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_SeekableRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SeekableRangesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SeekableRangesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_SupportedPlaybackRatesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SupportedPlaybackRatesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SupportedPlaybackRatesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_SupportedPlaybackRatesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackSession", L"SupportedPlaybackRatesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SupportedPlaybackRatesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSession[] = {
        { "get_buffered_ranges", reinterpret_cast<PyCFunction>(MediaPlaybackSession_GetBufferedRanges), METH_VARARGS, nullptr },
        { "get_output_degradation_policy_state", reinterpret_cast<PyCFunction>(MediaPlaybackSession_GetOutputDegradationPolicyState), METH_VARARGS, nullptr },
        { "get_played_ranges", reinterpret_cast<PyCFunction>(MediaPlaybackSession_GetPlayedRanges), METH_VARARGS, nullptr },
        { "get_seekable_ranges", reinterpret_cast<PyCFunction>(MediaPlaybackSession_GetSeekableRanges), METH_VARARGS, nullptr },
        { "is_supported_playback_rate_range", reinterpret_cast<PyCFunction>(MediaPlaybackSession_IsSupportedPlaybackRateRange), METH_VARARGS, nullptr },
        { "add_buffering_ended", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_BufferingEnded), METH_O, nullptr },
        { "remove_buffering_ended", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_BufferingEnded), METH_O, nullptr },
        { "add_buffering_progress_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_BufferingProgressChanged), METH_O, nullptr },
        { "remove_buffering_progress_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_BufferingProgressChanged), METH_O, nullptr },
        { "add_buffering_started", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_BufferingStarted), METH_O, nullptr },
        { "remove_buffering_started", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_BufferingStarted), METH_O, nullptr },
        { "add_download_progress_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_DownloadProgressChanged), METH_O, nullptr },
        { "remove_download_progress_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_DownloadProgressChanged), METH_O, nullptr },
        { "add_natural_duration_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_NaturalDurationChanged), METH_O, nullptr },
        { "remove_natural_duration_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_NaturalDurationChanged), METH_O, nullptr },
        { "add_natural_video_size_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_NaturalVideoSizeChanged), METH_O, nullptr },
        { "remove_natural_video_size_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_NaturalVideoSizeChanged), METH_O, nullptr },
        { "add_playback_rate_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_PlaybackRateChanged), METH_O, nullptr },
        { "remove_playback_rate_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_PlaybackRateChanged), METH_O, nullptr },
        { "add_playback_state_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_PlaybackStateChanged), METH_O, nullptr },
        { "remove_playback_state_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_PlaybackStateChanged), METH_O, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_PositionChanged), METH_O, nullptr },
        { "add_seek_completed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_SeekCompleted), METH_O, nullptr },
        { "remove_seek_completed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_SeekCompleted), METH_O, nullptr },
        { "add_buffered_ranges_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_BufferedRangesChanged), METH_O, nullptr },
        { "remove_buffered_ranges_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_BufferedRangesChanged), METH_O, nullptr },
        { "add_played_ranges_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_PlayedRangesChanged), METH_O, nullptr },
        { "remove_played_ranges_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_PlayedRangesChanged), METH_O, nullptr },
        { "add_seekable_ranges_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_SeekableRangesChanged), METH_O, nullptr },
        { "remove_seekable_ranges_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_SeekableRangesChanged), METH_O, nullptr },
        { "add_supported_playback_rates_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_add_SupportedPlaybackRatesChanged), METH_O, nullptr },
        { "remove_supported_playback_rates_changed", reinterpret_cast<PyCFunction>(MediaPlaybackSession_remove_SupportedPlaybackRatesChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackSession[] = {
        { "stereoscopic_video_packing_mode", reinterpret_cast<getter>(MediaPlaybackSession_get_StereoscopicVideoPackingMode), reinterpret_cast<setter>(MediaPlaybackSession_put_StereoscopicVideoPackingMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaPlaybackSession_get_Position), reinterpret_cast<setter>(MediaPlaybackSession_put_Position), nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(MediaPlaybackSession_get_PlaybackRate), reinterpret_cast<setter>(MediaPlaybackSession_put_PlaybackRate), nullptr, nullptr },
        { "normalized_source_rect", reinterpret_cast<getter>(MediaPlaybackSession_get_NormalizedSourceRect), reinterpret_cast<setter>(MediaPlaybackSession_put_NormalizedSourceRect), nullptr, nullptr },
        { "buffering_progress", reinterpret_cast<getter>(MediaPlaybackSession_get_BufferingProgress), nullptr, nullptr, nullptr },
        { "can_pause", reinterpret_cast<getter>(MediaPlaybackSession_get_CanPause), nullptr, nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(MediaPlaybackSession_get_CanSeek), nullptr, nullptr, nullptr },
        { "download_progress", reinterpret_cast<getter>(MediaPlaybackSession_get_DownloadProgress), nullptr, nullptr, nullptr },
        { "is_protected", reinterpret_cast<getter>(MediaPlaybackSession_get_IsProtected), nullptr, nullptr, nullptr },
        { "media_player", reinterpret_cast<getter>(MediaPlaybackSession_get_MediaPlayer), nullptr, nullptr, nullptr },
        { "natural_duration", reinterpret_cast<getter>(MediaPlaybackSession_get_NaturalDuration), nullptr, nullptr, nullptr },
        { "natural_video_height", reinterpret_cast<getter>(MediaPlaybackSession_get_NaturalVideoHeight), nullptr, nullptr, nullptr },
        { "natural_video_width", reinterpret_cast<getter>(MediaPlaybackSession_get_NaturalVideoWidth), nullptr, nullptr, nullptr },
        { "playback_state", reinterpret_cast<getter>(MediaPlaybackSession_get_PlaybackState), nullptr, nullptr, nullptr },
        { "is_mirroring", reinterpret_cast<getter>(MediaPlaybackSession_get_IsMirroring), reinterpret_cast<setter>(MediaPlaybackSession_put_IsMirroring), nullptr, nullptr },
        { "spherical_video_projection", reinterpret_cast<getter>(MediaPlaybackSession_get_SphericalVideoProjection), nullptr, nullptr, nullptr },
        { "playback_rotation", reinterpret_cast<getter>(MediaPlaybackSession_get_PlaybackRotation), reinterpret_cast<setter>(MediaPlaybackSession_put_PlaybackRotation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackSession) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackSession =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackSession",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSession
    };

    // ----- MediaPlaybackSessionBufferingStartedEventArgs class --------------------

    static PyObject* _new_MediaPlaybackSessionBufferingStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSessionBufferingStartedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackSessionBufferingStartedEventArgs_get_IsPlaybackInterruption(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSessionBufferingStartedEventArgs", L"IsPlaybackInterruption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlaybackInterruption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackSessionBufferingStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackSessionBufferingStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSessionBufferingStartedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPlaybackSessionBufferingStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackSessionBufferingStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackSessionBufferingStartedEventArgs[] = {
        { "is_playback_interruption", reinterpret_cast<getter>(MediaPlaybackSessionBufferingStartedEventArgs_get_IsPlaybackInterruption), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackSessionBufferingStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackSessionBufferingStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackSessionBufferingStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackSessionBufferingStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackSessionBufferingStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackSessionBufferingStartedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackSessionBufferingStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSessionBufferingStartedEventArgs
    };

    // ----- MediaPlaybackSessionOutputDegradationPolicyState class --------------------

    static PyObject* _new_MediaPlaybackSessionOutputDegradationPolicyState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSessionOutputDegradationPolicyState(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackSessionOutputDegradationPolicyState_get_VideoConstrictionReason(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSessionOutputDegradationPolicyState", L"VideoConstrictionReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoConstrictionReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackSessionOutputDegradationPolicyState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackSessionOutputDegradationPolicyState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSessionOutputDegradationPolicyState[] = {
        { "_assign_array_", _assign_array_MediaPlaybackSessionOutputDegradationPolicyState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackSessionOutputDegradationPolicyState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackSessionOutputDegradationPolicyState[] = {
        { "video_constriction_reason", reinterpret_cast<getter>(MediaPlaybackSessionOutputDegradationPolicyState_get_VideoConstrictionReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackSessionOutputDegradationPolicyState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackSessionOutputDegradationPolicyState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackSessionOutputDegradationPolicyState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackSessionOutputDegradationPolicyState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackSessionOutputDegradationPolicyState) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackSessionOutputDegradationPolicyState =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackSessionOutputDegradationPolicyState",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSessionOutputDegradationPolicyState
    };

    // ----- MediaPlaybackSphericalVideoProjection class --------------------

    static PyObject* _new_MediaPlaybackSphericalVideoProjection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSphericalVideoProjection(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_ViewOrientation(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"ViewOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_ViewOrientation(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"ViewOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.ViewOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_ProjectionMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"ProjectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProjectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_ProjectionMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"ProjectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::SphericalVideoProjectionMode>(arg);

            self->obj.ProjectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"HorizontalFieldOfViewInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalFieldOfViewInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"HorizontalFieldOfViewInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalFieldOfViewInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_FrameFormat(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"FrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_FrameFormat(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackSphericalVideoProjection", L"FrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat>(arg);

            self->obj.FrameFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaPlaybackSphericalVideoProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackSphericalVideoProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSphericalVideoProjection[] = {
        { "_assign_array_", _assign_array_MediaPlaybackSphericalVideoProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackSphericalVideoProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackSphericalVideoProjection[] = {
        { "view_orientation", reinterpret_cast<getter>(MediaPlaybackSphericalVideoProjection_get_ViewOrientation), reinterpret_cast<setter>(MediaPlaybackSphericalVideoProjection_put_ViewOrientation), nullptr, nullptr },
        { "projection_mode", reinterpret_cast<getter>(MediaPlaybackSphericalVideoProjection_get_ProjectionMode), reinterpret_cast<setter>(MediaPlaybackSphericalVideoProjection_put_ProjectionMode), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MediaPlaybackSphericalVideoProjection_get_IsEnabled), reinterpret_cast<setter>(MediaPlaybackSphericalVideoProjection_put_IsEnabled), nullptr, nullptr },
        { "horizontal_field_of_view_in_degrees", reinterpret_cast<getter>(MediaPlaybackSphericalVideoProjection_get_HorizontalFieldOfViewInDegrees), reinterpret_cast<setter>(MediaPlaybackSphericalVideoProjection_put_HorizontalFieldOfViewInDegrees), nullptr, nullptr },
        { "frame_format", reinterpret_cast<getter>(MediaPlaybackSphericalVideoProjection_get_FrameFormat), reinterpret_cast<setter>(MediaPlaybackSphericalVideoProjection_put_FrameFormat), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackSphericalVideoProjection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackSphericalVideoProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackSphericalVideoProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackSphericalVideoProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackSphericalVideoProjection) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackSphericalVideoProjection =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackSphericalVideoProjection",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSphericalVideoProjection
    };

    // ----- MediaPlaybackTimedMetadataTrackList class --------------------

    static PyObject* _new_MediaPlaybackTimedMetadataTrackList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_First(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_GetAt(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_GetMany(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Core::TimedMetadataTrack, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_GetPresentationMode(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"GetPresentationMode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetPresentationMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_IndexOf(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataTrack>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_SetPresentationMode(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"SetPresentationMode", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Playback::TimedMetadataTrackPresentationMode>(args, 1);

                self->obj.SetPresentationMode(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_get_Size(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_add_PresentationModeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"PresentationModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList, winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>>(arg);

            return py::convert(self->obj.PresentationModeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_remove_PresentationModeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList", L"PresentationModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PresentationModeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackTimedMetadataTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackTimedMetadataTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_MediaPlaybackTimedMetadataTrackList(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Media::Core::TimedMetadataTrack> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Media::Core::TimedMetadataTrack>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackTimedMetadataTrackList[] = {
        { "first", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_GetMany), METH_VARARGS, nullptr },
        { "get_presentation_mode", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_GetPresentationMode), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_IndexOf), METH_VARARGS, nullptr },
        { "set_presentation_mode", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_SetPresentationMode), METH_VARARGS, nullptr },
        { "add_presentation_mode_changed", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_add_PresentationModeChanged), METH_O, nullptr },
        { "remove_presentation_mode_changed", reinterpret_cast<PyCFunction>(MediaPlaybackTimedMetadataTrackList_remove_PresentationModeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackTimedMetadataTrackList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackTimedMetadataTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackTimedMetadataTrackList[] = {
        { "size", reinterpret_cast<getter>(MediaPlaybackTimedMetadataTrackList_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackTimedMetadataTrackList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackTimedMetadataTrackList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackTimedMetadataTrackList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackTimedMetadataTrackList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackTimedMetadataTrackList) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaPlaybackTimedMetadataTrackList) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_MediaPlaybackTimedMetadataTrackList) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_MediaPlaybackTimedMetadataTrackList) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_MediaPlaybackTimedMetadataTrackList) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackTimedMetadataTrackList =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackTimedMetadataTrackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackTimedMetadataTrackList
    };

    // ----- MediaPlaybackVideoTrackList class --------------------

    static PyObject* _new_MediaPlaybackVideoTrackList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlaybackVideoTrackList_First(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_GetAt(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_GetMany(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Media::Core::VideoTrack, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_IndexOf(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::VideoTrack>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_get_Size(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackVideoTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"SelectedIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlaybackVideoTrackList", L"SelectedIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlaybackVideoTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlaybackVideoTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_MediaPlaybackVideoTrackList(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Media::Core::VideoTrack> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Media::Core::VideoTrack>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackVideoTrackList[] = {
        { "first", reinterpret_cast<PyCFunction>(MediaPlaybackVideoTrackList_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(MediaPlaybackVideoTrackList_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(MediaPlaybackVideoTrackList_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(MediaPlaybackVideoTrackList_IndexOf), METH_VARARGS, nullptr },
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(MediaPlaybackVideoTrackList_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(MediaPlaybackVideoTrackList_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlaybackVideoTrackList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlaybackVideoTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlaybackVideoTrackList[] = {
        { "size", reinterpret_cast<getter>(MediaPlaybackVideoTrackList_get_Size), nullptr, nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(MediaPlaybackVideoTrackList_get_SelectedIndex), reinterpret_cast<setter>(MediaPlaybackVideoTrackList_put_SelectedIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlaybackVideoTrackList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlaybackVideoTrackList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlaybackVideoTrackList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlaybackVideoTrackList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlaybackVideoTrackList) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaPlaybackVideoTrackList) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_MediaPlaybackVideoTrackList) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_MediaPlaybackVideoTrackList) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_MediaPlaybackVideoTrackList) },
        { },
    };

    static PyType_Spec type_spec_MediaPlaybackVideoTrackList =
    {
        "winrt._winrt_windows_media_playback.MediaPlaybackVideoTrackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackVideoTrackList
    };

    // ----- MediaPlayer class --------------------

    static PyObject* _new_MediaPlayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Playback::MediaPlayer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlayer_AddAudioEffect(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"AddAudioEffect", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.AddAudioEffect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_AddVideoEffect(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"AddVideoEffect", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.AddVideoEffect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_Close(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_CopyFrameToStereoscopicVideoSurfaces(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"CopyFrameToStereoscopicVideoSurfaces", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 1);

                self->obj.CopyFrameToStereoscopicVideoSurfaces(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_CopyFrameToVideoSurface(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"CopyFrameToVideoSurface", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                self->obj.CopyFrameToVideoSurface(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"CopyFrameToVideoSurface", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                self->obj.CopyFrameToVideoSurface(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_GetAsCastingSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"GetAsCastingSource", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAsCastingSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_GetSurface(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"GetSurface", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(self->obj.GetSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_Pause(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_Play(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"Play", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Play();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_RemoveAllEffects(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"RemoveAllEffects", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAllEffects();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_RenderSubtitlesToSurface(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"RenderSubtitlesToSurface", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(self->obj.RenderSubtitlesToSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"RenderSubtitlesToSurface", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.RenderSubtitlesToSurface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetFileSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"SetFileSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetFileSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetMediaSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"SetMediaSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                self->obj.SetMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetStreamSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"SetStreamSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                self->obj.SetStreamSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetSurfaceSize(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"SetSurfaceSize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.SetSurfaceSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetUriSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"SetUriSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUriSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_StepBackwardOneFrame(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"StepBackwardOneFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StepBackwardOneFrame();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_StepForwardOneFrame(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayer", L"StepForwardOneFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StepForwardOneFrame();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_Volume(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_Volume(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Volume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_Position(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_Position(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"PlaybackRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_IsLoopingEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsLoopingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLoopingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_IsLoopingEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsLoopingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLoopingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_IsMuted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_IsMuted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AutoPlay(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AutoPlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AutoPlay(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AutoPlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoPlay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_CurrentState(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"CurrentState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_NaturalDuration(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"NaturalDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_PlaybackMediaMarkers(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"PlaybackMediaMarkers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackMediaMarkers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_IsProtected(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsProtected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_BufferingProgress(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"BufferingProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BufferingProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_CanPause(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"CanPause"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanPause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_CanSeek(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"CanSeek"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_AudioDeviceType(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioDeviceType(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaPlayerAudioDeviceType>(arg);

            self->obj.AudioDeviceType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioCategory(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioCategory(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaPlayerAudioCategory>(arg);

            self->obj.AudioCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_SystemMediaTransportControls(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"SystemMediaTransportControls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemMediaTransportControls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_TimelineControllerPositionOffset(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"TimelineControllerPositionOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimelineControllerPositionOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_TimelineControllerPositionOffset(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"TimelineControllerPositionOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimelineControllerPositionOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_TimelineController(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"TimelineController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimelineController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_TimelineController(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"TimelineController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaTimelineController>(arg);

            self->obj.TimelineController(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_StereoscopicVideoRenderMode(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"StereoscopicVideoRenderMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StereoscopicVideoRenderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_StereoscopicVideoRenderMode(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"StereoscopicVideoRenderMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::StereoscopicVideoRenderMode>(arg);

            self->obj.StereoscopicVideoRenderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_RealTimePlayback(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"RealTimePlayback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RealTimePlayback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_RealTimePlayback(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"RealTimePlayback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RealTimePlayback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioDevice(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioDevice(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            self->obj.AudioDevice(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioBalance(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioBalance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioBalance(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioBalance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.AudioBalance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_CommandManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"CommandManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_BreakManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"BreakManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BreakManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_PlaybackSession(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"PlaybackSession"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_IsVideoFrameServerEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsVideoFrameServerEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoFrameServerEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_IsVideoFrameServerEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"IsVideoFrameServerEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVideoFrameServerEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioStateMonitor(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"AudioStateMonitor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioStateMonitor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_ProtectionManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"ProtectionManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_ProtectionManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"ProtectionManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.ProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_Source(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_Source(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayer", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::IMediaPlaybackSource>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_add_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"BufferingEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"BufferingEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"BufferingStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"BufferingStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_CurrentStateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"CurrentStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CurrentStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_CurrentStateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"CurrentStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaFailed(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>>(arg);

            return py::convert(self->obj.MediaFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaFailed(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaOpened(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaOpened(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaPlayerRateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaPlayerRateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>>(arg);

            return py::convert(self->obj.MediaPlayerRateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaPlayerRateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"MediaPlayerRateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaPlayerRateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_PlaybackMediaMarkerReached(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"PlaybackMediaMarkerReached"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackMediaMarkerReached(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_PlaybackMediaMarkerReached(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"PlaybackMediaMarkerReached"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackMediaMarkerReached(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"SeekCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SeekCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"SeekCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SeekCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_VolumeChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"VolumeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VolumeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_VolumeChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"VolumeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VolumeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_IsMutedChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_IsMutedChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_SourceChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"SourceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_SourceChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"SourceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_VideoFrameAvailable(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"VideoFrameAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoFrameAvailable(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_VideoFrameAvailable(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"VideoFrameAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoFrameAvailable(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_SubtitleFrameChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"SubtitleFrameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SubtitleFrameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_SubtitleFrameChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Playback.MediaPlayer", L"SubtitleFrameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SubtitleFrameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayer[] = {
        { "add_audio_effect", reinterpret_cast<PyCFunction>(MediaPlayer_AddAudioEffect), METH_VARARGS, nullptr },
        { "add_video_effect", reinterpret_cast<PyCFunction>(MediaPlayer_AddVideoEffect), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaPlayer_Close), METH_VARARGS, nullptr },
        { "copy_frame_to_stereoscopic_video_surfaces", reinterpret_cast<PyCFunction>(MediaPlayer_CopyFrameToStereoscopicVideoSurfaces), METH_VARARGS, nullptr },
        { "copy_frame_to_video_surface", reinterpret_cast<PyCFunction>(MediaPlayer_CopyFrameToVideoSurface), METH_VARARGS, nullptr },
        { "get_as_casting_source", reinterpret_cast<PyCFunction>(MediaPlayer_GetAsCastingSource), METH_VARARGS, nullptr },
        { "get_surface", reinterpret_cast<PyCFunction>(MediaPlayer_GetSurface), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(MediaPlayer_Pause), METH_VARARGS, nullptr },
        { "play", reinterpret_cast<PyCFunction>(MediaPlayer_Play), METH_VARARGS, nullptr },
        { "remove_all_effects", reinterpret_cast<PyCFunction>(MediaPlayer_RemoveAllEffects), METH_VARARGS, nullptr },
        { "render_subtitles_to_surface", reinterpret_cast<PyCFunction>(MediaPlayer_RenderSubtitlesToSurface), METH_VARARGS, nullptr },
        { "set_file_source", reinterpret_cast<PyCFunction>(MediaPlayer_SetFileSource), METH_VARARGS, nullptr },
        { "set_media_source", reinterpret_cast<PyCFunction>(MediaPlayer_SetMediaSource), METH_VARARGS, nullptr },
        { "set_stream_source", reinterpret_cast<PyCFunction>(MediaPlayer_SetStreamSource), METH_VARARGS, nullptr },
        { "set_surface_size", reinterpret_cast<PyCFunction>(MediaPlayer_SetSurfaceSize), METH_VARARGS, nullptr },
        { "set_uri_source", reinterpret_cast<PyCFunction>(MediaPlayer_SetUriSource), METH_VARARGS, nullptr },
        { "step_backward_one_frame", reinterpret_cast<PyCFunction>(MediaPlayer_StepBackwardOneFrame), METH_VARARGS, nullptr },
        { "step_forward_one_frame", reinterpret_cast<PyCFunction>(MediaPlayer_StepForwardOneFrame), METH_VARARGS, nullptr },
        { "add_buffering_ended", reinterpret_cast<PyCFunction>(MediaPlayer_add_BufferingEnded), METH_O, nullptr },
        { "remove_buffering_ended", reinterpret_cast<PyCFunction>(MediaPlayer_remove_BufferingEnded), METH_O, nullptr },
        { "add_buffering_started", reinterpret_cast<PyCFunction>(MediaPlayer_add_BufferingStarted), METH_O, nullptr },
        { "remove_buffering_started", reinterpret_cast<PyCFunction>(MediaPlayer_remove_BufferingStarted), METH_O, nullptr },
        { "add_current_state_changed", reinterpret_cast<PyCFunction>(MediaPlayer_add_CurrentStateChanged), METH_O, nullptr },
        { "remove_current_state_changed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_CurrentStateChanged), METH_O, nullptr },
        { "add_media_ended", reinterpret_cast<PyCFunction>(MediaPlayer_add_MediaEnded), METH_O, nullptr },
        { "remove_media_ended", reinterpret_cast<PyCFunction>(MediaPlayer_remove_MediaEnded), METH_O, nullptr },
        { "add_media_failed", reinterpret_cast<PyCFunction>(MediaPlayer_add_MediaFailed), METH_O, nullptr },
        { "remove_media_failed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_MediaFailed), METH_O, nullptr },
        { "add_media_opened", reinterpret_cast<PyCFunction>(MediaPlayer_add_MediaOpened), METH_O, nullptr },
        { "remove_media_opened", reinterpret_cast<PyCFunction>(MediaPlayer_remove_MediaOpened), METH_O, nullptr },
        { "add_media_player_rate_changed", reinterpret_cast<PyCFunction>(MediaPlayer_add_MediaPlayerRateChanged), METH_O, nullptr },
        { "remove_media_player_rate_changed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_MediaPlayerRateChanged), METH_O, nullptr },
        { "add_playback_media_marker_reached", reinterpret_cast<PyCFunction>(MediaPlayer_add_PlaybackMediaMarkerReached), METH_O, nullptr },
        { "remove_playback_media_marker_reached", reinterpret_cast<PyCFunction>(MediaPlayer_remove_PlaybackMediaMarkerReached), METH_O, nullptr },
        { "add_seek_completed", reinterpret_cast<PyCFunction>(MediaPlayer_add_SeekCompleted), METH_O, nullptr },
        { "remove_seek_completed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_SeekCompleted), METH_O, nullptr },
        { "add_volume_changed", reinterpret_cast<PyCFunction>(MediaPlayer_add_VolumeChanged), METH_O, nullptr },
        { "remove_volume_changed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_VolumeChanged), METH_O, nullptr },
        { "add_is_muted_changed", reinterpret_cast<PyCFunction>(MediaPlayer_add_IsMutedChanged), METH_O, nullptr },
        { "remove_is_muted_changed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_IsMutedChanged), METH_O, nullptr },
        { "add_source_changed", reinterpret_cast<PyCFunction>(MediaPlayer_add_SourceChanged), METH_O, nullptr },
        { "remove_source_changed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_SourceChanged), METH_O, nullptr },
        { "add_video_frame_available", reinterpret_cast<PyCFunction>(MediaPlayer_add_VideoFrameAvailable), METH_O, nullptr },
        { "remove_video_frame_available", reinterpret_cast<PyCFunction>(MediaPlayer_remove_VideoFrameAvailable), METH_O, nullptr },
        { "add_subtitle_frame_changed", reinterpret_cast<PyCFunction>(MediaPlayer_add_SubtitleFrameChanged), METH_O, nullptr },
        { "remove_subtitle_frame_changed", reinterpret_cast<PyCFunction>(MediaPlayer_remove_SubtitleFrameChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaPlayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaPlayer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaPlayer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayer[] = {
        { "volume", reinterpret_cast<getter>(MediaPlayer_get_Volume), reinterpret_cast<setter>(MediaPlayer_put_Volume), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaPlayer_get_Position), reinterpret_cast<setter>(MediaPlayer_put_Position), nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(MediaPlayer_get_PlaybackRate), reinterpret_cast<setter>(MediaPlayer_put_PlaybackRate), nullptr, nullptr },
        { "is_looping_enabled", reinterpret_cast<getter>(MediaPlayer_get_IsLoopingEnabled), reinterpret_cast<setter>(MediaPlayer_put_IsLoopingEnabled), nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(MediaPlayer_get_IsMuted), reinterpret_cast<setter>(MediaPlayer_put_IsMuted), nullptr, nullptr },
        { "auto_play", reinterpret_cast<getter>(MediaPlayer_get_AutoPlay), reinterpret_cast<setter>(MediaPlayer_put_AutoPlay), nullptr, nullptr },
        { "current_state", reinterpret_cast<getter>(MediaPlayer_get_CurrentState), nullptr, nullptr, nullptr },
        { "natural_duration", reinterpret_cast<getter>(MediaPlayer_get_NaturalDuration), nullptr, nullptr, nullptr },
        { "playback_media_markers", reinterpret_cast<getter>(MediaPlayer_get_PlaybackMediaMarkers), nullptr, nullptr, nullptr },
        { "is_protected", reinterpret_cast<getter>(MediaPlayer_get_IsProtected), nullptr, nullptr, nullptr },
        { "buffering_progress", reinterpret_cast<getter>(MediaPlayer_get_BufferingProgress), nullptr, nullptr, nullptr },
        { "can_pause", reinterpret_cast<getter>(MediaPlayer_get_CanPause), nullptr, nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(MediaPlayer_get_CanSeek), nullptr, nullptr, nullptr },
        { "audio_device_type", reinterpret_cast<getter>(MediaPlayer_get_AudioDeviceType), reinterpret_cast<setter>(MediaPlayer_put_AudioDeviceType), nullptr, nullptr },
        { "audio_category", reinterpret_cast<getter>(MediaPlayer_get_AudioCategory), reinterpret_cast<setter>(MediaPlayer_put_AudioCategory), nullptr, nullptr },
        { "system_media_transport_controls", reinterpret_cast<getter>(MediaPlayer_get_SystemMediaTransportControls), nullptr, nullptr, nullptr },
        { "timeline_controller_position_offset", reinterpret_cast<getter>(MediaPlayer_get_TimelineControllerPositionOffset), reinterpret_cast<setter>(MediaPlayer_put_TimelineControllerPositionOffset), nullptr, nullptr },
        { "timeline_controller", reinterpret_cast<getter>(MediaPlayer_get_TimelineController), reinterpret_cast<setter>(MediaPlayer_put_TimelineController), nullptr, nullptr },
        { "stereoscopic_video_render_mode", reinterpret_cast<getter>(MediaPlayer_get_StereoscopicVideoRenderMode), reinterpret_cast<setter>(MediaPlayer_put_StereoscopicVideoRenderMode), nullptr, nullptr },
        { "real_time_playback", reinterpret_cast<getter>(MediaPlayer_get_RealTimePlayback), reinterpret_cast<setter>(MediaPlayer_put_RealTimePlayback), nullptr, nullptr },
        { "audio_device", reinterpret_cast<getter>(MediaPlayer_get_AudioDevice), reinterpret_cast<setter>(MediaPlayer_put_AudioDevice), nullptr, nullptr },
        { "audio_balance", reinterpret_cast<getter>(MediaPlayer_get_AudioBalance), reinterpret_cast<setter>(MediaPlayer_put_AudioBalance), nullptr, nullptr },
        { "command_manager", reinterpret_cast<getter>(MediaPlayer_get_CommandManager), nullptr, nullptr, nullptr },
        { "break_manager", reinterpret_cast<getter>(MediaPlayer_get_BreakManager), nullptr, nullptr, nullptr },
        { "playback_session", reinterpret_cast<getter>(MediaPlayer_get_PlaybackSession), nullptr, nullptr, nullptr },
        { "is_video_frame_server_enabled", reinterpret_cast<getter>(MediaPlayer_get_IsVideoFrameServerEnabled), reinterpret_cast<setter>(MediaPlayer_put_IsVideoFrameServerEnabled), nullptr, nullptr },
        { "audio_state_monitor", reinterpret_cast<getter>(MediaPlayer_get_AudioStateMonitor), nullptr, nullptr, nullptr },
        { "protection_manager", reinterpret_cast<getter>(MediaPlayer_get_ProtectionManager), reinterpret_cast<setter>(MediaPlayer_put_ProtectionManager), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(MediaPlayer_get_Source), reinterpret_cast<setter>(MediaPlayer_put_Source), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlayer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayer) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayer =
    {
        "winrt._winrt_windows_media_playback.MediaPlayer",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayer
    };

    // ----- MediaPlayerDataReceivedEventArgs class --------------------

    static PyObject* _new_MediaPlayerDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlayerDataReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlayerDataReceivedEventArgs_get_Data(py::wrapper::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerDataReceivedEventArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlayerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPlayerDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerDataReceivedEventArgs[] = {
        { "data", reinterpret_cast<getter>(MediaPlayerDataReceivedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayerDataReceivedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlayerDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerDataReceivedEventArgs
    };

    // ----- MediaPlayerFailedEventArgs class --------------------

    static PyObject* _new_MediaPlayerFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlayerFailedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlayerFailedEventArgs_get_Error(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerFailedEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerFailedEventArgs_get_ErrorMessage(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerFailedEventArgs", L"ErrorMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerFailedEventArgs_get_ExtendedErrorCode(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerFailedEventArgs", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlayerFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerFailedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPlayerFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerFailedEventArgs[] = {
        { "error", reinterpret_cast<getter>(MediaPlayerFailedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "error_message", reinterpret_cast<getter>(MediaPlayerFailedEventArgs_get_ErrorMessage), nullptr, nullptr, nullptr },
        { "extended_error_code", reinterpret_cast<getter>(MediaPlayerFailedEventArgs_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayerFailedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlayerFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerFailedEventArgs
    };

    // ----- MediaPlayerRateChangedEventArgs class --------------------

    static PyObject* _new_MediaPlayerRateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlayerRateChangedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlayerRateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlayerRateChangedEventArgs_get_NewRate(py::wrapper::Windows::Media::Playback::MediaPlayerRateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerRateChangedEventArgs", L"NewRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlayerRateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerRateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerRateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPlayerRateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerRateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerRateChangedEventArgs[] = {
        { "new_rate", reinterpret_cast<getter>(MediaPlayerRateChangedEventArgs_get_NewRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerRateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerRateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerRateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerRateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerRateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayerRateChangedEventArgs =
    {
        "winrt._winrt_windows_media_playback.MediaPlayerRateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerRateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerRateChangedEventArgs
    };

    // ----- MediaPlayerSurface class --------------------

    static PyObject* _new_MediaPlayerSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::MediaPlayerSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::MediaPlayerSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPlayerSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPlayerSurface_Close(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.MediaPlayerSurface", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayerSurface_get_CompositionSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerSurface", L"CompositionSurface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompositionSurface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerSurface_get_Compositor(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerSurface", L"Compositor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Compositor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerSurface_get_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.MediaPlayerSurface", L"MediaPlayer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPlayerSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::MediaPlayerSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaPlayerSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaPlayerSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerSurface[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaPlayerSurface_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPlayerSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerSurface), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaPlayerSurface), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaPlayerSurface), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerSurface[] = {
        { "composition_surface", reinterpret_cast<getter>(MediaPlayerSurface_get_CompositionSurface), nullptr, nullptr, nullptr },
        { "compositor", reinterpret_cast<getter>(MediaPlayerSurface_get_Compositor), nullptr, nullptr, nullptr },
        { "media_player", reinterpret_cast<getter>(MediaPlayerSurface_get_MediaPlayer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerSurface[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerSurface) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayerSurface =
    {
        "winrt._winrt_windows_media_playback.MediaPlayerSurface",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerSurface
    };

    // ----- PlaybackMediaMarker class --------------------

    static PyObject* _new_PlaybackMediaMarker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                winrt::Windows::Media::Playback::PlaybackMediaMarker instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::Playback::PlaybackMediaMarker instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlaybackMediaMarker(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaybackMediaMarker_get_MediaMarkerType(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.PlaybackMediaMarker", L"MediaMarkerType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaMarkerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarker_get_Text(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.PlaybackMediaMarker", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarker_get_Time(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.PlaybackMediaMarker", L"Time"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaybackMediaMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::PlaybackMediaMarker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackMediaMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::PlaybackMediaMarker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackMediaMarker[] = {
        { "_assign_array_", _assign_array_PlaybackMediaMarker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackMediaMarker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackMediaMarker[] = {
        { "media_marker_type", reinterpret_cast<getter>(PlaybackMediaMarker_get_MediaMarkerType), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(PlaybackMediaMarker_get_Text), nullptr, nullptr, nullptr },
        { "time", reinterpret_cast<getter>(PlaybackMediaMarker_get_Time), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaybackMediaMarker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackMediaMarker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackMediaMarker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackMediaMarker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackMediaMarker) },
        { },
    };

    static PyType_Spec type_spec_PlaybackMediaMarker =
    {
        "winrt._winrt_windows_media_playback.PlaybackMediaMarker",
        sizeof(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackMediaMarker
    };

    // ----- PlaybackMediaMarkerReachedEventArgs class --------------------

    static PyObject* _new_PlaybackMediaMarkerReachedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PlaybackMediaMarkerReachedEventArgs(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaybackMediaMarkerReachedEventArgs_get_PlaybackMediaMarker(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.PlaybackMediaMarkerReachedEventArgs", L"PlaybackMediaMarker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackMediaMarker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaybackMediaMarkerReachedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackMediaMarkerReachedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackMediaMarkerReachedEventArgs[] = {
        { "_assign_array_", _assign_array_PlaybackMediaMarkerReachedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackMediaMarkerReachedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackMediaMarkerReachedEventArgs[] = {
        { "playback_media_marker", reinterpret_cast<getter>(PlaybackMediaMarkerReachedEventArgs_get_PlaybackMediaMarker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaybackMediaMarkerReachedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackMediaMarkerReachedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackMediaMarkerReachedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackMediaMarkerReachedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackMediaMarkerReachedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PlaybackMediaMarkerReachedEventArgs =
    {
        "winrt._winrt_windows_media_playback.PlaybackMediaMarkerReachedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackMediaMarkerReachedEventArgs
    };

    // ----- PlaybackMediaMarkerSequence class --------------------

    static PyObject* _new_PlaybackMediaMarkerSequence(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>::type_name);
        return nullptr;
    }

    static void _dealloc_PlaybackMediaMarkerSequence(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaybackMediaMarkerSequence_Clear(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.PlaybackMediaMarkerSequence", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarkerSequence_First(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.PlaybackMediaMarkerSequence", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarkerSequence_Insert(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.PlaybackMediaMarkerSequence", L"Insert", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::PlaybackMediaMarker>(args, 0);

                self->obj.Insert(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarkerSequence_get_Size(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.PlaybackMediaMarkerSequence", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaybackMediaMarkerSequence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackMediaMarkerSequence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlaybackMediaMarkerSequence(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackMediaMarkerSequence[] = {
        { "clear", reinterpret_cast<PyCFunction>(PlaybackMediaMarkerSequence_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PlaybackMediaMarkerSequence_First), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(PlaybackMediaMarkerSequence_Insert), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PlaybackMediaMarkerSequence, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackMediaMarkerSequence), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackMediaMarkerSequence[] = {
        { "size", reinterpret_cast<getter>(PlaybackMediaMarkerSequence_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaybackMediaMarkerSequence[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackMediaMarkerSequence) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackMediaMarkerSequence) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackMediaMarkerSequence) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackMediaMarkerSequence) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PlaybackMediaMarkerSequence) },
        { },
    };

    static PyType_Spec type_spec_PlaybackMediaMarkerSequence =
    {
        "winrt._winrt_windows_media_playback.PlaybackMediaMarkerSequence",
        sizeof(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackMediaMarkerSequence
    };

    // ----- TimedMetadataPresentationModeChangedEventArgs class --------------------

    static PyObject* _new_TimedMetadataPresentationModeChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TimedMetadataPresentationModeChangedEventArgs(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataPresentationModeChangedEventArgs_get_NewPresentationMode(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs", L"NewPresentationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewPresentationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataPresentationModeChangedEventArgs_get_OldPresentationMode(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs", L"OldPresentationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldPresentationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataPresentationModeChangedEventArgs_get_Track(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs", L"Track"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataPresentationModeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataPresentationModeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataPresentationModeChangedEventArgs[] = {
        { "_assign_array_", _assign_array_TimedMetadataPresentationModeChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataPresentationModeChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataPresentationModeChangedEventArgs[] = {
        { "new_presentation_mode", reinterpret_cast<getter>(TimedMetadataPresentationModeChangedEventArgs_get_NewPresentationMode), nullptr, nullptr, nullptr },
        { "old_presentation_mode", reinterpret_cast<getter>(TimedMetadataPresentationModeChangedEventArgs_get_OldPresentationMode), nullptr, nullptr, nullptr },
        { "track", reinterpret_cast<getter>(TimedMetadataPresentationModeChangedEventArgs_get_Track), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataPresentationModeChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataPresentationModeChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataPresentationModeChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataPresentationModeChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataPresentationModeChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataPresentationModeChangedEventArgs =
    {
        "winrt._winrt_windows_media_playback.TimedMetadataPresentationModeChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataPresentationModeChangedEventArgs
    };

    // ----- IMediaEnginePlaybackSource interface --------------------

    static PyObject* _new_IMediaEnginePlaybackSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaEnginePlaybackSource(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaEnginePlaybackSource_SetPlaybackSource(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Playback.IMediaEnginePlaybackSource", L"SetPlaybackSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::IMediaPlaybackSource>(args, 0);

                self->obj.SetPlaybackSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaEnginePlaybackSource_get_CurrentItem(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Playback.IMediaEnginePlaybackSource", L"CurrentItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaEnginePlaybackSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaEnginePlaybackSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaEnginePlaybackSource[] = {
        { "set_playback_source", reinterpret_cast<PyCFunction>(IMediaEnginePlaybackSource_SetPlaybackSource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMediaEnginePlaybackSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaEnginePlaybackSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaEnginePlaybackSource[] = {
        { "current_item", reinterpret_cast<getter>(IMediaEnginePlaybackSource_get_CurrentItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaEnginePlaybackSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaEnginePlaybackSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaEnginePlaybackSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaEnginePlaybackSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaEnginePlaybackSource) },
        { },
    };

    static PyType_Spec type_spec_IMediaEnginePlaybackSource =
    {
        "winrt._winrt_windows_media_playback.IMediaEnginePlaybackSource",
        sizeof(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaEnginePlaybackSource
    };

    // ----- IMediaPlaybackSource interface --------------------

    static PyObject* _new_IMediaPlaybackSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Playback::IMediaPlaybackSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Playback::IMediaPlaybackSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaPlaybackSource(py::wrapper::Windows::Media::Playback::IMediaPlaybackSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IMediaPlaybackSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Playback::IMediaPlaybackSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaPlaybackSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::IMediaPlaybackSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaPlaybackSource[] = {
        { "_assign_array_", _assign_array_IMediaPlaybackSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaPlaybackSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaPlaybackSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaPlaybackSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaPlaybackSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaPlaybackSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaPlaybackSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaPlaybackSource) },
        { },
    };

    static PyType_Spec type_spec_IMediaPlaybackSource =
    {
        "winrt._winrt_windows_media_playback.IMediaPlaybackSource",
        sizeof(py::wrapper::Windows::Media::Playback::IMediaPlaybackSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaPlaybackSource
    };

    // ----- Windows.Media.Playback Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Playback");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_playback",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Playback

PyMODINIT_FUNC PyInit__winrt_windows_media_playback(void) noexcept
{
    using namespace py::cpp::Windows::Media::Playback;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundMediaPlayer_Static{PyType_FromSpec(&type_spec_BackgroundMediaPlayer_Static)};
    if (!type_BackgroundMediaPlayer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundMediaPlayer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundMediaPlayer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CurrentMediaPlaybackItemChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreak, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreakEndedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreakManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreakSchedule, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreakSeekedOverEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreakSkippedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaBreakStartedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaItemDisplayProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackAudioTrackList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerCommandBehavior, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerFastForwardReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerNextReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerPauseReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerPlayReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerPositionReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerPreviousReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerRateReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerRewindReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackCommandManagerShuffleReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaPlaybackItem_Static{PyType_FromSpec(&type_spec_MediaPlaybackItem_Static)};
    if (!type_MediaPlaybackItem_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaPlaybackItem_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackItemError, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackItemFailedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackItemOpenedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackSessionBufferingStartedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackSessionOutputDegradationPolicyState, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackSphericalVideoProjection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackTimedMetadataTrackList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlaybackVideoTrackList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlayer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlayerDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlayerFailedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlayerRateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPlayerSurface, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlaybackMediaMarker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlaybackMediaMarkerReachedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlaybackMediaMarkerSequence, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TimedMetadataPresentationModeChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMediaEnginePlaybackSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMediaPlaybackSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
