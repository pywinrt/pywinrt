// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.Devices.Usb.h"


namespace py::cpp::Windows::Devices::Usb
{
    // ----- UsbBulkInEndpointDescriptor class --------------------

    static PyObject* _new_UsbBulkInEndpointDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbBulkInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbBulkInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInEndpointDescriptor[] = {
        { "_assign_array_", _assign_array_UsbBulkInEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkInEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkInEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkInEndpointDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbBulkInEndpointDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbBulkInEndpointDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbBulkInEndpointDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbBulkInEndpointDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbBulkInEndpointDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbBulkInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInEndpointDescriptor
    };

    // ----- UsbBulkInPipe class --------------------

    static PyObject* _new_UsbBulkInPipe(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbBulkInPipe(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"ClearStallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_FlushBuffer(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"FlushBuffer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.FlushBuffer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"ReadOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkInPipe_put_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"ReadOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbReadOptions>(arg);

            self->obj.ReadOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_InputStream(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"InputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_MaxTransferSizeBytes(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"MaxTransferSizeBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxTransferSizeBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbBulkInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbBulkInPipe>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbBulkInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbBulkInPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "flush_buffer", reinterpret_cast<PyCFunction>(UsbBulkInPipe_FlushBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UsbBulkInPipe, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkInPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkInPipe[] = {
        { "read_options", reinterpret_cast<getter>(UsbBulkInPipe_get_ReadOptions), reinterpret_cast<setter>(UsbBulkInPipe_put_ReadOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbBulkInPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(UsbBulkInPipe_get_InputStream), nullptr, nullptr, nullptr },
        { "max_transfer_size_bytes", reinterpret_cast<getter>(UsbBulkInPipe_get_MaxTransferSizeBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkInPipe[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbBulkInPipe) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbBulkInPipe) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbBulkInPipe) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbBulkInPipe) },
        { },
    };

    static PyType_Spec type_spec_UsbBulkInPipe =
    {
        "winrt._winrt_windows_devices_usb.UsbBulkInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInPipe
    };

    // ----- UsbBulkOutEndpointDescriptor class --------------------

    static PyObject* _new_UsbBulkOutEndpointDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbBulkOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbBulkOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutEndpointDescriptor[] = {
        { "_assign_array_", _assign_array_UsbBulkOutEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkOutEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkOutEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkOutEndpointDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbBulkOutEndpointDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbBulkOutEndpointDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbBulkOutEndpointDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbBulkOutEndpointDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbBulkOutEndpointDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbBulkOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutEndpointDescriptor
    };

    // ----- UsbBulkOutPipe class --------------------

    static PyObject* _new_UsbBulkOutPipe(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutPipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"ClearStallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbBulkOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbBulkOutPipe>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbBulkOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbBulkOutPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UsbBulkOutPipe, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkOutPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkOutPipe[] = {
        { "write_options", reinterpret_cast<getter>(UsbBulkOutPipe_get_WriteOptions), reinterpret_cast<setter>(UsbBulkOutPipe_put_WriteOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbBulkOutPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(UsbBulkOutPipe_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkOutPipe[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbBulkOutPipe) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbBulkOutPipe) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbBulkOutPipe) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbBulkOutPipe) },
        { },
    };

    static PyType_Spec type_spec_UsbBulkOutPipe =
    {
        "winrt._winrt_windows_devices_usb.UsbBulkOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutPipe
    };

    // ----- UsbConfiguration class --------------------

    static PyObject* _new_UsbConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbConfiguration(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbConfiguration_get_ConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfiguration", L"ConfigurationDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConfigurationDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfiguration", L"Descriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_UsbInterfaces(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfiguration", L"UsbInterfaces"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsbInterfaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfiguration[] = {
        { "_assign_array_", _assign_array_UsbConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbConfiguration[] = {
        { "configuration_descriptor", reinterpret_cast<getter>(UsbConfiguration_get_ConfigurationDescriptor), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbConfiguration_get_Descriptors), nullptr, nullptr, nullptr },
        { "usb_interfaces", reinterpret_cast<getter>(UsbConfiguration_get_UsbInterfaces), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbConfiguration) },
        { },
    };

    static PyType_Spec type_spec_UsbConfiguration =
    {
        "winrt._winrt_windows_devices_usb.UsbConfiguration",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfiguration
    };

    // ----- UsbConfigurationDescriptor class --------------------

    static PyObject* _new_UsbConfigurationDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbConfigurationDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"Parse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"TryParse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbConfigurationDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_ConfigurationValue(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"ConfigurationValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConfigurationValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_MaxPowerMilliamps(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"MaxPowerMilliamps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPowerMilliamps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_RemoteWakeup(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"RemoteWakeup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteWakeup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_SelfPowered(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"SelfPowered"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelfPowered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbConfigurationDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbConfigurationDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfigurationDescriptor[] = {
        { "_assign_array_", _assign_array_UsbConfigurationDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbConfigurationDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbConfigurationDescriptor[] = {
        { "configuration_value", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_ConfigurationValue), nullptr, nullptr, nullptr },
        { "max_power_milliamps", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_MaxPowerMilliamps), nullptr, nullptr, nullptr },
        { "remote_wakeup", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_RemoteWakeup), nullptr, nullptr, nullptr },
        { "self_powered", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_SelfPowered), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbConfigurationDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbConfigurationDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbConfigurationDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbConfigurationDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbConfigurationDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbConfigurationDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbConfigurationDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfigurationDescriptor
    };

    static PyGetSetDef getset_UsbConfigurationDescriptor_Static[] = {
        { }
    };

    static PyMethodDef methods_UsbConfigurationDescriptor_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbConfigurationDescriptor_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbConfigurationDescriptor_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UsbConfigurationDescriptor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UsbConfigurationDescriptor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UsbConfigurationDescriptor_Static) },
        { }
    };

    static PyType_Spec type_spec_UsbConfigurationDescriptor_Static =
    {
        "winrt._winrt_windows_devices_usb.UsbConfigurationDescriptor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UsbConfigurationDescriptor_Static
    };

    // ----- UsbControlRequestType class --------------------

    static PyObject* _new_UsbControlRequestType(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbControlRequestType instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbControlRequestType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbControlRequestType_get_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRecipient>(arg);

            self->obj.Recipient(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbTransferDirection>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"ControlTransferType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlTransferType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"ControlTransferType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlTransferType>(arg);

            self->obj.ControlTransferType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"AsByte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsByte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"AsByte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.AsByte(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UsbControlRequestType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbControlRequestType>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbControlRequestType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbControlRequestType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbControlRequestType[] = {
        { "_assign_array_", _assign_array_UsbControlRequestType, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbControlRequestType), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbControlRequestType[] = {
        { "recipient", reinterpret_cast<getter>(UsbControlRequestType_get_Recipient), reinterpret_cast<setter>(UsbControlRequestType_put_Recipient), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(UsbControlRequestType_get_Direction), reinterpret_cast<setter>(UsbControlRequestType_put_Direction), nullptr, nullptr },
        { "control_transfer_type", reinterpret_cast<getter>(UsbControlRequestType_get_ControlTransferType), reinterpret_cast<setter>(UsbControlRequestType_put_ControlTransferType), nullptr, nullptr },
        { "as_byte", reinterpret_cast<getter>(UsbControlRequestType_get_AsByte), reinterpret_cast<setter>(UsbControlRequestType_put_AsByte), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbControlRequestType[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbControlRequestType) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbControlRequestType) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbControlRequestType) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbControlRequestType) },
        { },
    };

    static PyType_Spec type_spec_UsbControlRequestType =
    {
        "winrt._winrt_windows_devices_usb.UsbControlRequestType",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbControlRequestType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbControlRequestType
    };

    // ----- UsbDescriptor class --------------------

    static PyObject* _new_UsbDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbDescriptor(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDescriptor_ReadDescriptorBuffer(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDescriptor", L"ReadDescriptorBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.ReadDescriptorBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_DescriptorType(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDescriptor", L"DescriptorType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DescriptorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_Length(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDescriptor", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDescriptor[] = {
        { "read_descriptor_buffer", reinterpret_cast<PyCFunction>(UsbDescriptor_ReadDescriptorBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UsbDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDescriptor[] = {
        { "descriptor_type", reinterpret_cast<getter>(UsbDescriptor_get_DescriptorType), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(UsbDescriptor_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDescriptor
    };

    // ----- UsbDevice class --------------------

    static PyObject* _new_UsbDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDevice_Close(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceClassSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceClassSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceClassSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceSelector", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceSelector", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlInTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlInTransferAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlInTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlInTransferAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlInTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlOutTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlOutTransferAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlOutTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlOutTransferAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlOutTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_Configuration(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDevice", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DefaultInterface(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDevice", L"DefaultInterface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultInterface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDevice", L"DeviceDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(UsbDevice_Close), METH_VARARGS, nullptr },
        { "send_control_in_transfer_async", reinterpret_cast<PyCFunction>(UsbDevice_SendControlInTransferAsync), METH_VARARGS, nullptr },
        { "send_control_out_transfer_async", reinterpret_cast<PyCFunction>(UsbDevice_SendControlOutTransferAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UsbDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_UsbDevice), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_UsbDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDevice[] = {
        { "configuration", reinterpret_cast<getter>(UsbDevice_get_Configuration), nullptr, nullptr, nullptr },
        { "default_interface", reinterpret_cast<getter>(UsbDevice_get_DefaultInterface), nullptr, nullptr, nullptr },
        { "device_descriptor", reinterpret_cast<getter>(UsbDevice_get_DeviceDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbDevice) },
        { },
    };

    static PyType_Spec type_spec_UsbDevice =
    {
        "winrt._winrt_windows_devices_usb.UsbDevice",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDevice
    };

    static PyGetSetDef getset_UsbDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_UsbDevice_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(UsbDevice_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_class_selector", reinterpret_cast<PyCFunction>(UsbDevice_GetDeviceClassSelector), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(UsbDevice_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UsbDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UsbDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UsbDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_UsbDevice_Static =
    {
        "winrt._winrt_windows_devices_usb.UsbDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UsbDevice_Static
    };

    // ----- UsbDeviceClass class --------------------

    static PyObject* _new_UsbDeviceClass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbDeviceClass instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbDeviceClass(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDeviceClass_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"SubclassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"SubclassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.SubclassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ProtocolCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ProtocolCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.ProtocolCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ClassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ClassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ClassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UsbDeviceClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbDeviceClass>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbDeviceClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClass[] = {
        { "_assign_array_", _assign_array_UsbDeviceClass, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceClass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceClass[] = {
        { "subclass_code", reinterpret_cast<getter>(UsbDeviceClass_get_SubclassCode), reinterpret_cast<setter>(UsbDeviceClass_put_SubclassCode), nullptr, nullptr },
        { "protocol_code", reinterpret_cast<getter>(UsbDeviceClass_get_ProtocolCode), reinterpret_cast<setter>(UsbDeviceClass_put_ProtocolCode), nullptr, nullptr },
        { "class_code", reinterpret_cast<getter>(UsbDeviceClass_get_ClassCode), reinterpret_cast<setter>(UsbDeviceClass_put_ClassCode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceClass[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbDeviceClass) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbDeviceClass) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbDeviceClass) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbDeviceClass) },
        { },
    };

    static PyType_Spec type_spec_UsbDeviceClass =
    {
        "winrt._winrt_windows_devices_usb.UsbDeviceClass",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClass
    };

    // ----- UsbDeviceClasses class --------------------

    static PyObject* _new_UsbDeviceClasses(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbDeviceClasses(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDeviceClasses_get_ActiveSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"ActiveSync"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::ActiveSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_CdcControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"CdcControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::CdcControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_DeviceFirmwareUpdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"DeviceFirmwareUpdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::DeviceFirmwareUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Irda(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"Irda"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Irda());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Measurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"Measurement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Measurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PalmSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"PalmSync"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PalmSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PersonalHealthcare(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"PersonalHealthcare"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PersonalHealthcare());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Physical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"Physical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Physical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_VendorSpecific(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"VendorSpecific"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::VendorSpecific());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbDeviceClasses(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbDeviceClasses>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbDeviceClasses(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClasses>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClasses[] = {
        { "_assign_array_", _assign_array_UsbDeviceClasses, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceClasses), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceClasses[] = {
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceClasses[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbDeviceClasses) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbDeviceClasses) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbDeviceClasses) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbDeviceClasses) },
        { },
    };

    static PyType_Spec type_spec_UsbDeviceClasses =
    {
        "winrt._winrt_windows_devices_usb.UsbDeviceClasses",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClasses
    };

    static PyGetSetDef getset_UsbDeviceClasses_Static[] = {
        { "active_sync", reinterpret_cast<getter>(UsbDeviceClasses_get_ActiveSync), nullptr, nullptr, nullptr },
        { "cdc_control", reinterpret_cast<getter>(UsbDeviceClasses_get_CdcControl), nullptr, nullptr, nullptr },
        { "device_firmware_update", reinterpret_cast<getter>(UsbDeviceClasses_get_DeviceFirmwareUpdate), nullptr, nullptr, nullptr },
        { "irda", reinterpret_cast<getter>(UsbDeviceClasses_get_Irda), nullptr, nullptr, nullptr },
        { "measurement", reinterpret_cast<getter>(UsbDeviceClasses_get_Measurement), nullptr, nullptr, nullptr },
        { "palm_sync", reinterpret_cast<getter>(UsbDeviceClasses_get_PalmSync), nullptr, nullptr, nullptr },
        { "personal_healthcare", reinterpret_cast<getter>(UsbDeviceClasses_get_PersonalHealthcare), nullptr, nullptr, nullptr },
        { "physical", reinterpret_cast<getter>(UsbDeviceClasses_get_Physical), nullptr, nullptr, nullptr },
        { "vendor_specific", reinterpret_cast<getter>(UsbDeviceClasses_get_VendorSpecific), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_UsbDeviceClasses_Static[] = {
        { }
    };

    static PyType_Slot type_slots_UsbDeviceClasses_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UsbDeviceClasses_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UsbDeviceClasses_Static) },
        { }
    };

    static PyType_Spec type_spec_UsbDeviceClasses_Static =
    {
        "winrt._winrt_windows_devices_usb.UsbDeviceClasses_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UsbDeviceClasses_Static
    };

    // ----- UsbDeviceDescriptor class --------------------

    static PyObject* _new_UsbDeviceDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbDeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDeviceDescriptor_get_BcdDeviceRevision(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"BcdDeviceRevision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BcdDeviceRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_BcdUsb(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"BcdUsb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BcdUsb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_MaxPacketSize0(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"MaxPacketSize0"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize0());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_NumberOfConfigurations(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"NumberOfConfigurations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberOfConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_ProductId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_VendorId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"VendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbDeviceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbDeviceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceDescriptor[] = {
        { "_assign_array_", _assign_array_UsbDeviceDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceDescriptor[] = {
        { "bcd_device_revision", reinterpret_cast<getter>(UsbDeviceDescriptor_get_BcdDeviceRevision), nullptr, nullptr, nullptr },
        { "bcd_usb", reinterpret_cast<getter>(UsbDeviceDescriptor_get_BcdUsb), nullptr, nullptr, nullptr },
        { "max_packet_size0", reinterpret_cast<getter>(UsbDeviceDescriptor_get_MaxPacketSize0), nullptr, nullptr, nullptr },
        { "number_of_configurations", reinterpret_cast<getter>(UsbDeviceDescriptor_get_NumberOfConfigurations), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(UsbDeviceDescriptor_get_ProductId), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(UsbDeviceDescriptor_get_VendorId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbDeviceDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbDeviceDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbDeviceDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbDeviceDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbDeviceDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbDeviceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceDescriptor
    };

    // ----- UsbEndpointDescriptor class --------------------

    static PyObject* _new_UsbEndpointDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbEndpointDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"Parse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbEndpointDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"TryParse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbEndpointDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbEndpointDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsBulkInEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsBulkInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsBulkOutEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsBulkOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsInterruptInEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsInterruptInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsInterruptOutEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsInterruptOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_Direction(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointType(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"EndpointType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbEndpointDescriptor[] = {
        { "_assign_array_", _assign_array_UsbEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbEndpointDescriptor[] = {
        { "as_bulk_in_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_bulk_out_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_interrupt_in_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_interrupt_out_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor), nullptr, nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(UsbEndpointDescriptor_get_Direction), nullptr, nullptr, nullptr },
        { "endpoint_number", reinterpret_cast<getter>(UsbEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "endpoint_type", reinterpret_cast<getter>(UsbEndpointDescriptor_get_EndpointType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbEndpointDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbEndpointDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbEndpointDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbEndpointDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbEndpointDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbEndpointDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbEndpointDescriptor
    };

    static PyGetSetDef getset_UsbEndpointDescriptor_Static[] = {
        { }
    };

    static PyMethodDef methods_UsbEndpointDescriptor_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbEndpointDescriptor_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbEndpointDescriptor_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UsbEndpointDescriptor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UsbEndpointDescriptor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UsbEndpointDescriptor_Static) },
        { }
    };

    static PyType_Spec type_spec_UsbEndpointDescriptor_Static =
    {
        "winrt._winrt_windows_devices_usb.UsbEndpointDescriptor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UsbEndpointDescriptor_Static
    };

    // ----- UsbInterface class --------------------

    static PyObject* _new_UsbInterface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterface>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterface(py::wrapper::Windows::Devices::Usb::UsbInterface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterface_get_BulkInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"BulkInPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_BulkOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"BulkOutPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"Descriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterfaceNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceSettings(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterfaceSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterruptInPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterruptOutPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterface[] = {
        { "_assign_array_", _assign_array_UsbInterface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterface[] = {
        { "bulk_in_pipes", reinterpret_cast<getter>(UsbInterface_get_BulkInPipes), nullptr, nullptr, nullptr },
        { "bulk_out_pipes", reinterpret_cast<getter>(UsbInterface_get_BulkOutPipes), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbInterface_get_Descriptors), nullptr, nullptr, nullptr },
        { "interface_number", reinterpret_cast<getter>(UsbInterface_get_InterfaceNumber), nullptr, nullptr, nullptr },
        { "interface_settings", reinterpret_cast<getter>(UsbInterface_get_InterfaceSettings), nullptr, nullptr, nullptr },
        { "interrupt_in_pipes", reinterpret_cast<getter>(UsbInterface_get_InterruptInPipes), nullptr, nullptr, nullptr },
        { "interrupt_out_pipes", reinterpret_cast<getter>(UsbInterface_get_InterruptOutPipes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterface[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterface) },
        { },
    };

    static PyType_Spec type_spec_UsbInterface =
    {
        "winrt._winrt_windows_devices_usb.UsbInterface",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterface
    };

    // ----- UsbInterfaceDescriptor class --------------------

    static PyObject* _new_UsbInterfaceDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterfaceDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"Parse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"TryParse", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbInterfaceDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_AlternateSettingNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"AlternateSettingNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlternateSettingNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"ClassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"InterfaceNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"ProtocolCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"SubclassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterfaceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterfaceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceDescriptor[] = {
        { "_assign_array_", _assign_array_UsbInterfaceDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterfaceDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterfaceDescriptor[] = {
        { "alternate_setting_number", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_AlternateSettingNumber), nullptr, nullptr, nullptr },
        { "class_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_ClassCode), nullptr, nullptr, nullptr },
        { "interface_number", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_InterfaceNumber), nullptr, nullptr, nullptr },
        { "protocol_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_ProtocolCode), nullptr, nullptr, nullptr },
        { "subclass_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_SubclassCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterfaceDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterfaceDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterfaceDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterfaceDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterfaceDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbInterfaceDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbInterfaceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceDescriptor
    };

    static PyGetSetDef getset_UsbInterfaceDescriptor_Static[] = {
        { }
    };

    static PyMethodDef methods_UsbInterfaceDescriptor_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbInterfaceDescriptor_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbInterfaceDescriptor_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UsbInterfaceDescriptor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UsbInterfaceDescriptor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UsbInterfaceDescriptor_Static) },
        { }
    };

    static PyType_Spec type_spec_UsbInterfaceDescriptor_Static =
    {
        "winrt._winrt_windows_devices_usb.UsbInterfaceDescriptor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UsbInterfaceDescriptor_Static
    };

    // ----- UsbInterfaceSetting class --------------------

    static PyObject* _new_UsbInterfaceSetting(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceSetting(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterfaceSetting_SelectSettingAsync(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"SelectSettingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SelectSettingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"BulkInEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"BulkOutEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"Descriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"InterfaceDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"InterruptInEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"InterruptOutEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Selected(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"Selected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterfaceSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterfaceSetting>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterfaceSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceSetting>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceSetting[] = {
        { "select_setting_async", reinterpret_cast<PyCFunction>(UsbInterfaceSetting_SelectSettingAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UsbInterfaceSetting, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterfaceSetting), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterfaceSetting[] = {
        { "bulk_in_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_BulkInEndpoints), nullptr, nullptr, nullptr },
        { "bulk_out_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_BulkOutEndpoints), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbInterfaceSetting_get_Descriptors), nullptr, nullptr, nullptr },
        { "interface_descriptor", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterfaceDescriptor), nullptr, nullptr, nullptr },
        { "interrupt_in_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterruptInEndpoints), nullptr, nullptr, nullptr },
        { "interrupt_out_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterruptOutEndpoints), nullptr, nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(UsbInterfaceSetting_get_Selected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterfaceSetting[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterfaceSetting) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterfaceSetting) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterfaceSetting) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterfaceSetting) },
        { },
    };

    static PyType_Spec type_spec_UsbInterfaceSetting =
    {
        "winrt._winrt_windows_devices_usb.UsbInterfaceSetting",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceSetting
    };

    // ----- UsbInterruptInEndpointDescriptor class --------------------

    static PyObject* _new_UsbInterruptInEndpointDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterruptInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterruptInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEndpointDescriptor[] = {
        { "_assign_array_", _assign_array_UsbInterruptInEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_Interval), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInEndpointDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterruptInEndpointDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterruptInEndpointDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterruptInEndpointDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterruptInEndpointDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptInEndpointDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbInterruptInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEndpointDescriptor
    };

    // ----- UsbInterruptInEventArgs class --------------------

    static PyObject* _new_UsbInterruptInEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEventArgs(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptInEventArgs_get_InterruptData(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEventArgs", L"InterruptData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterruptInEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterruptInEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEventArgs[] = {
        { "_assign_array_", _assign_array_UsbInterruptInEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInEventArgs[] = {
        { "interrupt_data", reinterpret_cast<getter>(UsbInterruptInEventArgs_get_InterruptData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterruptInEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterruptInEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterruptInEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterruptInEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptInEventArgs =
    {
        "winrt._winrt_windows_devices_usb.UsbInterruptInEventArgs",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEventArgs
    };

    // ----- UsbInterruptInPipe class --------------------

    static PyObject* _new_UsbInterruptInPipe(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"ClearStallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_add_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Usb::UsbInterruptInPipe, winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_remove_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterruptInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterruptInPipe>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterruptInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_remove_DataReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_UsbInterruptInPipe, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInPipe[] = {
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbInterruptInPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInPipe[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterruptInPipe) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterruptInPipe) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterruptInPipe) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterruptInPipe) },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptInPipe =
    {
        "winrt._winrt_windows_devices_usb.UsbInterruptInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInPipe
    };

    // ----- UsbInterruptOutEndpointDescriptor class --------------------

    static PyObject* _new_UsbInterruptOutEndpointDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterruptOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterruptOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutEndpointDescriptor[] = {
        { "_assign_array_", _assign_array_UsbInterruptOutEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptOutEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptOutEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_Interval), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptOutEndpointDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterruptOutEndpointDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterruptOutEndpointDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterruptOutEndpointDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterruptOutEndpointDescriptor) },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptOutEndpointDescriptor =
    {
        "winrt._winrt_windows_devices_usb.UsbInterruptOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutEndpointDescriptor
    };

    // ----- UsbInterruptOutPipe class --------------------

    static PyObject* _new_UsbInterruptOutPipe(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::type_name);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"ClearStallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbInterruptOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UsbInterruptOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbInterruptOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbInterruptOutPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UsbInterruptOutPipe, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptOutPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptOutPipe[] = {
        { "write_options", reinterpret_cast<getter>(UsbInterruptOutPipe_get_WriteOptions), reinterpret_cast<setter>(UsbInterruptOutPipe_put_WriteOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbInterruptOutPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(UsbInterruptOutPipe_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptOutPipe[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbInterruptOutPipe) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbInterruptOutPipe) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbInterruptOutPipe) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbInterruptOutPipe) },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptOutPipe =
    {
        "winrt._winrt_windows_devices_usb.UsbInterruptOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutPipe
    };

    // ----- UsbSetupPacket class --------------------

    static PyObject* _new_UsbSetupPacket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Usb::UsbSetupPacket instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbSetupPacket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbSetupPacket(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbSetupPacket_get_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"RequestType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"RequestType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRequestType>(arg);

            self->obj.RequestType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.Request(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Index"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Index"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Index(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UsbSetupPacket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Usb::UsbSetupPacket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UsbSetupPacket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbSetupPacket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbSetupPacket[] = {
        { "_assign_array_", _assign_array_UsbSetupPacket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbSetupPacket), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbSetupPacket[] = {
        { "value", reinterpret_cast<getter>(UsbSetupPacket_get_Value), reinterpret_cast<setter>(UsbSetupPacket_put_Value), nullptr, nullptr },
        { "request_type", reinterpret_cast<getter>(UsbSetupPacket_get_RequestType), reinterpret_cast<setter>(UsbSetupPacket_put_RequestType), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(UsbSetupPacket_get_Request), reinterpret_cast<setter>(UsbSetupPacket_put_Request), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(UsbSetupPacket_get_Length), reinterpret_cast<setter>(UsbSetupPacket_put_Length), nullptr, nullptr },
        { "index", reinterpret_cast<getter>(UsbSetupPacket_get_Index), reinterpret_cast<setter>(UsbSetupPacket_put_Index), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbSetupPacket[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UsbSetupPacket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UsbSetupPacket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UsbSetupPacket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UsbSetupPacket) },
        { },
    };

    static PyType_Spec type_spec_UsbSetupPacket =
    {
        "winrt._winrt_windows_devices_usb.UsbSetupPacket",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbSetupPacket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbSetupPacket
    };

    // ----- Windows.Devices.Usb Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Usb");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_usb",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Usb

PyMODINIT_FUNC PyInit__winrt_windows_devices_usb(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Usb;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbBulkInEndpointDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbBulkInPipe, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbBulkOutEndpointDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbBulkOutPipe, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UsbConfigurationDescriptor_Static{PyType_FromSpec(&type_spec_UsbConfigurationDescriptor_Static)};
    if (!type_UsbConfigurationDescriptor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbConfigurationDescriptor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UsbConfigurationDescriptor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbControlRequestType, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UsbDevice_Static{PyType_FromSpec(&type_spec_UsbDevice_Static)};
    if (!type_UsbDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UsbDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbDeviceClass, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UsbDeviceClasses_Static{PyType_FromSpec(&type_spec_UsbDeviceClasses_Static)};
    if (!type_UsbDeviceClasses_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbDeviceClasses, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UsbDeviceClasses_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbDeviceDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UsbEndpointDescriptor_Static{PyType_FromSpec(&type_spec_UsbEndpointDescriptor_Static)};
    if (!type_UsbEndpointDescriptor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbEndpointDescriptor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UsbEndpointDescriptor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterface, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UsbInterfaceDescriptor_Static{PyType_FromSpec(&type_spec_UsbInterfaceDescriptor_Static)};
    if (!type_UsbInterfaceDescriptor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterfaceDescriptor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UsbInterfaceDescriptor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterfaceSetting, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterruptInEndpointDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterruptInEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterruptInPipe, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterruptOutEndpointDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbInterruptOutPipe, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UsbSetupPacket, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
