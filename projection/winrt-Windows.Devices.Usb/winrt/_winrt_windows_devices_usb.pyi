# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.streams

from winrt.windows.devices.usb import UsbControlRecipient, UsbControlTransferType, UsbEndpointType, UsbReadOptions, UsbTransferDirection, UsbWriteOptions

Self = typing.TypeVar('Self')

@typing.final
class UsbBulkInEndpointDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbBulkInEndpointDescriptor: ...
    @_property
    def endpoint_number(self) -> winrt.system.UInt8: ...
    @_property
    def max_packet_size(self) -> winrt.system.UInt32: ...
    @_property
    def pipe(self) -> typing.Optional[UsbBulkInPipe]: ...

@typing.final
class UsbBulkInPipe(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbBulkInPipe: ...
    def clear_stall_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def flush_buffer(self) -> None: ...
    @_property
    def read_options(self) -> UsbReadOptions: ...
    @read_options.setter
    def read_options(self, value: UsbReadOptions) -> None: ...
    @_property
    def endpoint_descriptor(self) -> typing.Optional[UsbBulkInEndpointDescriptor]: ...
    @_property
    def input_stream(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @_property
    def max_transfer_size_bytes(self) -> winrt.system.UInt32: ...

@typing.final
class UsbBulkOutEndpointDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbBulkOutEndpointDescriptor: ...
    @_property
    def endpoint_number(self) -> winrt.system.UInt8: ...
    @_property
    def max_packet_size(self) -> winrt.system.UInt32: ...
    @_property
    def pipe(self) -> typing.Optional[UsbBulkOutPipe]: ...

@typing.final
class UsbBulkOutPipe(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbBulkOutPipe: ...
    def clear_stall_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def write_options(self) -> UsbWriteOptions: ...
    @write_options.setter
    def write_options(self, value: UsbWriteOptions) -> None: ...
    @_property
    def endpoint_descriptor(self) -> typing.Optional[UsbBulkOutEndpointDescriptor]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class UsbConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbConfiguration: ...
    @_property
    def configuration_descriptor(self) -> typing.Optional[UsbConfigurationDescriptor]: ...
    @_property
    def descriptors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbDescriptor]]: ...
    @_property
    def usb_interfaces(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbInterface]]: ...

@typing.final
class UsbConfigurationDescriptor_Static(type):
    def parse(cls, descriptor: typing.Optional[UsbDescriptor], /) -> typing.Optional[UsbConfigurationDescriptor]: ...
    def try_parse(cls, descriptor: typing.Optional[UsbDescriptor], /) -> typing.Tuple[bool, typing.Optional[UsbConfigurationDescriptor]]: ...

@typing.final
class UsbConfigurationDescriptor(winrt.system.Object, metaclass=UsbConfigurationDescriptor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbConfigurationDescriptor: ...
    @_property
    def configuration_value(self) -> winrt.system.UInt8: ...
    @_property
    def max_power_milliamps(self) -> winrt.system.UInt32: ...
    @_property
    def remote_wakeup(self) -> bool: ...
    @_property
    def self_powered(self) -> bool: ...

@typing.final
class UsbControlRequestType(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbControlRequestType: ...
    def __new__(cls: typing.Type[UsbControlRequestType]) -> UsbControlRequestType:...
    @_property
    def recipient(self) -> UsbControlRecipient: ...
    @recipient.setter
    def recipient(self, value: UsbControlRecipient) -> None: ...
    @_property
    def direction(self) -> UsbTransferDirection: ...
    @direction.setter
    def direction(self, value: UsbTransferDirection) -> None: ...
    @_property
    def control_transfer_type(self) -> UsbControlTransferType: ...
    @control_transfer_type.setter
    def control_transfer_type(self, value: UsbControlTransferType) -> None: ...
    @_property
    def as_byte(self) -> winrt.system.UInt8: ...
    @as_byte.setter
    def as_byte(self, value: winrt.system.UInt8) -> None: ...

@typing.final
class UsbDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbDescriptor: ...
    def read_descriptor_buffer(self, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> None: ...
    @_property
    def descriptor_type(self) -> winrt.system.UInt8: ...
    @_property
    def length(self) -> winrt.system.UInt8: ...

@typing.final
class UsbDevice_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[UsbDevice]: ...
    def get_device_class_selector(cls, usb_class: typing.Optional[UsbDeviceClass], /) -> str: ...
    @typing.overload
    def get_device_selector(cls, win_usb_interface_class: _uuid.UUID, /) -> str: ...
    @typing.overload
    def get_device_selector(cls, vendor_id: winrt.system.UInt32, product_id: winrt.system.UInt32, /) -> str: ...
    @typing.overload
    def get_device_selector(cls, vendor_id: winrt.system.UInt32, product_id: winrt.system.UInt32, win_usb_interface_class: _uuid.UUID, /) -> str: ...

@typing.final
class UsbDevice(winrt.system.Object, metaclass=UsbDevice_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbDevice: ...
    def close(self) -> None: ...
    @typing.overload
    def send_control_in_transfer_async(self, setup_packet: typing.Optional[UsbSetupPacket], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    @typing.overload
    def send_control_in_transfer_async(self, setup_packet: typing.Optional[UsbSetupPacket], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    @typing.overload
    def send_control_out_transfer_async(self, setup_packet: typing.Optional[UsbSetupPacket], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    @typing.overload
    def send_control_out_transfer_async(self, setup_packet: typing.Optional[UsbSetupPacket], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    @_property
    def configuration(self) -> typing.Optional[UsbConfiguration]: ...
    @_property
    def default_interface(self) -> typing.Optional[UsbInterface]: ...
    @_property
    def device_descriptor(self) -> typing.Optional[UsbDeviceDescriptor]: ...

@typing.final
class UsbDeviceClass(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbDeviceClass: ...
    def __new__(cls: typing.Type[UsbDeviceClass]) -> UsbDeviceClass:...
    @_property
    def subclass_code(self) -> typing.Optional[typing.Optional[winrt.system.UInt8]]: ...
    @subclass_code.setter
    def subclass_code(self, value: typing.Optional[typing.Optional[winrt.system.UInt8]]) -> None: ...
    @_property
    def protocol_code(self) -> typing.Optional[typing.Optional[winrt.system.UInt8]]: ...
    @protocol_code.setter
    def protocol_code(self, value: typing.Optional[typing.Optional[winrt.system.UInt8]]) -> None: ...
    @_property
    def class_code(self) -> winrt.system.UInt8: ...
    @class_code.setter
    def class_code(self, value: winrt.system.UInt8) -> None: ...

@typing.final
class UsbDeviceClasses_Static(type):
    @_property
    def active_sync(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def cdc_control(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def device_firmware_update(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def irda(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def measurement(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def palm_sync(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def personal_healthcare(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def physical(cls) -> typing.Optional[UsbDeviceClass]: ...
    @_property
    def vendor_specific(cls) -> typing.Optional[UsbDeviceClass]: ...

@typing.final
class UsbDeviceClasses(winrt.system.Object, metaclass=UsbDeviceClasses_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbDeviceClasses: ...

@typing.final
class UsbDeviceDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbDeviceDescriptor: ...
    @_property
    def bcd_device_revision(self) -> winrt.system.UInt32: ...
    @_property
    def bcd_usb(self) -> winrt.system.UInt32: ...
    @_property
    def max_packet_size0(self) -> winrt.system.UInt8: ...
    @_property
    def number_of_configurations(self) -> winrt.system.UInt8: ...
    @_property
    def product_id(self) -> winrt.system.UInt32: ...
    @_property
    def vendor_id(self) -> winrt.system.UInt32: ...

@typing.final
class UsbEndpointDescriptor_Static(type):
    def parse(cls, descriptor: typing.Optional[UsbDescriptor], /) -> typing.Optional[UsbEndpointDescriptor]: ...
    def try_parse(cls, descriptor: typing.Optional[UsbDescriptor], /) -> typing.Tuple[bool, typing.Optional[UsbEndpointDescriptor]]: ...

@typing.final
class UsbEndpointDescriptor(winrt.system.Object, metaclass=UsbEndpointDescriptor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbEndpointDescriptor: ...
    @_property
    def as_bulk_in_endpoint_descriptor(self) -> typing.Optional[UsbBulkInEndpointDescriptor]: ...
    @_property
    def as_bulk_out_endpoint_descriptor(self) -> typing.Optional[UsbBulkOutEndpointDescriptor]: ...
    @_property
    def as_interrupt_in_endpoint_descriptor(self) -> typing.Optional[UsbInterruptInEndpointDescriptor]: ...
    @_property
    def as_interrupt_out_endpoint_descriptor(self) -> typing.Optional[UsbInterruptOutEndpointDescriptor]: ...
    @_property
    def direction(self) -> UsbTransferDirection: ...
    @_property
    def endpoint_number(self) -> winrt.system.UInt8: ...
    @_property
    def endpoint_type(self) -> UsbEndpointType: ...

@typing.final
class UsbInterface(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterface: ...
    @_property
    def bulk_in_pipes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbBulkInPipe]]: ...
    @_property
    def bulk_out_pipes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbBulkOutPipe]]: ...
    @_property
    def descriptors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbDescriptor]]: ...
    @_property
    def interface_number(self) -> winrt.system.UInt8: ...
    @_property
    def interface_settings(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbInterfaceSetting]]: ...
    @_property
    def interrupt_in_pipes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbInterruptInPipe]]: ...
    @_property
    def interrupt_out_pipes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbInterruptOutPipe]]: ...

@typing.final
class UsbInterfaceDescriptor_Static(type):
    def parse(cls, descriptor: typing.Optional[UsbDescriptor], /) -> typing.Optional[UsbInterfaceDescriptor]: ...
    def try_parse(cls, descriptor: typing.Optional[UsbDescriptor], /) -> typing.Tuple[bool, typing.Optional[UsbInterfaceDescriptor]]: ...

@typing.final
class UsbInterfaceDescriptor(winrt.system.Object, metaclass=UsbInterfaceDescriptor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterfaceDescriptor: ...
    @_property
    def alternate_setting_number(self) -> winrt.system.UInt8: ...
    @_property
    def class_code(self) -> winrt.system.UInt8: ...
    @_property
    def interface_number(self) -> winrt.system.UInt8: ...
    @_property
    def protocol_code(self) -> winrt.system.UInt8: ...
    @_property
    def subclass_code(self) -> winrt.system.UInt8: ...

@typing.final
class UsbInterfaceSetting(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterfaceSetting: ...
    def select_setting_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def bulk_in_endpoints(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbBulkInEndpointDescriptor]]: ...
    @_property
    def bulk_out_endpoints(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbBulkOutEndpointDescriptor]]: ...
    @_property
    def descriptors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbDescriptor]]: ...
    @_property
    def interface_descriptor(self) -> typing.Optional[UsbInterfaceDescriptor]: ...
    @_property
    def interrupt_in_endpoints(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbInterruptInEndpointDescriptor]]: ...
    @_property
    def interrupt_out_endpoints(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UsbInterruptOutEndpointDescriptor]]: ...
    @_property
    def selected(self) -> bool: ...

@typing.final
class UsbInterruptInEndpointDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterruptInEndpointDescriptor: ...
    @_property
    def endpoint_number(self) -> winrt.system.UInt8: ...
    @_property
    def interval(self) -> datetime.timedelta: ...
    @_property
    def max_packet_size(self) -> winrt.system.UInt32: ...
    @_property
    def pipe(self) -> typing.Optional[UsbInterruptInPipe]: ...

@typing.final
class UsbInterruptInEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterruptInEventArgs: ...
    @_property
    def interrupt_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...

@typing.final
class UsbInterruptInPipe(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterruptInPipe: ...
    def clear_stall_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[UsbInterruptInPipe, UsbInterruptInEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def endpoint_descriptor(self) -> typing.Optional[UsbInterruptInEndpointDescriptor]: ...

@typing.final
class UsbInterruptOutEndpointDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterruptOutEndpointDescriptor: ...
    @_property
    def endpoint_number(self) -> winrt.system.UInt8: ...
    @_property
    def interval(self) -> datetime.timedelta: ...
    @_property
    def max_packet_size(self) -> winrt.system.UInt32: ...
    @_property
    def pipe(self) -> typing.Optional[UsbInterruptOutPipe]: ...

@typing.final
class UsbInterruptOutPipe(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbInterruptOutPipe: ...
    def clear_stall_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def write_options(self) -> UsbWriteOptions: ...
    @write_options.setter
    def write_options(self, value: UsbWriteOptions) -> None: ...
    @_property
    def endpoint_descriptor(self) -> typing.Optional[UsbInterruptOutEndpointDescriptor]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class UsbSetupPacket(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UsbSetupPacket: ...
    @typing.overload
    def __new__(cls: typing.Type[UsbSetupPacket], eight_byte_buffer: typing.Optional[winrt.windows.storage.streams.IBuffer]) -> UsbSetupPacket:...
    @typing.overload
    def __new__(cls: typing.Type[UsbSetupPacket]) -> UsbSetupPacket:...
    @_property
    def value(self) -> winrt.system.UInt32: ...
    @value.setter
    def value(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def request_type(self) -> typing.Optional[UsbControlRequestType]: ...
    @request_type.setter
    def request_type(self, value: typing.Optional[UsbControlRequestType]) -> None: ...
    @_property
    def request(self) -> winrt.system.UInt8: ...
    @request.setter
    def request(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def length(self) -> winrt.system.UInt32: ...
    @length.setter
    def length(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def index(self) -> winrt.system.UInt32: ...
    @index.setter
    def index(self, value: winrt.system.UInt32) -> None: ...

