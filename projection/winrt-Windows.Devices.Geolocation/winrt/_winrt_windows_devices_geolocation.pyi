# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections

from winrt.windows.devices.geolocation import AltitudeReferenceSystem, GeolocationAccessStatus, GeoshapeType, PositionAccuracy, PositionSource, PositionStatus, VisitMonitoringScope, VisitStateChange

Self = typing.TypeVar('Self')

@typing.final
class BasicGeoposition:
    latitude: winrt.system.Double
    longitude: winrt.system.Double
    altitude: winrt.system.Double
    def __init__(self, latitude: winrt.system.Double, longitude: winrt.system.Double, altitude: winrt.system.Double) -> None: ...

@typing.final
class CivicAddress(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CivicAddress: ...
    @_property
    def city(self) -> str: ...
    @_property
    def country(self) -> str: ...
    @_property
    def postal_code(self) -> str: ...
    @_property
    def state(self) -> str: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class GeoboundingBox_Static(type):
    @typing.overload
    def try_compute(cls, positions: typing.Iterable[BasicGeoposition], /) -> typing.Optional[GeoboundingBox]: ...
    @typing.overload
    def try_compute(cls, positions: typing.Iterable[BasicGeoposition], altitude_ref_system: AltitudeReferenceSystem, /) -> typing.Optional[GeoboundingBox]: ...
    @typing.overload
    def try_compute(cls, positions: typing.Iterable[BasicGeoposition], altitude_ref_system: AltitudeReferenceSystem, spatial_reference_id: winrt.system.UInt32, /) -> typing.Optional[GeoboundingBox]: ...

@typing.final
class GeoboundingBox(winrt.system.Object, metaclass=GeoboundingBox_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeoboundingBox: ...
    @typing.overload
    def __new__(cls: typing.Type[GeoboundingBox], northwest_corner: BasicGeoposition, southeast_corner: BasicGeoposition) -> GeoboundingBox:...
    @typing.overload
    def __new__(cls: typing.Type[GeoboundingBox], northwest_corner: BasicGeoposition, southeast_corner: BasicGeoposition, altitude_reference_system: AltitudeReferenceSystem) -> GeoboundingBox:...
    @typing.overload
    def __new__(cls: typing.Type[GeoboundingBox], northwest_corner: BasicGeoposition, southeast_corner: BasicGeoposition, altitude_reference_system: AltitudeReferenceSystem, spatial_reference_id: winrt.system.UInt32) -> GeoboundingBox:...
    @_property
    def center(self) -> BasicGeoposition: ...
    @_property
    def max_altitude(self) -> winrt.system.Double: ...
    @_property
    def min_altitude(self) -> winrt.system.Double: ...
    @_property
    def northwest_corner(self) -> BasicGeoposition: ...
    @_property
    def southeast_corner(self) -> BasicGeoposition: ...
    @_property
    def altitude_reference_system(self) -> AltitudeReferenceSystem: ...
    @_property
    def geoshape_type(self) -> GeoshapeType: ...
    @_property
    def spatial_reference_id(self) -> winrt.system.UInt32: ...

@typing.final
class Geocircle(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geocircle: ...
    @typing.overload
    def __new__(cls: typing.Type[Geocircle], position: BasicGeoposition, radius: winrt.system.Double) -> Geocircle:...
    @typing.overload
    def __new__(cls: typing.Type[Geocircle], position: BasicGeoposition, radius: winrt.system.Double, altitude_reference_system: AltitudeReferenceSystem) -> Geocircle:...
    @typing.overload
    def __new__(cls: typing.Type[Geocircle], position: BasicGeoposition, radius: winrt.system.Double, altitude_reference_system: AltitudeReferenceSystem, spatial_reference_id: winrt.system.UInt32) -> Geocircle:...
    @_property
    def center(self) -> BasicGeoposition: ...
    @_property
    def radius(self) -> winrt.system.Double: ...
    @_property
    def altitude_reference_system(self) -> AltitudeReferenceSystem: ...
    @_property
    def geoshape_type(self) -> GeoshapeType: ...
    @_property
    def spatial_reference_id(self) -> winrt.system.UInt32: ...

@typing.final
class Geocoordinate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geocoordinate: ...
    @_property
    def accuracy(self) -> winrt.system.Double: ...
    @_property
    def altitude(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def altitude_accuracy(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def heading(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def latitude(self) -> winrt.system.Double: ...
    @_property
    def longitude(self) -> winrt.system.Double: ...
    @_property
    def speed(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def point(self) -> typing.Optional[Geopoint]: ...
    @_property
    def position_source(self) -> PositionSource: ...
    @_property
    def satellite_data(self) -> typing.Optional[GeocoordinateSatelliteData]: ...
    @_property
    def position_source_timestamp(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def is_remote_source(self) -> bool: ...

@typing.final
class GeocoordinateSatelliteData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeocoordinateSatelliteData: ...
    @_property
    def horizontal_dilution_of_precision(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def position_dilution_of_precision(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def vertical_dilution_of_precision(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def geometric_dilution_of_precision(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def time_dilution_of_precision(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...

@typing.final
class Geolocator_Static(type):
    @typing.overload
    def get_geoposition_history_async(cls, start_time: datetime.datetime, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[Geoposition]]: ...
    @typing.overload
    def get_geoposition_history_async(cls, start_time: datetime.datetime, duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[Geoposition]]: ...
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[GeolocationAccessStatus]: ...
    @_property
    def default_geoposition(cls) -> typing.Optional[typing.Optional[BasicGeoposition]]: ...
    @default_geoposition.setter
    def default_geoposition(cls, value: typing.Optional[typing.Optional[BasicGeoposition]]) -> None: ...
    @_property
    def is_default_geoposition_recommended(cls) -> bool: ...

@typing.final
class Geolocator(winrt.system.Object, metaclass=Geolocator_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geolocator: ...
    def __new__(cls: typing.Type[Geolocator]) -> Geolocator:...
    def allow_fallback_to_consentless_positions(self) -> None: ...
    @typing.overload
    def get_geoposition_async(self) -> winrt.windows.foundation.IAsyncOperation[Geoposition]: ...
    @typing.overload
    def get_geoposition_async(self, maximum_age: datetime.timedelta, timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[Geoposition]: ...
    def add_position_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Geolocator, PositionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_position_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Geolocator, StatusChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def movement_threshold(self) -> winrt.system.Double: ...
    @movement_threshold.setter
    def movement_threshold(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_accuracy(self) -> PositionAccuracy: ...
    @desired_accuracy.setter
    def desired_accuracy(self, value: PositionAccuracy) -> None: ...
    @_property
    def location_status(self) -> PositionStatus: ...
    @_property
    def desired_accuracy_in_meters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @desired_accuracy_in_meters.setter
    def desired_accuracy_in_meters(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...

@typing.final
class Geopath(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geopath: ...
    @typing.overload
    def __new__(cls: typing.Type[Geopath], positions: typing.Iterable[BasicGeoposition]) -> Geopath:...
    @typing.overload
    def __new__(cls: typing.Type[Geopath], positions: typing.Iterable[BasicGeoposition], altitude_reference_system: AltitudeReferenceSystem) -> Geopath:...
    @typing.overload
    def __new__(cls: typing.Type[Geopath], positions: typing.Iterable[BasicGeoposition], altitude_reference_system: AltitudeReferenceSystem, spatial_reference_id: winrt.system.UInt32) -> Geopath:...
    @_property
    def positions(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[BasicGeoposition]]: ...
    @_property
    def altitude_reference_system(self) -> AltitudeReferenceSystem: ...
    @_property
    def geoshape_type(self) -> GeoshapeType: ...
    @_property
    def spatial_reference_id(self) -> winrt.system.UInt32: ...

@typing.final
class Geopoint(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geopoint: ...
    @typing.overload
    def __new__(cls: typing.Type[Geopoint], position: BasicGeoposition) -> Geopoint:...
    @typing.overload
    def __new__(cls: typing.Type[Geopoint], position: BasicGeoposition, altitude_reference_system: AltitudeReferenceSystem) -> Geopoint:...
    @typing.overload
    def __new__(cls: typing.Type[Geopoint], position: BasicGeoposition, altitude_reference_system: AltitudeReferenceSystem, spatial_reference_id: winrt.system.UInt32) -> Geopoint:...
    @_property
    def position(self) -> BasicGeoposition: ...
    @_property
    def altitude_reference_system(self) -> AltitudeReferenceSystem: ...
    @_property
    def geoshape_type(self) -> GeoshapeType: ...
    @_property
    def spatial_reference_id(self) -> winrt.system.UInt32: ...

@typing.final
class Geoposition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geoposition: ...
    @_property
    def civic_address(self) -> typing.Optional[CivicAddress]: ...
    @_property
    def coordinate(self) -> typing.Optional[Geocoordinate]: ...
    @_property
    def venue_data(self) -> typing.Optional[VenueData]: ...

@typing.final
class Geovisit(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geovisit: ...
    @_property
    def position(self) -> typing.Optional[Geoposition]: ...
    @_property
    def state_change(self) -> VisitStateChange: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class GeovisitMonitor_Static(type):
    def get_last_report_async(cls) -> winrt.windows.foundation.IAsyncOperation[Geovisit]: ...

@typing.final
class GeovisitMonitor(winrt.system.Object, metaclass=GeovisitMonitor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeovisitMonitor: ...
    def __new__(cls: typing.Type[GeovisitMonitor]) -> GeovisitMonitor:...
    def start(self, value: VisitMonitoringScope, /) -> None: ...
    def stop(self) -> None: ...
    def add_visit_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[GeovisitMonitor, GeovisitStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_visit_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def monitoring_scope(self) -> VisitMonitoringScope: ...

@typing.final
class GeovisitStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeovisitStateChangedEventArgs: ...
    @_property
    def visit(self) -> typing.Optional[Geovisit]: ...

@typing.final
class GeovisitTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeovisitTriggerDetails: ...
    def read_reports(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Geovisit]]: ...

@typing.final
class PositionChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PositionChangedEventArgs: ...
    @_property
    def position(self) -> typing.Optional[Geoposition]: ...

@typing.final
class StatusChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StatusChangedEventArgs: ...
    @_property
    def status(self) -> PositionStatus: ...

@typing.final
class VenueData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VenueData: ...
    @_property
    def id(self) -> str: ...
    @_property
    def level(self) -> str: ...

@typing.final
class IGeoshape(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IGeoshape: ...
    @_property
    def altitude_reference_system(self) -> AltitudeReferenceSystem: ...
    @_property
    def geoshape_type(self) -> GeoshapeType: ...
    @_property
    def spatial_reference_id(self) -> winrt.system.UInt32: ...

