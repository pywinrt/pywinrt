// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.ApplicationModel.Wallet.h"


namespace py::cpp::Windows::ApplicationModel::Wallet
{
    // ----- WalletBarcode class --------------------

    static PyObject* _new_WalletBarcode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletBarcodeSymbology>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletBarcode instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                winrt::Windows::ApplicationModel::Wallet::WalletBarcode instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletBarcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletBarcode_GetImageAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletBarcode", L"GetImageAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetImageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletBarcode_get_Symbology(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletBarcode", L"Symbology"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Symbology());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletBarcode_get_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletBarcode", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletBarcode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletBarcode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletBarcode[] = {
        { "get_image_async", reinterpret_cast<PyCFunction>(WalletBarcode_GetImageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WalletBarcode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletBarcode), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletBarcode[] = {
        { "symbology", reinterpret_cast<getter>(WalletBarcode_get_Symbology), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WalletBarcode_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletBarcode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletBarcode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletBarcode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletBarcode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletBarcode) },
        { },
    };

    static PyType_Spec type_spec_WalletBarcode =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletBarcode",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletBarcode
    };

    // ----- WalletItem class --------------------

    static PyObject* _new_WalletItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletItem instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletItem(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItem_get_DisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_DisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LogoText(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogoText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LogoText(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LogoText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyFontColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BodyFontColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyFontColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BodyFontColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BodyColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BodyColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyBackgroundImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BodyBackgroundImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"BodyBackgroundImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.BodyBackgroundImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsDisplayMessageLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsDisplayMessageLaunchable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisplayMessageLaunchable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsDisplayMessageLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsDisplayMessageLaunchable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisplayMessageLaunchable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsAcknowledged(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsAcknowledged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAcknowledged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsAcknowledged(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsAcknowledged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAcknowledged(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsMoreTransactionHistoryLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsMoreTransactionHistoryLaunchable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMoreTransactionHistoryLaunchable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsMoreTransactionHistoryLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IsMoreTransactionHistoryLaunchable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMoreTransactionHistoryLaunchable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderFontColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderFontColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderFontColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.HeaderFontColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.HeaderColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderBackgroundImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderBackgroundImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"HeaderBackgroundImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.HeaderBackgroundImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_ExpirationDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_ExpirationDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo99x99(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo99x99"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo99x99());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo99x99(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo99x99"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo99x99(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LogoImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogoImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LogoImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LogoImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.LogoImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_PromotionalImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"PromotionalImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PromotionalImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_PromotionalImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"PromotionalImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.PromotionalImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo159x159(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo159x159"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo159x159());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo159x159(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo159x159"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo159x159(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LastUpdated(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LastUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastUpdated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LastUpdated(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"LastUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.LastUpdated(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IssuerDisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IssuerDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IssuerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IssuerDisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"IssuerDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IssuerDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Barcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Barcode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Barcode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Barcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Barcode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>(arg);

            self->obj.Barcode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_RelevantDateDisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDateDisplayMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelevantDateDisplayMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_RelevantDateDisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDateDisplayMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RelevantDateDisplayMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_RelevantDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelevantDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_RelevantDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.RelevantDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo336x336(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo336x336"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo336x336());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo336x336(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Logo336x336"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo336x336(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Kind(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_DisplayProperties(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"DisplayProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_Id(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_RelevantLocations(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"RelevantLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelevantLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_TransactionHistory(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"TransactionHistory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransactionHistory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_Verbs(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItem", L"Verbs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Verbs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItem[] = {
        { "_assign_array_", _assign_array_WalletItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletItem[] = {
        { "display_name", reinterpret_cast<getter>(WalletItem_get_DisplayName), reinterpret_cast<setter>(WalletItem_put_DisplayName), nullptr, nullptr },
        { "display_message", reinterpret_cast<getter>(WalletItem_get_DisplayMessage), reinterpret_cast<setter>(WalletItem_put_DisplayMessage), nullptr, nullptr },
        { "logo_text", reinterpret_cast<getter>(WalletItem_get_LogoText), reinterpret_cast<setter>(WalletItem_put_LogoText), nullptr, nullptr },
        { "body_font_color", reinterpret_cast<getter>(WalletItem_get_BodyFontColor), reinterpret_cast<setter>(WalletItem_put_BodyFontColor), nullptr, nullptr },
        { "body_color", reinterpret_cast<getter>(WalletItem_get_BodyColor), reinterpret_cast<setter>(WalletItem_put_BodyColor), nullptr, nullptr },
        { "body_background_image", reinterpret_cast<getter>(WalletItem_get_BodyBackgroundImage), reinterpret_cast<setter>(WalletItem_put_BodyBackgroundImage), nullptr, nullptr },
        { "is_display_message_launchable", reinterpret_cast<getter>(WalletItem_get_IsDisplayMessageLaunchable), reinterpret_cast<setter>(WalletItem_put_IsDisplayMessageLaunchable), nullptr, nullptr },
        { "is_acknowledged", reinterpret_cast<getter>(WalletItem_get_IsAcknowledged), reinterpret_cast<setter>(WalletItem_put_IsAcknowledged), nullptr, nullptr },
        { "is_more_transaction_history_launchable", reinterpret_cast<getter>(WalletItem_get_IsMoreTransactionHistoryLaunchable), reinterpret_cast<setter>(WalletItem_put_IsMoreTransactionHistoryLaunchable), nullptr, nullptr },
        { "header_font_color", reinterpret_cast<getter>(WalletItem_get_HeaderFontColor), reinterpret_cast<setter>(WalletItem_put_HeaderFontColor), nullptr, nullptr },
        { "header_color", reinterpret_cast<getter>(WalletItem_get_HeaderColor), reinterpret_cast<setter>(WalletItem_put_HeaderColor), nullptr, nullptr },
        { "header_background_image", reinterpret_cast<getter>(WalletItem_get_HeaderBackgroundImage), reinterpret_cast<setter>(WalletItem_put_HeaderBackgroundImage), nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(WalletItem_get_ExpirationDate), reinterpret_cast<setter>(WalletItem_put_ExpirationDate), nullptr, nullptr },
        { "logo99x99", reinterpret_cast<getter>(WalletItem_get_Logo99x99), reinterpret_cast<setter>(WalletItem_put_Logo99x99), nullptr, nullptr },
        { "logo_image", reinterpret_cast<getter>(WalletItem_get_LogoImage), reinterpret_cast<setter>(WalletItem_put_LogoImage), nullptr, nullptr },
        { "promotional_image", reinterpret_cast<getter>(WalletItem_get_PromotionalImage), reinterpret_cast<setter>(WalletItem_put_PromotionalImage), nullptr, nullptr },
        { "logo159x159", reinterpret_cast<getter>(WalletItem_get_Logo159x159), reinterpret_cast<setter>(WalletItem_put_Logo159x159), nullptr, nullptr },
        { "last_updated", reinterpret_cast<getter>(WalletItem_get_LastUpdated), reinterpret_cast<setter>(WalletItem_put_LastUpdated), nullptr, nullptr },
        { "issuer_display_name", reinterpret_cast<getter>(WalletItem_get_IssuerDisplayName), reinterpret_cast<setter>(WalletItem_put_IssuerDisplayName), nullptr, nullptr },
        { "barcode", reinterpret_cast<getter>(WalletItem_get_Barcode), reinterpret_cast<setter>(WalletItem_put_Barcode), nullptr, nullptr },
        { "relevant_date_display_message", reinterpret_cast<getter>(WalletItem_get_RelevantDateDisplayMessage), reinterpret_cast<setter>(WalletItem_put_RelevantDateDisplayMessage), nullptr, nullptr },
        { "relevant_date", reinterpret_cast<getter>(WalletItem_get_RelevantDate), reinterpret_cast<setter>(WalletItem_put_RelevantDate), nullptr, nullptr },
        { "logo336x336", reinterpret_cast<getter>(WalletItem_get_Logo336x336), reinterpret_cast<setter>(WalletItem_put_Logo336x336), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(WalletItem_get_Kind), nullptr, nullptr, nullptr },
        { "display_properties", reinterpret_cast<getter>(WalletItem_get_DisplayProperties), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(WalletItem_get_Id), nullptr, nullptr, nullptr },
        { "relevant_locations", reinterpret_cast<getter>(WalletItem_get_RelevantLocations), nullptr, nullptr, nullptr },
        { "transaction_history", reinterpret_cast<getter>(WalletItem_get_TransactionHistory), nullptr, nullptr, nullptr },
        { "verbs", reinterpret_cast<getter>(WalletItem_get_Verbs), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletItem) },
        { },
    };

    static PyType_Spec type_spec_WalletItem =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItem
    };

    // ----- WalletItemCustomProperty class --------------------

    static PyObject* _new_WalletItemCustomProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletItemCustomProperty(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItemCustomProperty_get_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_SummaryViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"SummaryViewPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SummaryViewPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_SummaryViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"SummaryViewPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletSummaryViewPosition>(arg);

            self->obj.SummaryViewPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_DetailViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"DetailViewPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DetailViewPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_DetailViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"DetailViewPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletDetailViewPosition>(arg);

            self->obj.DetailViewPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_AutoDetectLinks(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"AutoDetectLinks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoDetectLinks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_AutoDetectLinks(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletItemCustomProperty", L"AutoDetectLinks"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoDetectLinks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletItemCustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletItemCustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItemCustomProperty[] = {
        { "_assign_array_", _assign_array_WalletItemCustomProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItemCustomProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletItemCustomProperty[] = {
        { "value", reinterpret_cast<getter>(WalletItemCustomProperty_get_Value), reinterpret_cast<setter>(WalletItemCustomProperty_put_Value), nullptr, nullptr },
        { "summary_view_position", reinterpret_cast<getter>(WalletItemCustomProperty_get_SummaryViewPosition), reinterpret_cast<setter>(WalletItemCustomProperty_put_SummaryViewPosition), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(WalletItemCustomProperty_get_Name), reinterpret_cast<setter>(WalletItemCustomProperty_put_Name), nullptr, nullptr },
        { "detail_view_position", reinterpret_cast<getter>(WalletItemCustomProperty_get_DetailViewPosition), reinterpret_cast<setter>(WalletItemCustomProperty_put_DetailViewPosition), nullptr, nullptr },
        { "auto_detect_links", reinterpret_cast<getter>(WalletItemCustomProperty_get_AutoDetectLinks), reinterpret_cast<setter>(WalletItemCustomProperty_put_AutoDetectLinks), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletItemCustomProperty[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletItemCustomProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletItemCustomProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletItemCustomProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletItemCustomProperty) },
        { },
    };

    static PyType_Spec type_spec_WalletItemCustomProperty =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletItemCustomProperty",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItemCustomProperty
    };

    // ----- WalletItemStore class --------------------

    static PyObject* _new_WalletItemStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>::type_name);
        return nullptr;
    }

    static void _dealloc_WalletItemStore(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItemStore_AddAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"AddAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItem>(args, 1);

                return py::convert(self->obj.AddAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ClearAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ClearAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_DeleteAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"DeleteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetItemsAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"GetItemsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"GetItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>(args, 0);

                return py::convert(self->obj.GetItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetWalletItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"GetWalletItemAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetWalletItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ImportItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ImportItemAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(self->obj.ImportItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ShowAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ShowAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"ShowAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ShowAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_UpdateAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletItemStore", L"UpdateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItem>(args, 0);

                return py::convert(self->obj.UpdateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WalletItemStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletItemStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItemStore[] = {
        { "add_async", reinterpret_cast<PyCFunction>(WalletItemStore_AddAsync), METH_VARARGS, nullptr },
        { "clear_async", reinterpret_cast<PyCFunction>(WalletItemStore_ClearAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(WalletItemStore_DeleteAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetItemsAsync), METH_VARARGS, nullptr },
        { "get_wallet_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetWalletItemAsync), METH_VARARGS, nullptr },
        { "import_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_ImportItemAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(WalletItemStore_ShowAsync), METH_VARARGS, nullptr },
        { "update_async", reinterpret_cast<PyCFunction>(WalletItemStore_UpdateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WalletItemStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItemStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletItemStore[] = {
        { }
    };

    static PyType_Slot _type_slots_WalletItemStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletItemStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletItemStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletItemStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletItemStore) },
        { },
    };

    static PyType_Spec type_spec_WalletItemStore =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletItemStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItemStore
    };

    // ----- WalletManager class --------------------

    static PyObject* _new_WalletManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletManager>::type_name);
        return nullptr;
    }

    static PyObject* WalletManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Wallet.WalletManager", L"RequestStoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Wallet::WalletManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletManager[] = {
        { }
    };

    static PyGetSetDef _getset_WalletManager[] = {
        { }
    };

    static PyType_Slot _type_slots_WalletManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletManager) },
        { },
    };

    static PyType_Spec type_spec_WalletManager =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletManager
    };

    static PyGetSetDef getset_WalletManager_Static[] = {
        { }
    };

    static PyMethodDef methods_WalletManager_Static[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(WalletManager_RequestStoreAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_WalletManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WalletManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WalletManager_Static) },
        { }
    };

    static PyType_Spec type_spec_WalletManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WalletManager_Static
    };

    // ----- WalletRelevantLocation class --------------------

    static PyObject* _new_WalletRelevantLocation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletRelevantLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletRelevantLocation_get_Position(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletRelevantLocation_put_Position(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletRelevantLocation_get_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"DisplayMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletRelevantLocation_put_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletRelevantLocation", L"DisplayMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletRelevantLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletRelevantLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletRelevantLocation[] = {
        { "_assign_array_", _assign_array_WalletRelevantLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletRelevantLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletRelevantLocation[] = {
        { "position", reinterpret_cast<getter>(WalletRelevantLocation_get_Position), reinterpret_cast<setter>(WalletRelevantLocation_put_Position), nullptr, nullptr },
        { "display_message", reinterpret_cast<getter>(WalletRelevantLocation_get_DisplayMessage), reinterpret_cast<setter>(WalletRelevantLocation_put_DisplayMessage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletRelevantLocation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletRelevantLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletRelevantLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletRelevantLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletRelevantLocation) },
        { },
    };

    static PyType_Spec type_spec_WalletRelevantLocation =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletRelevantLocation",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletRelevantLocation
    };

    // ----- WalletTransaction class --------------------

    static PyObject* _new_WalletTransaction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Wallet::WalletTransaction instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletTransaction(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletTransaction_get_TransactionDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"TransactionDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransactionDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_TransactionDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"TransactionDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.TransactionDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_IsLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IsLaunchable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLaunchable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_IsLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IsLaunchable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLaunchable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_IgnoreTimeOfDay(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IgnoreTimeOfDay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnoreTimeOfDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_IgnoreTimeOfDay(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"IgnoreTimeOfDay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTimeOfDay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_DisplayLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_DisplayLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_DisplayAmount(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayAmount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayAmount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_DisplayAmount(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"DisplayAmount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayAmount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_Description(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_Description(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletTransaction", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletTransaction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletTransaction[] = {
        { "_assign_array_", _assign_array_WalletTransaction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletTransaction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletTransaction[] = {
        { "transaction_date", reinterpret_cast<getter>(WalletTransaction_get_TransactionDate), reinterpret_cast<setter>(WalletTransaction_put_TransactionDate), nullptr, nullptr },
        { "is_launchable", reinterpret_cast<getter>(WalletTransaction_get_IsLaunchable), reinterpret_cast<setter>(WalletTransaction_put_IsLaunchable), nullptr, nullptr },
        { "ignore_time_of_day", reinterpret_cast<getter>(WalletTransaction_get_IgnoreTimeOfDay), reinterpret_cast<setter>(WalletTransaction_put_IgnoreTimeOfDay), nullptr, nullptr },
        { "display_location", reinterpret_cast<getter>(WalletTransaction_get_DisplayLocation), reinterpret_cast<setter>(WalletTransaction_put_DisplayLocation), nullptr, nullptr },
        { "display_amount", reinterpret_cast<getter>(WalletTransaction_get_DisplayAmount), reinterpret_cast<setter>(WalletTransaction_put_DisplayAmount), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WalletTransaction_get_Description), reinterpret_cast<setter>(WalletTransaction_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletTransaction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletTransaction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletTransaction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletTransaction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletTransaction) },
        { },
    };

    static PyType_Spec type_spec_WalletTransaction =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletTransaction",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletTransaction
    };

    // ----- WalletVerb class --------------------

    static PyObject* _new_WalletVerb(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Wallet::WalletVerb instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletVerb(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletVerb_get_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletVerb", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletVerb_put_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Wallet.WalletVerb", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WalletVerb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Wallet::WalletVerb>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WalletVerb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletVerb>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletVerb[] = {
        { "_assign_array_", _assign_array_WalletVerb, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletVerb), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletVerb[] = {
        { "name", reinterpret_cast<getter>(WalletVerb_get_Name), reinterpret_cast<setter>(WalletVerb_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletVerb[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WalletVerb) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WalletVerb) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WalletVerb) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WalletVerb) },
        { },
    };

    static PyType_Spec type_spec_WalletVerb =
    {
        "winrt._winrt_windows_applicationmodel_wallet.WalletVerb",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletVerb
    };

    // ----- Windows.ApplicationModel.Wallet Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Wallet");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_wallet",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Wallet

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_wallet(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletBarcode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletItemCustomProperty, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletItemStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WalletManager_Static{PyType_FromSpec(&type_spec_WalletManager_Static)};
    if (!type_WalletManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WalletManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletRelevantLocation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletTransaction, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WalletVerb, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
