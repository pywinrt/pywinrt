// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Controls.h"

namespace py::cpp::Microsoft::UI::Xaml::Controls
{
    // ----- AppBarButton class --------------------

    static PyObject* _new_AppBarButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AppBarButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButton(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButton_get_LabelPosition(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_LabelPosition(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_Label(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Label(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverride(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_KeyboardAcceleratorTextOverride(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_Icon(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Icon(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconElement>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompact(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_IsCompact(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrder(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_DynamicOverflowOrder(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflow(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"IsInOverflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>().IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"IsCompactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"IsInOverflowProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverrideProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"LabelPositionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarButton", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButton[] = {
        { "_assign_array_", _assign_array_AppBarButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButton[] = {
        { "label_position", reinterpret_cast<getter>(AppBarButton_get_LabelPosition), reinterpret_cast<setter>(AppBarButton_put_LabelPosition), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AppBarButton_get_Label), reinterpret_cast<setter>(AppBarButton_put_Label), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarButton_get_Icon), reinterpret_cast<setter>(AppBarButton_put_Icon), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarButton_get_IsCompact), reinterpret_cast<setter>(AppBarButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButton) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.AppBarButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButton};

    static PyGetSetDef getset_AppBarButton_Static[] = {
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "icon_property", reinterpret_cast<getter>(AppBarButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.AppBarButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarButton_Static
    };

    // ----- AppBarToggleButton class --------------------

    static PyObject* _new_AppBarToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButton(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButton_get_LabelPosition(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_LabelPosition(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_Label(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Label(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverride(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_KeyboardAcceleratorTextOverride(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_Icon(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Icon(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconElement>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompact(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_IsCompact(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrder(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_DynamicOverflowOrder(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflow(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>().IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"IsCompactProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflowProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverrideProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"LabelPositionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.AppBarToggleButton", L"LabelProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButton[] = {
        { "_assign_array_", _assign_array_AppBarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButton[] = {
        { "label_position", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPosition), reinterpret_cast<setter>(AppBarToggleButton_put_LabelPosition), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AppBarToggleButton_get_Label), reinterpret_cast<setter>(AppBarToggleButton_put_Label), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarToggleButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarToggleButton_get_Icon), reinterpret_cast<setter>(AppBarToggleButton_put_Icon), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarToggleButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompact), reinterpret_cast<setter>(AppBarToggleButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarToggleButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButton) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.AppBarToggleButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::AppBarToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButton};

    static PyGetSetDef getset_AppBarToggleButton_Static[] = {
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "icon_property", reinterpret_cast<getter>(AppBarToggleButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.AppBarToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarToggleButton_Static
    };

    // ----- Button class --------------------

    static PyObject* _new_Button(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Button instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Button(py::wrapper::Microsoft::UI::Xaml::Controls::Button* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Button_get_Flyout(py::wrapper::Microsoft::UI::Xaml::Controls::Button* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Button", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Button>().Flyout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Button_put_Flyout(py::wrapper::Microsoft::UI::Xaml::Controls::Button* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Button", L"Flyout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Button>().Flyout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Button_get_FlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Button", L"FlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Button::FlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Button>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Button>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Button[] = {
        { "_assign_array_", _assign_array_Button, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Button), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Button[] = {
        { "flyout", reinterpret_cast<getter>(Button_get_Flyout), reinterpret_cast<setter>(Button_put_Flyout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Button[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Button) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Button) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Button) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Button) },
        { }
    };

    static PyType_Spec type_spec_Button = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.Button",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Button),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Button};

    static PyGetSetDef getset_Button_Static[] = {
        { "flyout_property", reinterpret_cast<getter>(Button_get_FlyoutProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Button_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Button_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Button_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Button_Static) },
        { }
    };

    static PyType_Spec type_spec_Button_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.Button_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Button_Static
    };

    // ----- CheckBox class --------------------

    static PyObject* _new_CheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::CheckBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBox(py::wrapper::Microsoft::UI::Xaml::Controls::CheckBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::CheckBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::CheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBox[] = {
        { "_assign_array_", _assign_array_CheckBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBox[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBox) },
        { }
    };

    static PyType_Spec type_spec_CheckBox = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.CheckBox",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::CheckBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CheckBox};

    static PyGetSetDef getset_CheckBox_Static[] = {
        { }
    };

    static PyMethodDef methods_CheckBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CheckBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CheckBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CheckBox_Static) },
        { }
    };

    static PyType_Spec type_spec_CheckBox_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.CheckBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CheckBox_Static
    };

    // ----- ComboBox class --------------------

    static PyObject* _new_ComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ComboBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBox(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBox_get_TextBoxStyle(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TextBoxStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().TextBoxStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_TextBoxStyle(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TextBoxStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Style>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().TextBoxStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Text(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Text(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTrigger(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().SelectionChangedTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_SelectionChangedTrigger(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBoxSelectionChangedTrigger>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().SelectionChangedTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_PlaceholderText(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderText(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForeground(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().PlaceholderForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderForeground(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().PlaceholderForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_MaxDropDownHeight(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().MaxDropDownHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_MaxDropDownHeight(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().MaxDropDownHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsTextSearchEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsTextSearchEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsTextSearchEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsEditable(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsEditable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsEditable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsEditable(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsEditable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsEditable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpen(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsDropDownOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsDropDownOpen(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsDropDownOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Header(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Header(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Description(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Description(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsSelectionBoxHighlighted(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsSelectionBoxHighlighted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().IsSelectionBoxHighlighted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItem(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"SelectionBoxItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().SelectionBoxItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItemTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"SelectionBoxItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().SelectionBoxItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"DescriptionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::DescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsDropDownOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::IsDropDownOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsEditableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsEditableProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::IsEditableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::IsTextSearchEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_MaxDropDownHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::MaxDropDownHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"PlaceholderForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::PlaceholderForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"PlaceholderTextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::PlaceholderTextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"SelectionChangedTriggerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::SelectionChangedTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TextBoxStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::TextBoxStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ComboBox::TextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownClosed(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"DropDownClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().DropDownClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownClosed(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"DropDownClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().DropDownClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownOpened(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"DropDownOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().DropDownOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownOpened(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"DropDownOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().DropDownOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_TextSubmitted(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TextSubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ComboBox, winrt::Microsoft::UI::Xaml::Controls::ComboBoxTextSubmittedEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().TextSubmitted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_TextSubmitted(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ComboBox", L"TextSubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>().TextSubmitted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBox[] = {
        { "add_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownClosed), METH_O, nullptr },
        { "remove_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownClosed), METH_O, nullptr },
        { "add_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownOpened), METH_O, nullptr },
        { "remove_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownOpened), METH_O, nullptr },
        { "add_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_add_TextSubmitted), METH_O, nullptr },
        { "remove_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_remove_TextSubmitted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBox[] = {
        { "text_box_style", reinterpret_cast<getter>(ComboBox_get_TextBoxStyle), reinterpret_cast<setter>(ComboBox_put_TextBoxStyle), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ComboBox_get_Text), reinterpret_cast<setter>(ComboBox_put_Text), nullptr, nullptr },
        { "selection_changed_trigger", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTrigger), reinterpret_cast<setter>(ComboBox_put_SelectionChangedTrigger), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(ComboBox_get_PlaceholderText), reinterpret_cast<setter>(ComboBox_put_PlaceholderText), nullptr, nullptr },
        { "placeholder_foreground", reinterpret_cast<getter>(ComboBox_get_PlaceholderForeground), reinterpret_cast<setter>(ComboBox_put_PlaceholderForeground), nullptr, nullptr },
        { "max_drop_down_height", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeight), reinterpret_cast<setter>(ComboBox_put_MaxDropDownHeight), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayMode), reinterpret_cast<setter>(ComboBox_put_LightDismissOverlayMode), nullptr, nullptr },
        { "is_text_search_enabled", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabled), reinterpret_cast<setter>(ComboBox_put_IsTextSearchEnabled), nullptr, nullptr },
        { "is_editable", reinterpret_cast<getter>(ComboBox_get_IsEditable), reinterpret_cast<setter>(ComboBox_put_IsEditable), nullptr, nullptr },
        { "is_drop_down_open", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpen), reinterpret_cast<setter>(ComboBox_put_IsDropDownOpen), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ComboBox_get_HeaderTemplate), reinterpret_cast<setter>(ComboBox_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ComboBox_get_Header), reinterpret_cast<setter>(ComboBox_put_Header), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ComboBox_get_Description), reinterpret_cast<setter>(ComboBox_put_Description), nullptr, nullptr },
        { "is_selection_box_highlighted", reinterpret_cast<getter>(ComboBox_get_IsSelectionBoxHighlighted), nullptr, nullptr, nullptr },
        { "selection_box_item", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItem), nullptr, nullptr, nullptr },
        { "selection_box_item_template", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItemTemplate), nullptr, nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ComboBox_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBox) },
        { }
    };

    static PyType_Spec type_spec_ComboBox = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ComboBox",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBox};

    static PyGetSetDef getset_ComboBox_Static[] = {
        { "description_property", reinterpret_cast<getter>(ComboBox_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ComboBox_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ComboBox_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "is_drop_down_open_property", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpenProperty), nullptr, nullptr, nullptr },
        { "is_editable_property", reinterpret_cast<getter>(ComboBox_get_IsEditableProperty), nullptr, nullptr, nullptr },
        { "is_text_search_enabled_property", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabledProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "max_drop_down_height_property", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeightProperty), nullptr, nullptr, nullptr },
        { "placeholder_foreground_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderForegroundProperty), nullptr, nullptr, nullptr },
        { "placeholder_text_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderTextProperty), nullptr, nullptr, nullptr },
        { "selection_changed_trigger_property", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTriggerProperty), nullptr, nullptr, nullptr },
        { "text_box_style_property", reinterpret_cast<getter>(ComboBox_get_TextBoxStyleProperty), nullptr, nullptr, nullptr },
        { "text_property", reinterpret_cast<getter>(ComboBox_get_TextProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ComboBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBox_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ComboBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBox_Static
    };

    // ----- ComboBoxItem class --------------------

    static PyObject* _new_ComboBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ComboBoxItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItem(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBoxItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ComboBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ComboBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItem[] = {
        { "_assign_array_", _assign_array_ComboBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItem) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ComboBoxItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ComboBoxItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItem};

    static PyGetSetDef getset_ComboBoxItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ComboBoxItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxItem_Static
    };

    // ----- DropDownButton class --------------------

    static PyObject* _new_DropDownButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::DropDownButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButton(py::wrapper::Microsoft::UI::Xaml::Controls::DropDownButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButton[] = {
        { "_assign_array_", _assign_array_DropDownButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropDownButton[] = {
        { }
    };

    static PyType_Slot _type_slots_DropDownButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButton) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.DropDownButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::DropDownButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropDownButton};

    static PyGetSetDef getset_DropDownButton_Static[] = {
        { }
    };

    static PyMethodDef methods_DropDownButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DropDownButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropDownButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropDownButton_Static) },
        { }
    };

    static PyType_Spec type_spec_DropDownButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.DropDownButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DropDownButton_Static
    };

    // ----- FlipView class --------------------

    static PyObject* _new_FlipView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::FlipView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipView(py::wrapper::Microsoft::UI::Xaml::Controls::FlipView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigation(py::wrapper::Microsoft::UI::Xaml::Controls::FlipView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FlipView>().UseTouchAnimationsForAllNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlipView_put_UseTouchAnimationsForAllNavigation(py::wrapper::Microsoft::UI::Xaml::Controls::FlipView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::FlipView>().UseTouchAnimationsForAllNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::FlipView::UseTouchAnimationsForAllNavigationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::FlipView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::FlipView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipView[] = {
        { "_assign_array_", _assign_array_FlipView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipView[] = {
        { "use_touch_animations_for_all_navigation", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigation), reinterpret_cast<setter>(FlipView_put_UseTouchAnimationsForAllNavigation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlipView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipView) },
        { }
    };

    static PyType_Spec type_spec_FlipView = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.FlipView",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::FlipView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipView};

    static PyGetSetDef getset_FlipView_Static[] = {
        { "use_touch_animations_for_all_navigation_property", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlipView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipView_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipView_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.FlipView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipView_Static
    };

    // ----- FlipViewItem class --------------------

    static PyObject* _new_FlipViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::FlipViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItem(py::wrapper::Microsoft::UI::Xaml::Controls::FlipViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::FlipViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::FlipViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItem[] = {
        { "_assign_array_", _assign_array_FlipViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItem[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItem) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.FlipViewItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::FlipViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItem};

    static PyGetSetDef getset_FlipViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.FlipViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipViewItem_Static
    };

    // ----- GridView class --------------------

    static PyObject* _new_GridView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::GridView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridView(py::wrapper::Microsoft::UI::Xaml::Controls::GridView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::GridView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::GridView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridView[] = {
        { "_assign_array_", _assign_array_GridView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridView[] = {
        { }
    };

    static PyType_Slot _type_slots_GridView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridView) },
        { }
    };

    static PyType_Spec type_spec_GridView = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.GridView",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::GridView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridView};

    static PyGetSetDef getset_GridView_Static[] = {
        { }
    };

    static PyMethodDef methods_GridView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridView_Static) },
        { }
    };

    static PyType_Spec type_spec_GridView_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.GridView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridView_Static
    };

    // ----- GridViewItem class --------------------

    static PyObject* _new_GridViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::GridViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItem(py::wrapper::Microsoft::UI::Xaml::Controls::GridViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItem_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::GridViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.GridViewItem", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::GridViewItem>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::GridViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::GridViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItem[] = {
        { "_assign_array_", _assign_array_GridViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(GridViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItem) },
        { }
    };

    static PyType_Spec type_spec_GridViewItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.GridViewItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::GridViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItem};

    static PyGetSetDef getset_GridViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.GridViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewItem_Static
    };

    // ----- HyperlinkButton class --------------------

    static PyObject* _new_HyperlinkButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButton(py::wrapper::Microsoft::UI::Xaml::Controls::HyperlinkButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButton_get_NavigateUri(py::wrapper::Microsoft::UI::Xaml::Controls::HyperlinkButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton>().NavigateUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HyperlinkButton_put_NavigateUri(py::wrapper::Microsoft::UI::Xaml::Controls::HyperlinkButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton>().NavigateUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HyperlinkButton_get_NavigateUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.HyperlinkButton", L"NavigateUriProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton::NavigateUriProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButton[] = {
        { "_assign_array_", _assign_array_HyperlinkButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButton[] = {
        { "navigate_uri", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUri), reinterpret_cast<setter>(HyperlinkButton_put_NavigateUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButton) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.HyperlinkButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::HyperlinkButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkButton};

    static PyGetSetDef getset_HyperlinkButton_Static[] = {
        { "navigate_uri_property", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUriProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HyperlinkButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HyperlinkButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HyperlinkButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HyperlinkButton_Static) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.HyperlinkButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HyperlinkButton_Static
    };

    // ----- ListBox class --------------------

    static PyObject* _new_ListBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ListBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBox(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBox_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_SelectAll(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocus(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SingleSelectionFollowsFocus(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectionMode(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SelectionMode(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SelectionMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectedItems(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListBox>().SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListBox::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListBox::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ListBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ListBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBox[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBox_ScrollIntoView), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListBox_SelectAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBox[] = {
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListBox_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { "selection_mode", reinterpret_cast<getter>(ListBox_get_SelectionMode), reinterpret_cast<setter>(ListBox_put_SelectionMode), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListBox_get_SelectedItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBox) },
        { }
    };

    static PyType_Spec type_spec_ListBox = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListBox",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ListBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBox};

    static PyGetSetDef getset_ListBox_Static[] = {
        { "selection_mode_property", reinterpret_cast<getter>(ListBox_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBox_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBox_Static
    };

    // ----- ListBoxItem class --------------------

    static PyObject* _new_ListBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ListBoxItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItem(py::wrapper::Microsoft::UI::Xaml::Controls::ListBoxItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ListBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ListBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItem[] = {
        { "_assign_array_", _assign_array_ListBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItem) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListBoxItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ListBoxItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItem};

    static PyGetSetDef getset_ListBoxItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListBoxItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBoxItem_Static
    };

    // ----- ListView class --------------------

    static PyObject* _new_ListView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ListView instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListView(py::wrapper::Microsoft::UI::Xaml::Controls::ListView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ListView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ListView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListView[] = {
        { "_assign_array_", _assign_array_ListView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListView[] = {
        { }
    };

    static PyType_Slot _type_slots_ListView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListView) },
        { }
    };

    static PyType_Spec type_spec_ListView = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListView",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ListView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListView};

    static PyGetSetDef getset_ListView_Static[] = {
        { }
    };

    static PyMethodDef methods_ListView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListView_Static) },
        { }
    };

    static PyType_Spec type_spec_ListView_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListView_Static
    };

    // ----- ListViewBase class --------------------

    static PyObject* _new_ListViewBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBase(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBase_CompleteViewChange(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CompleteViewChange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CompleteViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeFrom(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeFrom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CompleteViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeTo(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CompleteViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_DeselectRange(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DeselectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DeselectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_InitializeViewChange(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"InitializeViewChange", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().InitializeViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_IsDragSource(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsDragSource", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsDragSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_LoadMoreItemsAsync(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"LoadMoreItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().LoadMoreItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_MakeVisible(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"MakeVisible", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().MakeVisible(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_PrepareConnectedAnimation(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"PrepareConnectedAnimation", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().PrepareConnectedAnimation(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoViewWithAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollIntoViewAlignment>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ScrollIntoView(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectAll(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectRange(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SelectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SetDesiredContainerUpdateDuration(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SetDesiredContainerUpdateDuration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SetDesiredContainerUpdateDuration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeFrom(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"StartViewChangeFrom", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().StartViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeTo(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"StartViewChangeTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().StartViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_TryStartConnectedAnimationAsync(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"TryStartConnectedAnimationAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Animation::ConnectedAnimation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().TryStartConnectedAnimationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocus(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SingleSelectionFollowsFocus(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholders(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ShowsScrollingPlaceholders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ShowsScrollingPlaceholders(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ShowsScrollingPlaceholders(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectionMode(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SelectionMode(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListViewSelectionMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_ReorderMode(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ReorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ReorderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ReorderMode(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ReorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListViewReorderMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ReorderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsSwipeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsSwipeEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsSwipeEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsMultiSelectCheckBoxEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsMultiSelectCheckBoxEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsMultiSelectCheckBoxEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsItemClickEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsItemClickEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsItemClickEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTrigger(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingTrigger(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IncrementalLoadingTrigger>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThreshold(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingThreshold(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IncrementalLoadingThreshold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().HeaderTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().HeaderTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Header(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Header(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().FooterTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().FooterTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().FooterTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().FooterTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Footer(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"Footer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().Footer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Footer(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"Footer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().Footer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSize(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DataFetchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DataFetchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_DataFetchSize(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DataFetchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DataFetchSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItems(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CanReorderItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanReorderItems(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CanReorderItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CanReorderItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItems(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CanDragItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanDragItems(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CanDragItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().CanDragItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedItems(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectedRanges(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectedRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SelectedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwner(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SemanticZoomOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SemanticZoomOwner(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoom>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().SemanticZoomOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInView(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsZoomedInView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsZoomedInView(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsZoomedInView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsActiveView(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsActiveView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsActiveView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsActiveView(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsActiveView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().IsActiveView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CanDragItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::CanDragItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"CanReorderItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::CanReorderItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DataFetchSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::DataFetchSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::FooterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::FooterTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"FooterTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::FooterTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"HeaderTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::HeaderTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThresholdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThresholdProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IncrementalLoadingThresholdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTriggerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IncrementalLoadingTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsActiveViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsActiveViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IsActiveViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IsItemClickEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IsMultiSelectCheckBoxEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IsSwipeEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"IsZoomedInViewProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::IsZoomedInViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ReorderModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ReorderModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::ReorderModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SelectionModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwnerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::SemanticZoomOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholdersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholdersProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::ShowsScrollingPlaceholdersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ListViewBase::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingGroupHeaderContainer(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ListViewBase, winrt::Microsoft::UI::Xaml::Controls::ChoosingGroupHeaderContainerEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ChoosingGroupHeaderContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingGroupHeaderContainer(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ChoosingGroupHeaderContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingItemContainer(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ListViewBase, winrt::Microsoft::UI::Xaml::Controls::ChoosingItemContainerEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ChoosingItemContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingItemContainer(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ChoosingItemContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ContainerContentChanging(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ListViewBase, winrt::Microsoft::UI::Xaml::Controls::ContainerContentChangingEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ContainerContentChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ContainerContentChanging(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ContainerContentChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::ListViewBase, winrt::Microsoft::UI::Xaml::Controls::DragItemsCompletedEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DragItemsCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DragItemsCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsStarting(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::DragItemsStartingEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DragItemsStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsStarting(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().DragItemsStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ItemClick(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ItemClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ItemClickEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ItemClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ItemClick(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.ListViewBase", L"ItemClick");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>().ItemClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBase[] = {
        { "complete_view_change", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChange), METH_VARARGS, nullptr },
        { "complete_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeFrom), METH_VARARGS, nullptr },
        { "complete_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeTo), METH_VARARGS, nullptr },
        { "deselect_range", reinterpret_cast<PyCFunction>(ListViewBase_DeselectRange), METH_VARARGS, nullptr },
        { "initialize_view_change", reinterpret_cast<PyCFunction>(ListViewBase_InitializeViewChange), METH_VARARGS, nullptr },
        { "is_drag_source", reinterpret_cast<PyCFunction>(ListViewBase_IsDragSource), METH_VARARGS, nullptr },
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ListViewBase_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(ListViewBase_MakeVisible), METH_VARARGS, nullptr },
        { "prepare_connected_animation", reinterpret_cast<PyCFunction>(ListViewBase_PrepareConnectedAnimation), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoView), METH_VARARGS, nullptr },
        { "scroll_into_view_with_alignment", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoViewWithAlignment), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListViewBase_SelectAll), METH_VARARGS, nullptr },
        { "select_range", reinterpret_cast<PyCFunction>(ListViewBase_SelectRange), METH_VARARGS, nullptr },
        { "set_desired_container_update_duration", reinterpret_cast<PyCFunction>(ListViewBase_SetDesiredContainerUpdateDuration), METH_VARARGS, nullptr },
        { "start_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeFrom), METH_VARARGS, nullptr },
        { "start_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeTo), METH_VARARGS, nullptr },
        { "try_start_connected_animation_async", reinterpret_cast<PyCFunction>(ListViewBase_TryStartConnectedAnimationAsync), METH_VARARGS, nullptr },
        { "add_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "remove_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "add_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingItemContainer), METH_O, nullptr },
        { "remove_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingItemContainer), METH_O, nullptr },
        { "add_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_add_ContainerContentChanging), METH_O, nullptr },
        { "remove_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_remove_ContainerContentChanging), METH_O, nullptr },
        { "add_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsCompleted), METH_O, nullptr },
        { "remove_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsCompleted), METH_O, nullptr },
        { "add_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsStarting), METH_O, nullptr },
        { "remove_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsStarting), METH_O, nullptr },
        { "add_item_click", reinterpret_cast<PyCFunction>(ListViewBase_add_ItemClick), METH_O, nullptr },
        { "remove_item_click", reinterpret_cast<PyCFunction>(ListViewBase_remove_ItemClick), METH_O, nullptr },
        { "_assign_array_", _assign_array_ListViewBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBase[] = {
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListViewBase_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { "shows_scrolling_placeholders", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholders), reinterpret_cast<setter>(ListViewBase_put_ShowsScrollingPlaceholders), nullptr, nullptr },
        { "selection_mode", reinterpret_cast<getter>(ListViewBase_get_SelectionMode), reinterpret_cast<setter>(ListViewBase_put_SelectionMode), nullptr, nullptr },
        { "reorder_mode", reinterpret_cast<getter>(ListViewBase_get_ReorderMode), reinterpret_cast<setter>(ListViewBase_put_ReorderMode), nullptr, nullptr },
        { "is_swipe_enabled", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabled), reinterpret_cast<setter>(ListViewBase_put_IsSwipeEnabled), nullptr, nullptr },
        { "is_multi_select_check_box_enabled", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabled), reinterpret_cast<setter>(ListViewBase_put_IsMultiSelectCheckBoxEnabled), nullptr, nullptr },
        { "is_item_click_enabled", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabled), reinterpret_cast<setter>(ListViewBase_put_IsItemClickEnabled), nullptr, nullptr },
        { "incremental_loading_trigger", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTrigger), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingTrigger), nullptr, nullptr },
        { "incremental_loading_threshold", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThreshold), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingThreshold), nullptr, nullptr },
        { "header_transitions", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitions), reinterpret_cast<setter>(ListViewBase_put_HeaderTransitions), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplate), reinterpret_cast<setter>(ListViewBase_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ListViewBase_get_Header), reinterpret_cast<setter>(ListViewBase_put_Header), nullptr, nullptr },
        { "footer_transitions", reinterpret_cast<getter>(ListViewBase_get_FooterTransitions), reinterpret_cast<setter>(ListViewBase_put_FooterTransitions), nullptr, nullptr },
        { "footer_template", reinterpret_cast<getter>(ListViewBase_get_FooterTemplate), reinterpret_cast<setter>(ListViewBase_put_FooterTemplate), nullptr, nullptr },
        { "footer", reinterpret_cast<getter>(ListViewBase_get_Footer), reinterpret_cast<setter>(ListViewBase_put_Footer), nullptr, nullptr },
        { "data_fetch_size", reinterpret_cast<getter>(ListViewBase_get_DataFetchSize), reinterpret_cast<setter>(ListViewBase_put_DataFetchSize), nullptr, nullptr },
        { "can_reorder_items", reinterpret_cast<getter>(ListViewBase_get_CanReorderItems), reinterpret_cast<setter>(ListViewBase_put_CanReorderItems), nullptr, nullptr },
        { "can_drag_items", reinterpret_cast<getter>(ListViewBase_get_CanDragItems), reinterpret_cast<setter>(ListViewBase_put_CanDragItems), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListViewBase_get_SelectedItems), nullptr, nullptr, nullptr },
        { "selected_ranges", reinterpret_cast<getter>(ListViewBase_get_SelectedRanges), nullptr, nullptr, nullptr },
        { "semantic_zoom_owner", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwner), reinterpret_cast<setter>(ListViewBase_put_SemanticZoomOwner), nullptr, nullptr },
        { "is_zoomed_in_view", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInView), reinterpret_cast<setter>(ListViewBase_put_IsZoomedInView), nullptr, nullptr },
        { "is_active_view", reinterpret_cast<getter>(ListViewBase_get_IsActiveView), reinterpret_cast<setter>(ListViewBase_put_IsActiveView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBase) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListViewBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBase};

    static PyGetSetDef getset_ListViewBase_Static[] = {
        { "can_drag_items_property", reinterpret_cast<getter>(ListViewBase_get_CanDragItemsProperty), nullptr, nullptr, nullptr },
        { "can_reorder_items_property", reinterpret_cast<getter>(ListViewBase_get_CanReorderItemsProperty), nullptr, nullptr, nullptr },
        { "data_fetch_size_property", reinterpret_cast<getter>(ListViewBase_get_DataFetchSizeProperty), nullptr, nullptr, nullptr },
        { "footer_property", reinterpret_cast<getter>(ListViewBase_get_FooterProperty), nullptr, nullptr, nullptr },
        { "footer_template_property", reinterpret_cast<getter>(ListViewBase_get_FooterTemplateProperty), nullptr, nullptr, nullptr },
        { "footer_transitions_property", reinterpret_cast<getter>(ListViewBase_get_FooterTransitionsProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ListViewBase_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "header_transitions_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitionsProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_threshold_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThresholdProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_trigger_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTriggerProperty), nullptr, nullptr, nullptr },
        { "is_active_view_property", reinterpret_cast<getter>(ListViewBase_get_IsActiveViewProperty), nullptr, nullptr, nullptr },
        { "is_item_click_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabledProperty), nullptr, nullptr, nullptr },
        { "is_multi_select_check_box_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty), nullptr, nullptr, nullptr },
        { "is_swipe_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabledProperty), nullptr, nullptr, nullptr },
        { "is_zoomed_in_view_property", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInViewProperty), nullptr, nullptr, nullptr },
        { "reorder_mode_property", reinterpret_cast<getter>(ListViewBase_get_ReorderModeProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(ListViewBase_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "semantic_zoom_owner_property", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwnerProperty), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders_property", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholdersProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListViewBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewBase_Static
    };

    // ----- ListViewItem class --------------------

    static PyObject* _new_ListViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ListViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItem(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItem_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ListViewItem", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ListViewItem>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ListViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ListViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItem[] = {
        { "_assign_array_", _assign_array_ListViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(ListViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItem) },
        { }
    };

    static PyType_Spec type_spec_ListViewItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListViewItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ListViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItem};

    static PyGetSetDef getset_ListViewItem_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ListViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewItem_Static
    };

    // ----- ProgressBar class --------------------

    static PyObject* _new_ProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::ProgressBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBar(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBar_get_ShowPaused(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowPaused(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_ShowError(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowError(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().ShowError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminate(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().IsIndeterminate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_IsIndeterminate(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().IsIndeterminate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>().TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"IsIndeterminateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ProgressBar::IsIndeterminateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowErrorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowErrorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ProgressBar::ShowErrorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowPausedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.ProgressBar", L"ShowPausedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::ProgressBar::ShowPausedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBar[] = {
        { "_assign_array_", _assign_array_ProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBar[] = {
        { "show_paused", reinterpret_cast<getter>(ProgressBar_get_ShowPaused), reinterpret_cast<setter>(ProgressBar_put_ShowPaused), nullptr, nullptr },
        { "show_error", reinterpret_cast<getter>(ProgressBar_get_ShowError), reinterpret_cast<setter>(ProgressBar_put_ShowError), nullptr, nullptr },
        { "is_indeterminate", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminate), reinterpret_cast<setter>(ProgressBar_put_IsIndeterminate), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ProgressBar_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBar) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ProgressBar",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::ProgressBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBar};

    static PyGetSetDef getset_ProgressBar_Static[] = {
        { "is_indeterminate_property", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminateProperty), nullptr, nullptr, nullptr },
        { "show_error_property", reinterpret_cast<getter>(ProgressBar_get_ShowErrorProperty), nullptr, nullptr, nullptr },
        { "show_paused_property", reinterpret_cast<getter>(ProgressBar_get_ShowPausedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ProgressBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.ProgressBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProgressBar_Static
    };

    // ----- RadioButton class --------------------

    static PyObject* _new_RadioButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::RadioButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButton(py::wrapper::Microsoft::UI::Xaml::Controls::RadioButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButton_get_GroupName(py::wrapper::Microsoft::UI::Xaml::Controls::RadioButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButton", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButton>().GroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButton_put_GroupName(py::wrapper::Microsoft::UI::Xaml::Controls::RadioButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButton", L"GroupName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::RadioButton>().GroupName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButton_get_GroupNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.RadioButton", L"GroupNameProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::RadioButton::GroupNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RadioButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RadioButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButton[] = {
        { "_assign_array_", _assign_array_RadioButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButton[] = {
        { "group_name", reinterpret_cast<getter>(RadioButton_get_GroupName), reinterpret_cast<setter>(RadioButton_put_GroupName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButton) },
        { }
    };

    static PyType_Spec type_spec_RadioButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.RadioButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::RadioButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButton};

    static PyGetSetDef getset_RadioButton_Static[] = {
        { "group_name_property", reinterpret_cast<getter>(RadioButton_get_GroupNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RadioButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.RadioButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadioButton_Static
    };

    // ----- RevealListViewItemPresenter class --------------------

    static PyObject* _new_RevealListViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RevealListViewItemPresenter(py::wrapper::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RevealListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RevealListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RevealListViewItemPresenter[] = {
        { "_assign_array_", _assign_array_RevealListViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RevealListViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RevealListViewItemPresenter[] = {
        { }
    };

    static PyType_Slot _type_slots_RevealListViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RevealListViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RevealListViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RevealListViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RevealListViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_RevealListViewItemPresenter = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.RevealListViewItemPresenter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::RevealListViewItemPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RevealListViewItemPresenter};

    static PyGetSetDef getset_RevealListViewItemPresenter_Static[] = {
        { }
    };

    static PyMethodDef methods_RevealListViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RevealListViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RevealListViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RevealListViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_RevealListViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.RevealListViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RevealListViewItemPresenter_Static
    };

    // ----- Slider class --------------------

    static PyObject* _new_Slider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Slider instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Slider(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Slider_get_TickPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"TickPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().TickPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"TickPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::TickPlacement>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().TickPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_TickFrequency(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"TickFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().TickFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickFrequency(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"TickFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().TickFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().ThumbToolTipValueConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_ThumbToolTipValueConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Data::IValueConverter>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().ThumbToolTipValueConverter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_StepFrequency(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"StepFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().StepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_StepFrequency(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"StepFrequency");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().StepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_SnapsTo(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"SnapsTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().SnapsTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_SnapsTo(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"SnapsTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SliderSnapsTo>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().SnapsTo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().IsThumbToolTipEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsThumbToolTipEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().IsThumbToolTipEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsDirectionReversed(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IsDirectionReversed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().IsDirectionReversed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsDirectionReversed(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IsDirectionReversed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().IsDirectionReversed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValue(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IntermediateValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().IntermediateValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IntermediateValue(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IntermediateValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().IntermediateValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Header(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Header(py::wrapper::Microsoft::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Slider>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IntermediateValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IntermediateValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::IntermediateValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsDirectionReversedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IsDirectionReversedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::IsDirectionReversedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::IsThumbToolTipEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_SnapsToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"SnapsToProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::SnapsToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_StepFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"StepFrequencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::StepFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::ThumbToolTipValueConverterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"TickFrequencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::TickFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Slider", L"TickPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Slider::TickPlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Slider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Slider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Slider[] = {
        { "_assign_array_", _assign_array_Slider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Slider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Slider[] = {
        { "tick_placement", reinterpret_cast<getter>(Slider_get_TickPlacement), reinterpret_cast<setter>(Slider_put_TickPlacement), nullptr, nullptr },
        { "tick_frequency", reinterpret_cast<getter>(Slider_get_TickFrequency), reinterpret_cast<setter>(Slider_put_TickFrequency), nullptr, nullptr },
        { "thumb_tool_tip_value_converter", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverter), reinterpret_cast<setter>(Slider_put_ThumbToolTipValueConverter), nullptr, nullptr },
        { "step_frequency", reinterpret_cast<getter>(Slider_get_StepFrequency), reinterpret_cast<setter>(Slider_put_StepFrequency), nullptr, nullptr },
        { "snaps_to", reinterpret_cast<getter>(Slider_get_SnapsTo), reinterpret_cast<setter>(Slider_put_SnapsTo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(Slider_get_Orientation), reinterpret_cast<setter>(Slider_put_Orientation), nullptr, nullptr },
        { "is_thumb_tool_tip_enabled", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabled), reinterpret_cast<setter>(Slider_put_IsThumbToolTipEnabled), nullptr, nullptr },
        { "is_direction_reversed", reinterpret_cast<getter>(Slider_get_IsDirectionReversed), reinterpret_cast<setter>(Slider_put_IsDirectionReversed), nullptr, nullptr },
        { "intermediate_value", reinterpret_cast<getter>(Slider_get_IntermediateValue), reinterpret_cast<setter>(Slider_put_IntermediateValue), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(Slider_get_HeaderTemplate), reinterpret_cast<setter>(Slider_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(Slider_get_Header), reinterpret_cast<setter>(Slider_put_Header), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Slider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Slider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Slider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Slider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Slider) },
        { }
    };

    static PyType_Spec type_spec_Slider = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.Slider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Slider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Slider};

    static PyGetSetDef getset_Slider_Static[] = {
        { "header_property", reinterpret_cast<getter>(Slider_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(Slider_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "intermediate_value_property", reinterpret_cast<getter>(Slider_get_IntermediateValueProperty), nullptr, nullptr, nullptr },
        { "is_direction_reversed_property", reinterpret_cast<getter>(Slider_get_IsDirectionReversedProperty), nullptr, nullptr, nullptr },
        { "is_thumb_tool_tip_enabled_property", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabledProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(Slider_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "snaps_to_property", reinterpret_cast<getter>(Slider_get_SnapsToProperty), nullptr, nullptr, nullptr },
        { "step_frequency_property", reinterpret_cast<getter>(Slider_get_StepFrequencyProperty), nullptr, nullptr, nullptr },
        { "thumb_tool_tip_value_converter_property", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverterProperty), nullptr, nullptr, nullptr },
        { "tick_frequency_property", reinterpret_cast<getter>(Slider_get_TickFrequencyProperty), nullptr, nullptr, nullptr },
        { "tick_placement_property", reinterpret_cast<getter>(Slider_get_TickPlacementProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Slider_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Slider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Slider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Slider_Static) },
        { }
    };

    static PyType_Spec type_spec_Slider_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.Slider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Slider_Static
    };

    // ----- TabViewItem class --------------------

    static PyObject* _new_TabViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::TabViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewItem(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TabViewItem_get_IsClosable(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IsClosable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IsClosable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_IsClosable(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IsClosable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IsClosable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_IconSource(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IconSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_IconSource(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconSource>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().IconSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_HeaderTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_Header(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TabViewItem_put_Header(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TabViewItem_get_TabViewTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"TabViewTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().TabViewTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TabViewItem::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"HeaderTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TabViewItem::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_IconSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IconSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TabViewItem::IconSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_IsClosableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"IsClosableProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TabViewItem::IsClosableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_get_TabViewTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"TabViewTemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TabViewItem::TabViewTemplateSettingsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_add_CloseRequested(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"CloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::TabViewItem, winrt::Microsoft::UI::Xaml::Controls::TabViewTabCloseRequestedEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().CloseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TabViewItem_remove_CloseRequested(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.TabViewItem", L"CloseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>().CloseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TabViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewItem[] = {
        { "add_close_requested", reinterpret_cast<PyCFunction>(TabViewItem_add_CloseRequested), METH_O, nullptr },
        { "remove_close_requested", reinterpret_cast<PyCFunction>(TabViewItem_remove_CloseRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_TabViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TabViewItem[] = {
        { "is_closable", reinterpret_cast<getter>(TabViewItem_get_IsClosable), reinterpret_cast<setter>(TabViewItem_put_IsClosable), nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(TabViewItem_get_IconSource), reinterpret_cast<setter>(TabViewItem_put_IconSource), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(TabViewItem_get_HeaderTemplate), reinterpret_cast<setter>(TabViewItem_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(TabViewItem_get_Header), reinterpret_cast<setter>(TabViewItem_put_Header), nullptr, nullptr },
        { "tab_view_template_settings", reinterpret_cast<getter>(TabViewItem_get_TabViewTemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TabViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewItem) },
        { }
    };

    static PyType_Spec type_spec_TabViewItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.TabViewItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TabViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewItem};

    static PyGetSetDef getset_TabViewItem_Static[] = {
        { "header_property", reinterpret_cast<getter>(TabViewItem_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(TabViewItem_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "icon_source_property", reinterpret_cast<getter>(TabViewItem_get_IconSourceProperty), nullptr, nullptr, nullptr },
        { "is_closable_property", reinterpret_cast<getter>(TabViewItem_get_IsClosableProperty), nullptr, nullptr, nullptr },
        { "tab_view_template_settings_property", reinterpret_cast<getter>(TabViewItem_get_TabViewTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TabViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TabViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.TabViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TabViewItem_Static
    };

    // ----- TreeViewItem class --------------------

    static PyObject* _new_TreeViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::TreeViewItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItem(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItem_get_IsExpanded(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().IsExpanded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_IsExpanded(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"IsExpanded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().IsExpanded(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSize(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphSize(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrush(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphBrush(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().GlyphBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyph(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ExpandedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ExpandedGlyph(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ExpandedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyph(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().CollapsedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_CollapsedGlyph(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().CollapsedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().TreeViewItemTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSource(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ItemsSource(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ItemsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildren(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().HasUnrealizedChildren());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_HasUnrealizedChildren(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>().HasUnrealizedChildren(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::CollapsedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyphProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::ExpandedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::GlyphBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::GlyphOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"GlyphSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::GlyphSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"IsExpandedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::IsExpandedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::TreeViewItemTemplateSettingsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::HasUnrealizedChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.TreeViewItem", L"ItemsSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::TreeViewItem::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItem[] = {
        { "_assign_array_", _assign_array_TreeViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItem[] = {
        { "is_expanded", reinterpret_cast<getter>(TreeViewItem_get_IsExpanded), reinterpret_cast<setter>(TreeViewItem_put_IsExpanded), nullptr, nullptr },
        { "glyph_size", reinterpret_cast<getter>(TreeViewItem_get_GlyphSize), reinterpret_cast<setter>(TreeViewItem_put_GlyphSize), nullptr, nullptr },
        { "glyph_opacity", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacity), reinterpret_cast<setter>(TreeViewItem_put_GlyphOpacity), nullptr, nullptr },
        { "glyph_brush", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrush), reinterpret_cast<setter>(TreeViewItem_put_GlyphBrush), nullptr, nullptr },
        { "expanded_glyph", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyph), reinterpret_cast<setter>(TreeViewItem_put_ExpandedGlyph), nullptr, nullptr },
        { "collapsed_glyph", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyph), reinterpret_cast<setter>(TreeViewItem_put_CollapsedGlyph), nullptr, nullptr },
        { "tree_view_item_template_settings", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettings), nullptr, nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(TreeViewItem_get_ItemsSource), reinterpret_cast<setter>(TreeViewItem_put_ItemsSource), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildren), reinterpret_cast<setter>(TreeViewItem_put_HasUnrealizedChildren), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItem) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.TreeViewItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItem};

    static PyGetSetDef getset_TreeViewItem_Static[] = {
        { "collapsed_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyphProperty), nullptr, nullptr, nullptr },
        { "expanded_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyphProperty), nullptr, nullptr, nullptr },
        { "glyph_brush_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrushProperty), nullptr, nullptr, nullptr },
        { "glyph_opacity_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacityProperty), nullptr, nullptr, nullptr },
        { "glyph_size_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphSizeProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(TreeViewItem_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { "tree_view_item_template_settings_property", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "has_unrealized_children_property", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildrenProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(TreeViewItem_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TreeViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.TreeViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewItem_Static
    };

    // ----- TreeViewList class --------------------

    static PyObject* _new_TreeViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::TreeViewList instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewList(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewList[] = {
        { "_assign_array_", _assign_array_TreeViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewList) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.TreeViewList",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::TreeViewList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewList};

    static PyGetSetDef getset_TreeViewList_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewList_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewList_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewList_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewList_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewList_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.TreeViewList_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewList_Static
    };

    // ----- VirtualizingStackPanel class --------------------

    static PyObject* _new_VirtualizingStackPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualizingStackPanel(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VirtualizingStackPanel_GetIsVirtualizing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"GetIsVirtualizing", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::GetIsVirtualizing(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_GetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"GetVirtualizationMode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::GetVirtualizationMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_SetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"SetVirtualizationMode", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::VirtualizationMode>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::SetVirtualizationMode(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreScrollSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_AreScrollSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreScrollSnapPointsRegular(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegularProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::AreScrollSnapPointsRegularProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_IsVirtualizingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"IsVirtualizingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::IsVirtualizingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_VirtualizationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"VirtualizationModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel::VirtualizationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::CleanUpVirtualizedItemEventHandler>(arg);

            return py::convert(self->obj.CleanUpVirtualizedItemEvent(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CleanUpVirtualizedItemEvent(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualizingStackPanel[] = {
        { "add_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "remove_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "_assign_array_", _assign_array_VirtualizingStackPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualizingStackPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VirtualizingStackPanel[] = {
        { "orientation", reinterpret_cast<getter>(VirtualizingStackPanel_get_Orientation), reinterpret_cast<setter>(VirtualizingStackPanel_put_Orientation), nullptr, nullptr },
        { "are_scroll_snap_points_regular", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegular), reinterpret_cast<setter>(VirtualizingStackPanel_put_AreScrollSnapPointsRegular), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VirtualizingStackPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualizingStackPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualizingStackPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualizingStackPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualizingStackPanel) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.VirtualizingStackPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::VirtualizingStackPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VirtualizingStackPanel};

    static PyGetSetDef getset_VirtualizingStackPanel_Static[] = {
        { "are_scroll_snap_points_regular_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty), nullptr, nullptr, nullptr },
        { "is_virtualizing_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_IsVirtualizingProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "virtualization_mode_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_VirtualizationModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_VirtualizingStackPanel_Static[] = {
        { "get_is_virtualizing", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetIsVirtualizing), METH_VARARGS, nullptr },
        { "get_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetVirtualizationMode), METH_VARARGS, nullptr },
        { "set_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_SetVirtualizationMode), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VirtualizingStackPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VirtualizingStackPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VirtualizingStackPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.VirtualizingStackPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VirtualizingStackPanel_Static
    };

    // ----- WrapGrid class --------------------

    static PyObject* _new_WrapGrid(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::WrapGrid instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WrapGrid(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_VerticalChildrenAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumns(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaximumRowsOrColumns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_MaximumRowsOrColumns(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaximumRowsOrColumns(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemWidth(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemWidth(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemHeight(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemHeight(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_HorizontalChildrenAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::WrapGrid::HorizontalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"ItemHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::WrapGrid::ItemHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"ItemWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::WrapGrid::ItemWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::WrapGrid::MaximumRowsOrColumnsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::WrapGrid::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Controls::WrapGrid::VerticalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::WrapGrid>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::WrapGrid>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WrapGrid[] = {
        { "_assign_array_", _assign_array_WrapGrid, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WrapGrid), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WrapGrid[] = {
        { "vertical_children_alignment", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_VerticalChildrenAlignment), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(WrapGrid_get_Orientation), reinterpret_cast<setter>(WrapGrid_put_Orientation), nullptr, nullptr },
        { "maximum_rows_or_columns", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumns), reinterpret_cast<setter>(WrapGrid_put_MaximumRowsOrColumns), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(WrapGrid_get_ItemWidth), reinterpret_cast<setter>(WrapGrid_put_ItemWidth), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(WrapGrid_get_ItemHeight), reinterpret_cast<setter>(WrapGrid_put_ItemHeight), nullptr, nullptr },
        { "horizontal_children_alignment", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_HorizontalChildrenAlignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WrapGrid[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WrapGrid) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WrapGrid) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WrapGrid) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WrapGrid) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid = {
        "winrt._winrt_microsoft_ui_xaml_controls_2.WrapGrid",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::WrapGrid),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WrapGrid};

    static PyGetSetDef getset_WrapGrid_Static[] = {
        { "horizontal_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { "item_height_property", reinterpret_cast<getter>(WrapGrid_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(WrapGrid_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "maximum_rows_or_columns_property", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumnsProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(WrapGrid_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "vertical_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WrapGrid_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WrapGrid_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WrapGrid_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WrapGrid_Static) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_2.WrapGrid_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WrapGrid_Static
    };

    // ----- Microsoft.UI.Xaml.Controls Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Controls");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_xaml_controls_2",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Controls

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_controls_2(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Controls;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Button_Static{PyType_FromSpec(&type_spec_Button_Static)};
    if (!type_Button_Static)
    {
        return nullptr;
    }

    py::pytype_handle Button_type{py::register_python_type(module.get(), &type_spec_Button, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Button_Static.get()))};
    if (!Button_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarButton_Static{PyType_FromSpec(&type_spec_AppBarButton_Static)};
    if (!type_AppBarButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButton_type{py::register_python_type(module.get(), &type_spec_AppBarButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarButton_Static.get()))};
    if (!AppBarButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarToggleButton_Static{PyType_FromSpec(&type_spec_AppBarToggleButton_Static)};
    if (!type_AppBarToggleButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButton_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarToggleButton_Static.get()))};
    if (!AppBarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CheckBox_Static{PyType_FromSpec(&type_spec_CheckBox_Static)};
    if (!type_CheckBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle CheckBox_type{py::register_python_type(module.get(), &type_spec_CheckBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CheckBox_Static.get()))};
    if (!CheckBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBox_Static{PyType_FromSpec(&type_spec_ComboBox_Static)};
    if (!type_ComboBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBox_type{py::register_python_type(module.get(), &type_spec_ComboBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBox_Static.get()))};
    if (!ComboBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItem_Static{PyType_FromSpec(&type_spec_ComboBoxItem_Static)};
    if (!type_ComboBoxItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItem_type{py::register_python_type(module.get(), &type_spec_ComboBoxItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItem_Static.get()))};
    if (!ComboBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropDownButton_Static{PyType_FromSpec(&type_spec_DropDownButton_Static)};
    if (!type_DropDownButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle DropDownButton_type{py::register_python_type(module.get(), &type_spec_DropDownButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropDownButton_Static.get()))};
    if (!DropDownButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipView_Static{PyType_FromSpec(&type_spec_FlipView_Static)};
    if (!type_FlipView_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipView_type{py::register_python_type(module.get(), &type_spec_FlipView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipView_Static.get()))};
    if (!FlipView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItem_Static{PyType_FromSpec(&type_spec_FlipViewItem_Static)};
    if (!type_FlipViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItem_type{py::register_python_type(module.get(), &type_spec_FlipViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItem_Static.get()))};
    if (!FlipViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBase_Static{PyType_FromSpec(&type_spec_ListViewBase_Static)};
    if (!type_ListViewBase_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBase_type{py::register_python_type(module.get(), &type_spec_ListViewBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBase_Static.get()))};
    if (!ListViewBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridView_Static{PyType_FromSpec(&type_spec_GridView_Static)};
    if (!type_GridView_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridView_type{py::register_python_type(module.get(), &type_spec_GridView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridView_Static.get()))};
    if (!GridView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItem_Static{PyType_FromSpec(&type_spec_GridViewItem_Static)};
    if (!type_GridViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItem_type{py::register_python_type(module.get(), &type_spec_GridViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItem_Static.get()))};
    if (!GridViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_HyperlinkButton_Static{PyType_FromSpec(&type_spec_HyperlinkButton_Static)};
    if (!type_HyperlinkButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle HyperlinkButton_type{py::register_python_type(module.get(), &type_spec_HyperlinkButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HyperlinkButton_Static.get()))};
    if (!HyperlinkButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBox_Static{PyType_FromSpec(&type_spec_ListBox_Static)};
    if (!type_ListBox_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBox_type{py::register_python_type(module.get(), &type_spec_ListBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBox_Static.get()))};
    if (!ListBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItem_Static{PyType_FromSpec(&type_spec_ListBoxItem_Static)};
    if (!type_ListBoxItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItem_type{py::register_python_type(module.get(), &type_spec_ListBoxItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItem_Static.get()))};
    if (!ListBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListView_Static{PyType_FromSpec(&type_spec_ListView_Static)};
    if (!type_ListView_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListView_type{py::register_python_type(module.get(), &type_spec_ListView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListView_Static.get()))};
    if (!ListView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItem_Static{PyType_FromSpec(&type_spec_ListViewItem_Static)};
    if (!type_ListViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItem_type{py::register_python_type(module.get(), &type_spec_ListViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItem_Static.get()))};
    if (!ListViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBar_Static{PyType_FromSpec(&type_spec_ProgressBar_Static)};
    if (!type_ProgressBar_Static)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBar_type{py::register_python_type(module.get(), &type_spec_ProgressBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBar_Static.get()))};
    if (!ProgressBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButton_Static{PyType_FromSpec(&type_spec_RadioButton_Static)};
    if (!type_RadioButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadioButton_type{py::register_python_type(module.get(), &type_spec_RadioButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButton_Static.get()))};
    if (!RadioButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RevealListViewItemPresenter_Static{PyType_FromSpec(&type_spec_RevealListViewItemPresenter_Static)};
    if (!type_RevealListViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pytype_handle RevealListViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_RevealListViewItemPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RevealListViewItemPresenter_Static.get()))};
    if (!RevealListViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Slider_Static{PyType_FromSpec(&type_spec_Slider_Static)};
    if (!type_Slider_Static)
    {
        return nullptr;
    }

    py::pytype_handle Slider_type{py::register_python_type(module.get(), &type_spec_Slider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Slider_Static.get()))};
    if (!Slider_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewItem_Static{PyType_FromSpec(&type_spec_TabViewItem_Static)};
    if (!type_TabViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle TabViewItem_type{py::register_python_type(module.get(), &type_spec_TabViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewItem_Static.get()))};
    if (!TabViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItem_Static{PyType_FromSpec(&type_spec_TreeViewItem_Static)};
    if (!type_TreeViewItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItem_type{py::register_python_type(module.get(), &type_spec_TreeViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItem_Static.get()))};
    if (!TreeViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewList_Static{PyType_FromSpec(&type_spec_TreeViewList_Static)};
    if (!type_TreeViewList_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewList_type{py::register_python_type(module.get(), &type_spec_TreeViewList, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewList_Static.get()))};
    if (!TreeViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_VirtualizingStackPanel_Static{PyType_FromSpec(&type_spec_VirtualizingStackPanel_Static)};
    if (!type_VirtualizingStackPanel_Static)
    {
        return nullptr;
    }

    py::pytype_handle VirtualizingStackPanel_type{py::register_python_type(module.get(), &type_spec_VirtualizingStackPanel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VirtualizingStackPanel_Static.get()))};
    if (!VirtualizingStackPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WrapGrid_Static{PyType_FromSpec(&type_spec_WrapGrid_Static)};
    if (!type_WrapGrid_Static)
    {
        return nullptr;
    }

    py::pytype_handle WrapGrid_type{py::register_python_type(module.get(), &type_spec_WrapGrid, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WrapGrid_Static.get()))};
    if (!WrapGrid_type)
    {
        return nullptr;
    }


    return module.detach();
}
