// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.3.0

#include "py.Windows.Devices.SmartCards.h"

namespace py::cpp::Windows::Devices::SmartCards
{
    // ----- CardAddedEventArgs class --------------------

    static PyObject* _new_CardAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CardAddedEventArgs(py::wrapper::Windows::Devices::SmartCards::CardAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CardAddedEventArgs_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::CardAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.CardAddedEventArgs", L"SmartCard");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CardAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CardAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::CardAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CardAddedEventArgs[] = {
        { "_assign_array_", _assign_array_CardAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CardAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CardAddedEventArgs[] = {
        { "smart_card", reinterpret_cast<getter>(CardAddedEventArgs_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CardAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CardAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CardAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CardAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CardAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CardAddedEventArgs = {
        "winrt._winrt_windows_devices_smartcards.CardAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::CardAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CardAddedEventArgs};

    // ----- CardRemovedEventArgs class --------------------

    static PyObject* _new_CardRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CardRemovedEventArgs(py::wrapper::Windows::Devices::SmartCards::CardRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CardRemovedEventArgs_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::CardRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.CardRemovedEventArgs", L"SmartCard");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CardRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CardRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CardRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_CardRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CardRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CardRemovedEventArgs[] = {
        { "smart_card", reinterpret_cast<getter>(CardRemovedEventArgs_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CardRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CardRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CardRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CardRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CardRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CardRemovedEventArgs = {
        "winrt._winrt_windows_devices_smartcards.CardRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::CardRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CardRemovedEventArgs};

    // ----- KnownSmartCardAppletIds class --------------------

    static PyObject* _new_KnownSmartCardAppletIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds>::type_name);
        return nullptr;
    }

    static PyObject* KnownSmartCardAppletIds_get_PaymentSystemEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.KnownSmartCardAppletIds", L"PaymentSystemEnvironment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds::PaymentSystemEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSmartCardAppletIds_get_ProximityPaymentSystemEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.KnownSmartCardAppletIds", L"ProximityPaymentSystemEnvironment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::SmartCards::KnownSmartCardAppletIds::ProximityPaymentSystemEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownSmartCardAppletIds[] = {
        { }
    };

    static PyGetSetDef _getset_KnownSmartCardAppletIds[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownSmartCardAppletIds[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownSmartCardAppletIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownSmartCardAppletIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownSmartCardAppletIds) },
        { }
    };

    static PyType_Spec type_spec_KnownSmartCardAppletIds = {
        "winrt._winrt_windows_devices_smartcards.KnownSmartCardAppletIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownSmartCardAppletIds};

    static PyGetSetDef getset_KnownSmartCardAppletIds_Static[] = {
        { "payment_system_environment", reinterpret_cast<getter>(KnownSmartCardAppletIds_get_PaymentSystemEnvironment), nullptr, nullptr, nullptr },
        { "proximity_payment_system_environment", reinterpret_cast<getter>(KnownSmartCardAppletIds_get_ProximityPaymentSystemEnvironment), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownSmartCardAppletIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownSmartCardAppletIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownSmartCardAppletIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownSmartCardAppletIds_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownSmartCardAppletIds_Static =
    {
        "winrt._winrt_windows_devices_smartcards.KnownSmartCardAppletIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownSmartCardAppletIds_Static
    };

    // ----- SmartCard class --------------------

    static PyObject* _new_SmartCard(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCard>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCard>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCard(py::wrapper::Windows::Devices::SmartCards::SmartCard* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCard_ConnectAsync(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCard", L"ConnectAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ConnectAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCard_GetAnswerToResetAsync(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCard", L"GetAnswerToResetAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAnswerToResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCard_GetStatusAsync(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCard", L"GetStatusAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCard_get_Reader(py::wrapper::Windows::Devices::SmartCards::SmartCard* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCard", L"Reader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCard[] = {
        { "connect_async", reinterpret_cast<PyCFunction>(SmartCard_ConnectAsync), METH_VARARGS, nullptr },
        { "get_answer_to_reset_async", reinterpret_cast<PyCFunction>(SmartCard_GetAnswerToResetAsync), METH_VARARGS, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(SmartCard_GetStatusAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCard[] = {
        { "reader", reinterpret_cast<getter>(SmartCard_get_Reader), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCard[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCard) },
        { }
    };

    static PyType_Spec type_spec_SmartCard = {
        "winrt._winrt_windows_devices_smartcards.SmartCard",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCard};

    // ----- SmartCardAppletIdGroup class --------------------

    static PyObject* _new_SmartCardAppletIdGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Streams::IBuffer>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationCategory>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationType>(args, 3);

                winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardAppletIdGroup(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardAppletIdGroup_get_SmartCardEmulationType(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCardEmulationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_SmartCardEmulationType(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationType>(arg);

            self->obj.SmartCardEmulationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_SmartCardEmulationCategory(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationCategory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCardEmulationCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_SmartCardEmulationCategory(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SmartCardEmulationCategory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardEmulationCategory>(arg);

            self->obj.SmartCardEmulationCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_DisplayName(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_DisplayName(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_AutomaticEnablement(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"AutomaticEnablement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomaticEnablement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_AutomaticEnablement(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"AutomaticEnablement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutomaticEnablement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_AppletIds(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"AppletIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppletIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_SecureUserAuthenticationRequired(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SecureUserAuthenticationRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecureUserAuthenticationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_SecureUserAuthenticationRequired(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"SecureUserAuthenticationRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SecureUserAuthenticationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_Logo(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_Logo(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Logo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_Description(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAppletIdGroup_put_Description(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_Properties(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroup_get_MaxAppletIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroup", L"MaxAppletIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup::MaxAppletIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardAppletIdGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardAppletIdGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardAppletIdGroup[] = {
        { "_assign_array_", _assign_array_SmartCardAppletIdGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardAppletIdGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardAppletIdGroup[] = {
        { "smart_card_emulation_type", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_SmartCardEmulationType), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_SmartCardEmulationType), nullptr, nullptr },
        { "smart_card_emulation_category", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_SmartCardEmulationCategory), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_SmartCardEmulationCategory), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_DisplayName), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_DisplayName), nullptr, nullptr },
        { "automatic_enablement", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_AutomaticEnablement), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_AutomaticEnablement), nullptr, nullptr },
        { "applet_ids", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_AppletIds), nullptr, nullptr, nullptr },
        { "secure_user_authentication_required", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_SecureUserAuthenticationRequired), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_SecureUserAuthenticationRequired), nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_Logo), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_Logo), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_Description), reinterpret_cast<setter>(SmartCardAppletIdGroup_put_Description), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardAppletIdGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardAppletIdGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardAppletIdGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardAppletIdGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardAppletIdGroup) },
        { }
    };

    static PyType_Spec type_spec_SmartCardAppletIdGroup = {
        "winrt._winrt_windows_devices_smartcards.SmartCardAppletIdGroup",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardAppletIdGroup};

    static PyGetSetDef getset_SmartCardAppletIdGroup_Static[] = {
        { "max_applet_ids", reinterpret_cast<getter>(SmartCardAppletIdGroup_get_MaxAppletIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SmartCardAppletIdGroup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SmartCardAppletIdGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardAppletIdGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartCardAppletIdGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartCardAppletIdGroup_Static =
    {
        "winrt._winrt_windows_devices_smartcards.SmartCardAppletIdGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardAppletIdGroup_Static
    };

    // ----- SmartCardAppletIdGroupRegistration class --------------------

    static PyObject* _new_SmartCardAppletIdGroupRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardAppletIdGroupRegistration(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardAppletIdGroupRegistration_RequestActivationPolicyChangeAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"RequestActivationPolicyChangeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupActivationPolicy>(args, 0);

                return py::convert(self->obj.RequestActivationPolicyChangeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_SetAutomaticResponseApdusAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"SetAutomaticResponseApdusAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>>(args, 0);

                return py::convert(self->obj.SetAutomaticResponseApdusAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_SetPropertiesAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"SetPropertiesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.SetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_ActivationPolicy(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"ActivationPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_AppletIdGroup(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"AppletIdGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppletIdGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_Id(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardAppletIdGroupRegistration_get_SmartCardReaderId(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAppletIdGroupRegistration", L"SmartCardReaderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCardReaderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardAppletIdGroupRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardAppletIdGroupRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardAppletIdGroupRegistration[] = {
        { "request_activation_policy_change_async", reinterpret_cast<PyCFunction>(SmartCardAppletIdGroupRegistration_RequestActivationPolicyChangeAsync), METH_VARARGS, nullptr },
        { "set_automatic_response_apdus_async", reinterpret_cast<PyCFunction>(SmartCardAppletIdGroupRegistration_SetAutomaticResponseApdusAsync), METH_VARARGS, nullptr },
        { "set_properties_async", reinterpret_cast<PyCFunction>(SmartCardAppletIdGroupRegistration_SetPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardAppletIdGroupRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardAppletIdGroupRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardAppletIdGroupRegistration[] = {
        { "activation_policy", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_ActivationPolicy), nullptr, nullptr, nullptr },
        { "applet_id_group", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_AppletIdGroup), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_Id), nullptr, nullptr, nullptr },
        { "smart_card_reader_id", reinterpret_cast<getter>(SmartCardAppletIdGroupRegistration_get_SmartCardReaderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardAppletIdGroupRegistration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardAppletIdGroupRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardAppletIdGroupRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardAppletIdGroupRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardAppletIdGroupRegistration) },
        { }
    };

    static PyType_Spec type_spec_SmartCardAppletIdGroupRegistration = {
        "winrt._winrt_windows_devices_smartcards.SmartCardAppletIdGroupRegistration",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardAppletIdGroupRegistration};

    // ----- SmartCardAutomaticResponseApdu class --------------------

    static PyObject* _new_SmartCardAutomaticResponseApdu(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardAutomaticResponseApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_ShouldMatchLength(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ShouldMatchLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldMatchLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_ShouldMatchLength(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ShouldMatchLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldMatchLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_ResponseApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ResponseApdu");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseApdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_ResponseApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"ResponseApdu");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.ResponseApdu(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_CommandApduBitMask(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApduBitMask");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CommandApduBitMask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_CommandApduBitMask(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApduBitMask");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.CommandApduBitMask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_CommandApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApdu");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CommandApdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_CommandApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"CommandApdu");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.CommandApdu(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_AppletId(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AppletId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppletId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_AppletId(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AppletId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.AppletId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_OutputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"OutputState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_OutputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"OutputState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.OutputState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_InputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"InputState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_InputState(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"InputState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.InputState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardAutomaticResponseApdu_get_AllowWhenCryptogramGeneratorNotPrepared(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AllowWhenCryptogramGeneratorNotPrepared");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowWhenCryptogramGeneratorNotPrepared());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardAutomaticResponseApdu_put_AllowWhenCryptogramGeneratorNotPrepared(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardAutomaticResponseApdu", L"AllowWhenCryptogramGeneratorNotPrepared");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWhenCryptogramGeneratorNotPrepared(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SmartCardAutomaticResponseApdu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardAutomaticResponseApdu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardAutomaticResponseApdu[] = {
        { "_assign_array_", _assign_array_SmartCardAutomaticResponseApdu, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardAutomaticResponseApdu), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardAutomaticResponseApdu[] = {
        { "should_match_length", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_ShouldMatchLength), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_ShouldMatchLength), nullptr, nullptr },
        { "response_apdu", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_ResponseApdu), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_ResponseApdu), nullptr, nullptr },
        { "command_apdu_bit_mask", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_CommandApduBitMask), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_CommandApduBitMask), nullptr, nullptr },
        { "command_apdu", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_CommandApdu), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_CommandApdu), nullptr, nullptr },
        { "applet_id", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_AppletId), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_AppletId), nullptr, nullptr },
        { "output_state", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_OutputState), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_OutputState), nullptr, nullptr },
        { "input_state", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_InputState), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_InputState), nullptr, nullptr },
        { "allow_when_cryptogram_generator_not_prepared", reinterpret_cast<getter>(SmartCardAutomaticResponseApdu_get_AllowWhenCryptogramGeneratorNotPrepared), reinterpret_cast<setter>(SmartCardAutomaticResponseApdu_put_AllowWhenCryptogramGeneratorNotPrepared), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardAutomaticResponseApdu[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardAutomaticResponseApdu) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardAutomaticResponseApdu) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardAutomaticResponseApdu) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardAutomaticResponseApdu) },
        { }
    };

    static PyType_Spec type_spec_SmartCardAutomaticResponseApdu = {
        "winrt._winrt_windows_devices_smartcards.SmartCardAutomaticResponseApdu",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardAutomaticResponseApdu),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardAutomaticResponseApdu};

    // ----- SmartCardChallengeContext class --------------------

    static PyObject* _new_SmartCardChallengeContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardChallengeContext(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardChallengeContext_ChangeAdministrativeKeyAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"ChangeAdministrativeKeyAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.ChangeAdministrativeKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_Close(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_ProvisionAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"ProvisionAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.ProvisionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"ProvisionAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(self->obj.ProvisionAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_VerifyResponseAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"VerifyResponseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.VerifyResponseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardChallengeContext_get_Challenge(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardChallengeContext", L"Challenge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Challenge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardChallengeContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardChallengeContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardChallengeContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SmartCardChallengeContext(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SmartCardChallengeContext(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardChallengeContext[] = {
        { "change_administrative_key_async", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_ChangeAdministrativeKeyAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_Close), METH_VARARGS, nullptr },
        { "provision_async", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_ProvisionAsync), METH_VARARGS, nullptr },
        { "verify_response_async", reinterpret_cast<PyCFunction>(SmartCardChallengeContext_VerifyResponseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardChallengeContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardChallengeContext), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SmartCardChallengeContext), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_SmartCardChallengeContext), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardChallengeContext[] = {
        { "challenge", reinterpret_cast<getter>(SmartCardChallengeContext_get_Challenge), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardChallengeContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardChallengeContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardChallengeContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardChallengeContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardChallengeContext) },
        { }
    };

    static PyType_Spec type_spec_SmartCardChallengeContext = {
        "winrt._winrt_windows_devices_smartcards.SmartCardChallengeContext",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardChallengeContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardChallengeContext};

    // ----- SmartCardConnection class --------------------

    static PyObject* _new_SmartCardConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardConnection(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardConnection_Close(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardConnection", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardConnection_TransmitAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardConnection", L"TransmitAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.TransmitAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SmartCardConnection(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SmartCardConnection(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(SmartCardConnection_Close), METH_VARARGS, nullptr },
        { "transmit_async", reinterpret_cast<PyCFunction>(SmartCardConnection_TransmitAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SmartCardConnection), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_SmartCardConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_SmartCardConnection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardConnection) },
        { }
    };

    static PyType_Spec type_spec_SmartCardConnection = {
        "winrt._winrt_windows_devices_smartcards.SmartCardConnection",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardConnection};

    // ----- SmartCardCryptogramGenerator class --------------------

    static PyObject* _new_SmartCardCryptogramGenerator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardCryptogramGenerator(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGenerator_CreateCryptogramMaterialStorageKeyAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"CreateCryptogramMaterialStorageKeyAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyAlgorithm>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCapabilities>(args, 3);

                return py::convert(self->obj.CreateCryptogramMaterialStorageKeyAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_DeleteCryptogramMaterialPackageAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"DeleteCryptogramMaterialPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteCryptogramMaterialPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_DeleteCryptogramMaterialStorageKeyAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"DeleteCryptogramMaterialStorageKeyAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteCryptogramMaterialStorageKeyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetAllCryptogramMaterialCharacteristicsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramMaterialCharacteristicsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetAllCryptogramMaterialCharacteristicsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetAllCryptogramMaterialPackageCharacteristicsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramMaterialPackageCharacteristicsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAllCryptogramMaterialPackageCharacteristicsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramMaterialPackageCharacteristicsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAllCryptogramMaterialPackageCharacteristicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetAllCryptogramStorageKeyCharacteristicsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetAllCryptogramStorageKeyCharacteristicsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAllCryptogramStorageKeyCharacteristicsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_GetSmartCardCryptogramGeneratorAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"GetSmartCardCryptogramGeneratorAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator::GetSmartCardCryptogramGeneratorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_ImportCryptogramMaterialPackageAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"ImportCryptogramMaterialPackageAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageFormat>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);

                return py::convert(self->obj.ImportCryptogramMaterialPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_RequestCryptogramMaterialStorageKeyInfoAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"RequestCryptogramMaterialStorageKeyInfoAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 2);

                return py::convert(self->obj.RequestCryptogramMaterialStorageKeyInfoAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_RequestUnlockCryptogramMaterialForUseAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"RequestUnlockCryptogramMaterialForUseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);

                return py::convert(self->obj.RequestUnlockCryptogramMaterialForUseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_TryProvePossessionOfCryptogramMaterialPackageAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"TryProvePossessionOfCryptogramMaterialPackageAsync", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageConfirmationResponseFormat>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(self->obj.TryProvePossessionOfCryptogramMaterialPackageAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_ValidateRequestApduAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"ValidateRequestApduAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardUnlockPromptingBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>(args, 2);

                return py::convert(self->obj.ValidateRequestApduAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramAlgorithms(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramAlgorithms");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCryptogramAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageConfirmationResponseFormats(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramMaterialPackageConfirmationResponseFormats");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCryptogramMaterialPackageConfirmationResponseFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageFormats(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramMaterialPackageFormats");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCryptogramMaterialPackageFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialTypes(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedCryptogramMaterialTypes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCryptogramMaterialTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGenerator_get_SupportedSmartCardCryptogramStorageKeyCapabilities(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGenerator", L"SupportedSmartCardCryptogramStorageKeyCapabilities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedSmartCardCryptogramStorageKeyCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGenerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGenerator[] = {
        { "create_cryptogram_material_storage_key_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_CreateCryptogramMaterialStorageKeyAsync), METH_VARARGS, nullptr },
        { "delete_cryptogram_material_package_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_DeleteCryptogramMaterialPackageAsync), METH_VARARGS, nullptr },
        { "delete_cryptogram_material_storage_key_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_DeleteCryptogramMaterialStorageKeyAsync), METH_VARARGS, nullptr },
        { "get_all_cryptogram_material_characteristics_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetAllCryptogramMaterialCharacteristicsAsync), METH_VARARGS, nullptr },
        { "get_all_cryptogram_material_package_characteristics_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetAllCryptogramMaterialPackageCharacteristicsAsync), METH_VARARGS, nullptr },
        { "get_all_cryptogram_storage_key_characteristics_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetAllCryptogramStorageKeyCharacteristicsAsync), METH_VARARGS, nullptr },
        { "import_cryptogram_material_package_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_ImportCryptogramMaterialPackageAsync), METH_VARARGS, nullptr },
        { "request_cryptogram_material_storage_key_info_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_RequestCryptogramMaterialStorageKeyInfoAsync), METH_VARARGS, nullptr },
        { "request_unlock_cryptogram_material_for_use_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_RequestUnlockCryptogramMaterialForUseAsync), METH_VARARGS, nullptr },
        { "try_prove_possession_of_cryptogram_material_package_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_TryProvePossessionOfCryptogramMaterialPackageAsync), METH_VARARGS, nullptr },
        { "validate_request_apdu_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_ValidateRequestApduAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardCryptogramGenerator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGenerator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGenerator[] = {
        { "supported_cryptogram_algorithms", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramAlgorithms), nullptr, nullptr, nullptr },
        { "supported_cryptogram_material_package_confirmation_response_formats", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageConfirmationResponseFormats), nullptr, nullptr, nullptr },
        { "supported_cryptogram_material_package_formats", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialPackageFormats), nullptr, nullptr, nullptr },
        { "supported_cryptogram_material_types", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedCryptogramMaterialTypes), nullptr, nullptr, nullptr },
        { "supported_smart_card_cryptogram_storage_key_capabilities", reinterpret_cast<getter>(SmartCardCryptogramGenerator_get_SupportedSmartCardCryptogramStorageKeyCapabilities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGenerator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGenerator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGenerator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGenerator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGenerator) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramGenerator = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramGenerator",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGenerator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGenerator};

    static PyGetSetDef getset_SmartCardCryptogramGenerator_Static[] = {
        { }
    };

    static PyMethodDef methods_SmartCardCryptogramGenerator_Static[] = {
        { "get_smart_card_cryptogram_generator_async", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_GetSmartCardCryptogramGeneratorAsync), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(SmartCardCryptogramGenerator_IsSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartCardCryptogramGenerator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardCryptogramGenerator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartCardCryptogramGenerator_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramGenerator_Static =
    {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramGenerator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardCryptogramGenerator_Static
    };

    // ----- SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult class --------------------

    static PyObject* _new_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult", L"Characteristics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult", L"OperationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult};

    // ----- SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult class --------------------

    static PyObject* _new_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult", L"Characteristics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult", L"OperationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult};

    // ----- SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult class --------------------

    static PyObject* _new_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult", L"Characteristics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult", L"OperationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult};

    // ----- SmartCardCryptogramMaterialCharacteristics class --------------------

    static PyObject* _new_SmartCardCryptogramMaterialCharacteristics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramMaterialCharacteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_AllowedAlgorithms(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"AllowedAlgorithms");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_AllowedProofOfPossessionAlgorithms(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"AllowedProofOfPossessionAlgorithms");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedProofOfPossessionAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_AllowedValidations(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"AllowedValidations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedValidations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_MaterialLength(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"MaterialLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_MaterialName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"MaterialName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_MaterialType(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"MaterialType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_ProtectionMethod(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"ProtectionMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialCharacteristics_get_ProtectionVersion(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialCharacteristics", L"ProtectionVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramMaterialCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramMaterialCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramMaterialCharacteristics[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramMaterialCharacteristics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramMaterialCharacteristics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramMaterialCharacteristics[] = {
        { "allowed_algorithms", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_AllowedAlgorithms), nullptr, nullptr, nullptr },
        { "allowed_proof_of_possession_algorithms", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_AllowedProofOfPossessionAlgorithms), nullptr, nullptr, nullptr },
        { "allowed_validations", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_AllowedValidations), nullptr, nullptr, nullptr },
        { "material_length", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_MaterialLength), nullptr, nullptr, nullptr },
        { "material_name", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_MaterialName), nullptr, nullptr, nullptr },
        { "material_type", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_MaterialType), nullptr, nullptr, nullptr },
        { "protection_method", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_ProtectionMethod), nullptr, nullptr, nullptr },
        { "protection_version", reinterpret_cast<getter>(SmartCardCryptogramMaterialCharacteristics_get_ProtectionVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramMaterialCharacteristics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramMaterialCharacteristics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramMaterialCharacteristics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramMaterialCharacteristics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramMaterialCharacteristics) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramMaterialCharacteristics = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramMaterialCharacteristics",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialCharacteristics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramMaterialCharacteristics};

    // ----- SmartCardCryptogramMaterialPackageCharacteristics class --------------------

    static PyObject* _new_SmartCardCryptogramMaterialPackageCharacteristics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramMaterialPackageCharacteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_DateImported(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"DateImported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateImported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_PackageFormat(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"PackageFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_PackageName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"PackageName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPackageCharacteristics_get_StorageKeyName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPackageCharacteristics", L"StorageKeyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StorageKeyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramMaterialPackageCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramMaterialPackageCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramMaterialPackageCharacteristics[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramMaterialPackageCharacteristics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramMaterialPackageCharacteristics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramMaterialPackageCharacteristics[] = {
        { "date_imported", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_DateImported), nullptr, nullptr, nullptr },
        { "package_format", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_PackageFormat), nullptr, nullptr, nullptr },
        { "package_name", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_PackageName), nullptr, nullptr, nullptr },
        { "storage_key_name", reinterpret_cast<getter>(SmartCardCryptogramMaterialPackageCharacteristics_get_StorageKeyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramMaterialPackageCharacteristics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramMaterialPackageCharacteristics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramMaterialPackageCharacteristics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramMaterialPackageCharacteristics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramMaterialPackageCharacteristics) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramMaterialPackageCharacteristics = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramMaterialPackageCharacteristics",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPackageCharacteristics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramMaterialPackageCharacteristics};

    // ----- SmartCardCryptogramMaterialPossessionProof class --------------------

    static PyObject* _new_SmartCardCryptogramMaterialPossessionProof(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardCryptogramMaterialPossessionProof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramMaterialPossessionProof_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPossessionProof", L"OperationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramMaterialPossessionProof_get_Proof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramMaterialPossessionProof", L"Proof");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Proof());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramMaterialPossessionProof(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramMaterialPossessionProof(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramMaterialPossessionProof[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramMaterialPossessionProof, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramMaterialPossessionProof), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramMaterialPossessionProof[] = {
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramMaterialPossessionProof_get_OperationStatus), nullptr, nullptr, nullptr },
        { "proof", reinterpret_cast<getter>(SmartCardCryptogramMaterialPossessionProof_get_Proof), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramMaterialPossessionProof[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramMaterialPossessionProof) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramMaterialPossessionProof) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramMaterialPossessionProof) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramMaterialPossessionProof) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramMaterialPossessionProof = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramMaterialPossessionProof",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramMaterialPossessionProof),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramMaterialPossessionProof};

    // ----- SmartCardCryptogramPlacementStep class --------------------

    static PyObject* _new_SmartCardCryptogramPlacementStep(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramPlacementStep(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_TemplateOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"TemplateOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_TemplateOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"TemplateOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TemplateOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_SourceData(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"SourceData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_SourceData(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"SourceData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.SourceData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramPlacementOptions(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramPlacementOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CryptogramPlacementOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramPlacementOptions(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramPlacementOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementOptions>(arg);

            self->obj.CryptogramPlacementOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CryptogramOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramOffset(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CryptogramOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramMaterialPackageName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialPackageName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CryptogramMaterialPackageName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramMaterialPackageName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialPackageName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CryptogramMaterialPackageName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramMaterialName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CryptogramMaterialName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramMaterialName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramMaterialName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CryptogramMaterialName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_CryptogramLength(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CryptogramLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_CryptogramLength(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"CryptogramLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CryptogramLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_ChainedOutputStep(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"ChainedOutputStep");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChainedOutputStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_ChainedOutputStep(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"ChainedOutputStep");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>(arg);

            self->obj.ChainedOutputStep(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardCryptogramPlacementStep_get_Algorithm(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"Algorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Algorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardCryptogramPlacementStep_put_Algorithm(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramPlacementStep", L"Algorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardCryptogramAlgorithm>(arg);

            self->obj.Algorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramPlacementStep(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramPlacementStep(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramPlacementStep[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramPlacementStep, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramPlacementStep), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramPlacementStep[] = {
        { "template_offset", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_TemplateOffset), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_TemplateOffset), nullptr, nullptr },
        { "source_data", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_SourceData), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_SourceData), nullptr, nullptr },
        { "cryptogram_placement_options", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramPlacementOptions), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramPlacementOptions), nullptr, nullptr },
        { "cryptogram_offset", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramOffset), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramOffset), nullptr, nullptr },
        { "cryptogram_material_package_name", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramMaterialPackageName), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramMaterialPackageName), nullptr, nullptr },
        { "cryptogram_material_name", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramMaterialName), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramMaterialName), nullptr, nullptr },
        { "cryptogram_length", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_CryptogramLength), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_CryptogramLength), nullptr, nullptr },
        { "chained_output_step", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_ChainedOutputStep), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_ChainedOutputStep), nullptr, nullptr },
        { "algorithm", reinterpret_cast<getter>(SmartCardCryptogramPlacementStep_get_Algorithm), reinterpret_cast<setter>(SmartCardCryptogramPlacementStep_put_Algorithm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramPlacementStep[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramPlacementStep) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramPlacementStep) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramPlacementStep) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramPlacementStep) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramPlacementStep = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramPlacementStep",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramPlacementStep};

    // ----- SmartCardCryptogramStorageKeyCharacteristics class --------------------

    static PyObject* _new_SmartCardCryptogramStorageKeyCharacteristics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardCryptogramStorageKeyCharacteristics(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_Algorithm(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"Algorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Algorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_Capabilities(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"Capabilities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_DateCreated(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"DateCreated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyCharacteristics_get_StorageKeyName(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyCharacteristics", L"StorageKeyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StorageKeyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramStorageKeyCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramStorageKeyCharacteristics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramStorageKeyCharacteristics[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramStorageKeyCharacteristics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramStorageKeyCharacteristics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramStorageKeyCharacteristics[] = {
        { "algorithm", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_Algorithm), nullptr, nullptr, nullptr },
        { "capabilities", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_Capabilities), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_DateCreated), nullptr, nullptr, nullptr },
        { "storage_key_name", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyCharacteristics_get_StorageKeyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramStorageKeyCharacteristics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramStorageKeyCharacteristics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramStorageKeyCharacteristics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramStorageKeyCharacteristics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramStorageKeyCharacteristics) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramStorageKeyCharacteristics = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramStorageKeyCharacteristics",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyCharacteristics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramStorageKeyCharacteristics};

    // ----- SmartCardCryptogramStorageKeyInfo class --------------------

    static PyObject* _new_SmartCardCryptogramStorageKeyInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardCryptogramStorageKeyInfo(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_Attestation(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"Attestation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attestation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_AttestationCertificateChain(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"AttestationCertificateChain");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttestationCertificateChain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_AttestationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"AttestationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttestationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_Capabilities(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"Capabilities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_OperationStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"OperationStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_PublicKey(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"PublicKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_PublicKeyBlobType(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"PublicKeyBlobType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicKeyBlobType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardCryptogramStorageKeyInfo_get_OperationalRequirements(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardCryptogramStorageKeyInfo", L"OperationalRequirements");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OperationalRequirements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardCryptogramStorageKeyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardCryptogramStorageKeyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardCryptogramStorageKeyInfo[] = {
        { "_assign_array_", _assign_array_SmartCardCryptogramStorageKeyInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardCryptogramStorageKeyInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardCryptogramStorageKeyInfo[] = {
        { "attestation", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_Attestation), nullptr, nullptr, nullptr },
        { "attestation_certificate_chain", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_AttestationCertificateChain), nullptr, nullptr, nullptr },
        { "attestation_status", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_AttestationStatus), nullptr, nullptr, nullptr },
        { "capabilities", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_Capabilities), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_OperationStatus), nullptr, nullptr, nullptr },
        { "public_key", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_PublicKey), nullptr, nullptr, nullptr },
        { "public_key_blob_type", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_PublicKeyBlobType), nullptr, nullptr, nullptr },
        { "operational_requirements", reinterpret_cast<getter>(SmartCardCryptogramStorageKeyInfo_get_OperationalRequirements), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardCryptogramStorageKeyInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardCryptogramStorageKeyInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardCryptogramStorageKeyInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardCryptogramStorageKeyInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardCryptogramStorageKeyInfo) },
        { }
    };

    static PyType_Spec type_spec_SmartCardCryptogramStorageKeyInfo = {
        "winrt._winrt_windows_devices_smartcards.SmartCardCryptogramStorageKeyInfo",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardCryptogramStorageKeyInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardCryptogramStorageKeyInfo};

    // ----- SmartCardEmulator class --------------------

    static PyObject* _new_SmartCardEmulator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulator>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulator(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulator_GetAppletIdGroupRegistrationsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"GetAppletIdGroupRegistrationsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::GetAppletIdGroupRegistrationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"GetDefaultAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_IsHostCardEmulationSupported(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"IsHostCardEmulationSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsHostCardEmulationSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_RegisterAppletIdGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"RegisterAppletIdGroupAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroup>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::RegisterAppletIdGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_Start(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_UnregisterAppletIdGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"UnregisterAppletIdGroupAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardAppletIdGroupRegistration>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::UnregisterAppletIdGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_get_EnablementPolicy(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"EnablementPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnablementPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_get_MaxAppletIdGroupRegistrations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"MaxAppletIdGroupRegistrations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::SmartCards::SmartCardEmulator::MaxAppletIdGroupRegistrations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_add_ApduReceived(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ApduReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardEmulator, winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>>(arg);

            return py::convert(self->obj.ApduReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_remove_ApduReceived(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ApduReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ApduReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_add_ConnectionDeactivated(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ConnectionDeactivated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardEmulator, winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionDeactivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulator_remove_ConnectionDeactivated(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardEmulator", L"ConnectionDeactivated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionDeactivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulator[] = {
        { "is_host_card_emulation_supported", reinterpret_cast<PyCFunction>(SmartCardEmulator_IsHostCardEmulationSupported), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(SmartCardEmulator_Start), METH_VARARGS, nullptr },
        { "add_apdu_received", reinterpret_cast<PyCFunction>(SmartCardEmulator_add_ApduReceived), METH_O, nullptr },
        { "remove_apdu_received", reinterpret_cast<PyCFunction>(SmartCardEmulator_remove_ApduReceived), METH_O, nullptr },
        { "add_connection_deactivated", reinterpret_cast<PyCFunction>(SmartCardEmulator_add_ConnectionDeactivated), METH_O, nullptr },
        { "remove_connection_deactivated", reinterpret_cast<PyCFunction>(SmartCardEmulator_remove_ConnectionDeactivated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmartCardEmulator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulator[] = {
        { "enablement_policy", reinterpret_cast<getter>(SmartCardEmulator_get_EnablementPolicy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulator) },
        { }
    };

    static PyType_Spec type_spec_SmartCardEmulator = {
        "winrt._winrt_windows_devices_smartcards.SmartCardEmulator",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulator};

    static PyGetSetDef getset_SmartCardEmulator_Static[] = {
        { "max_applet_id_group_registrations", reinterpret_cast<getter>(SmartCardEmulator_get_MaxAppletIdGroupRegistrations), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SmartCardEmulator_Static[] = {
        { "get_applet_id_group_registrations_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_GetAppletIdGroupRegistrationsAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_GetDefaultAsync), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(SmartCardEmulator_IsSupported), METH_VARARGS, nullptr },
        { "register_applet_id_group_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_RegisterAppletIdGroupAsync), METH_VARARGS, nullptr },
        { "unregister_applet_id_group_async", reinterpret_cast<PyCFunction>(SmartCardEmulator_UnregisterAppletIdGroupAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartCardEmulator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardEmulator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartCardEmulator_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartCardEmulator_Static =
    {
        "winrt._winrt_windows_devices_smartcards.SmartCardEmulator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardEmulator_Static
    };

    // ----- SmartCardEmulatorApduReceivedEventArgs class --------------------

    static PyObject* _new_SmartCardEmulatorApduReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulatorApduReceivedEventArgs(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_TryRespondAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.TryRespondAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.TryRespondAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_TryRespondWithCryptogramsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondWithCryptogramsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>(args, 1);

                return py::convert(self->obj.TryRespondWithCryptogramsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"TryRespondWithCryptogramsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::SmartCards::SmartCardCryptogramPlacementStep>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 2);

                return py::convert(self->obj.TryRespondWithCryptogramsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_AutomaticResponseStatus(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"AutomaticResponseStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomaticResponseStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_CommandApdu(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"CommandApdu");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CommandApdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_ConnectionProperties(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"ConnectionProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorApduReceivedEventArgs_get_State(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorApduReceivedEventArgs", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulatorApduReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulatorApduReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulatorApduReceivedEventArgs[] = {
        { "try_respond_async", reinterpret_cast<PyCFunction>(SmartCardEmulatorApduReceivedEventArgs_TryRespondAsync), METH_VARARGS, nullptr },
        { "try_respond_with_cryptograms_async", reinterpret_cast<PyCFunction>(SmartCardEmulatorApduReceivedEventArgs_TryRespondWithCryptogramsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardEmulatorApduReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulatorApduReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulatorApduReceivedEventArgs[] = {
        { "automatic_response_status", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_AutomaticResponseStatus), nullptr, nullptr, nullptr },
        { "command_apdu", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_CommandApdu), nullptr, nullptr, nullptr },
        { "connection_properties", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_ConnectionProperties), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(SmartCardEmulatorApduReceivedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulatorApduReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulatorApduReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulatorApduReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulatorApduReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulatorApduReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SmartCardEmulatorApduReceivedEventArgs = {
        "winrt._winrt_windows_devices_smartcards.SmartCardEmulatorApduReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorApduReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulatorApduReceivedEventArgs};

    // ----- SmartCardEmulatorConnectionDeactivatedEventArgs class --------------------

    static PyObject* _new_SmartCardEmulatorConnectionDeactivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulatorConnectionDeactivatedEventArgs(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulatorConnectionDeactivatedEventArgs_get_ConnectionProperties(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionDeactivatedEventArgs", L"ConnectionProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorConnectionDeactivatedEventArgs_get_Reason(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionDeactivatedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulatorConnectionDeactivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulatorConnectionDeactivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulatorConnectionDeactivatedEventArgs[] = {
        { "_assign_array_", _assign_array_SmartCardEmulatorConnectionDeactivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulatorConnectionDeactivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulatorConnectionDeactivatedEventArgs[] = {
        { "connection_properties", reinterpret_cast<getter>(SmartCardEmulatorConnectionDeactivatedEventArgs_get_ConnectionProperties), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(SmartCardEmulatorConnectionDeactivatedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulatorConnectionDeactivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulatorConnectionDeactivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SmartCardEmulatorConnectionDeactivatedEventArgs = {
        "winrt._winrt_windows_devices_smartcards.SmartCardEmulatorConnectionDeactivatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionDeactivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulatorConnectionDeactivatedEventArgs};

    // ----- SmartCardEmulatorConnectionProperties class --------------------

    static PyObject* _new_SmartCardEmulatorConnectionProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardEmulatorConnectionProperties(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardEmulatorConnectionProperties_get_Id(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionProperties", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardEmulatorConnectionProperties_get_Source(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardEmulatorConnectionProperties", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardEmulatorConnectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardEmulatorConnectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardEmulatorConnectionProperties[] = {
        { "_assign_array_", _assign_array_SmartCardEmulatorConnectionProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardEmulatorConnectionProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardEmulatorConnectionProperties[] = {
        { "id", reinterpret_cast<getter>(SmartCardEmulatorConnectionProperties_get_Id), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SmartCardEmulatorConnectionProperties_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardEmulatorConnectionProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardEmulatorConnectionProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardEmulatorConnectionProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardEmulatorConnectionProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardEmulatorConnectionProperties) },
        { }
    };

    static PyType_Spec type_spec_SmartCardEmulatorConnectionProperties = {
        "winrt._winrt_windows_devices_smartcards.SmartCardEmulatorConnectionProperties",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardEmulatorConnectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardEmulatorConnectionProperties};

    // ----- SmartCardPinPolicy class --------------------

    static PyObject* _new_SmartCardPinPolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::SmartCards::SmartCardPinPolicy instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardPinPolicy(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardPinPolicy_get_UppercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"UppercaseLetters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UppercaseLetters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_UppercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"UppercaseLetters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.UppercaseLetters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_SpecialCharacters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"SpecialCharacters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SpecialCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_SpecialCharacters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"SpecialCharacters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.SpecialCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_MinLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MinLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_MinLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MinLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MinLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_MaxLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MaxLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_MaxLength(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"MaxLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_LowercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"LowercaseLetters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LowercaseLetters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_LowercaseLetters(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"LowercaseLetters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.LowercaseLetters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmartCardPinPolicy_get_Digits(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"Digits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Digits());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmartCardPinPolicy_put_Digits(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinPolicy", L"Digits");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinCharacterPolicyOption>(arg);

            self->obj.Digits(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SmartCardPinPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardPinPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardPinPolicy[] = {
        { "_assign_array_", _assign_array_SmartCardPinPolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardPinPolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardPinPolicy[] = {
        { "uppercase_letters", reinterpret_cast<getter>(SmartCardPinPolicy_get_UppercaseLetters), reinterpret_cast<setter>(SmartCardPinPolicy_put_UppercaseLetters), nullptr, nullptr },
        { "special_characters", reinterpret_cast<getter>(SmartCardPinPolicy_get_SpecialCharacters), reinterpret_cast<setter>(SmartCardPinPolicy_put_SpecialCharacters), nullptr, nullptr },
        { "min_length", reinterpret_cast<getter>(SmartCardPinPolicy_get_MinLength), reinterpret_cast<setter>(SmartCardPinPolicy_put_MinLength), nullptr, nullptr },
        { "max_length", reinterpret_cast<getter>(SmartCardPinPolicy_get_MaxLength), reinterpret_cast<setter>(SmartCardPinPolicy_put_MaxLength), nullptr, nullptr },
        { "lowercase_letters", reinterpret_cast<getter>(SmartCardPinPolicy_get_LowercaseLetters), reinterpret_cast<setter>(SmartCardPinPolicy_put_LowercaseLetters), nullptr, nullptr },
        { "digits", reinterpret_cast<getter>(SmartCardPinPolicy_get_Digits), reinterpret_cast<setter>(SmartCardPinPolicy_put_Digits), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardPinPolicy[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardPinPolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardPinPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardPinPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardPinPolicy) },
        { }
    };

    static PyType_Spec type_spec_SmartCardPinPolicy = {
        "winrt._winrt_windows_devices_smartcards.SmartCardPinPolicy",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardPinPolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardPinPolicy};

    // ----- SmartCardPinResetDeferral class --------------------

    static PyObject* _new_SmartCardPinResetDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardPinResetDeferral(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardPinResetDeferral_Complete(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardPinResetDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardPinResetDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardPinResetDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardPinResetDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardPinResetDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SmartCardPinResetDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardPinResetDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardPinResetDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardPinResetDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SmartCardPinResetDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardPinResetDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardPinResetDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardPinResetDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardPinResetDeferral) },
        { }
    };

    static PyType_Spec type_spec_SmartCardPinResetDeferral = {
        "winrt._winrt_windows_devices_smartcards.SmartCardPinResetDeferral",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardPinResetDeferral};

    // ----- SmartCardPinResetRequest class --------------------

    static PyObject* _new_SmartCardPinResetRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardPinResetRequest(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardPinResetRequest_GetDeferral(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardPinResetRequest_SetResponse(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"SetResponse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SetResponse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardPinResetRequest_get_Challenge(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"Challenge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Challenge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardPinResetRequest_get_Deadline(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardPinResetRequest", L"Deadline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardPinResetRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardPinResetRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardPinResetRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardPinResetRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SmartCardPinResetRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_response", reinterpret_cast<PyCFunction>(SmartCardPinResetRequest_SetResponse), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardPinResetRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardPinResetRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardPinResetRequest[] = {
        { "challenge", reinterpret_cast<getter>(SmartCardPinResetRequest_get_Challenge), nullptr, nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(SmartCardPinResetRequest_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardPinResetRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardPinResetRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardPinResetRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardPinResetRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardPinResetRequest) },
        { }
    };

    static PyType_Spec type_spec_SmartCardPinResetRequest = {
        "winrt._winrt_windows_devices_smartcards.SmartCardPinResetRequest",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardPinResetRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardPinResetRequest};

    // ----- SmartCardProvisioning class --------------------

    static PyObject* _new_SmartCardProvisioning(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardProvisioning(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardProvisioning_FromSmartCardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"FromSmartCardAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCard>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::FromSmartCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetAuthorityKeyContainerNameAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetAuthorityKeyContainerNameAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAuthorityKeyContainerNameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetChallengeContextAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetChallengeContextAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChallengeContextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetIdAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetIdAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_GetNameAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"GetNameAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetNameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestAttestedVirtualSmartCardCreationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestAttestedVirtualSmartCardCreationAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestAttestedVirtualSmartCardCreationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestAttestedVirtualSmartCardCreationAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);
                auto param3 = py::convert_to<winrt::guid>(args, 3);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestAttestedVirtualSmartCardCreationAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestPinChangeAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestPinChangeAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestPinChangeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestPinResetAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestPinResetAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinResetHandler>(args, 0);

                return py::convert(self->obj.RequestPinResetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestVirtualSmartCardCreationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestVirtualSmartCardCreationAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestVirtualSmartCardCreationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestVirtualSmartCardCreationAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardPinPolicy>(args, 2);
                auto param3 = py::convert_to<winrt::guid>(args, 3);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestVirtualSmartCardCreationAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_RequestVirtualSmartCardDeletionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"RequestVirtualSmartCardDeletionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCard>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardProvisioning::RequestVirtualSmartCardDeletionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardProvisioning_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardProvisioning", L"SmartCard");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardProvisioning(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardProvisioning(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardProvisioning>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardProvisioning[] = {
        { "get_authority_key_container_name_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetAuthorityKeyContainerNameAsync), METH_VARARGS, nullptr },
        { "get_challenge_context_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetChallengeContextAsync), METH_VARARGS, nullptr },
        { "get_id_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetIdAsync), METH_VARARGS, nullptr },
        { "get_name_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_GetNameAsync), METH_VARARGS, nullptr },
        { "request_pin_change_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestPinChangeAsync), METH_VARARGS, nullptr },
        { "request_pin_reset_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestPinResetAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardProvisioning, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardProvisioning), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardProvisioning[] = {
        { "smart_card", reinterpret_cast<getter>(SmartCardProvisioning_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardProvisioning[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardProvisioning) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardProvisioning) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardProvisioning) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardProvisioning) },
        { }
    };

    static PyType_Spec type_spec_SmartCardProvisioning = {
        "winrt._winrt_windows_devices_smartcards.SmartCardProvisioning",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardProvisioning),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardProvisioning};

    static PyGetSetDef getset_SmartCardProvisioning_Static[] = {
        { }
    };

    static PyMethodDef methods_SmartCardProvisioning_Static[] = {
        { "from_smart_card_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_FromSmartCardAsync), METH_VARARGS, nullptr },
        { "request_attested_virtual_smart_card_creation_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestAttestedVirtualSmartCardCreationAsync), METH_VARARGS, nullptr },
        { "request_virtual_smart_card_creation_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestVirtualSmartCardCreationAsync), METH_VARARGS, nullptr },
        { "request_virtual_smart_card_deletion_async", reinterpret_cast<PyCFunction>(SmartCardProvisioning_RequestVirtualSmartCardDeletionAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartCardProvisioning_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardProvisioning_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartCardProvisioning_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartCardProvisioning_Static =
    {
        "winrt._winrt_windows_devices_smartcards.SmartCardProvisioning_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardProvisioning_Static
    };

    // ----- SmartCardReader class --------------------

    static PyObject* _new_SmartCardReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardReader>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardReader(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardReader_FindAllCardsAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"FindAllCardsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindAllCardsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardReader::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"GetDeviceSelector", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardReader::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"GetDeviceSelector", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardReaderKind>(args, 0);

                return py::convert(winrt::Windows::Devices::SmartCards::SmartCardReader::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_GetStatusAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"GetStatusAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_get_DeviceId(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_get_Kind(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_get_Name(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_add_CardAdded(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardReader, winrt::Windows::Devices::SmartCards::CardAddedEventArgs>>(arg);

            return py::convert(self->obj.CardAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_remove_CardAdded(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CardAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_add_CardRemoved(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::SmartCards::SmartCardReader, winrt::Windows::Devices::SmartCards::CardRemovedEventArgs>>(arg);

            return py::convert(self->obj.CardRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardReader_remove_CardRemoved(py::wrapper::Windows::Devices::SmartCards::SmartCardReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.SmartCards.SmartCardReader", L"CardRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CardRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardReader[] = {
        { "find_all_cards_async", reinterpret_cast<PyCFunction>(SmartCardReader_FindAllCardsAsync), METH_VARARGS, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(SmartCardReader_GetStatusAsync), METH_VARARGS, nullptr },
        { "add_card_added", reinterpret_cast<PyCFunction>(SmartCardReader_add_CardAdded), METH_O, nullptr },
        { "remove_card_added", reinterpret_cast<PyCFunction>(SmartCardReader_remove_CardAdded), METH_O, nullptr },
        { "add_card_removed", reinterpret_cast<PyCFunction>(SmartCardReader_add_CardRemoved), METH_O, nullptr },
        { "remove_card_removed", reinterpret_cast<PyCFunction>(SmartCardReader_remove_CardRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmartCardReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardReader[] = {
        { "device_id", reinterpret_cast<getter>(SmartCardReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SmartCardReader_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(SmartCardReader_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardReader) },
        { }
    };

    static PyType_Spec type_spec_SmartCardReader = {
        "winrt._winrt_windows_devices_smartcards.SmartCardReader",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardReader};

    static PyGetSetDef getset_SmartCardReader_Static[] = {
        { }
    };

    static PyMethodDef methods_SmartCardReader_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(SmartCardReader_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmartCardReader_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartCardReader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartCardReader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartCardReader_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartCardReader_Static =
    {
        "winrt._winrt_windows_devices_smartcards.SmartCardReader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartCardReader_Static
    };

    // ----- SmartCardTriggerDetails class --------------------

    static PyObject* _new_SmartCardTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SmartCardTriggerDetails(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmartCardTriggerDetails_TryLaunchCurrentAppAsync(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TryLaunchCurrentAppAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryLaunchCurrentAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TryLaunchCurrentAppAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardLaunchBehavior>(args, 1);

                return py::convert(self->obj.TryLaunchCurrentAppAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_SourceAppletId(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"SourceAppletId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceAppletId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_TriggerData(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TriggerData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TriggerData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_TriggerType(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"TriggerType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_Emulator(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"Emulator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emulator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartCardTriggerDetails_get_SmartCard(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.SmartCards.SmartCardTriggerDetails", L"SmartCard");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmartCard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmartCardTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmartCardTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::SmartCards::SmartCardTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardTriggerDetails[] = {
        { "try_launch_current_app_async", reinterpret_cast<PyCFunction>(SmartCardTriggerDetails_TryLaunchCurrentAppAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmartCardTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmartCardTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartCardTriggerDetails[] = {
        { "source_applet_id", reinterpret_cast<getter>(SmartCardTriggerDetails_get_SourceAppletId), nullptr, nullptr, nullptr },
        { "trigger_data", reinterpret_cast<getter>(SmartCardTriggerDetails_get_TriggerData), nullptr, nullptr, nullptr },
        { "trigger_type", reinterpret_cast<getter>(SmartCardTriggerDetails_get_TriggerType), nullptr, nullptr, nullptr },
        { "emulator", reinterpret_cast<getter>(SmartCardTriggerDetails_get_Emulator), nullptr, nullptr, nullptr },
        { "smart_card", reinterpret_cast<getter>(SmartCardTriggerDetails_get_SmartCard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmartCardTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartCardTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmartCardTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartCardTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartCardTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_SmartCardTriggerDetails = {
        "winrt._winrt_windows_devices_smartcards.SmartCardTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::SmartCards::SmartCardTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardTriggerDetails};

    // ----- Windows.Devices.SmartCards Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.SmartCards");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_smartcards",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::SmartCards

PyMODINIT_FUNC PyInit__winrt_windows_devices_smartcards(void) noexcept
{
    using namespace py::cpp::Windows::Devices::SmartCards;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CardAddedEventArgs_type{py::register_python_type(module.get(), &type_spec_CardAddedEventArgs, object_bases.get(), nullptr)};
    if (!CardAddedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CardRemovedEventArgs_type{py::register_python_type(module.get(), &type_spec_CardRemovedEventArgs, object_bases.get(), nullptr)};
    if (!CardRemovedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownSmartCardAppletIds_Static{PyType_FromSpec(&type_spec_KnownSmartCardAppletIds_Static)};
    if (!type_KnownSmartCardAppletIds_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownSmartCardAppletIds_type{py::register_python_type(module.get(), &type_spec_KnownSmartCardAppletIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownSmartCardAppletIds_Static.get()))};
    if (!KnownSmartCardAppletIds_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCard_type{py::register_python_type(module.get(), &type_spec_SmartCard, object_bases.get(), nullptr)};
    if (!SmartCard_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardAppletIdGroup_Static{PyType_FromSpec(&type_spec_SmartCardAppletIdGroup_Static)};
    if (!type_SmartCardAppletIdGroup_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardAppletIdGroup_type{py::register_python_type(module.get(), &type_spec_SmartCardAppletIdGroup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardAppletIdGroup_Static.get()))};
    if (!SmartCardAppletIdGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardAppletIdGroupRegistration_type{py::register_python_type(module.get(), &type_spec_SmartCardAppletIdGroupRegistration, object_bases.get(), nullptr)};
    if (!SmartCardAppletIdGroupRegistration_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardAutomaticResponseApdu_type{py::register_python_type(module.get(), &type_spec_SmartCardAutomaticResponseApdu, object_bases.get(), nullptr)};
    if (!SmartCardAutomaticResponseApdu_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardChallengeContext_type{py::register_python_type(module.get(), &type_spec_SmartCardChallengeContext, object_bases.get(), nullptr)};
    if (!SmartCardChallengeContext_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardConnection_type{py::register_python_type(module.get(), &type_spec_SmartCardConnection, object_bases.get(), nullptr)};
    if (!SmartCardConnection_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardCryptogramGenerator_Static{PyType_FromSpec(&type_spec_SmartCardCryptogramGenerator_Static)};
    if (!type_SmartCardCryptogramGenerator_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramGenerator_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramGenerator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardCryptogramGenerator_Static.get()))};
    if (!SmartCardCryptogramGenerator_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramMaterialCharacteristics_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramMaterialCharacteristics, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramMaterialCharacteristics_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramMaterialPackageCharacteristics_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramMaterialPackageCharacteristics, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramMaterialPackageCharacteristics_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramMaterialPossessionProof_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramMaterialPossessionProof, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramMaterialPossessionProof_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramPlacementStep_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramPlacementStep, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramPlacementStep_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramStorageKeyCharacteristics_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramStorageKeyCharacteristics, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramStorageKeyCharacteristics_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardCryptogramStorageKeyInfo_type{py::register_python_type(module.get(), &type_spec_SmartCardCryptogramStorageKeyInfo, object_bases.get(), nullptr)};
    if (!SmartCardCryptogramStorageKeyInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardEmulator_Static{PyType_FromSpec(&type_spec_SmartCardEmulator_Static)};
    if (!type_SmartCardEmulator_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardEmulator_type{py::register_python_type(module.get(), &type_spec_SmartCardEmulator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardEmulator_Static.get()))};
    if (!SmartCardEmulator_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardEmulatorApduReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_SmartCardEmulatorApduReceivedEventArgs, object_bases.get(), nullptr)};
    if (!SmartCardEmulatorApduReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardEmulatorConnectionDeactivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_SmartCardEmulatorConnectionDeactivatedEventArgs, object_bases.get(), nullptr)};
    if (!SmartCardEmulatorConnectionDeactivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardEmulatorConnectionProperties_type{py::register_python_type(module.get(), &type_spec_SmartCardEmulatorConnectionProperties, object_bases.get(), nullptr)};
    if (!SmartCardEmulatorConnectionProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardPinPolicy_type{py::register_python_type(module.get(), &type_spec_SmartCardPinPolicy, object_bases.get(), nullptr)};
    if (!SmartCardPinPolicy_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardPinResetDeferral_type{py::register_python_type(module.get(), &type_spec_SmartCardPinResetDeferral, object_bases.get(), nullptr)};
    if (!SmartCardPinResetDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardPinResetRequest_type{py::register_python_type(module.get(), &type_spec_SmartCardPinResetRequest, object_bases.get(), nullptr)};
    if (!SmartCardPinResetRequest_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardProvisioning_Static{PyType_FromSpec(&type_spec_SmartCardProvisioning_Static)};
    if (!type_SmartCardProvisioning_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardProvisioning_type{py::register_python_type(module.get(), &type_spec_SmartCardProvisioning, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardProvisioning_Static.get()))};
    if (!SmartCardProvisioning_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartCardReader_Static{PyType_FromSpec(&type_spec_SmartCardReader_Static)};
    if (!type_SmartCardReader_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardReader_type{py::register_python_type(module.get(), &type_spec_SmartCardReader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartCardReader_Static.get()))};
    if (!SmartCardReader_type)
    {
        return nullptr;
    }

    py::pytype_handle SmartCardTriggerDetails_type{py::register_python_type(module.get(), &type_spec_SmartCardTriggerDetails, object_bases.get(), nullptr)};
    if (!SmartCardTriggerDetails_type)
    {
        return nullptr;
    }


    return module.detach();
}
