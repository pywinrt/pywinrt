// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Networking.Vpn.h"


namespace py::cpp::Windows::Networking::Vpn
{
    // ----- VpnAppId class --------------------

    static PyObject* _new_VpnAppId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppIdType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::Vpn::VpnAppId instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnAppId(py::wrapper::Windows::Networking::Vpn::VpnAppId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnAppId_get_Value(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnAppId_put_Value(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnAppId_get_Type(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnAppId_put_Type(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppIdType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnAppId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnAppId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnAppId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnAppId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnAppId[] = {
        { "_assign_array_", _assign_array_VpnAppId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnAppId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnAppId[] = {
        { "value", reinterpret_cast<getter>(VpnAppId_get_Value), reinterpret_cast<setter>(VpnAppId_put_Value), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(VpnAppId_get_Type), reinterpret_cast<setter>(VpnAppId_put_Type), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnAppId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnAppId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnAppId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnAppId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnAppId) },
        { },
    };

    static PyType_Spec type_spec_VpnAppId =
    {
        "winrt._winrt_windows_networking_vpn.VpnAppId",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnAppId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnAppId
    };

    // ----- VpnChannel class --------------------

    static PyObject* _new_VpnChannel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannel>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannel(py::wrapper::Windows::Networking::Vpn::VpnChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannel_ActivateForeground(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivateForeground", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 1);

                return py::convert(self->obj.ActivateForeground(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AddAndAssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AddAndAssociateTransport", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AddAndAssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AppendVpnReceivePacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AppendVpnReceivePacketBuffer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AppendVpnReceivePacketBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AppendVpnSendPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AppendVpnSendPacketBuffer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AppendVpnSendPacketBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AssociateTransport", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_FlushVpnReceivePacketBuffers(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"FlushVpnReceivePacketBuffers", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.FlushVpnReceivePacketBuffers();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_FlushVpnSendPacketBuffers(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"FlushVpnSendPacketBuffers", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.FlushVpnSendPacketBuffers();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetSlotTypeForTransportContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"GetSlotTypeForTransportContext", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.GetSlotTypeForTransportContext(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetVpnReceivePacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"GetVpnReceivePacketBuffer", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVpnReceivePacketBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetVpnSendPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"GetVpnSendPacketBuffer", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVpnSendPacketBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_LogDiagnosticMessage(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"LogDiagnosticMessage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogDiagnosticMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_ProcessEventAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"ProcessEventAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                winrt::Windows::Networking::Vpn::VpnChannel::ProcessEventAsync(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_ReplaceAndAssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"ReplaceAndAssociateTransport", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ReplaceAndAssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentials(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentials", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 3);

                return py::convert(self->obj.RequestCredentials(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentialsAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentialsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);

                return py::convert(self->obj.RequestCredentialsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentialsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.RequestCredentialsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentialsAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 2);

                return py::convert(self->obj.RequestCredentialsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCustomPrompt(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCustomPrompt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>>(args, 0);

                self->obj.RequestCustomPrompt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCustomPromptAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCustomPromptAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>>(args, 0);

                return py::convert(self->obj.RequestCustomPromptAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestVpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestVpnPacketBuffer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDataPathType>(args, 0);
                winrt::Windows::Networking::Vpn::VpnPacketBuffer param1 { nullptr };

                self->obj.RequestVpnPacketBuffer(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_SetAllowedSslTlsVersions(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"SetAllowedSslTlsVersions", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetAllowedSslTlsVersions(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_SetErrorMessage(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"SetErrorMessage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetErrorMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_Start(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"Start", 10))
                {
                    py::set_arg_count_version_error(10);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 9);

                self->obj.Start(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartExistingTransports(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 8)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartExistingTransports", 8))
                {
                    py::set_arg_count_version_error(8);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);

                self->obj.StartExistingTransports(param0, param1, param2, param3, param4, param5, param6, param7);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartReconnectingTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartReconnectingTransport", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.StartReconnectingTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithMainTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartWithMainTransport", 9))
                {
                    py::set_arg_count_version_error(9);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);

                self->obj.StartWithMainTransport(param0, param1, param2, param3, param4, param5, param6, param7, param8);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithTrafficFilter(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartWithTrafficFilter", 10))
                {
                    py::set_arg_count_version_error(10);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>(args, 9);

                self->obj.StartWithTrafficFilter(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 11)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartWithTrafficFilter", 11))
                {
                    py::set_arg_count_version_error(11);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 9);
                auto param10 = py::convert_to<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>(args, 10);

                self->obj.StartWithTrafficFilter(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_Stop(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_TerminateConnection(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"TerminateConnection", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TerminateConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_PlugInContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"PlugInContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlugInContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnChannel_put_PlugInContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"PlugInContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.PlugInContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnChannel_get_Configuration(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"Configuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_Id(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_SystemHealth(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"SystemHealth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemHealth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_CurrentRequestTransportContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"CurrentRequestTransportContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentRequestTransportContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_add_ActivityChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Vpn::VpnChannel, winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>>(arg);

            return py::convert(self->obj.ActivityChange(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_remove_ActivityChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActivityChange(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_add_ActivityStateChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityStateChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Vpn::VpnChannel, winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>>(arg);

            return py::convert(self->obj.ActivityStateChange(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_remove_ActivityStateChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityStateChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActivityStateChange(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannel[] = {
        { "activate_foreground", reinterpret_cast<PyCFunction>(VpnChannel_ActivateForeground), METH_VARARGS, nullptr },
        { "add_and_associate_transport", reinterpret_cast<PyCFunction>(VpnChannel_AddAndAssociateTransport), METH_VARARGS, nullptr },
        { "append_vpn_receive_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_AppendVpnReceivePacketBuffer), METH_VARARGS, nullptr },
        { "append_vpn_send_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_AppendVpnSendPacketBuffer), METH_VARARGS, nullptr },
        { "associate_transport", reinterpret_cast<PyCFunction>(VpnChannel_AssociateTransport), METH_VARARGS, nullptr },
        { "flush_vpn_receive_packet_buffers", reinterpret_cast<PyCFunction>(VpnChannel_FlushVpnReceivePacketBuffers), METH_VARARGS, nullptr },
        { "flush_vpn_send_packet_buffers", reinterpret_cast<PyCFunction>(VpnChannel_FlushVpnSendPacketBuffers), METH_VARARGS, nullptr },
        { "get_slot_type_for_transport_context", reinterpret_cast<PyCFunction>(VpnChannel_GetSlotTypeForTransportContext), METH_VARARGS, nullptr },
        { "get_vpn_receive_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_GetVpnReceivePacketBuffer), METH_VARARGS, nullptr },
        { "get_vpn_send_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_GetVpnSendPacketBuffer), METH_VARARGS, nullptr },
        { "log_diagnostic_message", reinterpret_cast<PyCFunction>(VpnChannel_LogDiagnosticMessage), METH_VARARGS, nullptr },
        { "replace_and_associate_transport", reinterpret_cast<PyCFunction>(VpnChannel_ReplaceAndAssociateTransport), METH_VARARGS, nullptr },
        { "request_credentials", reinterpret_cast<PyCFunction>(VpnChannel_RequestCredentials), METH_VARARGS, nullptr },
        { "request_credentials_async", reinterpret_cast<PyCFunction>(VpnChannel_RequestCredentialsAsync), METH_VARARGS, nullptr },
        { "request_custom_prompt", reinterpret_cast<PyCFunction>(VpnChannel_RequestCustomPrompt), METH_VARARGS, nullptr },
        { "request_custom_prompt_async", reinterpret_cast<PyCFunction>(VpnChannel_RequestCustomPromptAsync), METH_VARARGS, nullptr },
        { "request_vpn_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_RequestVpnPacketBuffer), METH_VARARGS, nullptr },
        { "set_allowed_ssl_tls_versions", reinterpret_cast<PyCFunction>(VpnChannel_SetAllowedSslTlsVersions), METH_VARARGS, nullptr },
        { "set_error_message", reinterpret_cast<PyCFunction>(VpnChannel_SetErrorMessage), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(VpnChannel_Start), METH_VARARGS, nullptr },
        { "start_existing_transports", reinterpret_cast<PyCFunction>(VpnChannel_StartExistingTransports), METH_VARARGS, nullptr },
        { "start_reconnecting_transport", reinterpret_cast<PyCFunction>(VpnChannel_StartReconnectingTransport), METH_VARARGS, nullptr },
        { "start_with_main_transport", reinterpret_cast<PyCFunction>(VpnChannel_StartWithMainTransport), METH_VARARGS, nullptr },
        { "start_with_traffic_filter", reinterpret_cast<PyCFunction>(VpnChannel_StartWithTrafficFilter), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(VpnChannel_Stop), METH_VARARGS, nullptr },
        { "terminate_connection", reinterpret_cast<PyCFunction>(VpnChannel_TerminateConnection), METH_VARARGS, nullptr },
        { "add_activity_change", reinterpret_cast<PyCFunction>(VpnChannel_add_ActivityChange), METH_O, nullptr },
        { "remove_activity_change", reinterpret_cast<PyCFunction>(VpnChannel_remove_ActivityChange), METH_O, nullptr },
        { "add_activity_state_change", reinterpret_cast<PyCFunction>(VpnChannel_add_ActivityStateChange), METH_O, nullptr },
        { "remove_activity_state_change", reinterpret_cast<PyCFunction>(VpnChannel_remove_ActivityStateChange), METH_O, nullptr },
        { "_assign_array_", _assign_array_VpnChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannel[] = {
        { "plug_in_context", reinterpret_cast<getter>(VpnChannel_get_PlugInContext), reinterpret_cast<setter>(VpnChannel_put_PlugInContext), nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(VpnChannel_get_Configuration), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VpnChannel_get_Id), nullptr, nullptr, nullptr },
        { "system_health", reinterpret_cast<getter>(VpnChannel_get_SystemHealth), nullptr, nullptr, nullptr },
        { "current_request_transport_context", reinterpret_cast<getter>(VpnChannel_get_CurrentRequestTransportContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannel) },
        { },
    };

    static PyType_Spec type_spec_VpnChannel =
    {
        "winrt._winrt_windows_networking_vpn.VpnChannel",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannel
    };

    static PyGetSetDef getset_VpnChannel_Static[] = {
        { }
    };

    static PyMethodDef methods_VpnChannel_Static[] = {
        { "process_event_async", reinterpret_cast<PyCFunction>(VpnChannel_ProcessEventAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VpnChannel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VpnChannel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VpnChannel_Static) },
        { }
    };

    static PyType_Spec type_spec_VpnChannel_Static =
    {
        "winrt._winrt_windows_networking_vpn.VpnChannel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VpnChannel_Static
    };

    // ----- VpnChannelActivityEventArgs class --------------------

    static PyObject* _new_VpnChannelActivityEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannelActivityEventArgs(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannelActivityEventArgs_get_Type(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelActivityEventArgs", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannelActivityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannelActivityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelActivityEventArgs[] = {
        { "_assign_array_", _assign_array_VpnChannelActivityEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannelActivityEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannelActivityEventArgs[] = {
        { "type", reinterpret_cast<getter>(VpnChannelActivityEventArgs_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannelActivityEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannelActivityEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannelActivityEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannelActivityEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannelActivityEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VpnChannelActivityEventArgs =
    {
        "winrt._winrt_windows_networking_vpn.VpnChannelActivityEventArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelActivityEventArgs
    };

    // ----- VpnChannelActivityStateChangedArgs class --------------------

    static PyObject* _new_VpnChannelActivityStateChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannelActivityStateChangedArgs(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannelActivityStateChangedArgs_get_ActivityState(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelActivityStateChangedArgs", L"ActivityState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannelActivityStateChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannelActivityStateChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelActivityStateChangedArgs[] = {
        { "_assign_array_", _assign_array_VpnChannelActivityStateChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannelActivityStateChangedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannelActivityStateChangedArgs[] = {
        { "activity_state", reinterpret_cast<getter>(VpnChannelActivityStateChangedArgs_get_ActivityState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannelActivityStateChangedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannelActivityStateChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannelActivityStateChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannelActivityStateChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannelActivityStateChangedArgs) },
        { },
    };

    static PyType_Spec type_spec_VpnChannelActivityStateChangedArgs =
    {
        "winrt._winrt_windows_networking_vpn.VpnChannelActivityStateChangedArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelActivityStateChangedArgs
    };

    // ----- VpnChannelConfiguration class --------------------

    static PyObject* _new_VpnChannelConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannelConfiguration(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannelConfiguration_get_CustomField(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"CustomField"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerHostNameList(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"ServerHostNameList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerServiceName(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"ServerServiceName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerUris(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"ServerUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannelConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannelConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelConfiguration[] = {
        { "_assign_array_", _assign_array_VpnChannelConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannelConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannelConfiguration[] = {
        { "custom_field", reinterpret_cast<getter>(VpnChannelConfiguration_get_CustomField), nullptr, nullptr, nullptr },
        { "server_host_name_list", reinterpret_cast<getter>(VpnChannelConfiguration_get_ServerHostNameList), nullptr, nullptr, nullptr },
        { "server_service_name", reinterpret_cast<getter>(VpnChannelConfiguration_get_ServerServiceName), nullptr, nullptr, nullptr },
        { "server_uris", reinterpret_cast<getter>(VpnChannelConfiguration_get_ServerUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannelConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannelConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannelConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannelConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannelConfiguration) },
        { },
    };

    static PyType_Spec type_spec_VpnChannelConfiguration =
    {
        "winrt._winrt_windows_networking_vpn.VpnChannelConfiguration",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelConfiguration
    };

    // ----- VpnCredential class --------------------

    static PyObject* _new_VpnCredential(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnCredential>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnCredential>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"AdditionalPin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_CertificateCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"CertificateCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CertificateCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"OldPasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"PasskeyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCredential>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCredential[] = {
        { "_assign_array_", _assign_array_VpnCredential, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCredential), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCredential[] = {
        { "additional_pin", reinterpret_cast<getter>(VpnCredential_get_AdditionalPin), nullptr, nullptr, nullptr },
        { "certificate_credential", reinterpret_cast<getter>(VpnCredential_get_CertificateCredential), nullptr, nullptr, nullptr },
        { "old_password_credential", reinterpret_cast<getter>(VpnCredential_get_OldPasswordCredential), nullptr, nullptr, nullptr },
        { "passkey_credential", reinterpret_cast<getter>(VpnCredential_get_PasskeyCredential), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCredential[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCredential) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCredential) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCredential) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCredential) },
        { },
    };

    static PyType_Spec type_spec_VpnCredential =
    {
        "winrt._winrt_windows_networking_vpn.VpnCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCredential
    };

    // ----- VpnCustomCheckBox class --------------------

    static PyObject* _new_VpnCustomCheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomCheckBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomCheckBox(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomCheckBox_get_InitialCheckState(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"InitialCheckState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InitialCheckState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_InitialCheckState(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"InitialCheckState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InitialCheckState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Checked(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Checked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Checked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomCheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomCheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomCheckBox[] = {
        { "_assign_array_", _assign_array_VpnCustomCheckBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomCheckBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomCheckBox[] = {
        { "initial_check_state", reinterpret_cast<getter>(VpnCustomCheckBox_get_InitialCheckState), reinterpret_cast<setter>(VpnCustomCheckBox_put_InitialCheckState), nullptr, nullptr },
        { "checked", reinterpret_cast<getter>(VpnCustomCheckBox_get_Checked), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VpnCustomCheckBox_get_Label), reinterpret_cast<setter>(VpnCustomCheckBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomCheckBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomCheckBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomCheckBox_get_Bordered), reinterpret_cast<setter>(VpnCustomCheckBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomCheckBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomCheckBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomCheckBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomCheckBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomCheckBox) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomCheckBox =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomCheckBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomCheckBox
    };

    // ----- VpnCustomComboBox class --------------------

    static PyObject* _new_VpnCustomComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomComboBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomComboBox(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomComboBox_get_OptionsText(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"OptionsText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionsText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_OptionsText(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"OptionsText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(arg);

            self->obj.OptionsText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Selected(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Selected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomComboBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomComboBox[] = {
        { "_assign_array_", _assign_array_VpnCustomComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomComboBox[] = {
        { "options_text", reinterpret_cast<getter>(VpnCustomComboBox_get_OptionsText), reinterpret_cast<setter>(VpnCustomComboBox_put_OptionsText), nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(VpnCustomComboBox_get_Selected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VpnCustomComboBox_get_Label), reinterpret_cast<setter>(VpnCustomComboBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomComboBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomComboBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomComboBox_get_Bordered), reinterpret_cast<setter>(VpnCustomComboBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomComboBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomComboBox) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomComboBox =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomComboBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomComboBox
    };

    // ----- VpnCustomEditBox class --------------------

    static PyObject* _new_VpnCustomEditBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomEditBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomEditBox(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomEditBox_get_NoEcho(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"NoEcho"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NoEcho());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_NoEcho(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"NoEcho"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoEcho(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_DefaultText(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"DefaultText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_DefaultText(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"DefaultText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomEditBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomEditBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomEditBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomEditBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomEditBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomEditBox[] = {
        { "_assign_array_", _assign_array_VpnCustomEditBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomEditBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomEditBox[] = {
        { "no_echo", reinterpret_cast<getter>(VpnCustomEditBox_get_NoEcho), reinterpret_cast<setter>(VpnCustomEditBox_put_NoEcho), nullptr, nullptr },
        { "default_text", reinterpret_cast<getter>(VpnCustomEditBox_get_DefaultText), reinterpret_cast<setter>(VpnCustomEditBox_put_DefaultText), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(VpnCustomEditBox_get_Text), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VpnCustomEditBox_get_Label), reinterpret_cast<setter>(VpnCustomEditBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomEditBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomEditBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomEditBox_get_Bordered), reinterpret_cast<setter>(VpnCustomEditBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomEditBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomEditBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomEditBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomEditBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomEditBox) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomEditBox =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomEditBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomEditBox
    };

    // ----- VpnCustomErrorBox class --------------------

    static PyObject* _new_VpnCustomErrorBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomErrorBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomErrorBox(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomErrorBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomErrorBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomErrorBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomErrorBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomErrorBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomErrorBox[] = {
        { "_assign_array_", _assign_array_VpnCustomErrorBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomErrorBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomErrorBox[] = {
        { "label", reinterpret_cast<getter>(VpnCustomErrorBox_get_Label), reinterpret_cast<setter>(VpnCustomErrorBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomErrorBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomErrorBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomErrorBox_get_Bordered), reinterpret_cast<setter>(VpnCustomErrorBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomErrorBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomErrorBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomErrorBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomErrorBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomErrorBox) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomErrorBox =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomErrorBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomErrorBox
    };

    // ----- VpnCustomPromptBooleanInput class --------------------

    static PyObject* _new_VpnCustomPromptBooleanInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptBooleanInput(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptBooleanInput_get_InitialValue(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"InitialValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InitialValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_InitialValue(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"InitialValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InitialValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Value(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptBooleanInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptBooleanInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptBooleanInput[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptBooleanInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptBooleanInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptBooleanInput[] = {
        { "initial_value", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_InitialValue), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_InitialValue), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_Value), nullptr, nullptr, nullptr },
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_Compulsory), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptBooleanInput[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptBooleanInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptBooleanInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptBooleanInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptBooleanInput) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomPromptBooleanInput =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptBooleanInput",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptBooleanInput
    };

    // ----- VpnCustomPromptOptionSelector class --------------------

    static PyObject* _new_VpnCustomPromptOptionSelector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptOptionSelector(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Options(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Options"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_SelectedIndex(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"SelectedIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptOptionSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptOptionSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptOptionSelector[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptOptionSelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptOptionSelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptOptionSelector[] = {
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptOptionSelector_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptOptionSelector_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptOptionSelector_put_Compulsory), nullptr, nullptr },
        { "options", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_Options), nullptr, nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_SelectedIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptOptionSelector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptOptionSelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptOptionSelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptOptionSelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptOptionSelector) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomPromptOptionSelector =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptOptionSelector",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptOptionSelector
    };

    // ----- VpnCustomPromptText class --------------------

    static PyObject* _new_VpnCustomPromptText(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptText instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptText_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptText>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptText>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptText[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptText, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptText), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptText[] = {
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptText_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptText_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptText_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptText_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptText_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptText_put_Compulsory), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(VpnCustomPromptText_get_Text), reinterpret_cast<setter>(VpnCustomPromptText_put_Text), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptText[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptText) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptText) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptText) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptText) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomPromptText =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptText",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptText
    };

    // ----- VpnCustomPromptTextInput class --------------------

    static PyObject* _new_VpnCustomPromptTextInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptTextInput(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptTextInput_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_PlaceholderText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"PlaceholderText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_PlaceholderText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"PlaceholderText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_IsTextHidden(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"IsTextHidden"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTextHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_IsTextHidden(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"IsTextHidden"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptTextInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptTextInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptTextInput[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptTextInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptTextInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptTextInput[] = {
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_Compulsory), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_PlaceholderText), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_PlaceholderText), nullptr, nullptr },
        { "is_text_hidden", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_IsTextHidden), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_IsTextHidden), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptTextInput[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptTextInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptTextInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptTextInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptTextInput) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomPromptTextInput =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptTextInput",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptTextInput
    };

    // ----- VpnCustomTextBox class --------------------

    static PyObject* _new_VpnCustomTextBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomTextBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomTextBox(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomTextBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_DisplayText(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"DisplayText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_DisplayText(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"DisplayText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomTextBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomTextBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomTextBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomTextBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomTextBox[] = {
        { "_assign_array_", _assign_array_VpnCustomTextBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomTextBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomTextBox[] = {
        { "label", reinterpret_cast<getter>(VpnCustomTextBox_get_Label), reinterpret_cast<setter>(VpnCustomTextBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomTextBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomTextBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomTextBox_get_Bordered), reinterpret_cast<setter>(VpnCustomTextBox_put_Bordered), nullptr, nullptr },
        { "display_text", reinterpret_cast<getter>(VpnCustomTextBox_get_DisplayText), reinterpret_cast<setter>(VpnCustomTextBox_put_DisplayText), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomTextBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomTextBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomTextBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomTextBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomTextBox) },
        { },
    };

    static PyType_Spec type_spec_VpnCustomTextBox =
    {
        "winrt._winrt_windows_networking_vpn.VpnCustomTextBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomTextBox
    };

    // ----- VpnDomainNameAssignment class --------------------

    static PyObject* _new_VpnDomainNameAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnDomainNameAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnDomainNameAssignment(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnDomainNameAssignment_get_ProxyAutoConfigurationUri(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameAssignment", L"ProxyAutoConfigurationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyAutoConfigurationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameAssignment_put_ProxyAutoConfigurationUri(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameAssignment", L"ProxyAutoConfigurationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProxyAutoConfigurationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameAssignment_get_DomainNameList(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameAssignment", L"DomainNameList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnDomainNameAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnDomainNameAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnDomainNameAssignment[] = {
        { "_assign_array_", _assign_array_VpnDomainNameAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnDomainNameAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnDomainNameAssignment[] = {
        { "proxy_auto_configuration_uri", reinterpret_cast<getter>(VpnDomainNameAssignment_get_ProxyAutoConfigurationUri), reinterpret_cast<setter>(VpnDomainNameAssignment_put_ProxyAutoConfigurationUri), nullptr, nullptr },
        { "domain_name_list", reinterpret_cast<getter>(VpnDomainNameAssignment_get_DomainNameList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnDomainNameAssignment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnDomainNameAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnDomainNameAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnDomainNameAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnDomainNameAssignment) },
        { },
    };

    static PyType_Spec type_spec_VpnDomainNameAssignment =
    {
        "winrt._winrt_windows_networking_vpn.VpnDomainNameAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnDomainNameAssignment
    };

    // ----- VpnDomainNameInfo class --------------------

    static PyObject* _new_VpnDomainNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 3);

                winrt::Windows::Networking::Vpn::VpnDomainNameInfo instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnDomainNameInfo(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnDomainNameInfo_get_DomainNameType(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainNameType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameInfo_put_DomainNameType(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainNameType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(arg);

            self->obj.DomainNameType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameInfo_get_DomainName(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameInfo_put_DomainName(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.DomainName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameInfo_get_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DnsServers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DnsServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnDomainNameInfo_get_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"WebProxyServers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebProxyServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnDomainNameInfo_get_WebProxyUris(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"WebProxyUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnDomainNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnDomainNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnDomainNameInfo[] = {
        { "_assign_array_", _assign_array_VpnDomainNameInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnDomainNameInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnDomainNameInfo[] = {
        { "domain_name_type", reinterpret_cast<getter>(VpnDomainNameInfo_get_DomainNameType), reinterpret_cast<setter>(VpnDomainNameInfo_put_DomainNameType), nullptr, nullptr },
        { "domain_name", reinterpret_cast<getter>(VpnDomainNameInfo_get_DomainName), reinterpret_cast<setter>(VpnDomainNameInfo_put_DomainName), nullptr, nullptr },
        { "dns_servers", reinterpret_cast<getter>(VpnDomainNameInfo_get_DnsServers), nullptr, nullptr, nullptr },
        { "web_proxy_servers", reinterpret_cast<getter>(VpnDomainNameInfo_get_WebProxyServers), nullptr, nullptr, nullptr },
        { "web_proxy_uris", reinterpret_cast<getter>(VpnDomainNameInfo_get_WebProxyUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnDomainNameInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnDomainNameInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnDomainNameInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnDomainNameInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnDomainNameInfo) },
        { },
    };

    static PyType_Spec type_spec_VpnDomainNameInfo =
    {
        "winrt._winrt_windows_networking_vpn.VpnDomainNameInfo",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnDomainNameInfo
    };

    // ----- VpnForegroundActivatedEventArgs class --------------------

    static PyObject* _new_VpnForegroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnForegroundActivatedEventArgs(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_Kind(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"PreviousExecutionState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"SplashScreen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_User(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_ActivationOperation(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"ActivationOperation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivationOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_SharedContext(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"SharedContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnForegroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnForegroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnForegroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_VpnForegroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnForegroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnForegroundActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "activation_operation", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_ActivationOperation), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_ProfileName), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnForegroundActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnForegroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnForegroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnForegroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnForegroundActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VpnForegroundActivatedEventArgs =
    {
        "winrt._winrt_windows_networking_vpn.VpnForegroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnForegroundActivatedEventArgs
    };

    // ----- VpnForegroundActivationOperation class --------------------

    static PyObject* _new_VpnForegroundActivationOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnForegroundActivationOperation(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnForegroundActivationOperation_Complete(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnForegroundActivationOperation", L"Complete", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                self->obj.Complete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnForegroundActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnForegroundActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnForegroundActivationOperation[] = {
        { "complete", reinterpret_cast<PyCFunction>(VpnForegroundActivationOperation_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnForegroundActivationOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnForegroundActivationOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnForegroundActivationOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_VpnForegroundActivationOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnForegroundActivationOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnForegroundActivationOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnForegroundActivationOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnForegroundActivationOperation) },
        { },
    };

    static PyType_Spec type_spec_VpnForegroundActivationOperation =
    {
        "winrt._winrt_windows_networking_vpn.VpnForegroundActivationOperation",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnForegroundActivationOperation
    };

    // ----- VpnInterfaceId class --------------------

    static PyObject* _new_VpnInterfaceId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Networking::Vpn::VpnInterfaceId instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnInterfaceId(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnInterfaceId_GetAddressInfo(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnInterfaceId", L"GetAddressInfo", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0 { };

                self->obj.GetAddressInfo(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnInterfaceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnInterfaceId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnInterfaceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnInterfaceId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnInterfaceId[] = {
        { "get_address_info", reinterpret_cast<PyCFunction>(VpnInterfaceId_GetAddressInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnInterfaceId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnInterfaceId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnInterfaceId[] = {
        { }
    };

    static PyType_Slot _type_slots_VpnInterfaceId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnInterfaceId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnInterfaceId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnInterfaceId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnInterfaceId) },
        { },
    };

    static PyType_Spec type_spec_VpnInterfaceId =
    {
        "winrt._winrt_windows_networking_vpn.VpnInterfaceId",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnInterfaceId
    };

    // ----- VpnManagementAgent class --------------------

    static PyObject* _new_VpnManagementAgent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnManagementAgent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnManagementAgent(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnManagementAgent_AddProfileFromObjectAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"AddProfileFromObjectAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.AddProfileFromObjectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_AddProfileFromXmlAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"AddProfileFromXmlAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddProfileFromXmlAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_ConnectProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"ConnectProfileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.ConnectProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_ConnectProfileWithPasswordCredentialAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"ConnectProfileWithPasswordCredentialAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 1);

                return py::convert(self->obj.ConnectProfileWithPasswordCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_DeleteProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"DeleteProfileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.DeleteProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_DisconnectProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"DisconnectProfileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.DisconnectProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_GetProfilesAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"GetProfilesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetProfilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_UpdateProfileFromObjectAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"UpdateProfileFromObjectAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.UpdateProfileFromObjectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_UpdateProfileFromXmlAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"UpdateProfileFromXmlAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UpdateProfileFromXmlAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnManagementAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnManagementAgent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnManagementAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnManagementAgent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnManagementAgent[] = {
        { "add_profile_from_object_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_AddProfileFromObjectAsync), METH_VARARGS, nullptr },
        { "add_profile_from_xml_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_AddProfileFromXmlAsync), METH_VARARGS, nullptr },
        { "connect_profile_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_ConnectProfileAsync), METH_VARARGS, nullptr },
        { "connect_profile_with_password_credential_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_ConnectProfileWithPasswordCredentialAsync), METH_VARARGS, nullptr },
        { "delete_profile_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_DeleteProfileAsync), METH_VARARGS, nullptr },
        { "disconnect_profile_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_DisconnectProfileAsync), METH_VARARGS, nullptr },
        { "get_profiles_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_GetProfilesAsync), METH_VARARGS, nullptr },
        { "update_profile_from_object_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_UpdateProfileFromObjectAsync), METH_VARARGS, nullptr },
        { "update_profile_from_xml_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_UpdateProfileFromXmlAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnManagementAgent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnManagementAgent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnManagementAgent[] = {
        { }
    };

    static PyType_Slot _type_slots_VpnManagementAgent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnManagementAgent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnManagementAgent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnManagementAgent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnManagementAgent) },
        { },
    };

    static PyType_Spec type_spec_VpnManagementAgent =
    {
        "winrt._winrt_windows_networking_vpn.VpnManagementAgent",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnManagementAgent
    };

    // ----- VpnNamespaceAssignment class --------------------

    static PyObject* _new_VpnNamespaceAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnNamespaceAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNamespaceAssignment(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnNamespaceAssignment_get_ProxyAutoConfigUri(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"ProxyAutoConfigUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyAutoConfigUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceAssignment_put_ProxyAutoConfigUri(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"ProxyAutoConfigUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProxyAutoConfigUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceAssignment_get_NamespaceList(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"NamespaceList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NamespaceList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceAssignment_put_NamespaceList(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"NamespaceList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>>(arg);

            self->obj.NamespaceList(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnNamespaceAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnNamespaceAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNamespaceAssignment[] = {
        { "_assign_array_", _assign_array_VpnNamespaceAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnNamespaceAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnNamespaceAssignment[] = {
        { "proxy_auto_config_uri", reinterpret_cast<getter>(VpnNamespaceAssignment_get_ProxyAutoConfigUri), reinterpret_cast<setter>(VpnNamespaceAssignment_put_ProxyAutoConfigUri), nullptr, nullptr },
        { "namespace_list", reinterpret_cast<getter>(VpnNamespaceAssignment_get_NamespaceList), reinterpret_cast<setter>(VpnNamespaceAssignment_put_NamespaceList), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnNamespaceAssignment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnNamespaceAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnNamespaceAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnNamespaceAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnNamespaceAssignment) },
        { },
    };

    static PyType_Spec type_spec_VpnNamespaceAssignment =
    {
        "winrt._winrt_windows_networking_vpn.VpnNamespaceAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNamespaceAssignment
    };

    // ----- VpnNamespaceInfo class --------------------

    static PyObject* _new_VpnNamespaceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 2);

                winrt::Windows::Networking::Vpn::VpnNamespaceInfo instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNamespaceInfo(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnNamespaceInfo_get_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"WebProxyServers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebProxyServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"WebProxyServers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(arg);

            self->obj.WebProxyServers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceInfo_get_Namespace(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"Namespace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Namespace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_Namespace(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"Namespace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Namespace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceInfo_get_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"DnsServers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DnsServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"DnsServers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(arg);

            self->obj.DnsServers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnNamespaceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnNamespaceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNamespaceInfo[] = {
        { "_assign_array_", _assign_array_VpnNamespaceInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnNamespaceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnNamespaceInfo[] = {
        { "web_proxy_servers", reinterpret_cast<getter>(VpnNamespaceInfo_get_WebProxyServers), reinterpret_cast<setter>(VpnNamespaceInfo_put_WebProxyServers), nullptr, nullptr },
        { "namespace", reinterpret_cast<getter>(VpnNamespaceInfo_get_Namespace), reinterpret_cast<setter>(VpnNamespaceInfo_put_Namespace), nullptr, nullptr },
        { "dns_servers", reinterpret_cast<getter>(VpnNamespaceInfo_get_DnsServers), reinterpret_cast<setter>(VpnNamespaceInfo_put_DnsServers), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnNamespaceInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnNamespaceInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnNamespaceInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnNamespaceInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnNamespaceInfo) },
        { },
    };

    static PyType_Spec type_spec_VpnNamespaceInfo =
    {
        "winrt._winrt_windows_networking_vpn.VpnNamespaceInfo",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNamespaceInfo
    };

    // ----- VpnNativeProfile class --------------------

    static PyObject* _new_VpnNativeProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnNativeProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNativeProfile(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnNativeProfile_get_UserAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"UserAuthenticationMethod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserAuthenticationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_UserAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"UserAuthenticationMethod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAuthenticationMethod>(arg);

            self->obj.UserAuthenticationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_TunnelAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"TunnelAuthenticationMethod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TunnelAuthenticationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_TunnelAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"TunnelAuthenticationMethod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAuthenticationMethod>(arg);

            self->obj.TunnelAuthenticationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RoutingPolicyType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoutingPolicyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RoutingPolicyType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRoutingPolicyType>(arg);

            self->obj.RoutingPolicyType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_EapConfiguration(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"EapConfiguration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EapConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_EapConfiguration(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"EapConfiguration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EapConfiguration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_NativeProtocolType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"NativeProtocolType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NativeProtocolType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_NativeProtocolType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"NativeProtocolType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnNativeProtocolType>(arg);

            self->obj.NativeProtocolType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_Servers(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"Servers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Servers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RequireVpnClientAppUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequireVpnClientAppUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RequireVpnClientAppUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireVpnClientAppUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_ConnectionStatus(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"ConnectionStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RememberCredentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RememberCredentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"AlwaysOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"AlwaysOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"Routes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"AppTriggers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"TrafficFilters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"DomainNameInfoList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnNativeProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnNativeProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnNativeProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNativeProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNativeProfile[] = {
        { "_assign_array_", _assign_array_VpnNativeProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnNativeProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnNativeProfile[] = {
        { "user_authentication_method", reinterpret_cast<getter>(VpnNativeProfile_get_UserAuthenticationMethod), reinterpret_cast<setter>(VpnNativeProfile_put_UserAuthenticationMethod), nullptr, nullptr },
        { "tunnel_authentication_method", reinterpret_cast<getter>(VpnNativeProfile_get_TunnelAuthenticationMethod), reinterpret_cast<setter>(VpnNativeProfile_put_TunnelAuthenticationMethod), nullptr, nullptr },
        { "routing_policy_type", reinterpret_cast<getter>(VpnNativeProfile_get_RoutingPolicyType), reinterpret_cast<setter>(VpnNativeProfile_put_RoutingPolicyType), nullptr, nullptr },
        { "eap_configuration", reinterpret_cast<getter>(VpnNativeProfile_get_EapConfiguration), reinterpret_cast<setter>(VpnNativeProfile_put_EapConfiguration), nullptr, nullptr },
        { "native_protocol_type", reinterpret_cast<getter>(VpnNativeProfile_get_NativeProtocolType), reinterpret_cast<setter>(VpnNativeProfile_put_NativeProtocolType), nullptr, nullptr },
        { "servers", reinterpret_cast<getter>(VpnNativeProfile_get_Servers), nullptr, nullptr, nullptr },
        { "require_vpn_client_app_u_i", reinterpret_cast<getter>(VpnNativeProfile_get_RequireVpnClientAppUI), reinterpret_cast<setter>(VpnNativeProfile_put_RequireVpnClientAppUI), nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(VpnNativeProfile_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(VpnNativeProfile_get_ProfileName), reinterpret_cast<setter>(VpnNativeProfile_put_ProfileName), nullptr, nullptr },
        { "remember_credentials", reinterpret_cast<getter>(VpnNativeProfile_get_RememberCredentials), reinterpret_cast<setter>(VpnNativeProfile_put_RememberCredentials), nullptr, nullptr },
        { "always_on", reinterpret_cast<getter>(VpnNativeProfile_get_AlwaysOn), reinterpret_cast<setter>(VpnNativeProfile_put_AlwaysOn), nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(VpnNativeProfile_get_Routes), nullptr, nullptr, nullptr },
        { "app_triggers", reinterpret_cast<getter>(VpnNativeProfile_get_AppTriggers), nullptr, nullptr, nullptr },
        { "traffic_filters", reinterpret_cast<getter>(VpnNativeProfile_get_TrafficFilters), nullptr, nullptr, nullptr },
        { "domain_name_info_list", reinterpret_cast<getter>(VpnNativeProfile_get_DomainNameInfoList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnNativeProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnNativeProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnNativeProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnNativeProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnNativeProfile) },
        { },
    };

    static PyType_Spec type_spec_VpnNativeProfile =
    {
        "winrt._winrt_windows_networking_vpn.VpnNativeProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNativeProfile
    };

    // ----- VpnPacketBuffer class --------------------

    static PyObject* _new_VpnPacketBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Networking::Vpn::VpnPacketBuffer instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPacketBuffer_get_TransportAffinity(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportAffinity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportAffinity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_TransportAffinity(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportAffinity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TransportAffinity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBuffer_get_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBuffer_get_Buffer(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"Buffer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPacketBuffer_get_AppId(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPacketBuffer_get_TransportContext(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_TransportContext(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.TransportContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnPacketBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPacketBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPacketBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPacketBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPacketBuffer[] = {
        { "_assign_array_", _assign_array_VpnPacketBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPacketBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPacketBuffer[] = {
        { "transport_affinity", reinterpret_cast<getter>(VpnPacketBuffer_get_TransportAffinity), reinterpret_cast<setter>(VpnPacketBuffer_put_TransportAffinity), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(VpnPacketBuffer_get_Status), reinterpret_cast<setter>(VpnPacketBuffer_put_Status), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(VpnPacketBuffer_get_Buffer), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(VpnPacketBuffer_get_AppId), nullptr, nullptr, nullptr },
        { "transport_context", reinterpret_cast<getter>(VpnPacketBuffer_get_TransportContext), reinterpret_cast<setter>(VpnPacketBuffer_put_TransportContext), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPacketBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPacketBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPacketBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPacketBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPacketBuffer) },
        { },
    };

    static PyType_Spec type_spec_VpnPacketBuffer =
    {
        "winrt._winrt_windows_networking_vpn.VpnPacketBuffer",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPacketBuffer
    };

    // ----- VpnPacketBufferList class --------------------

    static PyObject* _new_VpnPacketBufferList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnPacketBufferList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnPacketBufferList>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnPacketBufferList(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPacketBufferList_AddAtBegin(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"AddAtBegin", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AddAtBegin(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_Append(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_Clear(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_First(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_RemoveAtBegin(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"RemoveAtBegin", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RemoveAtBegin());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_RemoveAtEnd(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RemoveAtEnd());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_get_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBufferList_put_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBufferList_get_Size(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnPacketBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPacketBufferList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPacketBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPacketBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_VpnPacketBufferList(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPacketBufferList[] = {
        { "add_at_begin", reinterpret_cast<PyCFunction>(VpnPacketBufferList_AddAtBegin), METH_VARARGS, nullptr },
        { "append", reinterpret_cast<PyCFunction>(VpnPacketBufferList_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(VpnPacketBufferList_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(VpnPacketBufferList_First), METH_VARARGS, nullptr },
        { "remove_at_begin", reinterpret_cast<PyCFunction>(VpnPacketBufferList_RemoveAtBegin), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(VpnPacketBufferList_RemoveAtEnd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnPacketBufferList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPacketBufferList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPacketBufferList[] = {
        { "status", reinterpret_cast<getter>(VpnPacketBufferList_get_Status), reinterpret_cast<setter>(VpnPacketBufferList_put_Status), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(VpnPacketBufferList_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPacketBufferList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPacketBufferList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPacketBufferList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPacketBufferList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPacketBufferList) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_VpnPacketBufferList) },
        { },
    };

    static PyType_Spec type_spec_VpnPacketBufferList =
    {
        "winrt._winrt_windows_networking_vpn.VpnPacketBufferList",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPacketBufferList
    };

    // ----- VpnPickedCredential class --------------------

    static PyObject* _new_VpnPickedCredential(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnPickedCredential>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnPickedCredential>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnPickedCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPickedCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPickedCredential", L"AdditionalPin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPickedCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPickedCredential", L"OldPasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPickedCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPickedCredential", L"PasskeyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnPickedCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPickedCredential>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPickedCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPickedCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPickedCredential[] = {
        { "_assign_array_", _assign_array_VpnPickedCredential, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPickedCredential), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPickedCredential[] = {
        { "additional_pin", reinterpret_cast<getter>(VpnPickedCredential_get_AdditionalPin), nullptr, nullptr, nullptr },
        { "old_password_credential", reinterpret_cast<getter>(VpnPickedCredential_get_OldPasswordCredential), nullptr, nullptr, nullptr },
        { "passkey_credential", reinterpret_cast<getter>(VpnPickedCredential_get_PasskeyCredential), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPickedCredential[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPickedCredential) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPickedCredential) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPickedCredential) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPickedCredential) },
        { },
    };

    static PyType_Spec type_spec_VpnPickedCredential =
    {
        "winrt._winrt_windows_networking_vpn.VpnPickedCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPickedCredential
    };

    // ----- VpnPlugInProfile class --------------------

    static PyObject* _new_VpnPlugInProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnPlugInProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnPlugInProfile(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPlugInProfile_get_VpnPluginPackageFamilyName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"VpnPluginPackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VpnPluginPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_VpnPluginPackageFamilyName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"VpnPluginPackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VpnPluginPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_CustomConfiguration(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"CustomConfiguration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_CustomConfiguration(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"CustomConfiguration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CustomConfiguration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_ServerUris(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ServerUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RequireVpnClientAppUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequireVpnClientAppUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RequireVpnClientAppUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireVpnClientAppUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_ConnectionStatus(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ConnectionStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RememberCredentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RememberCredentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"AlwaysOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"AlwaysOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"AppTriggers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"DomainNameInfoList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"Routes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"TrafficFilters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnPlugInProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPlugInProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPlugInProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPlugInProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPlugInProfile[] = {
        { "_assign_array_", _assign_array_VpnPlugInProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPlugInProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPlugInProfile[] = {
        { "vpn_plugin_package_family_name", reinterpret_cast<getter>(VpnPlugInProfile_get_VpnPluginPackageFamilyName), reinterpret_cast<setter>(VpnPlugInProfile_put_VpnPluginPackageFamilyName), nullptr, nullptr },
        { "custom_configuration", reinterpret_cast<getter>(VpnPlugInProfile_get_CustomConfiguration), reinterpret_cast<setter>(VpnPlugInProfile_put_CustomConfiguration), nullptr, nullptr },
        { "server_uris", reinterpret_cast<getter>(VpnPlugInProfile_get_ServerUris), nullptr, nullptr, nullptr },
        { "require_vpn_client_app_u_i", reinterpret_cast<getter>(VpnPlugInProfile_get_RequireVpnClientAppUI), reinterpret_cast<setter>(VpnPlugInProfile_put_RequireVpnClientAppUI), nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(VpnPlugInProfile_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(VpnPlugInProfile_get_ProfileName), reinterpret_cast<setter>(VpnPlugInProfile_put_ProfileName), nullptr, nullptr },
        { "remember_credentials", reinterpret_cast<getter>(VpnPlugInProfile_get_RememberCredentials), reinterpret_cast<setter>(VpnPlugInProfile_put_RememberCredentials), nullptr, nullptr },
        { "always_on", reinterpret_cast<getter>(VpnPlugInProfile_get_AlwaysOn), reinterpret_cast<setter>(VpnPlugInProfile_put_AlwaysOn), nullptr, nullptr },
        { "app_triggers", reinterpret_cast<getter>(VpnPlugInProfile_get_AppTriggers), nullptr, nullptr, nullptr },
        { "domain_name_info_list", reinterpret_cast<getter>(VpnPlugInProfile_get_DomainNameInfoList), nullptr, nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(VpnPlugInProfile_get_Routes), nullptr, nullptr, nullptr },
        { "traffic_filters", reinterpret_cast<getter>(VpnPlugInProfile_get_TrafficFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPlugInProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPlugInProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPlugInProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPlugInProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPlugInProfile) },
        { },
    };

    static PyType_Spec type_spec_VpnPlugInProfile =
    {
        "winrt._winrt_windows_networking_vpn.VpnPlugInProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPlugInProfile
    };

    // ----- VpnRoute class --------------------

    static PyObject* _new_VpnRoute(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Networking::Vpn::VpnRoute instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnRoute(py::wrapper::Windows::Networking::Vpn::VpnRoute* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnRoute_get_PrefixSize(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"PrefixSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrefixSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRoute_put_PrefixSize(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"PrefixSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PrefixSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRoute_get_Address(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRoute_put_Address(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnRoute(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnRoute>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnRoute(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnRoute>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnRoute[] = {
        { "_assign_array_", _assign_array_VpnRoute, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnRoute), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnRoute[] = {
        { "prefix_size", reinterpret_cast<getter>(VpnRoute_get_PrefixSize), reinterpret_cast<setter>(VpnRoute_put_PrefixSize), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(VpnRoute_get_Address), reinterpret_cast<setter>(VpnRoute_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnRoute[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnRoute) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnRoute) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnRoute) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnRoute) },
        { },
    };

    static PyType_Spec type_spec_VpnRoute =
    {
        "winrt._winrt_windows_networking_vpn.VpnRoute",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnRoute),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnRoute
    };

    // ----- VpnRouteAssignment class --------------------

    static PyObject* _new_VpnRouteAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnRouteAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnRouteAssignment(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnRouteAssignment_get_Ipv6InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6InclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv6InclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv6InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6InclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv6InclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv6ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6ExclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv6ExclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv6ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6ExclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv6ExclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv4InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4InclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv4InclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv4InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4InclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv4InclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv4ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4ExclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv4ExclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv4ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4ExclusionRoutes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv4ExclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_ExcludeLocalSubnets(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"ExcludeLocalSubnets"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExcludeLocalSubnets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_ExcludeLocalSubnets(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"ExcludeLocalSubnets"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExcludeLocalSubnets(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnRouteAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnRouteAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnRouteAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnRouteAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnRouteAssignment[] = {
        { "_assign_array_", _assign_array_VpnRouteAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnRouteAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnRouteAssignment[] = {
        { "ipv6_inclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv6InclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv6InclusionRoutes), nullptr, nullptr },
        { "ipv6_exclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv6ExclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv6ExclusionRoutes), nullptr, nullptr },
        { "ipv4_inclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv4InclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv4InclusionRoutes), nullptr, nullptr },
        { "ipv4_exclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv4ExclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv4ExclusionRoutes), nullptr, nullptr },
        { "exclude_local_subnets", reinterpret_cast<getter>(VpnRouteAssignment_get_ExcludeLocalSubnets), reinterpret_cast<setter>(VpnRouteAssignment_put_ExcludeLocalSubnets), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnRouteAssignment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnRouteAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnRouteAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnRouteAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnRouteAssignment) },
        { },
    };

    static PyType_Spec type_spec_VpnRouteAssignment =
    {
        "winrt._winrt_windows_networking_vpn.VpnRouteAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnRouteAssignment
    };

    // ----- VpnSystemHealth class --------------------

    static PyObject* _new_VpnSystemHealth(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnSystemHealth>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnSystemHealth>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnSystemHealth(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnSystemHealth_get_StatementOfHealth(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnSystemHealth", L"StatementOfHealth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatementOfHealth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnSystemHealth(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnSystemHealth>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnSystemHealth(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnSystemHealth>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnSystemHealth[] = {
        { "_assign_array_", _assign_array_VpnSystemHealth, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnSystemHealth), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnSystemHealth[] = {
        { "statement_of_health", reinterpret_cast<getter>(VpnSystemHealth_get_StatementOfHealth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnSystemHealth[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnSystemHealth) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnSystemHealth) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnSystemHealth) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnSystemHealth) },
        { },
    };

    static PyType_Spec type_spec_VpnSystemHealth =
    {
        "winrt._winrt_windows_networking_vpn.VpnSystemHealth",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnSystemHealth
    };

    // ----- VpnTrafficFilter class --------------------

    static PyObject* _new_VpnTrafficFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppId>(args, 0);

                winrt::Windows::Networking::Vpn::VpnTrafficFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnTrafficFilter(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnTrafficFilter_get_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RoutingPolicyType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoutingPolicyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RoutingPolicyType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRoutingPolicyType>(arg);

            self->obj.RoutingPolicyType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_Protocol(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"Protocol"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_Protocol(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"Protocol"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnIPProtocol>(arg);

            self->obj.Protocol(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_AppId(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_AppId(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppId>(arg);

            self->obj.AppId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_AppClaims(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"AppClaims"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppClaims());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_LocalAddressRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"LocalAddressRanges"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddressRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_LocalPortRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"LocalPortRanges"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPortRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_RemoteAddressRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RemoteAddressRanges"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteAddressRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_RemotePortRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RemotePortRanges"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemotePortRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnTrafficFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnTrafficFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnTrafficFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnTrafficFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnTrafficFilter[] = {
        { "_assign_array_", _assign_array_VpnTrafficFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnTrafficFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnTrafficFilter[] = {
        { "routing_policy_type", reinterpret_cast<getter>(VpnTrafficFilter_get_RoutingPolicyType), reinterpret_cast<setter>(VpnTrafficFilter_put_RoutingPolicyType), nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(VpnTrafficFilter_get_Protocol), reinterpret_cast<setter>(VpnTrafficFilter_put_Protocol), nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(VpnTrafficFilter_get_AppId), reinterpret_cast<setter>(VpnTrafficFilter_put_AppId), nullptr, nullptr },
        { "app_claims", reinterpret_cast<getter>(VpnTrafficFilter_get_AppClaims), nullptr, nullptr, nullptr },
        { "local_address_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_LocalAddressRanges), nullptr, nullptr, nullptr },
        { "local_port_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_LocalPortRanges), nullptr, nullptr, nullptr },
        { "remote_address_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_RemoteAddressRanges), nullptr, nullptr, nullptr },
        { "remote_port_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_RemotePortRanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnTrafficFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnTrafficFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnTrafficFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnTrafficFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnTrafficFilter) },
        { },
    };

    static PyType_Spec type_spec_VpnTrafficFilter =
    {
        "winrt._winrt_windows_networking_vpn.VpnTrafficFilter",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnTrafficFilter
    };

    // ----- VpnTrafficFilterAssignment class --------------------

    static PyObject* _new_VpnTrafficFilterAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnTrafficFilterAssignment(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnTrafficFilterAssignment_get_AllowOutbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowOutbound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowOutbound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilterAssignment_put_AllowOutbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowOutbound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowOutbound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilterAssignment_get_AllowInbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowInbound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowInbound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilterAssignment_put_AllowInbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowInbound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowInbound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilterAssignment_get_TrafficFilterList(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"TrafficFilterList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilterList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnTrafficFilterAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnTrafficFilterAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnTrafficFilterAssignment[] = {
        { "_assign_array_", _assign_array_VpnTrafficFilterAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnTrafficFilterAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnTrafficFilterAssignment[] = {
        { "allow_outbound", reinterpret_cast<getter>(VpnTrafficFilterAssignment_get_AllowOutbound), reinterpret_cast<setter>(VpnTrafficFilterAssignment_put_AllowOutbound), nullptr, nullptr },
        { "allow_inbound", reinterpret_cast<getter>(VpnTrafficFilterAssignment_get_AllowInbound), reinterpret_cast<setter>(VpnTrafficFilterAssignment_put_AllowInbound), nullptr, nullptr },
        { "traffic_filter_list", reinterpret_cast<getter>(VpnTrafficFilterAssignment_get_TrafficFilterList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnTrafficFilterAssignment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnTrafficFilterAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnTrafficFilterAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnTrafficFilterAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnTrafficFilterAssignment) },
        { },
    };

    static PyType_Spec type_spec_VpnTrafficFilterAssignment =
    {
        "winrt._winrt_windows_networking_vpn.VpnTrafficFilterAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnTrafficFilterAssignment
    };

    // ----- IVpnChannelStatics interface --------------------

    static PyObject* _new_IVpnChannelStatics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnChannelStatics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnChannelStatics>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnChannelStatics(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnChannelStatics_ProcessEventAsync(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnChannelStatics", L"ProcessEventAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ProcessEventAsync(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnChannelStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnChannelStatics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnChannelStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnChannelStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnChannelStatics[] = {
        { "process_event_async", reinterpret_cast<PyCFunction>(IVpnChannelStatics_ProcessEventAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnChannelStatics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnChannelStatics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnChannelStatics[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnChannelStatics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnChannelStatics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnChannelStatics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnChannelStatics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnChannelStatics) },
        { },
    };

    static PyType_Spec type_spec_IVpnChannelStatics =
    {
        "winrt._winrt_windows_networking_vpn.IVpnChannelStatics",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnChannelStatics
    };

    // ----- IVpnCredential interface --------------------

    static PyObject* _new_IVpnCredential(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnCredential>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnCredential>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"AdditionalPin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_CertificateCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"CertificateCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CertificateCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"OldPasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"PasskeyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnCredential>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCredential[] = {
        { "_assign_array_", _assign_array_IVpnCredential, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnCredential), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnCredential[] = {
        { "additional_pin", reinterpret_cast<getter>(IVpnCredential_get_AdditionalPin), nullptr, nullptr, nullptr },
        { "certificate_credential", reinterpret_cast<getter>(IVpnCredential_get_CertificateCredential), nullptr, nullptr, nullptr },
        { "old_password_credential", reinterpret_cast<getter>(IVpnCredential_get_OldPasswordCredential), nullptr, nullptr, nullptr },
        { "passkey_credential", reinterpret_cast<getter>(IVpnCredential_get_PasskeyCredential), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnCredential[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnCredential) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnCredential) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnCredential) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnCredential) },
        { },
    };

    static PyType_Spec type_spec_IVpnCredential =
    {
        "winrt._winrt_windows_networking_vpn.IVpnCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCredential
    };

    // ----- IVpnCustomPrompt interface --------------------

    static PyObject* _new_IVpnCustomPrompt(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnCustomPrompt(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnCustomPrompt_get_Bordered(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Bordered(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Bordered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPrompt_get_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPrompt_get_Label(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Label(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IVpnCustomPrompt(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnCustomPrompt(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCustomPrompt[] = {
        { "_assign_array_", _assign_array_IVpnCustomPrompt, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnCustomPrompt), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnCustomPrompt[] = {
        { "bordered", reinterpret_cast<getter>(IVpnCustomPrompt_get_Bordered), reinterpret_cast<setter>(IVpnCustomPrompt_put_Bordered), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(IVpnCustomPrompt_get_Compulsory), reinterpret_cast<setter>(IVpnCustomPrompt_put_Compulsory), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IVpnCustomPrompt_get_Label), reinterpret_cast<setter>(IVpnCustomPrompt_put_Label), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnCustomPrompt[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnCustomPrompt) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnCustomPrompt) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnCustomPrompt) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnCustomPrompt) },
        { },
    };

    static PyType_Spec type_spec_IVpnCustomPrompt =
    {
        "winrt._winrt_windows_networking_vpn.IVpnCustomPrompt",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCustomPrompt
    };

    // ----- IVpnCustomPromptElement interface --------------------

    static PyObject* _new_IVpnCustomPromptElement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnCustomPromptElement(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnCustomPromptElement_get_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Compulsory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPromptElement_get_DisplayName(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_DisplayName(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPromptElement_get_Emphasized(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_Emphasized(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Emphasized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IVpnCustomPromptElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnCustomPromptElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCustomPromptElement[] = {
        { "_assign_array_", _assign_array_IVpnCustomPromptElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnCustomPromptElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnCustomPromptElement[] = {
        { "compulsory", reinterpret_cast<getter>(IVpnCustomPromptElement_get_Compulsory), reinterpret_cast<setter>(IVpnCustomPromptElement_put_Compulsory), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IVpnCustomPromptElement_get_DisplayName), reinterpret_cast<setter>(IVpnCustomPromptElement_put_DisplayName), nullptr, nullptr },
        { "emphasized", reinterpret_cast<getter>(IVpnCustomPromptElement_get_Emphasized), reinterpret_cast<setter>(IVpnCustomPromptElement_put_Emphasized), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnCustomPromptElement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnCustomPromptElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnCustomPromptElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnCustomPromptElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnCustomPromptElement) },
        { },
    };

    static PyType_Spec type_spec_IVpnCustomPromptElement =
    {
        "winrt._winrt_windows_networking_vpn.IVpnCustomPromptElement",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCustomPromptElement
    };

    // ----- IVpnDomainNameInfoFactory interface --------------------

    static PyObject* _new_IVpnDomainNameInfoFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnDomainNameInfoFactory(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnDomainNameInfoFactory_CreateVpnDomainNameInfo(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnDomainNameInfoFactory", L"CreateVpnDomainNameInfo", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 3);

                return py::convert(self->obj.CreateVpnDomainNameInfo(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnDomainNameInfoFactory[] = {
        { "create_vpn_domain_name_info", reinterpret_cast<PyCFunction>(IVpnDomainNameInfoFactory_CreateVpnDomainNameInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnDomainNameInfoFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnDomainNameInfoFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnDomainNameInfoFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnDomainNameInfoFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnDomainNameInfoFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnDomainNameInfoFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnDomainNameInfoFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnDomainNameInfoFactory) },
        { },
    };

    static PyType_Spec type_spec_IVpnDomainNameInfoFactory =
    {
        "winrt._winrt_windows_networking_vpn.IVpnDomainNameInfoFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnDomainNameInfoFactory
    };

    // ----- IVpnInterfaceIdFactory interface --------------------

    static PyObject* _new_IVpnInterfaceIdFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnInterfaceIdFactory(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnInterfaceIdFactory_CreateVpnInterfaceId(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnInterfaceIdFactory", L"CreateVpnInterfaceId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.CreateVpnInterfaceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnInterfaceIdFactory[] = {
        { "create_vpn_interface_id", reinterpret_cast<PyCFunction>(IVpnInterfaceIdFactory_CreateVpnInterfaceId), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnInterfaceIdFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnInterfaceIdFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnInterfaceIdFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnInterfaceIdFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnInterfaceIdFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnInterfaceIdFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnInterfaceIdFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnInterfaceIdFactory) },
        { },
    };

    static PyType_Spec type_spec_IVpnInterfaceIdFactory =
    {
        "winrt._winrt_windows_networking_vpn.IVpnInterfaceIdFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnInterfaceIdFactory
    };

    // ----- IVpnNamespaceInfoFactory interface --------------------

    static PyObject* _new_IVpnNamespaceInfoFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnNamespaceInfoFactory(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnNamespaceInfoFactory_CreateVpnNamespaceInfo(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnNamespaceInfoFactory", L"CreateVpnNamespaceInfo", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 2);

                return py::convert(self->obj.CreateVpnNamespaceInfo(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnNamespaceInfoFactory[] = {
        { "create_vpn_namespace_info", reinterpret_cast<PyCFunction>(IVpnNamespaceInfoFactory_CreateVpnNamespaceInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnNamespaceInfoFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnNamespaceInfoFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnNamespaceInfoFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnNamespaceInfoFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnNamespaceInfoFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnNamespaceInfoFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnNamespaceInfoFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnNamespaceInfoFactory) },
        { },
    };

    static PyType_Spec type_spec_IVpnNamespaceInfoFactory =
    {
        "winrt._winrt_windows_networking_vpn.IVpnNamespaceInfoFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnNamespaceInfoFactory
    };

    // ----- IVpnPacketBufferFactory interface --------------------

    static PyObject* _new_IVpnPacketBufferFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnPacketBufferFactory(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnPacketBufferFactory_CreateVpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPacketBufferFactory", L"CreateVpnPacketBuffer", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.CreateVpnPacketBuffer(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPacketBufferFactory[] = {
        { "create_vpn_packet_buffer", reinterpret_cast<PyCFunction>(IVpnPacketBufferFactory_CreateVpnPacketBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnPacketBufferFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnPacketBufferFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnPacketBufferFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnPacketBufferFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnPacketBufferFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnPacketBufferFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnPacketBufferFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnPacketBufferFactory) },
        { },
    };

    static PyType_Spec type_spec_IVpnPacketBufferFactory =
    {
        "winrt._winrt_windows_networking_vpn.IVpnPacketBufferFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPacketBufferFactory
    };

    // ----- IVpnPlugIn interface --------------------

    static PyObject* _new_IVpnPlugIn(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnPlugIn>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnPlugIn>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnPlugIn(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnPlugIn_Connect(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Connect", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);

                self->obj.Connect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Decapsulate(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Decapsulate", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 3);

                self->obj.Decapsulate(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Disconnect(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Disconnect", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);

                self->obj.Disconnect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Encapsulate(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Encapsulate", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 2);

                self->obj.Encapsulate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_GetKeepAlivePayload(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"GetKeepAlivePayload", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                winrt::Windows::Networking::Vpn::VpnPacketBuffer param1 { nullptr };

                self->obj.GetKeepAlivePayload(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnPlugIn>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPlugIn>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPlugIn[] = {
        { "connect", reinterpret_cast<PyCFunction>(IVpnPlugIn_Connect), METH_VARARGS, nullptr },
        { "decapsulate", reinterpret_cast<PyCFunction>(IVpnPlugIn_Decapsulate), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(IVpnPlugIn_Disconnect), METH_VARARGS, nullptr },
        { "encapsulate", reinterpret_cast<PyCFunction>(IVpnPlugIn_Encapsulate), METH_VARARGS, nullptr },
        { "get_keep_alive_payload", reinterpret_cast<PyCFunction>(IVpnPlugIn_GetKeepAlivePayload), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnPlugIn, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnPlugIn), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnPlugIn[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnPlugIn[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnPlugIn) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnPlugIn) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnPlugIn) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnPlugIn) },
        { },
    };

    static PyType_Spec type_spec_IVpnPlugIn =
    {
        "winrt._winrt_windows_networking_vpn.IVpnPlugIn",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPlugIn
    };

    // ----- IVpnProfile interface --------------------

    static PyObject* _new_IVpnProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnProfile(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"AlwaysOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"AlwaysOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"AppTriggers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"DomainNameInfoList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"ProfileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"RememberCredentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"RememberCredentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"Routes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"TrafficFilters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnProfile[] = {
        { "_assign_array_", _assign_array_IVpnProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnProfile[] = {
        { "always_on", reinterpret_cast<getter>(IVpnProfile_get_AlwaysOn), reinterpret_cast<setter>(IVpnProfile_put_AlwaysOn), nullptr, nullptr },
        { "app_triggers", reinterpret_cast<getter>(IVpnProfile_get_AppTriggers), nullptr, nullptr, nullptr },
        { "domain_name_info_list", reinterpret_cast<getter>(IVpnProfile_get_DomainNameInfoList), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(IVpnProfile_get_ProfileName), reinterpret_cast<setter>(IVpnProfile_put_ProfileName), nullptr, nullptr },
        { "remember_credentials", reinterpret_cast<getter>(IVpnProfile_get_RememberCredentials), reinterpret_cast<setter>(IVpnProfile_put_RememberCredentials), nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(IVpnProfile_get_Routes), nullptr, nullptr, nullptr },
        { "traffic_filters", reinterpret_cast<getter>(IVpnProfile_get_TrafficFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnProfile) },
        { },
    };

    static PyType_Spec type_spec_IVpnProfile =
    {
        "winrt._winrt_windows_networking_vpn.IVpnProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnProfile
    };

    // ----- IVpnRouteFactory interface --------------------

    static PyObject* _new_IVpnRouteFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnRouteFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnRouteFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnRouteFactory(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnRouteFactory_CreateVpnRoute(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnRouteFactory", L"CreateVpnRoute", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                return py::convert(self->obj.CreateVpnRoute(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnRouteFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnRouteFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnRouteFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnRouteFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnRouteFactory[] = {
        { "create_vpn_route", reinterpret_cast<PyCFunction>(IVpnRouteFactory_CreateVpnRoute), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnRouteFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnRouteFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnRouteFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnRouteFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnRouteFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnRouteFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnRouteFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnRouteFactory) },
        { },
    };

    static PyType_Spec type_spec_IVpnRouteFactory =
    {
        "winrt._winrt_windows_networking_vpn.IVpnRouteFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnRouteFactory
    };

    // ----- Windows.Networking.Vpn Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::Vpn");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_networking_vpn",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Networking::Vpn

PyMODINIT_FUNC PyInit__winrt_windows_networking_vpn(void) noexcept
{
    using namespace py::cpp::Windows::Networking::Vpn;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnAppId, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_VpnChannel_Static{PyType_FromSpec(&type_spec_VpnChannel_Static)};
    if (!type_VpnChannel_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnChannel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VpnChannel_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnChannelActivityEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnChannelActivityStateChangedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnChannelConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCredential, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomCheckBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomComboBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomEditBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomErrorBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomPromptBooleanInput, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomPromptOptionSelector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomPromptText, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomPromptTextInput, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnCustomTextBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnDomainNameAssignment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnDomainNameInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnForegroundActivatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnForegroundActivationOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnInterfaceId, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnManagementAgent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnNamespaceAssignment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnNamespaceInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnNativeProfile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnPacketBuffer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnPacketBufferList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnPickedCredential, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnPlugInProfile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnRoute, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnRouteAssignment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnSystemHealth, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnTrafficFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VpnTrafficFilterAssignment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnChannelStatics, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnCredential, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnCustomPrompt, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnCustomPromptElement, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnDomainNameInfoFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnInterfaceIdFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnNamespaceInfoFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnPacketBufferFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnPlugIn, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnProfile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVpnRouteFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
