// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Networking.Vpn.h"

namespace py::cpp::Windows::Networking::Vpn
{
    // ----- VpnAppId class --------------------

    static PyObject* _new_VpnAppId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppIdType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::Vpn::VpnAppId instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnAppId(py::wrapper::Windows::Networking::Vpn::VpnAppId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnAppId_get_Value(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnAppId_put_Value(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnAppId_get_Type(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnAppId_put_Type(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnAppId", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppIdType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnAppId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnAppId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnAppId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnAppId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnAppId[] = {
        { "_assign_array_", _assign_array_VpnAppId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnAppId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnAppId[] = {
        { "value", reinterpret_cast<getter>(VpnAppId_get_Value), reinterpret_cast<setter>(VpnAppId_put_Value), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(VpnAppId_get_Type), reinterpret_cast<setter>(VpnAppId_put_Type), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnAppId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnAppId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnAppId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnAppId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnAppId) },
        { }
    };

    static PyType_Spec type_spec_VpnAppId = {
        "winrt._winrt_windows_networking_vpn.VpnAppId",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnAppId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnAppId};

    // ----- VpnChannel class --------------------

    static PyObject* _new_VpnChannel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannel>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannel(py::wrapper::Windows::Networking::Vpn::VpnChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannel_ActivateForeground(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivateForeground", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 1);

                return py::convert(self->obj.ActivateForeground(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AddAndAssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AddAndAssociateTransport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AddAndAssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AppendVpnReceivePacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AppendVpnReceivePacketBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AppendVpnReceivePacketBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AppendVpnSendPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AppendVpnSendPacketBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AppendVpnSendPacketBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"AssociateTransport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_FlushVpnReceivePacketBuffers(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"FlushVpnReceivePacketBuffers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.FlushVpnReceivePacketBuffers();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_FlushVpnSendPacketBuffers(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"FlushVpnSendPacketBuffers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.FlushVpnSendPacketBuffers();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetSlotTypeForTransportContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"GetSlotTypeForTransportContext", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.GetSlotTypeForTransportContext(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetVpnReceivePacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"GetVpnReceivePacketBuffer", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVpnReceivePacketBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetVpnSendPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"GetVpnSendPacketBuffer", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVpnSendPacketBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_LogDiagnosticMessage(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"LogDiagnosticMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogDiagnosticMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_ProcessEventAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"ProcessEventAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                winrt::Windows::Networking::Vpn::VpnChannel::ProcessEventAsync(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_ReplaceAndAssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"ReplaceAndAssociateTransport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ReplaceAndAssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentials(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentials", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 3);

                return py::convert(self->obj.RequestCredentials(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentialsSimpleAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentialsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);

                return py::convert(self->obj.RequestCredentialsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentialsWithCertificateAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentialsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 2);

                return py::convert(self->obj.RequestCredentialsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentialsWithOptionsAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCredentialsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.RequestCredentialsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCustomPrompt(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCustomPrompt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>>(args, 0);

                self->obj.RequestCustomPrompt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCustomPromptAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestCustomPromptAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>>(args, 0);

                return py::convert(self->obj.RequestCustomPromptAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestVpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"RequestVpnPacketBuffer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDataPathType>(args, 0);
                winrt::Windows::Networking::Vpn::VpnPacketBuffer param1{nullptr};

                self->obj.RequestVpnPacketBuffer(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_SetAllowedSslTlsVersions(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"SetAllowedSslTlsVersions", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetAllowedSslTlsVersions(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_SetErrorMessage(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"SetErrorMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetErrorMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_Start(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"Start", 10);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(10);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 9);

                self->obj.Start(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartExistingTransports(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 8)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartExistingTransports", 8);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(8);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);

                self->obj.StartExistingTransports(param0, param1, param2, param3, param4, param5, param6, param7);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartReconnectingTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartReconnectingTransport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.StartReconnectingTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithMainTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartWithMainTransport", 9);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(9);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);

                self->obj.StartWithMainTransport(param0, param1, param2, param3, param4, param5, param6, param7, param8);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithMultipleTransports(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartWithTrafficFilter", 10);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(10);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>(args, 9);

                self->obj.StartWithTrafficFilter(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithTrafficFilter(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 11)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"StartWithTrafficFilter", 11);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(11);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 9);
                auto param10 = py::convert_to<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>(args, 10);

                self->obj.StartWithTrafficFilter(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_Stop(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_TerminateConnection(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnChannel", L"TerminateConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TerminateConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_PlugInContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"PlugInContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlugInContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnChannel_put_PlugInContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"PlugInContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.PlugInContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnChannel_get_Configuration(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_Id(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_SystemHealth(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"SystemHealth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemHealth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_CurrentRequestTransportContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannel", L"CurrentRequestTransportContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentRequestTransportContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_add_ActivityChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityChange");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Vpn::VpnChannel, winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>>(arg);

            return py::convert(self->obj.ActivityChange(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_remove_ActivityChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityChange");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActivityChange(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_add_ActivityStateChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityStateChange");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Vpn::VpnChannel, winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>>(arg);

            return py::convert(self->obj.ActivityStateChange(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_remove_ActivityStateChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Vpn.VpnChannel", L"ActivityStateChange");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActivityStateChange(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannel[] = {
        { "activate_foreground", reinterpret_cast<PyCFunction>(VpnChannel_ActivateForeground), METH_VARARGS, nullptr },
        { "add_and_associate_transport", reinterpret_cast<PyCFunction>(VpnChannel_AddAndAssociateTransport), METH_VARARGS, nullptr },
        { "append_vpn_receive_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_AppendVpnReceivePacketBuffer), METH_VARARGS, nullptr },
        { "append_vpn_send_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_AppendVpnSendPacketBuffer), METH_VARARGS, nullptr },
        { "associate_transport", reinterpret_cast<PyCFunction>(VpnChannel_AssociateTransport), METH_VARARGS, nullptr },
        { "flush_vpn_receive_packet_buffers", reinterpret_cast<PyCFunction>(VpnChannel_FlushVpnReceivePacketBuffers), METH_VARARGS, nullptr },
        { "flush_vpn_send_packet_buffers", reinterpret_cast<PyCFunction>(VpnChannel_FlushVpnSendPacketBuffers), METH_VARARGS, nullptr },
        { "get_slot_type_for_transport_context", reinterpret_cast<PyCFunction>(VpnChannel_GetSlotTypeForTransportContext), METH_VARARGS, nullptr },
        { "get_vpn_receive_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_GetVpnReceivePacketBuffer), METH_VARARGS, nullptr },
        { "get_vpn_send_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_GetVpnSendPacketBuffer), METH_VARARGS, nullptr },
        { "log_diagnostic_message", reinterpret_cast<PyCFunction>(VpnChannel_LogDiagnosticMessage), METH_VARARGS, nullptr },
        { "replace_and_associate_transport", reinterpret_cast<PyCFunction>(VpnChannel_ReplaceAndAssociateTransport), METH_VARARGS, nullptr },
        { "request_credentials", reinterpret_cast<PyCFunction>(VpnChannel_RequestCredentials), METH_VARARGS, nullptr },
        { "request_credentials_simple_async", reinterpret_cast<PyCFunction>(VpnChannel_RequestCredentialsSimpleAsync), METH_VARARGS, nullptr },
        { "request_credentials_with_certificate_async", reinterpret_cast<PyCFunction>(VpnChannel_RequestCredentialsWithCertificateAsync), METH_VARARGS, nullptr },
        { "request_credentials_with_options_async", reinterpret_cast<PyCFunction>(VpnChannel_RequestCredentialsWithOptionsAsync), METH_VARARGS, nullptr },
        { "request_custom_prompt", reinterpret_cast<PyCFunction>(VpnChannel_RequestCustomPrompt), METH_VARARGS, nullptr },
        { "request_custom_prompt_async", reinterpret_cast<PyCFunction>(VpnChannel_RequestCustomPromptAsync), METH_VARARGS, nullptr },
        { "request_vpn_packet_buffer", reinterpret_cast<PyCFunction>(VpnChannel_RequestVpnPacketBuffer), METH_VARARGS, nullptr },
        { "set_allowed_ssl_tls_versions", reinterpret_cast<PyCFunction>(VpnChannel_SetAllowedSslTlsVersions), METH_VARARGS, nullptr },
        { "set_error_message", reinterpret_cast<PyCFunction>(VpnChannel_SetErrorMessage), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(VpnChannel_Start), METH_VARARGS, nullptr },
        { "start_existing_transports", reinterpret_cast<PyCFunction>(VpnChannel_StartExistingTransports), METH_VARARGS, nullptr },
        { "start_reconnecting_transport", reinterpret_cast<PyCFunction>(VpnChannel_StartReconnectingTransport), METH_VARARGS, nullptr },
        { "start_with_main_transport", reinterpret_cast<PyCFunction>(VpnChannel_StartWithMainTransport), METH_VARARGS, nullptr },
        { "start_with_multiple_transports", reinterpret_cast<PyCFunction>(VpnChannel_StartWithMultipleTransports), METH_VARARGS, nullptr },
        { "start_with_traffic_filter", reinterpret_cast<PyCFunction>(VpnChannel_StartWithTrafficFilter), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(VpnChannel_Stop), METH_VARARGS, nullptr },
        { "terminate_connection", reinterpret_cast<PyCFunction>(VpnChannel_TerminateConnection), METH_VARARGS, nullptr },
        { "add_activity_change", reinterpret_cast<PyCFunction>(VpnChannel_add_ActivityChange), METH_O, nullptr },
        { "remove_activity_change", reinterpret_cast<PyCFunction>(VpnChannel_remove_ActivityChange), METH_O, nullptr },
        { "add_activity_state_change", reinterpret_cast<PyCFunction>(VpnChannel_add_ActivityStateChange), METH_O, nullptr },
        { "remove_activity_state_change", reinterpret_cast<PyCFunction>(VpnChannel_remove_ActivityStateChange), METH_O, nullptr },
        { "_assign_array_", _assign_array_VpnChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannel[] = {
        { "plug_in_context", reinterpret_cast<getter>(VpnChannel_get_PlugInContext), reinterpret_cast<setter>(VpnChannel_put_PlugInContext), nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(VpnChannel_get_Configuration), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VpnChannel_get_Id), nullptr, nullptr, nullptr },
        { "system_health", reinterpret_cast<getter>(VpnChannel_get_SystemHealth), nullptr, nullptr, nullptr },
        { "current_request_transport_context", reinterpret_cast<getter>(VpnChannel_get_CurrentRequestTransportContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannel) },
        { }
    };

    static PyType_Spec type_spec_VpnChannel = {
        "winrt._winrt_windows_networking_vpn.VpnChannel",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannel};

    static PyGetSetDef getset_VpnChannel_Static[] = {
        { }
    };

    static PyMethodDef methods_VpnChannel_Static[] = {
        { "process_event_async", reinterpret_cast<PyCFunction>(VpnChannel_ProcessEventAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VpnChannel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VpnChannel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VpnChannel_Static) },
        { }
    };

    static PyType_Spec type_spec_VpnChannel_Static =
    {
        "winrt._winrt_windows_networking_vpn.VpnChannel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VpnChannel_Static
    };

    // ----- VpnChannelActivityEventArgs class --------------------

    static PyObject* _new_VpnChannelActivityEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannelActivityEventArgs(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannelActivityEventArgs_get_Type(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelActivityEventArgs", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannelActivityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannelActivityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelActivityEventArgs[] = {
        { "_assign_array_", _assign_array_VpnChannelActivityEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannelActivityEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannelActivityEventArgs[] = {
        { "type", reinterpret_cast<getter>(VpnChannelActivityEventArgs_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannelActivityEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannelActivityEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannelActivityEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannelActivityEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannelActivityEventArgs) },
        { }
    };

    static PyType_Spec type_spec_VpnChannelActivityEventArgs = {
        "winrt._winrt_windows_networking_vpn.VpnChannelActivityEventArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelActivityEventArgs};

    // ----- VpnChannelActivityStateChangedArgs class --------------------

    static PyObject* _new_VpnChannelActivityStateChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannelActivityStateChangedArgs(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannelActivityStateChangedArgs_get_ActivityState(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelActivityStateChangedArgs", L"ActivityState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannelActivityStateChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannelActivityStateChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelActivityStateChangedArgs[] = {
        { "_assign_array_", _assign_array_VpnChannelActivityStateChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannelActivityStateChangedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannelActivityStateChangedArgs[] = {
        { "activity_state", reinterpret_cast<getter>(VpnChannelActivityStateChangedArgs_get_ActivityState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannelActivityStateChangedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannelActivityStateChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannelActivityStateChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannelActivityStateChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannelActivityStateChangedArgs) },
        { }
    };

    static PyType_Spec type_spec_VpnChannelActivityStateChangedArgs = {
        "winrt._winrt_windows_networking_vpn.VpnChannelActivityStateChangedArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelActivityStateChangedArgs};

    // ----- VpnChannelConfiguration class --------------------

    static PyObject* _new_VpnChannelConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnChannelConfiguration(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnChannelConfiguration_get_CustomField(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"CustomField");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerHostNameList(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"ServerHostNameList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerServiceName(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"ServerServiceName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerUris(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnChannelConfiguration", L"ServerUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnChannelConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnChannelConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelConfiguration[] = {
        { "_assign_array_", _assign_array_VpnChannelConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnChannelConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnChannelConfiguration[] = {
        { "custom_field", reinterpret_cast<getter>(VpnChannelConfiguration_get_CustomField), nullptr, nullptr, nullptr },
        { "server_host_name_list", reinterpret_cast<getter>(VpnChannelConfiguration_get_ServerHostNameList), nullptr, nullptr, nullptr },
        { "server_service_name", reinterpret_cast<getter>(VpnChannelConfiguration_get_ServerServiceName), nullptr, nullptr, nullptr },
        { "server_uris", reinterpret_cast<getter>(VpnChannelConfiguration_get_ServerUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnChannelConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnChannelConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnChannelConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnChannelConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnChannelConfiguration) },
        { }
    };

    static PyType_Spec type_spec_VpnChannelConfiguration = {
        "winrt._winrt_windows_networking_vpn.VpnChannelConfiguration",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelConfiguration};

    // ----- VpnCredential class --------------------

    static PyObject* _new_VpnCredential(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnCredential>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnCredential>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"AdditionalPin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_CertificateCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"CertificateCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CertificateCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"OldPasswordCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCredential", L"PasskeyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCredential>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCredential[] = {
        { "_assign_array_", _assign_array_VpnCredential, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCredential), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCredential[] = {
        { "additional_pin", reinterpret_cast<getter>(VpnCredential_get_AdditionalPin), nullptr, nullptr, nullptr },
        { "certificate_credential", reinterpret_cast<getter>(VpnCredential_get_CertificateCredential), nullptr, nullptr, nullptr },
        { "old_password_credential", reinterpret_cast<getter>(VpnCredential_get_OldPasswordCredential), nullptr, nullptr, nullptr },
        { "passkey_credential", reinterpret_cast<getter>(VpnCredential_get_PasskeyCredential), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCredential[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCredential) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCredential) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCredential) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCredential) },
        { }
    };

    static PyType_Spec type_spec_VpnCredential = {
        "winrt._winrt_windows_networking_vpn.VpnCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCredential};

    // ----- VpnCustomCheckBox class --------------------

    static PyObject* _new_VpnCustomCheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomCheckBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomCheckBox(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomCheckBox_get_InitialCheckState(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"InitialCheckState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InitialCheckState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_InitialCheckState(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"InitialCheckState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InitialCheckState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Checked(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Checked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Checked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomCheckBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomCheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomCheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomCheckBox[] = {
        { "_assign_array_", _assign_array_VpnCustomCheckBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomCheckBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomCheckBox[] = {
        { "initial_check_state", reinterpret_cast<getter>(VpnCustomCheckBox_get_InitialCheckState), reinterpret_cast<setter>(VpnCustomCheckBox_put_InitialCheckState), nullptr, nullptr },
        { "checked", reinterpret_cast<getter>(VpnCustomCheckBox_get_Checked), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VpnCustomCheckBox_get_Label), reinterpret_cast<setter>(VpnCustomCheckBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomCheckBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomCheckBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomCheckBox_get_Bordered), reinterpret_cast<setter>(VpnCustomCheckBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomCheckBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomCheckBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomCheckBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomCheckBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomCheckBox) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomCheckBox = {
        "winrt._winrt_windows_networking_vpn.VpnCustomCheckBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomCheckBox};

    // ----- VpnCustomComboBox class --------------------

    static PyObject* _new_VpnCustomComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomComboBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomComboBox(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomComboBox_get_OptionsText(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"OptionsText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionsText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_OptionsText(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"OptionsText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(arg);

            self->obj.OptionsText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Selected(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Selected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomComboBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomComboBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomComboBox[] = {
        { "_assign_array_", _assign_array_VpnCustomComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomComboBox[] = {
        { "options_text", reinterpret_cast<getter>(VpnCustomComboBox_get_OptionsText), reinterpret_cast<setter>(VpnCustomComboBox_put_OptionsText), nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(VpnCustomComboBox_get_Selected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VpnCustomComboBox_get_Label), reinterpret_cast<setter>(VpnCustomComboBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomComboBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomComboBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomComboBox_get_Bordered), reinterpret_cast<setter>(VpnCustomComboBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomComboBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomComboBox) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomComboBox = {
        "winrt._winrt_windows_networking_vpn.VpnCustomComboBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomComboBox};

    // ----- VpnCustomEditBox class --------------------

    static PyObject* _new_VpnCustomEditBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomEditBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomEditBox(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomEditBox_get_NoEcho(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"NoEcho");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NoEcho());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_NoEcho(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"NoEcho");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoEcho(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_DefaultText(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"DefaultText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_DefaultText(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"DefaultText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomEditBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomEditBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomEditBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomEditBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomEditBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomEditBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomEditBox[] = {
        { "_assign_array_", _assign_array_VpnCustomEditBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomEditBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomEditBox[] = {
        { "no_echo", reinterpret_cast<getter>(VpnCustomEditBox_get_NoEcho), reinterpret_cast<setter>(VpnCustomEditBox_put_NoEcho), nullptr, nullptr },
        { "default_text", reinterpret_cast<getter>(VpnCustomEditBox_get_DefaultText), reinterpret_cast<setter>(VpnCustomEditBox_put_DefaultText), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(VpnCustomEditBox_get_Text), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VpnCustomEditBox_get_Label), reinterpret_cast<setter>(VpnCustomEditBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomEditBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomEditBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomEditBox_get_Bordered), reinterpret_cast<setter>(VpnCustomEditBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomEditBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomEditBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomEditBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomEditBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomEditBox) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomEditBox = {
        "winrt._winrt_windows_networking_vpn.VpnCustomEditBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomEditBox};

    // ----- VpnCustomErrorBox class --------------------

    static PyObject* _new_VpnCustomErrorBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomErrorBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomErrorBox(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomErrorBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomErrorBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomErrorBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomErrorBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomErrorBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomErrorBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomErrorBox[] = {
        { "_assign_array_", _assign_array_VpnCustomErrorBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomErrorBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomErrorBox[] = {
        { "label", reinterpret_cast<getter>(VpnCustomErrorBox_get_Label), reinterpret_cast<setter>(VpnCustomErrorBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomErrorBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomErrorBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomErrorBox_get_Bordered), reinterpret_cast<setter>(VpnCustomErrorBox_put_Bordered), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomErrorBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomErrorBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomErrorBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomErrorBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomErrorBox) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomErrorBox = {
        "winrt._winrt_windows_networking_vpn.VpnCustomErrorBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomErrorBox};

    // ----- VpnCustomPromptBooleanInput class --------------------

    static PyObject* _new_VpnCustomPromptBooleanInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptBooleanInput(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptBooleanInput_get_InitialValue(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InitialValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_InitialValue(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InitialValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Value(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptBooleanInput", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptBooleanInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptBooleanInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptBooleanInput[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptBooleanInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptBooleanInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptBooleanInput[] = {
        { "initial_value", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_InitialValue), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_InitialValue), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_Value), nullptr, nullptr, nullptr },
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptBooleanInput_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptBooleanInput_put_Compulsory), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptBooleanInput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptBooleanInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptBooleanInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptBooleanInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptBooleanInput) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomPromptBooleanInput = {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptBooleanInput",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptBooleanInput};

    // ----- VpnCustomPromptOptionSelector class --------------------

    static PyObject* _new_VpnCustomPromptOptionSelector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptOptionSelector(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Options(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_SelectedIndex(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptOptionSelector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptOptionSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptOptionSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptOptionSelector[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptOptionSelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptOptionSelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptOptionSelector[] = {
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptOptionSelector_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptOptionSelector_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptOptionSelector_put_Compulsory), nullptr, nullptr },
        { "options", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_Options), nullptr, nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(VpnCustomPromptOptionSelector_get_SelectedIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptOptionSelector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptOptionSelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptOptionSelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptOptionSelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptOptionSelector) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomPromptOptionSelector = {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptOptionSelector",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptOptionSelector};

    // ----- VpnCustomPromptText class --------------------

    static PyObject* _new_VpnCustomPromptText(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptText instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptText_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptText", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptText>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptText>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptText[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptText, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptText), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptText[] = {
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptText_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptText_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptText_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptText_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptText_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptText_put_Compulsory), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(VpnCustomPromptText_get_Text), reinterpret_cast<setter>(VpnCustomPromptText_put_Text), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptText[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptText) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptText) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptText) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptText) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomPromptText = {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptText",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptText};

    // ----- VpnCustomPromptTextInput class --------------------

    static PyObject* _new_VpnCustomPromptTextInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptTextInput(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomPromptTextInput_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_PlaceholderText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_PlaceholderText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_IsTextHidden(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"IsTextHidden");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTextHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_IsTextHidden(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"IsTextHidden");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomPromptTextInput", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnCustomPromptTextInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomPromptTextInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptTextInput[] = {
        { "_assign_array_", _assign_array_VpnCustomPromptTextInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomPromptTextInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomPromptTextInput[] = {
        { "emphasized", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_Emphasized), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_Emphasized), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_DisplayName), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_DisplayName), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_Compulsory), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_Compulsory), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_PlaceholderText), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_PlaceholderText), nullptr, nullptr },
        { "is_text_hidden", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_IsTextHidden), reinterpret_cast<setter>(VpnCustomPromptTextInput_put_IsTextHidden), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(VpnCustomPromptTextInput_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomPromptTextInput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomPromptTextInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomPromptTextInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomPromptTextInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomPromptTextInput) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomPromptTextInput = {
        "winrt._winrt_windows_networking_vpn.VpnCustomPromptTextInput",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptTextInput};

    // ----- VpnCustomTextBox class --------------------

    static PyObject* _new_VpnCustomTextBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomTextBox instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomTextBox(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnCustomTextBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_DisplayText(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"DisplayText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_DisplayText(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnCustomTextBox", L"DisplayText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnCustomTextBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnCustomTextBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnCustomTextBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomTextBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomTextBox[] = {
        { "_assign_array_", _assign_array_VpnCustomTextBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnCustomTextBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnCustomTextBox[] = {
        { "label", reinterpret_cast<getter>(VpnCustomTextBox_get_Label), reinterpret_cast<setter>(VpnCustomTextBox_put_Label), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(VpnCustomTextBox_get_Compulsory), reinterpret_cast<setter>(VpnCustomTextBox_put_Compulsory), nullptr, nullptr },
        { "bordered", reinterpret_cast<getter>(VpnCustomTextBox_get_Bordered), reinterpret_cast<setter>(VpnCustomTextBox_put_Bordered), nullptr, nullptr },
        { "display_text", reinterpret_cast<getter>(VpnCustomTextBox_get_DisplayText), reinterpret_cast<setter>(VpnCustomTextBox_put_DisplayText), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnCustomTextBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnCustomTextBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnCustomTextBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnCustomTextBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnCustomTextBox) },
        { }
    };

    static PyType_Spec type_spec_VpnCustomTextBox = {
        "winrt._winrt_windows_networking_vpn.VpnCustomTextBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomTextBox};

    // ----- VpnDomainNameAssignment class --------------------

    static PyObject* _new_VpnDomainNameAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnDomainNameAssignment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnDomainNameAssignment(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnDomainNameAssignment_get_ProxyAutoConfigurationUri(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameAssignment", L"ProxyAutoConfigurationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyAutoConfigurationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameAssignment_put_ProxyAutoConfigurationUri(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameAssignment", L"ProxyAutoConfigurationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProxyAutoConfigurationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameAssignment_get_DomainNameList(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameAssignment", L"DomainNameList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnDomainNameAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnDomainNameAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnDomainNameAssignment[] = {
        { "_assign_array_", _assign_array_VpnDomainNameAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnDomainNameAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnDomainNameAssignment[] = {
        { "proxy_auto_configuration_uri", reinterpret_cast<getter>(VpnDomainNameAssignment_get_ProxyAutoConfigurationUri), reinterpret_cast<setter>(VpnDomainNameAssignment_put_ProxyAutoConfigurationUri), nullptr, nullptr },
        { "domain_name_list", reinterpret_cast<getter>(VpnDomainNameAssignment_get_DomainNameList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnDomainNameAssignment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnDomainNameAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnDomainNameAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnDomainNameAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnDomainNameAssignment) },
        { }
    };

    static PyType_Spec type_spec_VpnDomainNameAssignment = {
        "winrt._winrt_windows_networking_vpn.VpnDomainNameAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnDomainNameAssignment};

    // ----- VpnDomainNameInfo class --------------------

    static PyObject* _new_VpnDomainNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 3);

                winrt::Windows::Networking::Vpn::VpnDomainNameInfo instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnDomainNameInfo(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnDomainNameInfo_get_DomainNameType(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainNameType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameInfo_put_DomainNameType(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainNameType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(arg);

            self->obj.DomainNameType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameInfo_get_DomainName(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameInfo_put_DomainName(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DomainName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.DomainName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameInfo_get_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"DnsServers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DnsServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnDomainNameInfo_get_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"WebProxyServers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebProxyServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnDomainNameInfo_get_WebProxyUris(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnDomainNameInfo", L"WebProxyUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnDomainNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnDomainNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnDomainNameInfo[] = {
        { "_assign_array_", _assign_array_VpnDomainNameInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnDomainNameInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnDomainNameInfo[] = {
        { "domain_name_type", reinterpret_cast<getter>(VpnDomainNameInfo_get_DomainNameType), reinterpret_cast<setter>(VpnDomainNameInfo_put_DomainNameType), nullptr, nullptr },
        { "domain_name", reinterpret_cast<getter>(VpnDomainNameInfo_get_DomainName), reinterpret_cast<setter>(VpnDomainNameInfo_put_DomainName), nullptr, nullptr },
        { "dns_servers", reinterpret_cast<getter>(VpnDomainNameInfo_get_DnsServers), nullptr, nullptr, nullptr },
        { "web_proxy_servers", reinterpret_cast<getter>(VpnDomainNameInfo_get_WebProxyServers), nullptr, nullptr, nullptr },
        { "web_proxy_uris", reinterpret_cast<getter>(VpnDomainNameInfo_get_WebProxyUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnDomainNameInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnDomainNameInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnDomainNameInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnDomainNameInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnDomainNameInfo) },
        { }
    };

    static PyType_Spec type_spec_VpnDomainNameInfo = {
        "winrt._winrt_windows_networking_vpn.VpnDomainNameInfo",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnDomainNameInfo};

    // ----- VpnForegroundActivatedEventArgs class --------------------

    static PyObject* _new_VpnForegroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnForegroundActivatedEventArgs(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_Kind(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_User(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_ActivationOperation(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"ActivationOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivationOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_SharedContext(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnForegroundActivatedEventArgs", L"SharedContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnForegroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnForegroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnForegroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_VpnForegroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnForegroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnForegroundActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "activation_operation", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_ActivationOperation), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_ProfileName), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(VpnForegroundActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnForegroundActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnForegroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnForegroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnForegroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnForegroundActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_VpnForegroundActivatedEventArgs = {
        "winrt._winrt_windows_networking_vpn.VpnForegroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnForegroundActivatedEventArgs};

    // ----- VpnForegroundActivationOperation class --------------------

    static PyObject* _new_VpnForegroundActivationOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnForegroundActivationOperation(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnForegroundActivationOperation_Complete(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnForegroundActivationOperation", L"Complete", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                self->obj.Complete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnForegroundActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnForegroundActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnForegroundActivationOperation[] = {
        { "complete", reinterpret_cast<PyCFunction>(VpnForegroundActivationOperation_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnForegroundActivationOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnForegroundActivationOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnForegroundActivationOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_VpnForegroundActivationOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnForegroundActivationOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnForegroundActivationOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnForegroundActivationOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnForegroundActivationOperation) },
        { }
    };

    static PyType_Spec type_spec_VpnForegroundActivationOperation = {
        "winrt._winrt_windows_networking_vpn.VpnForegroundActivationOperation",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnForegroundActivationOperation};

    // ----- VpnInterfaceId class --------------------

    static PyObject* _new_VpnInterfaceId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Networking::Vpn::VpnInterfaceId instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnInterfaceId(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnInterfaceId_GetAddressInfo(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnInterfaceId", L"GetAddressInfo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0{};

                self->obj.GetAddressInfo(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnInterfaceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnInterfaceId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnInterfaceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnInterfaceId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnInterfaceId[] = {
        { "get_address_info", reinterpret_cast<PyCFunction>(VpnInterfaceId_GetAddressInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnInterfaceId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnInterfaceId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnInterfaceId[] = {
        { }
    };

    static PyType_Slot _type_slots_VpnInterfaceId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnInterfaceId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnInterfaceId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnInterfaceId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnInterfaceId) },
        { }
    };

    static PyType_Spec type_spec_VpnInterfaceId = {
        "winrt._winrt_windows_networking_vpn.VpnInterfaceId",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnInterfaceId};

    // ----- VpnManagementAgent class --------------------

    static PyObject* _new_VpnManagementAgent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnManagementAgent instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnManagementAgent(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnManagementAgent_AddProfileFromObjectAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"AddProfileFromObjectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.AddProfileFromObjectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_AddProfileFromXmlAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"AddProfileFromXmlAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddProfileFromXmlAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_ConnectProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"ConnectProfileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.ConnectProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_ConnectProfileWithPasswordCredentialAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"ConnectProfileWithPasswordCredentialAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 1);

                return py::convert(self->obj.ConnectProfileWithPasswordCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_DeleteProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"DeleteProfileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.DeleteProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_DisconnectProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"DisconnectProfileAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.DisconnectProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_GetProfilesAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"GetProfilesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetProfilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_UpdateProfileFromObjectAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"UpdateProfileFromObjectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.UpdateProfileFromObjectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_UpdateProfileFromXmlAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnManagementAgent", L"UpdateProfileFromXmlAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UpdateProfileFromXmlAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnManagementAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnManagementAgent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnManagementAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnManagementAgent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnManagementAgent[] = {
        { "add_profile_from_object_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_AddProfileFromObjectAsync), METH_VARARGS, nullptr },
        { "add_profile_from_xml_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_AddProfileFromXmlAsync), METH_VARARGS, nullptr },
        { "connect_profile_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_ConnectProfileAsync), METH_VARARGS, nullptr },
        { "connect_profile_with_password_credential_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_ConnectProfileWithPasswordCredentialAsync), METH_VARARGS, nullptr },
        { "delete_profile_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_DeleteProfileAsync), METH_VARARGS, nullptr },
        { "disconnect_profile_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_DisconnectProfileAsync), METH_VARARGS, nullptr },
        { "get_profiles_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_GetProfilesAsync), METH_VARARGS, nullptr },
        { "update_profile_from_object_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_UpdateProfileFromObjectAsync), METH_VARARGS, nullptr },
        { "update_profile_from_xml_async", reinterpret_cast<PyCFunction>(VpnManagementAgent_UpdateProfileFromXmlAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnManagementAgent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnManagementAgent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnManagementAgent[] = {
        { }
    };

    static PyType_Slot _type_slots_VpnManagementAgent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnManagementAgent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnManagementAgent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnManagementAgent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnManagementAgent) },
        { }
    };

    static PyType_Spec type_spec_VpnManagementAgent = {
        "winrt._winrt_windows_networking_vpn.VpnManagementAgent",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnManagementAgent};

    // ----- VpnNamespaceAssignment class --------------------

    static PyObject* _new_VpnNamespaceAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnNamespaceAssignment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNamespaceAssignment(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnNamespaceAssignment_get_ProxyAutoConfigUri(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"ProxyAutoConfigUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyAutoConfigUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceAssignment_put_ProxyAutoConfigUri(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"ProxyAutoConfigUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProxyAutoConfigUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceAssignment_get_NamespaceList(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"NamespaceList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NamespaceList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceAssignment_put_NamespaceList(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceAssignment", L"NamespaceList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>>(arg);

            self->obj.NamespaceList(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnNamespaceAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnNamespaceAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNamespaceAssignment[] = {
        { "_assign_array_", _assign_array_VpnNamespaceAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnNamespaceAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnNamespaceAssignment[] = {
        { "proxy_auto_config_uri", reinterpret_cast<getter>(VpnNamespaceAssignment_get_ProxyAutoConfigUri), reinterpret_cast<setter>(VpnNamespaceAssignment_put_ProxyAutoConfigUri), nullptr, nullptr },
        { "namespace_list", reinterpret_cast<getter>(VpnNamespaceAssignment_get_NamespaceList), reinterpret_cast<setter>(VpnNamespaceAssignment_put_NamespaceList), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnNamespaceAssignment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnNamespaceAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnNamespaceAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnNamespaceAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnNamespaceAssignment) },
        { }
    };

    static PyType_Spec type_spec_VpnNamespaceAssignment = {
        "winrt._winrt_windows_networking_vpn.VpnNamespaceAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNamespaceAssignment};

    // ----- VpnNamespaceInfo class --------------------

    static PyObject* _new_VpnNamespaceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 2);

                winrt::Windows::Networking::Vpn::VpnNamespaceInfo instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNamespaceInfo(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnNamespaceInfo_get_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"WebProxyServers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WebProxyServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"WebProxyServers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(arg);

            self->obj.WebProxyServers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceInfo_get_Namespace(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"Namespace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Namespace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_Namespace(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"Namespace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Namespace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceInfo_get_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"DnsServers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DnsServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNamespaceInfo", L"DnsServers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(arg);

            self->obj.DnsServers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnNamespaceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnNamespaceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNamespaceInfo[] = {
        { "_assign_array_", _assign_array_VpnNamespaceInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnNamespaceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnNamespaceInfo[] = {
        { "web_proxy_servers", reinterpret_cast<getter>(VpnNamespaceInfo_get_WebProxyServers), reinterpret_cast<setter>(VpnNamespaceInfo_put_WebProxyServers), nullptr, nullptr },
        { "namespace", reinterpret_cast<getter>(VpnNamespaceInfo_get_Namespace), reinterpret_cast<setter>(VpnNamespaceInfo_put_Namespace), nullptr, nullptr },
        { "dns_servers", reinterpret_cast<getter>(VpnNamespaceInfo_get_DnsServers), reinterpret_cast<setter>(VpnNamespaceInfo_put_DnsServers), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnNamespaceInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnNamespaceInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnNamespaceInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnNamespaceInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnNamespaceInfo) },
        { }
    };

    static PyType_Spec type_spec_VpnNamespaceInfo = {
        "winrt._winrt_windows_networking_vpn.VpnNamespaceInfo",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNamespaceInfo};

    // ----- VpnNativeProfile class --------------------

    static PyObject* _new_VpnNativeProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnNativeProfile instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNativeProfile(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnNativeProfile_get_UserAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"UserAuthenticationMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserAuthenticationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_UserAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"UserAuthenticationMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAuthenticationMethod>(arg);

            self->obj.UserAuthenticationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_TunnelAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"TunnelAuthenticationMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TunnelAuthenticationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_TunnelAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"TunnelAuthenticationMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAuthenticationMethod>(arg);

            self->obj.TunnelAuthenticationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RoutingPolicyType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoutingPolicyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RoutingPolicyType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRoutingPolicyType>(arg);

            self->obj.RoutingPolicyType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_EapConfiguration(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"EapConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EapConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_EapConfiguration(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"EapConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EapConfiguration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_NativeProtocolType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"NativeProtocolType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NativeProtocolType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_NativeProtocolType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"NativeProtocolType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnNativeProtocolType>(arg);

            self->obj.NativeProtocolType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_Servers(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"Servers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Servers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RequireVpnClientAppUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequireVpnClientAppUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RequireVpnClientAppUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireVpnClientAppUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_ConnectionStatus(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"ConnectionStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RememberCredentials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"RememberCredentials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"AlwaysOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"AlwaysOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"Routes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"AppTriggers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"TrafficFilters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnNativeProfile", L"DomainNameInfoList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnNativeProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnNativeProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnNativeProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNativeProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNativeProfile[] = {
        { "_assign_array_", _assign_array_VpnNativeProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnNativeProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnNativeProfile[] = {
        { "user_authentication_method", reinterpret_cast<getter>(VpnNativeProfile_get_UserAuthenticationMethod), reinterpret_cast<setter>(VpnNativeProfile_put_UserAuthenticationMethod), nullptr, nullptr },
        { "tunnel_authentication_method", reinterpret_cast<getter>(VpnNativeProfile_get_TunnelAuthenticationMethod), reinterpret_cast<setter>(VpnNativeProfile_put_TunnelAuthenticationMethod), nullptr, nullptr },
        { "routing_policy_type", reinterpret_cast<getter>(VpnNativeProfile_get_RoutingPolicyType), reinterpret_cast<setter>(VpnNativeProfile_put_RoutingPolicyType), nullptr, nullptr },
        { "eap_configuration", reinterpret_cast<getter>(VpnNativeProfile_get_EapConfiguration), reinterpret_cast<setter>(VpnNativeProfile_put_EapConfiguration), nullptr, nullptr },
        { "native_protocol_type", reinterpret_cast<getter>(VpnNativeProfile_get_NativeProtocolType), reinterpret_cast<setter>(VpnNativeProfile_put_NativeProtocolType), nullptr, nullptr },
        { "servers", reinterpret_cast<getter>(VpnNativeProfile_get_Servers), nullptr, nullptr, nullptr },
        { "require_vpn_client_app_ui", reinterpret_cast<getter>(VpnNativeProfile_get_RequireVpnClientAppUI), reinterpret_cast<setter>(VpnNativeProfile_put_RequireVpnClientAppUI), nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(VpnNativeProfile_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(VpnNativeProfile_get_ProfileName), reinterpret_cast<setter>(VpnNativeProfile_put_ProfileName), nullptr, nullptr },
        { "remember_credentials", reinterpret_cast<getter>(VpnNativeProfile_get_RememberCredentials), reinterpret_cast<setter>(VpnNativeProfile_put_RememberCredentials), nullptr, nullptr },
        { "always_on", reinterpret_cast<getter>(VpnNativeProfile_get_AlwaysOn), reinterpret_cast<setter>(VpnNativeProfile_put_AlwaysOn), nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(VpnNativeProfile_get_Routes), nullptr, nullptr, nullptr },
        { "app_triggers", reinterpret_cast<getter>(VpnNativeProfile_get_AppTriggers), nullptr, nullptr, nullptr },
        { "traffic_filters", reinterpret_cast<getter>(VpnNativeProfile_get_TrafficFilters), nullptr, nullptr, nullptr },
        { "domain_name_info_list", reinterpret_cast<getter>(VpnNativeProfile_get_DomainNameInfoList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnNativeProfile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnNativeProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnNativeProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnNativeProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnNativeProfile) },
        { }
    };

    static PyType_Spec type_spec_VpnNativeProfile = {
        "winrt._winrt_windows_networking_vpn.VpnNativeProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNativeProfile};

    // ----- VpnPacketBuffer class --------------------

    static PyObject* _new_VpnPacketBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Networking::Vpn::VpnPacketBuffer instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPacketBuffer_get_TransportAffinity(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportAffinity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportAffinity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_TransportAffinity(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportAffinity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TransportAffinity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBuffer_get_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBuffer_get_Buffer(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"Buffer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPacketBuffer_get_AppId(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"AppId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPacketBuffer_get_TransportContext(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_TransportContext(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBuffer", L"TransportContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.TransportContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnPacketBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPacketBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPacketBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPacketBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPacketBuffer[] = {
        { "_assign_array_", _assign_array_VpnPacketBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPacketBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPacketBuffer[] = {
        { "transport_affinity", reinterpret_cast<getter>(VpnPacketBuffer_get_TransportAffinity), reinterpret_cast<setter>(VpnPacketBuffer_put_TransportAffinity), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(VpnPacketBuffer_get_Status), reinterpret_cast<setter>(VpnPacketBuffer_put_Status), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(VpnPacketBuffer_get_Buffer), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(VpnPacketBuffer_get_AppId), nullptr, nullptr, nullptr },
        { "transport_context", reinterpret_cast<getter>(VpnPacketBuffer_get_TransportContext), reinterpret_cast<setter>(VpnPacketBuffer_put_TransportContext), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPacketBuffer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPacketBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPacketBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPacketBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPacketBuffer) },
        { }
    };

    static PyType_Spec type_spec_VpnPacketBuffer = {
        "winrt._winrt_windows_networking_vpn.VpnPacketBuffer",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPacketBuffer};

    // ----- VpnPacketBufferList class --------------------

    static PyObject* _new_VpnPacketBufferList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnPacketBufferList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnPacketBufferList>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnPacketBufferList(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPacketBufferList_AddAtBegin(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"AddAtBegin", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AddAtBegin(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_Append(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_Clear(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_First(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_RemoveAtBegin(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"RemoveAtBegin", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RemoveAtBegin());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_RemoveAtEnd(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RemoveAtEnd());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_get_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBufferList_put_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBufferList_get_Size(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPacketBufferList", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnPacketBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPacketBufferList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPacketBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPacketBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_VpnPacketBufferList(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPacketBufferList[] = {
        { "add_at_begin", reinterpret_cast<PyCFunction>(VpnPacketBufferList_AddAtBegin), METH_VARARGS, nullptr },
        { "append", reinterpret_cast<PyCFunction>(VpnPacketBufferList_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(VpnPacketBufferList_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(VpnPacketBufferList_First), METH_VARARGS, nullptr },
        { "remove_at_begin", reinterpret_cast<PyCFunction>(VpnPacketBufferList_RemoveAtBegin), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(VpnPacketBufferList_RemoveAtEnd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VpnPacketBufferList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPacketBufferList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPacketBufferList[] = {
        { "status", reinterpret_cast<getter>(VpnPacketBufferList_get_Status), reinterpret_cast<setter>(VpnPacketBufferList_put_Status), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(VpnPacketBufferList_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPacketBufferList[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPacketBufferList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPacketBufferList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPacketBufferList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPacketBufferList) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_VpnPacketBufferList) },
        { }
    };

    static PyType_Spec type_spec_VpnPacketBufferList = {
        "winrt._winrt_windows_networking_vpn.VpnPacketBufferList",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPacketBufferList};

    // ----- VpnPickedCredential class --------------------

    static PyObject* _new_VpnPickedCredential(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnPickedCredential>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnPickedCredential>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnPickedCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPickedCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPickedCredential", L"AdditionalPin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPickedCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPickedCredential", L"OldPasswordCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPickedCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPickedCredential", L"PasskeyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnPickedCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPickedCredential>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPickedCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPickedCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPickedCredential[] = {
        { "_assign_array_", _assign_array_VpnPickedCredential, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPickedCredential), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPickedCredential[] = {
        { "additional_pin", reinterpret_cast<getter>(VpnPickedCredential_get_AdditionalPin), nullptr, nullptr, nullptr },
        { "old_password_credential", reinterpret_cast<getter>(VpnPickedCredential_get_OldPasswordCredential), nullptr, nullptr, nullptr },
        { "passkey_credential", reinterpret_cast<getter>(VpnPickedCredential_get_PasskeyCredential), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPickedCredential[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPickedCredential) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPickedCredential) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPickedCredential) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPickedCredential) },
        { }
    };

    static PyType_Spec type_spec_VpnPickedCredential = {
        "winrt._winrt_windows_networking_vpn.VpnPickedCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPickedCredential};

    // ----- VpnPlugInProfile class --------------------

    static PyObject* _new_VpnPlugInProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnPlugInProfile instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnPlugInProfile(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnPlugInProfile_get_VpnPluginPackageFamilyName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"VpnPluginPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VpnPluginPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_VpnPluginPackageFamilyName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"VpnPluginPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VpnPluginPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_CustomConfiguration(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"CustomConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_CustomConfiguration(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"CustomConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CustomConfiguration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_ServerUris(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ServerUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RequireVpnClientAppUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequireVpnClientAppUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RequireVpnClientAppUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireVpnClientAppUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_ConnectionStatus(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ConnectionStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RememberCredentials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"RememberCredentials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"AlwaysOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"AlwaysOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"AppTriggers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"DomainNameInfoList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"Routes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnPlugInProfile", L"TrafficFilters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnPlugInProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnPlugInProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnPlugInProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPlugInProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPlugInProfile[] = {
        { "_assign_array_", _assign_array_VpnPlugInProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnPlugInProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnPlugInProfile[] = {
        { "vpn_plugin_package_family_name", reinterpret_cast<getter>(VpnPlugInProfile_get_VpnPluginPackageFamilyName), reinterpret_cast<setter>(VpnPlugInProfile_put_VpnPluginPackageFamilyName), nullptr, nullptr },
        { "custom_configuration", reinterpret_cast<getter>(VpnPlugInProfile_get_CustomConfiguration), reinterpret_cast<setter>(VpnPlugInProfile_put_CustomConfiguration), nullptr, nullptr },
        { "server_uris", reinterpret_cast<getter>(VpnPlugInProfile_get_ServerUris), nullptr, nullptr, nullptr },
        { "require_vpn_client_app_ui", reinterpret_cast<getter>(VpnPlugInProfile_get_RequireVpnClientAppUI), reinterpret_cast<setter>(VpnPlugInProfile_put_RequireVpnClientAppUI), nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(VpnPlugInProfile_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(VpnPlugInProfile_get_ProfileName), reinterpret_cast<setter>(VpnPlugInProfile_put_ProfileName), nullptr, nullptr },
        { "remember_credentials", reinterpret_cast<getter>(VpnPlugInProfile_get_RememberCredentials), reinterpret_cast<setter>(VpnPlugInProfile_put_RememberCredentials), nullptr, nullptr },
        { "always_on", reinterpret_cast<getter>(VpnPlugInProfile_get_AlwaysOn), reinterpret_cast<setter>(VpnPlugInProfile_put_AlwaysOn), nullptr, nullptr },
        { "app_triggers", reinterpret_cast<getter>(VpnPlugInProfile_get_AppTriggers), nullptr, nullptr, nullptr },
        { "domain_name_info_list", reinterpret_cast<getter>(VpnPlugInProfile_get_DomainNameInfoList), nullptr, nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(VpnPlugInProfile_get_Routes), nullptr, nullptr, nullptr },
        { "traffic_filters", reinterpret_cast<getter>(VpnPlugInProfile_get_TrafficFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnPlugInProfile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnPlugInProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnPlugInProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnPlugInProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnPlugInProfile) },
        { }
    };

    static PyType_Spec type_spec_VpnPlugInProfile = {
        "winrt._winrt_windows_networking_vpn.VpnPlugInProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPlugInProfile};

    // ----- VpnRoute class --------------------

    static PyObject* _new_VpnRoute(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Networking::Vpn::VpnRoute instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnRoute(py::wrapper::Windows::Networking::Vpn::VpnRoute* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnRoute_get_PrefixSize(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"PrefixSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrefixSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRoute_put_PrefixSize(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"PrefixSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PrefixSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRoute_get_Address(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRoute_put_Address(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRoute", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnRoute(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnRoute>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnRoute(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnRoute>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnRoute[] = {
        { "_assign_array_", _assign_array_VpnRoute, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnRoute), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnRoute[] = {
        { "prefix_size", reinterpret_cast<getter>(VpnRoute_get_PrefixSize), reinterpret_cast<setter>(VpnRoute_put_PrefixSize), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(VpnRoute_get_Address), reinterpret_cast<setter>(VpnRoute_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnRoute[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnRoute) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnRoute) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnRoute) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnRoute) },
        { }
    };

    static PyType_Spec type_spec_VpnRoute = {
        "winrt._winrt_windows_networking_vpn.VpnRoute",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnRoute),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnRoute};

    // ----- VpnRouteAssignment class --------------------

    static PyObject* _new_VpnRouteAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnRouteAssignment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnRouteAssignment(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnRouteAssignment_get_Ipv6InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6InclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv6InclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv6InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6InclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv6InclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv6ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6ExclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv6ExclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv6ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv6ExclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv6ExclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv4InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4InclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv4InclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv4InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4InclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv4InclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv4ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4ExclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ipv4ExclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv4ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"Ipv4ExclusionRoutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv4ExclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_ExcludeLocalSubnets(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"ExcludeLocalSubnets");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExcludeLocalSubnets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_ExcludeLocalSubnets(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnRouteAssignment", L"ExcludeLocalSubnets");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExcludeLocalSubnets(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VpnRouteAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnRouteAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnRouteAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnRouteAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnRouteAssignment[] = {
        { "_assign_array_", _assign_array_VpnRouteAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnRouteAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnRouteAssignment[] = {
        { "ipv6_inclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv6InclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv6InclusionRoutes), nullptr, nullptr },
        { "ipv6_exclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv6ExclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv6ExclusionRoutes), nullptr, nullptr },
        { "ipv4_inclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv4InclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv4InclusionRoutes), nullptr, nullptr },
        { "ipv4_exclusion_routes", reinterpret_cast<getter>(VpnRouteAssignment_get_Ipv4ExclusionRoutes), reinterpret_cast<setter>(VpnRouteAssignment_put_Ipv4ExclusionRoutes), nullptr, nullptr },
        { "exclude_local_subnets", reinterpret_cast<getter>(VpnRouteAssignment_get_ExcludeLocalSubnets), reinterpret_cast<setter>(VpnRouteAssignment_put_ExcludeLocalSubnets), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnRouteAssignment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnRouteAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnRouteAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnRouteAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnRouteAssignment) },
        { }
    };

    static PyType_Spec type_spec_VpnRouteAssignment = {
        "winrt._winrt_windows_networking_vpn.VpnRouteAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnRouteAssignment};

    // ----- VpnSystemHealth class --------------------

    static PyObject* _new_VpnSystemHealth(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::VpnSystemHealth>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::VpnSystemHealth>::type_name);
        return nullptr;
    }

    static void _dealloc_VpnSystemHealth(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnSystemHealth_get_StatementOfHealth(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnSystemHealth", L"StatementOfHealth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatementOfHealth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnSystemHealth(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnSystemHealth>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnSystemHealth(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnSystemHealth>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnSystemHealth[] = {
        { "_assign_array_", _assign_array_VpnSystemHealth, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnSystemHealth), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnSystemHealth[] = {
        { "statement_of_health", reinterpret_cast<getter>(VpnSystemHealth_get_StatementOfHealth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnSystemHealth[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnSystemHealth) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnSystemHealth) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnSystemHealth) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnSystemHealth) },
        { }
    };

    static PyType_Spec type_spec_VpnSystemHealth = {
        "winrt._winrt_windows_networking_vpn.VpnSystemHealth",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnSystemHealth};

    // ----- VpnTrafficFilter class --------------------

    static PyObject* _new_VpnTrafficFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppId>(args, 0);

                winrt::Windows::Networking::Vpn::VpnTrafficFilter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnTrafficFilter(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnTrafficFilter_get_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RoutingPolicyType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoutingPolicyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RoutingPolicyType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRoutingPolicyType>(arg);

            self->obj.RoutingPolicyType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_Protocol(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_Protocol(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnIPProtocol>(arg);

            self->obj.Protocol(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_AppId(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"AppId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_AppId(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"AppId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppId>(arg);

            self->obj.AppId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_AppClaims(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"AppClaims");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppClaims());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_LocalAddressRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"LocalAddressRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddressRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_LocalPortRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"LocalPortRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPortRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_RemoteAddressRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RemoteAddressRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteAddressRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_RemotePortRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilter", L"RemotePortRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemotePortRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnTrafficFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnTrafficFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnTrafficFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnTrafficFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnTrafficFilter[] = {
        { "_assign_array_", _assign_array_VpnTrafficFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnTrafficFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnTrafficFilter[] = {
        { "routing_policy_type", reinterpret_cast<getter>(VpnTrafficFilter_get_RoutingPolicyType), reinterpret_cast<setter>(VpnTrafficFilter_put_RoutingPolicyType), nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(VpnTrafficFilter_get_Protocol), reinterpret_cast<setter>(VpnTrafficFilter_put_Protocol), nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(VpnTrafficFilter_get_AppId), reinterpret_cast<setter>(VpnTrafficFilter_put_AppId), nullptr, nullptr },
        { "app_claims", reinterpret_cast<getter>(VpnTrafficFilter_get_AppClaims), nullptr, nullptr, nullptr },
        { "local_address_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_LocalAddressRanges), nullptr, nullptr, nullptr },
        { "local_port_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_LocalPortRanges), nullptr, nullptr, nullptr },
        { "remote_address_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_RemoteAddressRanges), nullptr, nullptr, nullptr },
        { "remote_port_ranges", reinterpret_cast<getter>(VpnTrafficFilter_get_RemotePortRanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnTrafficFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnTrafficFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnTrafficFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnTrafficFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnTrafficFilter) },
        { }
    };

    static PyType_Spec type_spec_VpnTrafficFilter = {
        "winrt._winrt_windows_networking_vpn.VpnTrafficFilter",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnTrafficFilter};

    // ----- VpnTrafficFilterAssignment class --------------------

    static PyObject* _new_VpnTrafficFilterAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnTrafficFilterAssignment(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VpnTrafficFilterAssignment_get_AllowOutbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowOutbound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowOutbound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilterAssignment_put_AllowOutbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowOutbound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowOutbound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilterAssignment_get_AllowInbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowInbound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowInbound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilterAssignment_put_AllowInbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"AllowInbound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowInbound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilterAssignment_get_TrafficFilterList(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.VpnTrafficFilterAssignment", L"TrafficFilterList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilterList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VpnTrafficFilterAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VpnTrafficFilterAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnTrafficFilterAssignment[] = {
        { "_assign_array_", _assign_array_VpnTrafficFilterAssignment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VpnTrafficFilterAssignment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VpnTrafficFilterAssignment[] = {
        { "allow_outbound", reinterpret_cast<getter>(VpnTrafficFilterAssignment_get_AllowOutbound), reinterpret_cast<setter>(VpnTrafficFilterAssignment_put_AllowOutbound), nullptr, nullptr },
        { "allow_inbound", reinterpret_cast<getter>(VpnTrafficFilterAssignment_get_AllowInbound), reinterpret_cast<setter>(VpnTrafficFilterAssignment_put_AllowInbound), nullptr, nullptr },
        { "traffic_filter_list", reinterpret_cast<getter>(VpnTrafficFilterAssignment_get_TrafficFilterList), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VpnTrafficFilterAssignment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VpnTrafficFilterAssignment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VpnTrafficFilterAssignment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VpnTrafficFilterAssignment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VpnTrafficFilterAssignment) },
        { }
    };

    static PyType_Spec type_spec_VpnTrafficFilterAssignment = {
        "winrt._winrt_windows_networking_vpn.VpnTrafficFilterAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnTrafficFilterAssignment};

    // ----- IVpnChannelStatics interface --------------------

    static PyObject* _new_IVpnChannelStatics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnChannelStatics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnChannelStatics>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnChannelStatics(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnChannelStatics_ProcessEventAsync(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnChannelStatics", L"ProcessEventAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ProcessEventAsync(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnChannelStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnChannelStatics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnChannelStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnChannelStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnChannelStatics[] = {
        { "process_event_async", reinterpret_cast<PyCFunction>(IVpnChannelStatics_ProcessEventAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnChannelStatics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnChannelStatics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnChannelStatics[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnChannelStatics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnChannelStatics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnChannelStatics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnChannelStatics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnChannelStatics) },
        { }
    };

    static PyType_Spec type_spec_IVpnChannelStatics = {
        "winrt._winrt_windows_networking_vpn.IVpnChannelStatics",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnChannelStatics};

    struct ImplementsIVpnChannelStatics : py::ImplementsInterfaceT<ImplementsIVpnChannelStatics, winrt::Windows::Networking::Vpn::IVpnChannelStatics>
    {
        ImplementsIVpnChannelStatics() = delete;
        ImplementsIVpnChannelStatics(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnChannelStatics, winrt::Windows::Networking::Vpn::IVpnChannelStatics>(py_obj, runtime_class)
        {
        }

        auto ProcessEventAsync(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "process_event_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnChannelStatics(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnChannelStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnChannelStatics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnChannelStatics>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnChannelStatics[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnChannelStatics), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnChannelStatics), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnChannelStatics[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnChannelStatics) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnChannelStatics = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnChannelStatics",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnChannelStatics};

    // ----- IVpnCredential interface --------------------

    static PyObject* _new_IVpnCredential(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnCredential>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnCredential>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"AdditionalPin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_CertificateCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"CertificateCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CertificateCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"OldPasswordCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCredential", L"PasskeyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnCredential>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCredential[] = {
        { "_assign_array_", _assign_array_IVpnCredential, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnCredential), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnCredential[] = {
        { "additional_pin", reinterpret_cast<getter>(IVpnCredential_get_AdditionalPin), nullptr, nullptr, nullptr },
        { "certificate_credential", reinterpret_cast<getter>(IVpnCredential_get_CertificateCredential), nullptr, nullptr, nullptr },
        { "old_password_credential", reinterpret_cast<getter>(IVpnCredential_get_OldPasswordCredential), nullptr, nullptr, nullptr },
        { "passkey_credential", reinterpret_cast<getter>(IVpnCredential_get_PasskeyCredential), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnCredential[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnCredential) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnCredential) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnCredential) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnCredential) },
        { }
    };

    static PyType_Spec type_spec_IVpnCredential = {
        "winrt._winrt_windows_networking_vpn.IVpnCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCredential};

    struct ImplementsIVpnCredential : py::ImplementsInterfaceT<ImplementsIVpnCredential, winrt::Windows::Networking::Vpn::IVpnCredential>
    {
        ImplementsIVpnCredential() = delete;
        ImplementsIVpnCredential(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnCredential, winrt::Windows::Networking::Vpn::IVpnCredential>(py_obj, runtime_class)
        {
        }

        auto AdditionalPin()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "additional_pin")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CertificateCredential()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "certificate_credential")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OldPasswordCredential()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "old_password_credential")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PasskeyCredential()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "passkey_credential")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnCredential(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnCredential(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnCredential>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnCredential[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnCredential), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnCredential), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnCredential[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnCredential) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnCredential = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnCredential",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnCredential};

    // ----- IVpnCustomPrompt interface --------------------

    static PyObject* _new_IVpnCustomPrompt(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnCustomPrompt(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnCustomPrompt_get_Bordered(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Bordered(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Bordered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPrompt_get_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPrompt_get_Label(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Label(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPrompt", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IVpnCustomPrompt(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnCustomPrompt(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCustomPrompt[] = {
        { "_assign_array_", _assign_array_IVpnCustomPrompt, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnCustomPrompt), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnCustomPrompt[] = {
        { "bordered", reinterpret_cast<getter>(IVpnCustomPrompt_get_Bordered), reinterpret_cast<setter>(IVpnCustomPrompt_put_Bordered), nullptr, nullptr },
        { "compulsory", reinterpret_cast<getter>(IVpnCustomPrompt_get_Compulsory), reinterpret_cast<setter>(IVpnCustomPrompt_put_Compulsory), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IVpnCustomPrompt_get_Label), reinterpret_cast<setter>(IVpnCustomPrompt_put_Label), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnCustomPrompt[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnCustomPrompt) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnCustomPrompt) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnCustomPrompt) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnCustomPrompt) },
        { }
    };

    static PyType_Spec type_spec_IVpnCustomPrompt = {
        "winrt._winrt_windows_networking_vpn.IVpnCustomPrompt",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCustomPrompt};

    struct ImplementsIVpnCustomPrompt : py::ImplementsInterfaceT<ImplementsIVpnCustomPrompt, winrt::Windows::Networking::Vpn::IVpnCustomPrompt>
    {
        ImplementsIVpnCustomPrompt() = delete;
        ImplementsIVpnCustomPrompt(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnCustomPrompt, winrt::Windows::Networking::Vpn::IVpnCustomPrompt>(py_obj, runtime_class)
        {
        }

        auto Bordered()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "bordered")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Bordered(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "bordered", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Compulsory()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "compulsory")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Compulsory(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "compulsory", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Label()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "label")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Label(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "label", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnCustomPrompt(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnCustomPrompt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnCustomPrompt>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnCustomPrompt[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnCustomPrompt), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnCustomPrompt), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnCustomPrompt[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnCustomPrompt) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnCustomPrompt = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnCustomPrompt",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnCustomPrompt};

    // ----- IVpnCustomPromptElement interface --------------------

    static PyObject* _new_IVpnCustomPromptElement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnCustomPromptElement(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnCustomPromptElement_get_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Compulsory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPromptElement_get_DisplayName(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_DisplayName(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPromptElement_get_Emphasized(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_Emphasized(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnCustomPromptElement", L"Emphasized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IVpnCustomPromptElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnCustomPromptElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCustomPromptElement[] = {
        { "_assign_array_", _assign_array_IVpnCustomPromptElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnCustomPromptElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnCustomPromptElement[] = {
        { "compulsory", reinterpret_cast<getter>(IVpnCustomPromptElement_get_Compulsory), reinterpret_cast<setter>(IVpnCustomPromptElement_put_Compulsory), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IVpnCustomPromptElement_get_DisplayName), reinterpret_cast<setter>(IVpnCustomPromptElement_put_DisplayName), nullptr, nullptr },
        { "emphasized", reinterpret_cast<getter>(IVpnCustomPromptElement_get_Emphasized), reinterpret_cast<setter>(IVpnCustomPromptElement_put_Emphasized), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnCustomPromptElement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnCustomPromptElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnCustomPromptElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnCustomPromptElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnCustomPromptElement) },
        { }
    };

    static PyType_Spec type_spec_IVpnCustomPromptElement = {
        "winrt._winrt_windows_networking_vpn.IVpnCustomPromptElement",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCustomPromptElement};

    struct ImplementsIVpnCustomPromptElement : py::ImplementsInterfaceT<ImplementsIVpnCustomPromptElement, winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>
    {
        ImplementsIVpnCustomPromptElement() = delete;
        ImplementsIVpnCustomPromptElement(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnCustomPromptElement, winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>(py_obj, runtime_class)
        {
        }

        auto Compulsory()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "compulsory")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Compulsory(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "compulsory", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DisplayName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "display_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void DisplayName(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "display_name", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Emphasized()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "emphasized")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Emphasized(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "emphasized", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnCustomPromptElement(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnCustomPromptElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnCustomPromptElement>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnCustomPromptElement[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnCustomPromptElement), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnCustomPromptElement), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnCustomPromptElement[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnCustomPromptElement) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnCustomPromptElement = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnCustomPromptElement",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnCustomPromptElement};

    // ----- IVpnDomainNameInfoFactory interface --------------------

    static PyObject* _new_IVpnDomainNameInfoFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnDomainNameInfoFactory(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnDomainNameInfoFactory_CreateVpnDomainNameInfo(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnDomainNameInfoFactory", L"CreateVpnDomainNameInfo", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 3);

                return py::convert(self->obj.CreateVpnDomainNameInfo(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnDomainNameInfoFactory[] = {
        { "create_vpn_domain_name_info", reinterpret_cast<PyCFunction>(IVpnDomainNameInfoFactory_CreateVpnDomainNameInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnDomainNameInfoFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnDomainNameInfoFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnDomainNameInfoFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnDomainNameInfoFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnDomainNameInfoFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnDomainNameInfoFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnDomainNameInfoFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnDomainNameInfoFactory) },
        { }
    };

    static PyType_Spec type_spec_IVpnDomainNameInfoFactory = {
        "winrt._winrt_windows_networking_vpn.IVpnDomainNameInfoFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnDomainNameInfoFactory};

    struct ImplementsIVpnDomainNameInfoFactory : py::ImplementsInterfaceT<ImplementsIVpnDomainNameInfoFactory, winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>
    {
        ImplementsIVpnDomainNameInfoFactory() = delete;
        ImplementsIVpnDomainNameInfoFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnDomainNameInfoFactory, winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>(py_obj, runtime_class)
        {
        }

        auto CreateVpnDomainNameInfo(winrt::hstring const& param0, winrt::Windows::Networking::Vpn::VpnDomainNameType param1, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName> const& param2, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName> const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_vpn_domain_name_info")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnDomainNameInfoFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnDomainNameInfoFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnDomainNameInfoFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnDomainNameInfoFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnDomainNameInfoFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnDomainNameInfoFactory) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnDomainNameInfoFactory = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnDomainNameInfoFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnDomainNameInfoFactory};

    // ----- IVpnInterfaceIdFactory interface --------------------

    static PyObject* _new_IVpnInterfaceIdFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnInterfaceIdFactory(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnInterfaceIdFactory_CreateVpnInterfaceId(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnInterfaceIdFactory", L"CreateVpnInterfaceId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.CreateVpnInterfaceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnInterfaceIdFactory[] = {
        { "create_vpn_interface_id", reinterpret_cast<PyCFunction>(IVpnInterfaceIdFactory_CreateVpnInterfaceId), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnInterfaceIdFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnInterfaceIdFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnInterfaceIdFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnInterfaceIdFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnInterfaceIdFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnInterfaceIdFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnInterfaceIdFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnInterfaceIdFactory) },
        { }
    };

    static PyType_Spec type_spec_IVpnInterfaceIdFactory = {
        "winrt._winrt_windows_networking_vpn.IVpnInterfaceIdFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnInterfaceIdFactory};

    struct ImplementsIVpnInterfaceIdFactory : py::ImplementsInterfaceT<ImplementsIVpnInterfaceIdFactory, winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>
    {
        ImplementsIVpnInterfaceIdFactory() = delete;
        ImplementsIVpnInterfaceIdFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnInterfaceIdFactory, winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>(py_obj, runtime_class)
        {
        }

        auto CreateVpnInterfaceId(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_vpn_interface_id")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnInterfaceIdFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnInterfaceIdFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnInterfaceIdFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnInterfaceIdFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnInterfaceIdFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnInterfaceIdFactory) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnInterfaceIdFactory = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnInterfaceIdFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnInterfaceIdFactory};

    // ----- IVpnNamespaceInfoFactory interface --------------------

    static PyObject* _new_IVpnNamespaceInfoFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnNamespaceInfoFactory(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnNamespaceInfoFactory_CreateVpnNamespaceInfo(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnNamespaceInfoFactory", L"CreateVpnNamespaceInfo", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 2);

                return py::convert(self->obj.CreateVpnNamespaceInfo(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnNamespaceInfoFactory[] = {
        { "create_vpn_namespace_info", reinterpret_cast<PyCFunction>(IVpnNamespaceInfoFactory_CreateVpnNamespaceInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnNamespaceInfoFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnNamespaceInfoFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnNamespaceInfoFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnNamespaceInfoFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnNamespaceInfoFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnNamespaceInfoFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnNamespaceInfoFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnNamespaceInfoFactory) },
        { }
    };

    static PyType_Spec type_spec_IVpnNamespaceInfoFactory = {
        "winrt._winrt_windows_networking_vpn.IVpnNamespaceInfoFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnNamespaceInfoFactory};

    struct ImplementsIVpnNamespaceInfoFactory : py::ImplementsInterfaceT<ImplementsIVpnNamespaceInfoFactory, winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>
    {
        ImplementsIVpnNamespaceInfoFactory() = delete;
        ImplementsIVpnNamespaceInfoFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnNamespaceInfoFactory, winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>(py_obj, runtime_class)
        {
        }

        auto CreateVpnNamespaceInfo(winrt::hstring const& param0, winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName> const& param1, winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName> const& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_vpn_namespace_info")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnNamespaceInfoFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnNamespaceInfoFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnNamespaceInfoFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnNamespaceInfoFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnNamespaceInfoFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnNamespaceInfoFactory) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnNamespaceInfoFactory = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnNamespaceInfoFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnNamespaceInfoFactory};

    // ----- IVpnPacketBufferFactory interface --------------------

    static PyObject* _new_IVpnPacketBufferFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnPacketBufferFactory(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnPacketBufferFactory_CreateVpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPacketBufferFactory", L"CreateVpnPacketBuffer", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.CreateVpnPacketBuffer(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPacketBufferFactory[] = {
        { "create_vpn_packet_buffer", reinterpret_cast<PyCFunction>(IVpnPacketBufferFactory_CreateVpnPacketBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnPacketBufferFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnPacketBufferFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnPacketBufferFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnPacketBufferFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnPacketBufferFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnPacketBufferFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnPacketBufferFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnPacketBufferFactory) },
        { }
    };

    static PyType_Spec type_spec_IVpnPacketBufferFactory = {
        "winrt._winrt_windows_networking_vpn.IVpnPacketBufferFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPacketBufferFactory};

    struct ImplementsIVpnPacketBufferFactory : py::ImplementsInterfaceT<ImplementsIVpnPacketBufferFactory, winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>
    {
        ImplementsIVpnPacketBufferFactory() = delete;
        ImplementsIVpnPacketBufferFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnPacketBufferFactory, winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>(py_obj, runtime_class)
        {
        }

        auto CreateVpnPacketBuffer(winrt::Windows::Networking::Vpn::VpnPacketBuffer const& param0, uint32_t param1, uint32_t param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_vpn_packet_buffer")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnPacketBufferFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnPacketBufferFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnPacketBufferFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnPacketBufferFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnPacketBufferFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnPacketBufferFactory) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnPacketBufferFactory = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnPacketBufferFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnPacketBufferFactory};

    // ----- IVpnPlugIn interface --------------------

    static PyObject* _new_IVpnPlugIn(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnPlugIn>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnPlugIn>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnPlugIn(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnPlugIn_Connect(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Connect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);

                self->obj.Connect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Decapsulate(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Decapsulate", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 3);

                self->obj.Decapsulate(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Disconnect(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Disconnect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);

                self->obj.Disconnect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Encapsulate(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"Encapsulate", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 2);

                self->obj.Encapsulate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_GetKeepAlivePayload(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugIn", L"GetKeepAlivePayload", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                winrt::Windows::Networking::Vpn::VpnPacketBuffer param1{nullptr};

                self->obj.GetKeepAlivePayload(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnPlugIn>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPlugIn>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPlugIn[] = {
        { "connect", reinterpret_cast<PyCFunction>(IVpnPlugIn_Connect), METH_VARARGS, nullptr },
        { "decapsulate", reinterpret_cast<PyCFunction>(IVpnPlugIn_Decapsulate), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(IVpnPlugIn_Disconnect), METH_VARARGS, nullptr },
        { "encapsulate", reinterpret_cast<PyCFunction>(IVpnPlugIn_Encapsulate), METH_VARARGS, nullptr },
        { "get_keep_alive_payload", reinterpret_cast<PyCFunction>(IVpnPlugIn_GetKeepAlivePayload), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnPlugIn, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnPlugIn), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnPlugIn[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnPlugIn[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnPlugIn) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnPlugIn) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnPlugIn) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnPlugIn) },
        { }
    };

    static PyType_Spec type_spec_IVpnPlugIn = {
        "winrt._winrt_windows_networking_vpn.IVpnPlugIn",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPlugIn};

    struct ImplementsIVpnPlugIn : py::ImplementsInterfaceT<ImplementsIVpnPlugIn, winrt::Windows::Networking::Vpn::IVpnPlugIn>
    {
        ImplementsIVpnPlugIn() = delete;
        ImplementsIVpnPlugIn(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnPlugIn, winrt::Windows::Networking::Vpn::IVpnPlugIn>(py_obj, runtime_class)
        {
        }

        auto Connect(winrt::Windows::Networking::Vpn::VpnChannel const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "connect")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Decapsulate(winrt::Windows::Networking::Vpn::VpnChannel const& param0, winrt::Windows::Networking::Vpn::VpnPacketBuffer const& param1, winrt::Windows::Networking::Vpn::VpnPacketBufferList const& param2, winrt::Windows::Networking::Vpn::VpnPacketBufferList const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "decapsulate")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Disconnect(winrt::Windows::Networking::Vpn::VpnChannel const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "disconnect")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Encapsulate(winrt::Windows::Networking::Vpn::VpnChannel const& param0, winrt::Windows::Networking::Vpn::VpnPacketBufferList const& param1, winrt::Windows::Networking::Vpn::VpnPacketBufferList const& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "encapsulate")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetKeepAlivePayload(winrt::Windows::Networking::Vpn::VpnChannel const& param0, winrt::Windows::Networking::Vpn::VpnPacketBuffer& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_keep_alive_payload")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnPlugIn(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnPlugIn>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnPlugIn(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnPlugIn>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnPlugIn[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnPlugIn), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnPlugIn), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnPlugIn[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnPlugIn) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnPlugIn = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnPlugIn",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnPlugIn};

    // ----- IVpnPlugInReconnectTransport interface --------------------

    static PyObject* _new_IVpnPlugInReconnectTransport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnPlugInReconnectTransport(py::wrapper::Windows::Networking::Vpn::IVpnPlugInReconnectTransport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnPlugInReconnectTransport_ReconnectTransport(py::wrapper::Windows::Networking::Vpn::IVpnPlugInReconnectTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnPlugInReconnectTransport", L"ReconnectTransport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ReconnectTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnPlugInReconnectTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnPlugInReconnectTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPlugInReconnectTransport[] = {
        { "reconnect_transport", reinterpret_cast<PyCFunction>(IVpnPlugInReconnectTransport_ReconnectTransport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnPlugInReconnectTransport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnPlugInReconnectTransport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnPlugInReconnectTransport[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnPlugInReconnectTransport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnPlugInReconnectTransport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnPlugInReconnectTransport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnPlugInReconnectTransport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnPlugInReconnectTransport) },
        { }
    };

    static PyType_Spec type_spec_IVpnPlugInReconnectTransport = {
        "winrt._winrt_windows_networking_vpn.IVpnPlugInReconnectTransport",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPlugInReconnectTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPlugInReconnectTransport};

    struct ImplementsIVpnPlugInReconnectTransport : py::ImplementsInterfaceT<ImplementsIVpnPlugInReconnectTransport, winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>
    {
        ImplementsIVpnPlugInReconnectTransport() = delete;
        ImplementsIVpnPlugInReconnectTransport(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnPlugInReconnectTransport, winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>(py_obj, runtime_class)
        {
        }

        auto ReconnectTransport(winrt::Windows::Networking::Vpn::VpnChannel const& param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "reconnect_transport")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnPlugInReconnectTransport(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnPlugInReconnectTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnPlugInReconnectTransport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnPlugInReconnectTransport>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnPlugInReconnectTransport[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnPlugInReconnectTransport), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnPlugInReconnectTransport), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnPlugInReconnectTransport[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnPlugInReconnectTransport) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnPlugInReconnectTransport = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnPlugInReconnectTransport",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnPlugInReconnectTransport};

    // ----- IVpnProfile interface --------------------

    static PyObject* _new_IVpnProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnProfile(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"AlwaysOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"AlwaysOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"AppTriggers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"DomainNameInfoList");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"ProfileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"RememberCredentials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"RememberCredentials");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"Routes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Vpn.IVpnProfile", L"TrafficFilters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnProfile[] = {
        { "_assign_array_", _assign_array_IVpnProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnProfile[] = {
        { "always_on", reinterpret_cast<getter>(IVpnProfile_get_AlwaysOn), reinterpret_cast<setter>(IVpnProfile_put_AlwaysOn), nullptr, nullptr },
        { "app_triggers", reinterpret_cast<getter>(IVpnProfile_get_AppTriggers), nullptr, nullptr, nullptr },
        { "domain_name_info_list", reinterpret_cast<getter>(IVpnProfile_get_DomainNameInfoList), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(IVpnProfile_get_ProfileName), reinterpret_cast<setter>(IVpnProfile_put_ProfileName), nullptr, nullptr },
        { "remember_credentials", reinterpret_cast<getter>(IVpnProfile_get_RememberCredentials), reinterpret_cast<setter>(IVpnProfile_put_RememberCredentials), nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(IVpnProfile_get_Routes), nullptr, nullptr, nullptr },
        { "traffic_filters", reinterpret_cast<getter>(IVpnProfile_get_TrafficFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVpnProfile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnProfile) },
        { }
    };

    static PyType_Spec type_spec_IVpnProfile = {
        "winrt._winrt_windows_networking_vpn.IVpnProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnProfile};

    struct ImplementsIVpnProfile : py::ImplementsInterfaceT<ImplementsIVpnProfile, winrt::Windows::Networking::Vpn::IVpnProfile>
    {
        ImplementsIVpnProfile() = delete;
        ImplementsIVpnProfile(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnProfile, winrt::Windows::Networking::Vpn::IVpnProfile>(py_obj, runtime_class)
        {
        }

        auto AlwaysOn()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "always_on")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void AlwaysOn(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "always_on", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AppTriggers()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "app_triggers")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnAppId>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DomainNameInfoList()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "domain_name_info_list")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProfileName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "profile_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ProfileName(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "profile_name", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RememberCredentials()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "remember_credentials")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void RememberCredentials(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "remember_credentials", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Routes()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "routes")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TrafficFilters()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "traffic_filters")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnTrafficFilter>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnProfile(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnProfile>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnProfile[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnProfile), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnProfile), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnProfile[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnProfile) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnProfile = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnProfile",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnProfile};

    // ----- IVpnRouteFactory interface --------------------

    static PyObject* _new_IVpnRouteFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Vpn::IVpnRouteFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Vpn::IVpnRouteFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IVpnRouteFactory(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVpnRouteFactory_CreateVpnRoute(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Vpn.IVpnRouteFactory", L"CreateVpnRoute", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                return py::convert(self->obj.CreateVpnRoute(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVpnRouteFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Vpn::IVpnRouteFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVpnRouteFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnRouteFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnRouteFactory[] = {
        { "create_vpn_route", reinterpret_cast<PyCFunction>(IVpnRouteFactory_CreateVpnRoute), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVpnRouteFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVpnRouteFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVpnRouteFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IVpnRouteFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVpnRouteFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVpnRouteFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVpnRouteFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVpnRouteFactory) },
        { }
    };

    static PyType_Spec type_spec_IVpnRouteFactory = {
        "winrt._winrt_windows_networking_vpn.IVpnRouteFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnRouteFactory};

    struct ImplementsIVpnRouteFactory : py::ImplementsInterfaceT<ImplementsIVpnRouteFactory, winrt::Windows::Networking::Vpn::IVpnRouteFactory>
    {
        ImplementsIVpnRouteFactory() = delete;
        ImplementsIVpnRouteFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIVpnRouteFactory, winrt::Windows::Networking::Vpn::IVpnRouteFactory>(py_obj, runtime_class)
        {
        }

        auto CreateVpnRoute(winrt::Windows::Networking::HostName const& param0, uint8_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_vpn_route")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::Vpn::VpnRoute>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIVpnRouteFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::Vpn::IVpnRouteFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIVpnRouteFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIVpnRouteFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIVpnRouteFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIVpnRouteFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIVpnRouteFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIVpnRouteFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIVpnRouteFactory) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIVpnRouteFactory = {
        "winrt._winrt_windows_networking_vpn.ImplementsIVpnRouteFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIVpnRouteFactory};

    // ----- Windows.Networking.Vpn Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Networking.Vpn");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_networking_vpn",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Networking::Vpn

PyMODINIT_FUNC PyInit__winrt_windows_networking_vpn(void) noexcept
{
    using namespace py::cpp::Windows::Networking::Vpn;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle VpnAppId_type{py::register_python_type(module.get(), &type_spec_VpnAppId, object_bases.get(), nullptr)};
    if (!VpnAppId_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_VpnChannel_Static{PyType_FromSpec(&type_spec_VpnChannel_Static)};
    if (!type_VpnChannel_Static)
    {
        return nullptr;
    }

    py::pytype_handle VpnChannel_type{py::register_python_type(module.get(), &type_spec_VpnChannel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VpnChannel_Static.get()))};
    if (!VpnChannel_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnChannelActivityEventArgs_type{py::register_python_type(module.get(), &type_spec_VpnChannelActivityEventArgs, object_bases.get(), nullptr)};
    if (!VpnChannelActivityEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnChannelActivityStateChangedArgs_type{py::register_python_type(module.get(), &type_spec_VpnChannelActivityStateChangedArgs, object_bases.get(), nullptr)};
    if (!VpnChannelActivityStateChangedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnChannelConfiguration_type{py::register_python_type(module.get(), &type_spec_VpnChannelConfiguration, object_bases.get(), nullptr)};
    if (!VpnChannelConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCredential_type{py::register_python_type(module.get(), &type_spec_VpnCredential, object_bases.get(), nullptr)};
    if (!VpnCredential_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomCheckBox_type{py::register_python_type(module.get(), &type_spec_VpnCustomCheckBox, object_bases.get(), nullptr)};
    if (!VpnCustomCheckBox_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomComboBox_type{py::register_python_type(module.get(), &type_spec_VpnCustomComboBox, object_bases.get(), nullptr)};
    if (!VpnCustomComboBox_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomEditBox_type{py::register_python_type(module.get(), &type_spec_VpnCustomEditBox, object_bases.get(), nullptr)};
    if (!VpnCustomEditBox_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomErrorBox_type{py::register_python_type(module.get(), &type_spec_VpnCustomErrorBox, object_bases.get(), nullptr)};
    if (!VpnCustomErrorBox_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomPromptBooleanInput_type{py::register_python_type(module.get(), &type_spec_VpnCustomPromptBooleanInput, object_bases.get(), nullptr)};
    if (!VpnCustomPromptBooleanInput_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomPromptOptionSelector_type{py::register_python_type(module.get(), &type_spec_VpnCustomPromptOptionSelector, object_bases.get(), nullptr)};
    if (!VpnCustomPromptOptionSelector_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomPromptText_type{py::register_python_type(module.get(), &type_spec_VpnCustomPromptText, object_bases.get(), nullptr)};
    if (!VpnCustomPromptText_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomPromptTextInput_type{py::register_python_type(module.get(), &type_spec_VpnCustomPromptTextInput, object_bases.get(), nullptr)};
    if (!VpnCustomPromptTextInput_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnCustomTextBox_type{py::register_python_type(module.get(), &type_spec_VpnCustomTextBox, object_bases.get(), nullptr)};
    if (!VpnCustomTextBox_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnDomainNameAssignment_type{py::register_python_type(module.get(), &type_spec_VpnDomainNameAssignment, object_bases.get(), nullptr)};
    if (!VpnDomainNameAssignment_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnDomainNameInfo_type{py::register_python_type(module.get(), &type_spec_VpnDomainNameInfo, object_bases.get(), nullptr)};
    if (!VpnDomainNameInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnForegroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_VpnForegroundActivatedEventArgs, object_bases.get(), nullptr)};
    if (!VpnForegroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnForegroundActivationOperation_type{py::register_python_type(module.get(), &type_spec_VpnForegroundActivationOperation, object_bases.get(), nullptr)};
    if (!VpnForegroundActivationOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnInterfaceId_type{py::register_python_type(module.get(), &type_spec_VpnInterfaceId, object_bases.get(), nullptr)};
    if (!VpnInterfaceId_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnManagementAgent_type{py::register_python_type(module.get(), &type_spec_VpnManagementAgent, object_bases.get(), nullptr)};
    if (!VpnManagementAgent_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnNamespaceAssignment_type{py::register_python_type(module.get(), &type_spec_VpnNamespaceAssignment, object_bases.get(), nullptr)};
    if (!VpnNamespaceAssignment_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnNamespaceInfo_type{py::register_python_type(module.get(), &type_spec_VpnNamespaceInfo, object_bases.get(), nullptr)};
    if (!VpnNamespaceInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnNativeProfile_type{py::register_python_type(module.get(), &type_spec_VpnNativeProfile, object_bases.get(), nullptr)};
    if (!VpnNativeProfile_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnPacketBuffer_type{py::register_python_type(module.get(), &type_spec_VpnPacketBuffer, object_bases.get(), nullptr)};
    if (!VpnPacketBuffer_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnPacketBufferList_type{py::register_python_type(module.get(), &type_spec_VpnPacketBufferList, object_bases.get(), nullptr)};
    if (!VpnPacketBufferList_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnPickedCredential_type{py::register_python_type(module.get(), &type_spec_VpnPickedCredential, object_bases.get(), nullptr)};
    if (!VpnPickedCredential_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnPlugInProfile_type{py::register_python_type(module.get(), &type_spec_VpnPlugInProfile, object_bases.get(), nullptr)};
    if (!VpnPlugInProfile_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnRoute_type{py::register_python_type(module.get(), &type_spec_VpnRoute, object_bases.get(), nullptr)};
    if (!VpnRoute_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnRouteAssignment_type{py::register_python_type(module.get(), &type_spec_VpnRouteAssignment, object_bases.get(), nullptr)};
    if (!VpnRouteAssignment_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnSystemHealth_type{py::register_python_type(module.get(), &type_spec_VpnSystemHealth, object_bases.get(), nullptr)};
    if (!VpnSystemHealth_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnTrafficFilter_type{py::register_python_type(module.get(), &type_spec_VpnTrafficFilter, object_bases.get(), nullptr)};
    if (!VpnTrafficFilter_type)
    {
        return nullptr;
    }

    py::pytype_handle VpnTrafficFilterAssignment_type{py::register_python_type(module.get(), &type_spec_VpnTrafficFilterAssignment, object_bases.get(), nullptr)};
    if (!VpnTrafficFilterAssignment_type)
    {
        return nullptr;
    }

    py::pytype_handle IVpnChannelStatics_type{py::register_python_type(module.get(), &type_spec_IVpnChannelStatics, object_bases.get(), nullptr)};
    if (!IVpnChannelStatics_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnChannelStatics_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnChannelStatics, nullptr))};
    if (!ImplementsIVpnChannelStatics_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnChannelStatics_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnCredential_type{py::register_python_type(module.get(), &type_spec_IVpnCredential, object_bases.get(), nullptr)};
    if (!IVpnCredential_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnCredential_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnCredential, nullptr))};
    if (!ImplementsIVpnCredential_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnCredential_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnCustomPrompt_type{py::register_python_type(module.get(), &type_spec_IVpnCustomPrompt, object_bases.get(), nullptr)};
    if (!IVpnCustomPrompt_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnCustomPrompt_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnCustomPrompt, nullptr))};
    if (!ImplementsIVpnCustomPrompt_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnCustomPrompt_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnCustomPromptElement_type{py::register_python_type(module.get(), &type_spec_IVpnCustomPromptElement, object_bases.get(), nullptr)};
    if (!IVpnCustomPromptElement_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnCustomPromptElement_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnCustomPromptElement, nullptr))};
    if (!ImplementsIVpnCustomPromptElement_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnCustomPromptElement_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnDomainNameInfoFactory_type{py::register_python_type(module.get(), &type_spec_IVpnDomainNameInfoFactory, object_bases.get(), nullptr)};
    if (!IVpnDomainNameInfoFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnDomainNameInfoFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnDomainNameInfoFactory, nullptr))};
    if (!ImplementsIVpnDomainNameInfoFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnDomainNameInfoFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnInterfaceIdFactory_type{py::register_python_type(module.get(), &type_spec_IVpnInterfaceIdFactory, object_bases.get(), nullptr)};
    if (!IVpnInterfaceIdFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnInterfaceIdFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnInterfaceIdFactory, nullptr))};
    if (!ImplementsIVpnInterfaceIdFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnInterfaceIdFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnNamespaceInfoFactory_type{py::register_python_type(module.get(), &type_spec_IVpnNamespaceInfoFactory, object_bases.get(), nullptr)};
    if (!IVpnNamespaceInfoFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnNamespaceInfoFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnNamespaceInfoFactory, nullptr))};
    if (!ImplementsIVpnNamespaceInfoFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnNamespaceInfoFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnPacketBufferFactory_type{py::register_python_type(module.get(), &type_spec_IVpnPacketBufferFactory, object_bases.get(), nullptr)};
    if (!IVpnPacketBufferFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnPacketBufferFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnPacketBufferFactory, nullptr))};
    if (!ImplementsIVpnPacketBufferFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnPacketBufferFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnPlugIn_type{py::register_python_type(module.get(), &type_spec_IVpnPlugIn, object_bases.get(), nullptr)};
    if (!IVpnPlugIn_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnPlugIn_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnPlugIn, nullptr))};
    if (!ImplementsIVpnPlugIn_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnPlugIn_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnPlugInReconnectTransport_type{py::register_python_type(module.get(), &type_spec_IVpnPlugInReconnectTransport, object_bases.get(), nullptr)};
    if (!IVpnPlugInReconnectTransport_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnPlugInReconnectTransport_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnPlugInReconnectTransport, nullptr))};
    if (!ImplementsIVpnPlugInReconnectTransport_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnPlugInReconnectTransport_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnProfile_type{py::register_python_type(module.get(), &type_spec_IVpnProfile, object_bases.get(), nullptr)};
    if (!IVpnProfile_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnProfile_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnProfile, nullptr))};
    if (!ImplementsIVpnProfile_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnProfile_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IVpnRouteFactory_type{py::register_python_type(module.get(), &type_spec_IVpnRouteFactory, object_bases.get(), nullptr)};
    if (!IVpnRouteFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIVpnRouteFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIVpnRouteFactory, nullptr))};
    if (!ImplementsIVpnRouteFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIVpnRouteFactory_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
