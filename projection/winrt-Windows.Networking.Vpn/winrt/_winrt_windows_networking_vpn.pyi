# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.activation
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.networking.sockets
import winrt.windows.security.credentials
import winrt.windows.security.cryptography.certificates
import winrt.windows.storage.streams
import winrt.windows.system

from winrt.windows.networking.vpn import VpnAppIdType, VpnAuthenticationMethod, VpnChannelActivityEventType, VpnChannelRequestCredentialsOptions, VpnCredentialType, VpnDataPathType, VpnDomainNameType, VpnIPProtocol, VpnManagementConnectionStatus, VpnManagementErrorStatus, VpnNativeProtocolType, VpnPacketBufferStatus, VpnRoutingPolicyType

Self = typing.TypeVar('Self')

@typing.final
class VpnAppId(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnAppId: ...
    def __new__(cls: typing.Type[VpnAppId], type: VpnAppIdType, value: str) -> VpnAppId:...
    @_property
    def value(self) -> str: ...
    @value.setter
    def value(self, value: str) -> None: ...
    @_property
    def type(self) -> VpnAppIdType: ...
    @type.setter
    def type(self, value: VpnAppIdType) -> None: ...

@typing.final
class VpnChannel_Static(type):
    def process_event_async(cls, third_party_plug_in: typing.Optional[winrt.system.Object], event: typing.Optional[winrt.system.Object], /) -> None: ...

@typing.final
class VpnChannel(winrt.system.Object, metaclass=VpnChannel_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannel: ...
    def activate_foreground(self, package_relative_app_id: str, shared_context: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...
    def add_and_associate_transport(self, transport: typing.Optional[winrt.system.Object], context: typing.Optional[winrt.system.Object], /) -> None: ...
    def append_vpn_receive_packet_buffer(self, decapsulated_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def append_vpn_send_packet_buffer(self, encapsulated_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def associate_transport(self, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], optional_outer_tunnel_transport: typing.Optional[winrt.system.Object], /) -> None: ...
    def flush_vpn_receive_packet_buffers(self) -> None: ...
    def flush_vpn_send_packet_buffers(self) -> None: ...
    def get_slot_type_for_transport_context(self, context: typing.Optional[winrt.system.Object], /) -> winrt.windows.networking.sockets.ControlChannelTriggerStatus: ...
    def get_vpn_receive_packet_buffer(self) -> typing.Optional[VpnPacketBuffer]: ...
    def get_vpn_send_packet_buffer(self) -> typing.Optional[VpnPacketBuffer]: ...
    def log_diagnostic_message(self, message: str, /) -> None: ...
    def replace_and_associate_transport(self, transport: typing.Optional[winrt.system.Object], context: typing.Optional[winrt.system.Object], /) -> None: ...
    def request_credentials(self, cred_type: VpnCredentialType, is_retry: bool, is_single_sign_on_credential: bool, certificate: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate], /) -> typing.Optional[VpnPickedCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, /) -> winrt.windows.foundation.IAsyncOperation[VpnCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, cred_options: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[VpnCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, cred_options: winrt.system.UInt32, certificate: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate], /) -> winrt.windows.foundation.IAsyncOperation[VpnCredential]: ...
    def request_custom_prompt(self, custom_prompt: winrt.windows.foundation.collections.IVectorView[IVpnCustomPrompt], /) -> None: ...
    def request_custom_prompt_async(self, custom_prompt_element: winrt.windows.foundation.collections.IVectorView[IVpnCustomPromptElement], /) -> winrt.windows.foundation.IAsyncAction: ...
    def request_vpn_packet_buffer(self, type: VpnDataPathType, /) -> typing.Optional[VpnPacketBuffer]: ...
    def set_allowed_ssl_tls_versions(self, tunnel_transport: typing.Optional[winrt.system.Object], use_tls12: bool, /) -> None: ...
    def set_error_message(self, message: str, /) -> None: ...
    def start(self, assigned_client_i_pv4list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_i_pv6list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], route_scope: typing.Optional[VpnRouteAssignment], namespace_scope: typing.Optional[VpnNamespaceAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, optimize_for_low_cost_network: bool, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], optional_outer_tunnel_transport: typing.Optional[winrt.system.Object], /) -> None: ...
    def start_existing_transports(self, assigned_client_i_pv4list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_i_pv6list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_domain_name: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, /) -> None: ...
    def start_reconnecting_transport(self, transport: typing.Optional[winrt.system.Object], context: typing.Optional[winrt.system.Object], /) -> None: ...
    def start_with_main_transport(self, assigned_client_i_pv4list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_i_pv6list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_domain_name: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], /) -> None: ...
    @typing.overload
    def start_with_traffic_filter(self, assigned_client_ipv4_addresses: typing.Iterable[winrt.windows.networking.HostName], assigned_client_ipv6_addresses: typing.Iterable[winrt.windows.networking.HostName], vpninterface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_namespace: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, transports: typing.Iterable[winrt.system.Object], assigned_traffic_filters: typing.Optional[VpnTrafficFilterAssignment], /) -> None: ...
    @typing.overload
    def start_with_traffic_filter(self, assigned_client_ipv4_list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_ipv6_list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_namespace: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], optional_outer_tunnel_transport: typing.Optional[winrt.system.Object], assigned_traffic_filters: typing.Optional[VpnTrafficFilterAssignment], /) -> None: ...
    def stop(self) -> None: ...
    def terminate_connection(self, message: str, /) -> None: ...
    def add_activity_change(self, handler: winrt.windows.foundation.TypedEventHandler[VpnChannel, VpnChannelActivityEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activity_change(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_activity_state_change(self, handler: winrt.windows.foundation.TypedEventHandler[VpnChannel, VpnChannelActivityStateChangedArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activity_state_change(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def plug_in_context(self) -> typing.Optional[winrt.system.Object]: ...
    @plug_in_context.setter
    def plug_in_context(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def configuration(self) -> typing.Optional[VpnChannelConfiguration]: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def system_health(self) -> typing.Optional[VpnSystemHealth]: ...
    @_property
    def current_request_transport_context(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class VpnChannelActivityEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannelActivityEventArgs: ...
    @_property
    def type(self) -> VpnChannelActivityEventType: ...

@typing.final
class VpnChannelActivityStateChangedArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannelActivityStateChangedArgs: ...
    @_property
    def activity_state(self) -> VpnChannelActivityEventType: ...

@typing.final
class VpnChannelConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannelConfiguration: ...
    @_property
    def custom_field(self) -> str: ...
    @_property
    def server_host_name_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName]]: ...
    @_property
    def server_service_name(self) -> str: ...
    @_property
    def server_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]: ...

@typing.final
class VpnCredential(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCredential: ...
    @_property
    def additional_pin(self) -> str: ...
    @_property
    def certificate_credential(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def old_password_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @_property
    def passkey_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...

@typing.final
class VpnCustomCheckBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomCheckBox: ...
    def __new__(cls: typing.Type[VpnCustomCheckBox]) -> VpnCustomCheckBox:...
    @_property
    def initial_check_state(self) -> bool: ...
    @initial_check_state.setter
    def initial_check_state(self, value: bool) -> None: ...
    @_property
    def checked(self) -> bool: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def bordered(self) -> bool: ...
    @bordered.setter
    def bordered(self, value: bool) -> None: ...

@typing.final
class VpnCustomComboBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomComboBox: ...
    def __new__(cls: typing.Type[VpnCustomComboBox]) -> VpnCustomComboBox:...
    @_property
    def options_text(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @options_text.setter
    def options_text(self, value: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]) -> None: ...
    @_property
    def selected(self) -> winrt.system.UInt32: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def bordered(self) -> bool: ...
    @bordered.setter
    def bordered(self, value: bool) -> None: ...

@typing.final
class VpnCustomEditBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomEditBox: ...
    def __new__(cls: typing.Type[VpnCustomEditBox]) -> VpnCustomEditBox:...
    @_property
    def no_echo(self) -> bool: ...
    @no_echo.setter
    def no_echo(self, value: bool) -> None: ...
    @_property
    def default_text(self) -> str: ...
    @default_text.setter
    def default_text(self, value: str) -> None: ...
    @_property
    def text(self) -> str: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def bordered(self) -> bool: ...
    @bordered.setter
    def bordered(self, value: bool) -> None: ...

@typing.final
class VpnCustomErrorBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomErrorBox: ...
    def __new__(cls: typing.Type[VpnCustomErrorBox]) -> VpnCustomErrorBox:...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def bordered(self) -> bool: ...
    @bordered.setter
    def bordered(self, value: bool) -> None: ...

@typing.final
class VpnCustomPromptBooleanInput(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptBooleanInput: ...
    def __new__(cls: typing.Type[VpnCustomPromptBooleanInput]) -> VpnCustomPromptBooleanInput:...
    @_property
    def initial_value(self) -> bool: ...
    @initial_value.setter
    def initial_value(self, value: bool) -> None: ...
    @_property
    def value(self) -> bool: ...
    @_property
    def emphasized(self) -> bool: ...
    @emphasized.setter
    def emphasized(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...

@typing.final
class VpnCustomPromptOptionSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptOptionSelector: ...
    def __new__(cls: typing.Type[VpnCustomPromptOptionSelector]) -> VpnCustomPromptOptionSelector:...
    @_property
    def emphasized(self) -> bool: ...
    @emphasized.setter
    def emphasized(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def options(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def selected_index(self) -> winrt.system.UInt32: ...

@typing.final
class VpnCustomPromptText(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptText: ...
    def __new__(cls: typing.Type[VpnCustomPromptText]) -> VpnCustomPromptText:...
    @_property
    def emphasized(self) -> bool: ...
    @emphasized.setter
    def emphasized(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...

@typing.final
class VpnCustomPromptTextInput(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptTextInput: ...
    def __new__(cls: typing.Type[VpnCustomPromptTextInput]) -> VpnCustomPromptTextInput:...
    @_property
    def emphasized(self) -> bool: ...
    @emphasized.setter
    def emphasized(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def placeholder_text(self) -> str: ...
    @placeholder_text.setter
    def placeholder_text(self, value: str) -> None: ...
    @_property
    def is_text_hidden(self) -> bool: ...
    @is_text_hidden.setter
    def is_text_hidden(self, value: bool) -> None: ...
    @_property
    def text(self) -> str: ...

@typing.final
class VpnCustomTextBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomTextBox: ...
    def __new__(cls: typing.Type[VpnCustomTextBox]) -> VpnCustomTextBox:...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def bordered(self) -> bool: ...
    @bordered.setter
    def bordered(self, value: bool) -> None: ...
    @_property
    def display_text(self) -> str: ...
    @display_text.setter
    def display_text(self, value: str) -> None: ...

@typing.final
class VpnDomainNameAssignment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnDomainNameAssignment: ...
    def __new__(cls: typing.Type[VpnDomainNameAssignment]) -> VpnDomainNameAssignment:...
    @_property
    def proxy_auto_configuration_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @proxy_auto_configuration_uri.setter
    def proxy_auto_configuration_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def domain_name_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]: ...

@typing.final
class VpnDomainNameInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnDomainNameInfo: ...
    def __new__(cls: typing.Type[VpnDomainNameInfo], name: str, name_type: VpnDomainNameType, dns_server_list: typing.Iterable[winrt.windows.networking.HostName], proxy_server_list: typing.Iterable[winrt.windows.networking.HostName]) -> VpnDomainNameInfo:...
    @_property
    def domain_name_type(self) -> VpnDomainNameType: ...
    @domain_name_type.setter
    def domain_name_type(self, value: VpnDomainNameType) -> None: ...
    @_property
    def domain_name(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @domain_name.setter
    def domain_name(self, value: typing.Optional[winrt.windows.networking.HostName]) -> None: ...
    @_property
    def dns_servers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]: ...
    @_property
    def web_proxy_servers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]: ...
    @_property
    def web_proxy_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...

@typing.final
class VpnForegroundActivatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnForegroundActivatedEventArgs: ...
    @_property
    def kind(self) -> winrt.windows.applicationmodel.activation.ActivationKind: ...
    @_property
    def previous_execution_state(self) -> winrt.windows.applicationmodel.activation.ApplicationExecutionState: ...
    @_property
    def splash_screen(self) -> typing.Optional[winrt.windows.applicationmodel.activation.SplashScreen]: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...
    @_property
    def activation_operation(self) -> typing.Optional[VpnForegroundActivationOperation]: ...
    @_property
    def profile_name(self) -> str: ...
    @_property
    def shared_context(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...

@typing.final
class VpnForegroundActivationOperation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnForegroundActivationOperation: ...
    def complete(self, result: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> None: ...

@typing.final
class VpnInterfaceId(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnInterfaceId: ...
    def __new__(cls: typing.Type[VpnInterfaceId], address: winrt.system.Array[winrt.system.UInt8]) -> VpnInterfaceId:...
    def get_address_info(self) -> winrt.system.Array[winrt.system.UInt8]: ...

@typing.final
class VpnManagementAgent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnManagementAgent: ...
    def __new__(cls: typing.Type[VpnManagementAgent]) -> VpnManagementAgent:...
    def add_profile_from_object_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def add_profile_from_xml_async(self, xml: str, /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def connect_profile_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def connect_profile_with_password_credential_async(self, profile: typing.Optional[IVpnProfile], password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def delete_profile_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def disconnect_profile_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def get_profiles_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IVpnProfile]]: ...
    def update_profile_from_object_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def update_profile_from_xml_async(self, xml: str, /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...

@typing.final
class VpnNamespaceAssignment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnNamespaceAssignment: ...
    def __new__(cls: typing.Type[VpnNamespaceAssignment]) -> VpnNamespaceAssignment:...
    @_property
    def proxy_auto_config_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @proxy_auto_config_uri.setter
    def proxy_auto_config_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def namespace_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnNamespaceInfo]]: ...
    @namespace_list.setter
    def namespace_list(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[VpnNamespaceInfo]]) -> None: ...

@typing.final
class VpnNamespaceInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnNamespaceInfo: ...
    def __new__(cls: typing.Type[VpnNamespaceInfo], name: str, dns_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName], proxy_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]) -> VpnNamespaceInfo:...
    @_property
    def web_proxy_servers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]: ...
    @web_proxy_servers.setter
    def web_proxy_servers(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]) -> None: ...
    @_property
    def namespace(self) -> str: ...
    @namespace.setter
    def namespace(self, value: str) -> None: ...
    @_property
    def dns_servers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]: ...
    @dns_servers.setter
    def dns_servers(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]) -> None: ...

@typing.final
class VpnNativeProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnNativeProfile: ...
    def __new__(cls: typing.Type[VpnNativeProfile]) -> VpnNativeProfile:...
    @_property
    def user_authentication_method(self) -> VpnAuthenticationMethod: ...
    @user_authentication_method.setter
    def user_authentication_method(self, value: VpnAuthenticationMethod) -> None: ...
    @_property
    def tunnel_authentication_method(self) -> VpnAuthenticationMethod: ...
    @tunnel_authentication_method.setter
    def tunnel_authentication_method(self, value: VpnAuthenticationMethod) -> None: ...
    @_property
    def routing_policy_type(self) -> VpnRoutingPolicyType: ...
    @routing_policy_type.setter
    def routing_policy_type(self, value: VpnRoutingPolicyType) -> None: ...
    @_property
    def eap_configuration(self) -> str: ...
    @eap_configuration.setter
    def eap_configuration(self, value: str) -> None: ...
    @_property
    def native_protocol_type(self) -> VpnNativeProtocolType: ...
    @native_protocol_type.setter
    def native_protocol_type(self, value: VpnNativeProtocolType) -> None: ...
    @_property
    def servers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def require_vpn_client_app_u_i(self) -> bool: ...
    @require_vpn_client_app_u_i.setter
    def require_vpn_client_app_u_i(self, value: bool) -> None: ...
    @_property
    def connection_status(self) -> VpnManagementConnectionStatus: ...
    @_property
    def profile_name(self) -> str: ...
    @profile_name.setter
    def profile_name(self, value: str) -> None: ...
    @_property
    def remember_credentials(self) -> bool: ...
    @remember_credentials.setter
    def remember_credentials(self, value: bool) -> None: ...
    @_property
    def always_on(self) -> bool: ...
    @always_on.setter
    def always_on(self, value: bool) -> None: ...
    @_property
    def routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @_property
    def app_triggers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnAppId]]: ...
    @_property
    def traffic_filters(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]: ...
    @_property
    def domain_name_info_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]: ...

@typing.final
class VpnPacketBuffer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPacketBuffer: ...
    def __new__(cls: typing.Type[VpnPacketBuffer], parent_buffer: typing.Optional[VpnPacketBuffer], offset: winrt.system.UInt32, length: winrt.system.UInt32) -> VpnPacketBuffer:...
    @_property
    def transport_affinity(self) -> winrt.system.UInt32: ...
    @transport_affinity.setter
    def transport_affinity(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def status(self) -> VpnPacketBufferStatus: ...
    @status.setter
    def status(self, value: VpnPacketBufferStatus) -> None: ...
    @_property
    def buffer(self) -> typing.Optional[winrt.windows.storage.streams.Buffer]: ...
    @_property
    def app_id(self) -> typing.Optional[VpnAppId]: ...
    @_property
    def transport_context(self) -> typing.Optional[winrt.system.Object]: ...
    @transport_context.setter
    def transport_context(self, value: typing.Optional[winrt.system.Object]) -> None: ...

@typing.final
class VpnPacketBufferList(winrt.system.Object):
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[VpnPacketBuffer]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPacketBufferList: ...
    def add_at_begin(self, next_vpn_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def append(self, next_vpn_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[VpnPacketBuffer]]: ...
    def remove_at_begin(self) -> typing.Optional[VpnPacketBuffer]: ...
    def remove_at_end(self) -> typing.Optional[VpnPacketBuffer]: ...
    @_property
    def status(self) -> VpnPacketBufferStatus: ...
    @status.setter
    def status(self, value: VpnPacketBufferStatus) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class VpnPickedCredential(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPickedCredential: ...
    @_property
    def additional_pin(self) -> str: ...
    @_property
    def old_password_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @_property
    def passkey_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...

@typing.final
class VpnPlugInProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPlugInProfile: ...
    def __new__(cls: typing.Type[VpnPlugInProfile]) -> VpnPlugInProfile:...
    @_property
    def vpn_plugin_package_family_name(self) -> str: ...
    @vpn_plugin_package_family_name.setter
    def vpn_plugin_package_family_name(self, value: str) -> None: ...
    @_property
    def custom_configuration(self) -> str: ...
    @custom_configuration.setter
    def custom_configuration(self, value: str) -> None: ...
    @_property
    def server_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def require_vpn_client_app_u_i(self) -> bool: ...
    @require_vpn_client_app_u_i.setter
    def require_vpn_client_app_u_i(self, value: bool) -> None: ...
    @_property
    def connection_status(self) -> VpnManagementConnectionStatus: ...
    @_property
    def profile_name(self) -> str: ...
    @profile_name.setter
    def profile_name(self, value: str) -> None: ...
    @_property
    def remember_credentials(self) -> bool: ...
    @remember_credentials.setter
    def remember_credentials(self, value: bool) -> None: ...
    @_property
    def always_on(self) -> bool: ...
    @always_on.setter
    def always_on(self, value: bool) -> None: ...
    @_property
    def app_triggers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnAppId]]: ...
    @_property
    def domain_name_info_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]: ...
    @_property
    def routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @_property
    def traffic_filters(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]: ...

@typing.final
class VpnRoute(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnRoute: ...
    def __new__(cls: typing.Type[VpnRoute], address: typing.Optional[winrt.windows.networking.HostName], prefix_size: winrt.system.UInt8) -> VpnRoute:...
    @_property
    def prefix_size(self) -> winrt.system.UInt8: ...
    @prefix_size.setter
    def prefix_size(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @address.setter
    def address(self, value: typing.Optional[winrt.windows.networking.HostName]) -> None: ...

@typing.final
class VpnRouteAssignment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnRouteAssignment: ...
    def __new__(cls: typing.Type[VpnRouteAssignment]) -> VpnRouteAssignment:...
    @_property
    def ipv6_inclusion_routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @ipv6_inclusion_routes.setter
    def ipv6_inclusion_routes(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]) -> None: ...
    @_property
    def ipv6_exclusion_routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @ipv6_exclusion_routes.setter
    def ipv6_exclusion_routes(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]) -> None: ...
    @_property
    def ipv4_inclusion_routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @ipv4_inclusion_routes.setter
    def ipv4_inclusion_routes(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]) -> None: ...
    @_property
    def ipv4_exclusion_routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @ipv4_exclusion_routes.setter
    def ipv4_exclusion_routes(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]) -> None: ...
    @_property
    def exclude_local_subnets(self) -> bool: ...
    @exclude_local_subnets.setter
    def exclude_local_subnets(self, value: bool) -> None: ...

@typing.final
class VpnSystemHealth(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnSystemHealth: ...
    @_property
    def statement_of_health(self) -> typing.Optional[winrt.windows.storage.streams.Buffer]: ...

@typing.final
class VpnTrafficFilter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnTrafficFilter: ...
    def __new__(cls: typing.Type[VpnTrafficFilter], app_id: typing.Optional[VpnAppId]) -> VpnTrafficFilter:...
    @_property
    def routing_policy_type(self) -> VpnRoutingPolicyType: ...
    @routing_policy_type.setter
    def routing_policy_type(self, value: VpnRoutingPolicyType) -> None: ...
    @_property
    def protocol(self) -> VpnIPProtocol: ...
    @protocol.setter
    def protocol(self, value: VpnIPProtocol) -> None: ...
    @_property
    def app_id(self) -> typing.Optional[VpnAppId]: ...
    @app_id.setter
    def app_id(self, value: typing.Optional[VpnAppId]) -> None: ...
    @_property
    def app_claims(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def local_address_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def local_port_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def remote_address_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def remote_port_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class VpnTrafficFilterAssignment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnTrafficFilterAssignment: ...
    def __new__(cls: typing.Type[VpnTrafficFilterAssignment]) -> VpnTrafficFilterAssignment:...
    @_property
    def allow_outbound(self) -> bool: ...
    @allow_outbound.setter
    def allow_outbound(self, value: bool) -> None: ...
    @_property
    def allow_inbound(self) -> bool: ...
    @allow_inbound.setter
    def allow_inbound(self, value: bool) -> None: ...
    @_property
    def traffic_filter_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]: ...

@typing.final
class IVpnChannelStatics(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnChannelStatics: ...
    def process_event_async(self, third_party_plug_in: typing.Optional[winrt.system.Object], event: typing.Optional[winrt.system.Object], /) -> None: ...

@typing.final
class IVpnCredential(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnCredential: ...
    @_property
    def additional_pin(self) -> str: ...
    @_property
    def certificate_credential(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def old_password_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @_property
    def passkey_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...

@typing.final
class IVpnCustomPrompt(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnCustomPrompt: ...
    @_property
    def bordered(self) -> bool: ...
    @bordered.setter
    def bordered(self, value: bool) -> None: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def label(self) -> str: ...
    @label.setter
    def label(self, value: str) -> None: ...

@typing.final
class IVpnCustomPromptElement(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnCustomPromptElement: ...
    @_property
    def compulsory(self) -> bool: ...
    @compulsory.setter
    def compulsory(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def emphasized(self) -> bool: ...
    @emphasized.setter
    def emphasized(self, value: bool) -> None: ...

@typing.final
class IVpnDomainNameInfoFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnDomainNameInfoFactory: ...
    def create_vpn_domain_name_info(self, name: str, name_type: VpnDomainNameType, dns_server_list: typing.Iterable[winrt.windows.networking.HostName], proxy_server_list: typing.Iterable[winrt.windows.networking.HostName], /) -> typing.Optional[VpnDomainNameInfo]: ...

@typing.final
class IVpnInterfaceIdFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnInterfaceIdFactory: ...
    def create_vpn_interface_id(self, address: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[VpnInterfaceId]: ...

@typing.final
class IVpnNamespaceInfoFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnNamespaceInfoFactory: ...
    def create_vpn_namespace_info(self, name: str, dns_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName], proxy_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName], /) -> typing.Optional[VpnNamespaceInfo]: ...

@typing.final
class IVpnPacketBufferFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnPacketBufferFactory: ...
    def create_vpn_packet_buffer(self, parent_buffer: typing.Optional[VpnPacketBuffer], offset: winrt.system.UInt32, length: winrt.system.UInt32, /) -> typing.Optional[VpnPacketBuffer]: ...

@typing.final
class IVpnPlugIn(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnPlugIn: ...
    def connect(self, channel: typing.Optional[VpnChannel], /) -> None: ...
    def decapsulate(self, channel: typing.Optional[VpnChannel], encap_buffer: typing.Optional[VpnPacketBuffer], decapsulated_packets: typing.Optional[VpnPacketBufferList], control_packets_to_send: typing.Optional[VpnPacketBufferList], /) -> None: ...
    def disconnect(self, channel: typing.Optional[VpnChannel], /) -> None: ...
    def encapsulate(self, channel: typing.Optional[VpnChannel], packets: typing.Optional[VpnPacketBufferList], encapulated_packets: typing.Optional[VpnPacketBufferList], /) -> None: ...
    def get_keep_alive_payload(self, channel: typing.Optional[VpnChannel], /) -> typing.Optional[VpnPacketBuffer]: ...

@typing.final
class IVpnProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnProfile: ...
    @_property
    def always_on(self) -> bool: ...
    @always_on.setter
    def always_on(self, value: bool) -> None: ...
    @_property
    def app_triggers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnAppId]]: ...
    @_property
    def domain_name_info_list(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]: ...
    @_property
    def profile_name(self) -> str: ...
    @profile_name.setter
    def profile_name(self, value: str) -> None: ...
    @_property
    def remember_credentials(self) -> bool: ...
    @remember_credentials.setter
    def remember_credentials(self, value: bool) -> None: ...
    @_property
    def routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]: ...
    @_property
    def traffic_filters(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]: ...

@typing.final
class IVpnRouteFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnRouteFactory: ...
    def create_vpn_route(self, address: typing.Optional[winrt.windows.networking.HostName], prefix_size: winrt.system.UInt8, /) -> typing.Optional[VpnRoute]: ...

