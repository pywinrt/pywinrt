// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.h"


namespace py::cpp::Windows::ApplicationModel
{
    // ----- AppDisplayInfo class --------------------

    static PyObject* _new_AppDisplayInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppDisplayInfo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppDisplayInfo_GetLogo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppDisplayInfo", L"GetLogo", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_Description(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppDisplayInfo", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppDisplayInfo", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppDisplayInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppDisplayInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDisplayInfo[] = {
        { "get_logo", reinterpret_cast<PyCFunction>(AppDisplayInfo_GetLogo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppDisplayInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDisplayInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDisplayInfo[] = {
        { "description", reinterpret_cast<getter>(AppDisplayInfo_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppDisplayInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDisplayInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppDisplayInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppDisplayInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppDisplayInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppDisplayInfo) },
        { },
    };

    static PyType_Spec type_spec_AppDisplayInfo =
    {
        "winrt._winrt_windows_applicationmodel.AppDisplayInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppDisplayInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDisplayInfo
    };

    // ----- AppInfo class --------------------

    static PyObject* _new_AppInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::AppInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::AppInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInfo_GetFromAppUserModelId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInfo", L"GetFromAppUserModelId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_GetFromAppUserModelIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInfo", L"GetFromAppUserModelIdForUser", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelIdForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_AppUserModelId(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"AppUserModelId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_DisplayInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"DisplayInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Id(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Package(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_ExecutionContext(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"ExecutionContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExecutionContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_SupportedFileExtensions(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"SupportedFileExtensions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedFileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInfo", L"Current"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::AppInfo::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInfo[] = {
        { "_assign_array_", _assign_array_AppInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInfo[] = {
        { "app_user_model_id", reinterpret_cast<getter>(AppInfo_get_AppUserModelId), nullptr, nullptr, nullptr },
        { "display_info", reinterpret_cast<getter>(AppInfo_get_DisplayInfo), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AppInfo_get_Id), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppInfo_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(AppInfo_get_Package), nullptr, nullptr, nullptr },
        { "execution_context", reinterpret_cast<getter>(AppInfo_get_ExecutionContext), nullptr, nullptr, nullptr },
        { "supported_file_extensions", reinterpret_cast<getter>(AppInfo_get_SupportedFileExtensions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInfo) },
        { },
    };

    static PyType_Spec type_spec_AppInfo =
    {
        "winrt._winrt_windows_applicationmodel.AppInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInfo
    };

    static PyGetSetDef getset_AppInfo_Static[] = {
        { "current", reinterpret_cast<getter>(AppInfo_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppInfo_Static[] = {
        { "get_from_app_user_model_id", reinterpret_cast<PyCFunction>(AppInfo_GetFromAppUserModelId), METH_VARARGS, nullptr },
        { "get_from_app_user_model_id_for_user", reinterpret_cast<PyCFunction>(AppInfo_GetFromAppUserModelIdForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_AppInfo_Static =
    {
        "winrt._winrt_windows_applicationmodel.AppInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppInfo_Static
    };

    // ----- AppInstallerInfo class --------------------

    static PyObject* _new_AppInstallerInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppInstallerInfo(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInstallerInfo_get_Uri(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_AutomaticBackgroundTask(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"AutomaticBackgroundTask"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_DependencyPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"DependencyPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_HoursBetweenUpdateChecks(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"HoursBetweenUpdateChecks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_IsAutoRepairEnabled(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"IsAutoRepairEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_LastChecked(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"LastChecked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OnLaunch(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"OnLaunch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OptionalPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"OptionalPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PausedUntil(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"PausedUntil"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PausedUntil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PolicySource(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"PolicySource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PolicySource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_RepairUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"RepairUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ShowPrompt(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"ShowPrompt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateBlocksActivation(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"UpdateBlocksActivation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"UpdateUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_Version(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstallerInfo", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInstallerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppInstallerInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInstallerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstallerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerInfo[] = {
        { "_assign_array_", _assign_array_AppInstallerInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstallerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstallerInfo[] = {
        { "uri", reinterpret_cast<getter>(AppInstallerInfo_get_Uri), nullptr, nullptr, nullptr },
        { "automatic_background_task", reinterpret_cast<getter>(AppInstallerInfo_get_AutomaticBackgroundTask), nullptr, nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AppInstallerInfo_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AppInstallerInfo_get_ForceUpdateFromAnyVersion), nullptr, nullptr, nullptr },
        { "hours_between_update_checks", reinterpret_cast<getter>(AppInstallerInfo_get_HoursBetweenUpdateChecks), nullptr, nullptr, nullptr },
        { "is_auto_repair_enabled", reinterpret_cast<getter>(AppInstallerInfo_get_IsAutoRepairEnabled), nullptr, nullptr, nullptr },
        { "last_checked", reinterpret_cast<getter>(AppInstallerInfo_get_LastChecked), nullptr, nullptr, nullptr },
        { "on_launch", reinterpret_cast<getter>(AppInstallerInfo_get_OnLaunch), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AppInstallerInfo_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "paused_until", reinterpret_cast<getter>(AppInstallerInfo_get_PausedUntil), nullptr, nullptr, nullptr },
        { "policy_source", reinterpret_cast<getter>(AppInstallerInfo_get_PolicySource), nullptr, nullptr, nullptr },
        { "repair_uris", reinterpret_cast<getter>(AppInstallerInfo_get_RepairUris), nullptr, nullptr, nullptr },
        { "show_prompt", reinterpret_cast<getter>(AppInstallerInfo_get_ShowPrompt), nullptr, nullptr, nullptr },
        { "update_blocks_activation", reinterpret_cast<getter>(AppInstallerInfo_get_UpdateBlocksActivation), nullptr, nullptr, nullptr },
        { "update_uris", reinterpret_cast<getter>(AppInstallerInfo_get_UpdateUris), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(AppInstallerInfo_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInstallerInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInstallerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInstallerInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInstallerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInstallerInfo) },
        { },
    };

    static PyType_Spec type_spec_AppInstallerInfo =
    {
        "winrt._winrt_windows_applicationmodel.AppInstallerInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstallerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerInfo
    };

    // ----- AppInstance class --------------------

    static PyObject* _new_AppInstance(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::AppInstance>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::AppInstance>::type_name);
        return nullptr;
    }

    static void _dealloc_AppInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInstance_FindOrRegisterInstanceForKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"FindOrRegisterInstanceForKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInstance::FindOrRegisterInstanceForKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"GetActivatedEventArgs", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetActivatedEventArgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetInstances(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"GetInstances", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetInstances());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_RedirectActivationTo(py::wrapper::Windows::ApplicationModel::AppInstance* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"RedirectActivationTo", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RedirectActivationTo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.AppInstance", L"Unregister", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::ApplicationModel::AppInstance::Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_IsCurrentInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstance", L"IsCurrentInstance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCurrentInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_Key(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstance", L"Key"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_RecommendedInstance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.AppInstance", L"RecommendedInstance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::AppInstance::RecommendedInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::AppInstance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstance[] = {
        { "redirect_activation_to", reinterpret_cast<PyCFunction>(AppInstance_RedirectActivationTo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppInstance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstance[] = {
        { "is_current_instance", reinterpret_cast<getter>(AppInstance_get_IsCurrentInstance), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(AppInstance_get_Key), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInstance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInstance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInstance) },
        { },
    };

    static PyType_Spec type_spec_AppInstance =
    {
        "winrt._winrt_windows_applicationmodel.AppInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstance
    };

    static PyGetSetDef getset_AppInstance_Static[] = {
        { "recommended_instance", reinterpret_cast<getter>(AppInstance_get_RecommendedInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppInstance_Static[] = {
        { "find_or_register_instance_for_key", reinterpret_cast<PyCFunction>(AppInstance_FindOrRegisterInstanceForKey), METH_VARARGS, nullptr },
        { "get_activated_event_args", reinterpret_cast<PyCFunction>(AppInstance_GetActivatedEventArgs), METH_VARARGS, nullptr },
        { "get_instances", reinterpret_cast<PyCFunction>(AppInstance_GetInstances), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(AppInstance_Unregister), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppInstance_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppInstance_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppInstance_Static) },
        { }
    };

    static PyType_Spec type_spec_AppInstance_Static =
    {
        "winrt._winrt_windows_applicationmodel.AppInstance_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppInstance_Static
    };

    // ----- CameraApplicationManager class --------------------

    static PyObject* _new_CameraApplicationManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::CameraApplicationManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::CameraApplicationManager>::type_name);
        return nullptr;
    }

    static PyObject* CameraApplicationManager_ShowInstalledApplicationsUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.CameraApplicationManager", L"ShowInstalledApplicationsUI", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::ApplicationModel::CameraApplicationManager::ShowInstalledApplicationsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraApplicationManager[] = {
        { }
    };

    static PyGetSetDef _getset_CameraApplicationManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CameraApplicationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraApplicationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraApplicationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraApplicationManager) },
        { },
    };

    static PyType_Spec type_spec_CameraApplicationManager =
    {
        "winrt._winrt_windows_applicationmodel.CameraApplicationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraApplicationManager
    };

    static PyGetSetDef getset_CameraApplicationManager_Static[] = {
        { }
    };

    static PyMethodDef methods_CameraApplicationManager_Static[] = {
        { "show_installed_applications_u_i", reinterpret_cast<PyCFunction>(CameraApplicationManager_ShowInstalledApplicationsUI), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CameraApplicationManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CameraApplicationManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CameraApplicationManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CameraApplicationManager_Static =
    {
        "winrt._winrt_windows_applicationmodel.CameraApplicationManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CameraApplicationManager_Static
    };

    // ----- DesignMode class --------------------

    static PyObject* _new_DesignMode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::DesignMode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::DesignMode>::type_name);
        return nullptr;
    }

    static PyObject* DesignMode_get_DesignModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DesignMode", L"DesignModeEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesignMode_get_DesignMode2Enabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.DesignMode", L"DesignMode2Enabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignMode2Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesignMode[] = {
        { }
    };

    static PyGetSetDef _getset_DesignMode[] = {
        { }
    };

    static PyType_Slot _type_slots_DesignMode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesignMode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesignMode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesignMode) },
        { },
    };

    static PyType_Spec type_spec_DesignMode =
    {
        "winrt._winrt_windows_applicationmodel.DesignMode",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesignMode
    };

    static PyGetSetDef getset_DesignMode_Static[] = {
        { "design_mode_enabled", reinterpret_cast<getter>(DesignMode_get_DesignModeEnabled), nullptr, nullptr, nullptr },
        { "design_mode2_enabled", reinterpret_cast<getter>(DesignMode_get_DesignMode2Enabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DesignMode_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DesignMode_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DesignMode_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DesignMode_Static) },
        { }
    };

    static PyType_Spec type_spec_DesignMode_Static =
    {
        "winrt._winrt_windows_applicationmodel.DesignMode_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DesignMode_Static
    };

    // ----- EnteredBackgroundEventArgs class --------------------

    static PyObject* _new_EnteredBackgroundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.EnteredBackgroundEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_EnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnteredBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnteredBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnteredBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnteredBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EnteredBackgroundEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.EnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredBackgroundEventArgs
    };

    // ----- FindRelatedPackagesOptions class --------------------

    static PyObject* _new_FindRelatedPackagesOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageRelationship>(args, 0);

                winrt::Windows::ApplicationModel::FindRelatedPackagesOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindRelatedPackagesOptions(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FindRelatedPackagesOptions_get_Relationship(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"Relationship"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Relationship());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_Relationship(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"Relationship"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageRelationship>(arg);

            self->obj.Relationship(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeResources(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeResources(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeOptionals(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeOptionals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeOptionals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeOptionals(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeOptionals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeOptionals(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeHostRuntimes(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeHostRuntimes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeHostRuntimes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeHostRuntimes(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeHostRuntimes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeHostRuntimes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindRelatedPackagesOptions_get_IncludeFrameworks(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeFrameworks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncludeFrameworks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindRelatedPackagesOptions_put_IncludeFrameworks(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FindRelatedPackagesOptions", L"IncludeFrameworks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeFrameworks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FindRelatedPackagesOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FindRelatedPackagesOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindRelatedPackagesOptions[] = {
        { "_assign_array_", _assign_array_FindRelatedPackagesOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FindRelatedPackagesOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FindRelatedPackagesOptions[] = {
        { "relationship", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_Relationship), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_Relationship), nullptr, nullptr },
        { "include_resources", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeResources), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeResources), nullptr, nullptr },
        { "include_optionals", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeOptionals), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeOptionals), nullptr, nullptr },
        { "include_host_runtimes", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeHostRuntimes), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeHostRuntimes), nullptr, nullptr },
        { "include_frameworks", reinterpret_cast<getter>(FindRelatedPackagesOptions_get_IncludeFrameworks), reinterpret_cast<setter>(FindRelatedPackagesOptions_put_IncludeFrameworks), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FindRelatedPackagesOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FindRelatedPackagesOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FindRelatedPackagesOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FindRelatedPackagesOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FindRelatedPackagesOptions) },
        { },
    };

    static PyType_Spec type_spec_FindRelatedPackagesOptions =
    {
        "winrt._winrt_windows_applicationmodel.FindRelatedPackagesOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::FindRelatedPackagesOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindRelatedPackagesOptions
    };

    // ----- FullTrustProcessLaunchResult class --------------------

    static PyObject* _new_FullTrustProcessLaunchResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>::type_name);
        return nullptr;
    }

    static void _dealloc_FullTrustProcessLaunchResult(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FullTrustProcessLaunchResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FullTrustProcessLaunchResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLaunchResult_get_LaunchResult(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.FullTrustProcessLaunchResult", L"LaunchResult"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LaunchResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FullTrustProcessLaunchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FullTrustProcessLaunchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::FullTrustProcessLaunchResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullTrustProcessLaunchResult[] = {
        { "_assign_array_", _assign_array_FullTrustProcessLaunchResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FullTrustProcessLaunchResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FullTrustProcessLaunchResult[] = {
        { "extended_error", reinterpret_cast<getter>(FullTrustProcessLaunchResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "launch_result", reinterpret_cast<getter>(FullTrustProcessLaunchResult_get_LaunchResult), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FullTrustProcessLaunchResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FullTrustProcessLaunchResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FullTrustProcessLaunchResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FullTrustProcessLaunchResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FullTrustProcessLaunchResult) },
        { },
    };

    static PyType_Spec type_spec_FullTrustProcessLaunchResult =
    {
        "winrt._winrt_windows_applicationmodel.FullTrustProcessLaunchResult",
        sizeof(py::wrapper::Windows::ApplicationModel::FullTrustProcessLaunchResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullTrustProcessLaunchResult
    };

    // ----- FullTrustProcessLauncher class --------------------

    static PyObject* _new_FullTrustProcessLauncher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::FullTrustProcessLauncher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::FullTrustProcessLauncher>::type_name);
        return nullptr;
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForAppAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForAppAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForAppAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForAppWithArgumentsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForAppWithArgumentsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForAppWithArgumentsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForCurrentAppAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForCurrentAppAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForCurrentAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppWithArgumentsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.FullTrustProcessLauncher", L"LaunchFullTrustProcessForCurrentAppWithArgumentsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::FullTrustProcessLauncher::LaunchFullTrustProcessForCurrentAppWithArgumentsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullTrustProcessLauncher[] = {
        { }
    };

    static PyGetSetDef _getset_FullTrustProcessLauncher[] = {
        { }
    };

    static PyType_Slot _type_slots_FullTrustProcessLauncher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FullTrustProcessLauncher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FullTrustProcessLauncher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FullTrustProcessLauncher) },
        { },
    };

    static PyType_Spec type_spec_FullTrustProcessLauncher =
    {
        "winrt._winrt_windows_applicationmodel.FullTrustProcessLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullTrustProcessLauncher
    };

    static PyGetSetDef getset_FullTrustProcessLauncher_Static[] = {
        { }
    };

    static PyMethodDef methods_FullTrustProcessLauncher_Static[] = {
        { "launch_full_trust_process_for_app_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForAppAsync), METH_VARARGS, nullptr },
        { "launch_full_trust_process_for_app_with_arguments_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForAppWithArgumentsAsync), METH_VARARGS, nullptr },
        { "launch_full_trust_process_for_current_app_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppAsync), METH_VARARGS, nullptr },
        { "launch_full_trust_process_for_current_app_with_arguments_async", reinterpret_cast<PyCFunction>(FullTrustProcessLauncher_LaunchFullTrustProcessForCurrentAppWithArgumentsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FullTrustProcessLauncher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FullTrustProcessLauncher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FullTrustProcessLauncher_Static) },
        { }
    };

    static PyType_Spec type_spec_FullTrustProcessLauncher_Static =
    {
        "winrt._winrt_windows_applicationmodel.FullTrustProcessLauncher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FullTrustProcessLauncher_Static
    };

    // ----- LeavingBackgroundEventArgs class --------------------

    static PyObject* _new_LeavingBackgroundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.LeavingBackgroundEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_LeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LeavingBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LeavingBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LeavingBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LeavingBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LeavingBackgroundEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.LeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LeavingBackgroundEventArgs
    };

    // ----- LimitedAccessFeatureRequestResult class --------------------

    static PyObject* _new_LimitedAccessFeatureRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_LimitedAccessFeatureRequestResult(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.LimitedAccessFeatureRequestResult", L"EstimatedRemovalDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EstimatedRemovalDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_FeatureId(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.LimitedAccessFeatureRequestResult", L"FeatureId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FeatureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_Status(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.LimitedAccessFeatureRequestResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LimitedAccessFeatureRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LimitedAccessFeatureRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatureRequestResult[] = {
        { "_assign_array_", _assign_array_LimitedAccessFeatureRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LimitedAccessFeatureRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimitedAccessFeatureRequestResult[] = {
        { "estimated_removal_date", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate), nullptr, nullptr, nullptr },
        { "feature_id", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_FeatureId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatureRequestResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimitedAccessFeatureRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LimitedAccessFeatureRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimitedAccessFeatureRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimitedAccessFeatureRequestResult) },
        { },
    };

    static PyType_Spec type_spec_LimitedAccessFeatureRequestResult =
    {
        "winrt._winrt_windows_applicationmodel.LimitedAccessFeatureRequestResult",
        sizeof(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatureRequestResult
    };

    // ----- LimitedAccessFeatures class --------------------

    static PyObject* _new_LimitedAccessFeatures(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::type_name);
        return nullptr;
    }

    static PyObject* LimitedAccessFeatures_TryUnlockFeature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.LimitedAccessFeatures", L"TryUnlockFeature", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::LimitedAccessFeatures::TryUnlockFeature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatures[] = {
        { }
    };

    static PyGetSetDef _getset_LimitedAccessFeatures[] = {
        { }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatures[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimitedAccessFeatures) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimitedAccessFeatures) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimitedAccessFeatures) },
        { },
    };

    static PyType_Spec type_spec_LimitedAccessFeatures =
    {
        "winrt._winrt_windows_applicationmodel.LimitedAccessFeatures",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatures
    };

    static PyGetSetDef getset_LimitedAccessFeatures_Static[] = {
        { }
    };

    static PyMethodDef methods_LimitedAccessFeatures_Static[] = {
        { "try_unlock_feature", reinterpret_cast<PyCFunction>(LimitedAccessFeatures_TryUnlockFeature), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LimitedAccessFeatures_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LimitedAccessFeatures_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LimitedAccessFeatures_Static) },
        { }
    };

    static PyType_Spec type_spec_LimitedAccessFeatures_Static =
    {
        "winrt._winrt_windows_applicationmodel.LimitedAccessFeatures_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LimitedAccessFeatures_Static
    };

    // ----- Package class --------------------

    static PyObject* _new_Package(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Package>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Package>::type_name);
        return nullptr;
    }

    static void _dealloc_Package(py::wrapper::Windows::ApplicationModel::Package* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Package_CheckUpdateAvailabilityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"CheckUpdateAvailabilityAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CheckUpdateAvailabilityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_FindRelatedPackages(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"FindRelatedPackages", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::FindRelatedPackagesOptions>(args, 0);

                return py::convert(self->obj.FindRelatedPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppInstallerInfo(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetAppInstallerInfo", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAppInstallerInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntries(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetAppListEntries", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAppListEntries());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntriesAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetAppListEntriesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAppListEntriesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetContentGroupAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetContentGroupsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetContentGroupsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetLogoAsRandomAccessStreamReference(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetLogoAsRandomAccessStreamReference", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogoAsRandomAccessStreamReference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetThumbnailToken(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"GetThumbnailToken", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetThumbnailToken());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_Launch(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"Launch", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Launch(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_SetInUseAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"SetInUseAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetInUseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_StageContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"StageContentGroupsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.StageContentGroupsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"StageContentGroupsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StageContentGroupsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_VerifyContentIntegrityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Package", L"VerifyContentIntegrityAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.VerifyContentIntegrityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_get_Dependencies(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Dependencies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dependencies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Id(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstalledLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstalledLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsFramework(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsFramework"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFramework());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Description(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_DisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsBundle(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsBundle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBundle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsDevelopmentMode(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsDevelopmentMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDevelopmentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsResourcePackage(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsResourcePackage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsResourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Logo(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Logo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_PublisherDisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"PublisherDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublisherDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstalledDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstalledDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Status(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsOptional(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsOptional"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOptional());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_SignatureKind(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"SignatureKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SignatureKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectiveLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EffectiveLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutableLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MutableLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MutableLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectiveExternalLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EffectiveExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectiveExternalPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EffectiveExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectivePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"EffectivePath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EffectivePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstalledPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstalledPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsStub(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"IsStub"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MachineExternalLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MachineExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MachineExternalPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MachineExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutablePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"MutablePath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MutablePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"UserExternalLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"UserExternalPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_SourceUriSchemeName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"SourceUriSchemeName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceUriSchemeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstallDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"InstallDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Package", L"Current"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::Package::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Package(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Package>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Package(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Package>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Package[] = {
        { "check_update_availability_async", reinterpret_cast<PyCFunction>(Package_CheckUpdateAvailabilityAsync), METH_VARARGS, nullptr },
        { "find_related_packages", reinterpret_cast<PyCFunction>(Package_FindRelatedPackages), METH_VARARGS, nullptr },
        { "get_app_installer_info", reinterpret_cast<PyCFunction>(Package_GetAppInstallerInfo), METH_VARARGS, nullptr },
        { "get_app_list_entries", reinterpret_cast<PyCFunction>(Package_GetAppListEntries), METH_VARARGS, nullptr },
        { "get_app_list_entries_async", reinterpret_cast<PyCFunction>(Package_GetAppListEntriesAsync), METH_VARARGS, nullptr },
        { "get_content_group_async", reinterpret_cast<PyCFunction>(Package_GetContentGroupAsync), METH_VARARGS, nullptr },
        { "get_content_groups_async", reinterpret_cast<PyCFunction>(Package_GetContentGroupsAsync), METH_VARARGS, nullptr },
        { "get_logo_as_random_access_stream_reference", reinterpret_cast<PyCFunction>(Package_GetLogoAsRandomAccessStreamReference), METH_VARARGS, nullptr },
        { "get_thumbnail_token", reinterpret_cast<PyCFunction>(Package_GetThumbnailToken), METH_VARARGS, nullptr },
        { "launch", reinterpret_cast<PyCFunction>(Package_Launch), METH_VARARGS, nullptr },
        { "set_in_use_async", reinterpret_cast<PyCFunction>(Package_SetInUseAsync), METH_VARARGS, nullptr },
        { "stage_content_groups_async", reinterpret_cast<PyCFunction>(Package_StageContentGroupsAsync), METH_VARARGS, nullptr },
        { "verify_content_integrity_async", reinterpret_cast<PyCFunction>(Package_VerifyContentIntegrityAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Package, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Package), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Package[] = {
        { "dependencies", reinterpret_cast<getter>(Package_get_Dependencies), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(Package_get_Id), nullptr, nullptr, nullptr },
        { "installed_location", reinterpret_cast<getter>(Package_get_InstalledLocation), nullptr, nullptr, nullptr },
        { "is_framework", reinterpret_cast<getter>(Package_get_IsFramework), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(Package_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(Package_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_bundle", reinterpret_cast<getter>(Package_get_IsBundle), nullptr, nullptr, nullptr },
        { "is_development_mode", reinterpret_cast<getter>(Package_get_IsDevelopmentMode), nullptr, nullptr, nullptr },
        { "is_resource_package", reinterpret_cast<getter>(Package_get_IsResourcePackage), nullptr, nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(Package_get_Logo), nullptr, nullptr, nullptr },
        { "publisher_display_name", reinterpret_cast<getter>(Package_get_PublisherDisplayName), nullptr, nullptr, nullptr },
        { "installed_date", reinterpret_cast<getter>(Package_get_InstalledDate), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(Package_get_Status), nullptr, nullptr, nullptr },
        { "is_optional", reinterpret_cast<getter>(Package_get_IsOptional), nullptr, nullptr, nullptr },
        { "signature_kind", reinterpret_cast<getter>(Package_get_SignatureKind), nullptr, nullptr, nullptr },
        { "effective_location", reinterpret_cast<getter>(Package_get_EffectiveLocation), nullptr, nullptr, nullptr },
        { "mutable_location", reinterpret_cast<getter>(Package_get_MutableLocation), nullptr, nullptr, nullptr },
        { "effective_external_location", reinterpret_cast<getter>(Package_get_EffectiveExternalLocation), nullptr, nullptr, nullptr },
        { "effective_external_path", reinterpret_cast<getter>(Package_get_EffectiveExternalPath), nullptr, nullptr, nullptr },
        { "effective_path", reinterpret_cast<getter>(Package_get_EffectivePath), nullptr, nullptr, nullptr },
        { "installed_path", reinterpret_cast<getter>(Package_get_InstalledPath), nullptr, nullptr, nullptr },
        { "is_stub", reinterpret_cast<getter>(Package_get_IsStub), nullptr, nullptr, nullptr },
        { "machine_external_location", reinterpret_cast<getter>(Package_get_MachineExternalLocation), nullptr, nullptr, nullptr },
        { "machine_external_path", reinterpret_cast<getter>(Package_get_MachineExternalPath), nullptr, nullptr, nullptr },
        { "mutable_path", reinterpret_cast<getter>(Package_get_MutablePath), nullptr, nullptr, nullptr },
        { "user_external_location", reinterpret_cast<getter>(Package_get_UserExternalLocation), nullptr, nullptr, nullptr },
        { "user_external_path", reinterpret_cast<getter>(Package_get_UserExternalPath), nullptr, nullptr, nullptr },
        { "source_uri_scheme_name", reinterpret_cast<getter>(Package_get_SourceUriSchemeName), nullptr, nullptr, nullptr },
        { "install_date", reinterpret_cast<getter>(Package_get_InstallDate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Package[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Package) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Package) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Package) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Package) },
        { },
    };

    static PyType_Spec type_spec_Package =
    {
        "winrt._winrt_windows_applicationmodel.Package",
        sizeof(py::wrapper::Windows::ApplicationModel::Package),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Package
    };

    static PyGetSetDef getset_Package_Static[] = {
        { "current", reinterpret_cast<getter>(Package_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Package_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Package_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Package_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Package_Static) },
        { }
    };

    static PyType_Spec type_spec_Package_Static =
    {
        "winrt._winrt_windows_applicationmodel.Package_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Package_Static
    };

    // ----- PackageCatalog class --------------------

    static PyObject* _new_PackageCatalog(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageCatalog>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageCatalog>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageCatalog(py::wrapper::Windows::ApplicationModel::PackageCatalog* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalog_AddOptionalPackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"AddOptionalPackageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_AddResourcePackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"AddResourcePackageAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::AddResourcePackageOptions>(args, 2);

                return py::convert(self->obj.AddResourcePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"OpenForCurrentPackage", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentPackage());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"OpenForCurrentUser", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentUser());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"OpenForPackage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveOptionalPackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"RemoveOptionalPackagesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RemoveOptionalPackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveResourcePackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageCatalog", L"RemoveResourcePackagesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Package>>(args, 0);

                return py::convert(self->obj.RemoveResourcePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageInstalling"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageInstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageInstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageInstalling"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageInstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStaging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStaging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.PackageStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUninstalling"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageUninstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUninstalling"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUninstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUpdating"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>>(arg);

            return py::convert(self->obj.PackageUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageUpdating"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageContentGroupStaging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageContentGroupStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.PackageCatalog", L"PackageContentGroupStaging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageContentGroupStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalog>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalog>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalog[] = {
        { "add_optional_package_async", reinterpret_cast<PyCFunction>(PackageCatalog_AddOptionalPackageAsync), METH_VARARGS, nullptr },
        { "add_resource_package_async", reinterpret_cast<PyCFunction>(PackageCatalog_AddResourcePackageAsync), METH_VARARGS, nullptr },
        { "remove_optional_packages_async", reinterpret_cast<PyCFunction>(PackageCatalog_RemoveOptionalPackagesAsync), METH_VARARGS, nullptr },
        { "remove_resource_packages_async", reinterpret_cast<PyCFunction>(PackageCatalog_RemoveResourcePackagesAsync), METH_VARARGS, nullptr },
        { "add_package_installing", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageInstalling), METH_O, nullptr },
        { "remove_package_installing", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageInstalling), METH_O, nullptr },
        { "add_package_staging", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageStaging), METH_O, nullptr },
        { "remove_package_staging", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageStaging), METH_O, nullptr },
        { "add_package_status_changed", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageStatusChanged), METH_O, nullptr },
        { "remove_package_status_changed", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageStatusChanged), METH_O, nullptr },
        { "add_package_uninstalling", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageUninstalling), METH_O, nullptr },
        { "remove_package_uninstalling", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageUninstalling), METH_O, nullptr },
        { "add_package_updating", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageUpdating), METH_O, nullptr },
        { "remove_package_updating", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageUpdating), METH_O, nullptr },
        { "add_package_content_group_staging", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageContentGroupStaging), METH_O, nullptr },
        { "remove_package_content_group_staging", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageContentGroupStaging), METH_O, nullptr },
        { "_assign_array_", _assign_array_PackageCatalog, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalog), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalog[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageCatalog[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalog) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalog) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalog) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalog) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalog =
    {
        "winrt._winrt_windows_applicationmodel.PackageCatalog",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalog),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalog
    };

    static PyGetSetDef getset_PackageCatalog_Static[] = {
        { }
    };

    static PyMethodDef methods_PackageCatalog_Static[] = {
        { "open_for_current_package", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForCurrentPackage), METH_VARARGS, nullptr },
        { "open_for_current_user", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForCurrentUser), METH_VARARGS, nullptr },
        { "open_for_package", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForPackage), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PackageCatalog_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageCatalog_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageCatalog_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageCatalog_Static =
    {
        "winrt._winrt_windows_applicationmodel.PackageCatalog_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageCatalog_Static
    };

    // ----- PackageCatalogAddOptionalPackageResult class --------------------

    static PyObject* _new_PackageCatalogAddOptionalPackageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddOptionalPackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddOptionalPackageResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddOptionalPackageResult", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogAddOptionalPackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogAddOptionalPackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddOptionalPackageResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogAddOptionalPackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogAddOptionalPackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogAddOptionalPackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogAddOptionalPackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageCatalogAddOptionalPackageResult_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogAddOptionalPackageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogAddOptionalPackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogAddOptionalPackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogAddOptionalPackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogAddOptionalPackageResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogAddOptionalPackageResult =
    {
        "winrt._winrt_windows_applicationmodel.PackageCatalogAddOptionalPackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddOptionalPackageResult
    };

    // ----- PackageCatalogAddResourcePackageResult class --------------------

    static PyObject* _new_PackageCatalogAddResourcePackageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddResourcePackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddResourcePackageResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddResourcePackageResult", L"IsComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogAddResourcePackageResult", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogAddResourcePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogAddResourcePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddResourcePackageResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogAddResourcePackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogAddResourcePackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogAddResourcePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogAddResourcePackageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogAddResourcePackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogAddResourcePackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogAddResourcePackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogAddResourcePackageResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogAddResourcePackageResult =
    {
        "winrt._winrt_windows_applicationmodel.PackageCatalogAddResourcePackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddResourcePackageResult
    };

    // ----- PackageCatalogRemoveOptionalPackagesResult class --------------------

    static PyObject* _new_PackageCatalogRemoveOptionalPackagesResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveOptionalPackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveOptionalPackagesResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveOptionalPackagesResult", L"PackagesRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogRemoveOptionalPackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogRemoveOptionalPackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogRemoveOptionalPackagesResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogRemoveOptionalPackagesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "packages_removed", reinterpret_cast<getter>(PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveOptionalPackagesResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogRemoveOptionalPackagesResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogRemoveOptionalPackagesResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogRemoveOptionalPackagesResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogRemoveOptionalPackagesResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogRemoveOptionalPackagesResult =
    {
        "winrt._winrt_windows_applicationmodel.PackageCatalogRemoveOptionalPackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveOptionalPackagesResult
    };

    // ----- PackageCatalogRemoveResourcePackagesResult class --------------------

    static PyObject* _new_PackageCatalogRemoveResourcePackagesResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveResourcePackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveResourcePackagesResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageCatalogRemoveResourcePackagesResult", L"PackagesRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageCatalogRemoveResourcePackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageCatalogRemoveResourcePackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveResourcePackagesResult[] = {
        { "_assign_array_", _assign_array_PackageCatalogRemoveResourcePackagesResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogRemoveResourcePackagesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveResourcePackagesResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogRemoveResourcePackagesResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "packages_removed", reinterpret_cast<getter>(PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveResourcePackagesResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageCatalogRemoveResourcePackagesResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageCatalogRemoveResourcePackagesResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageCatalogRemoveResourcePackagesResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageCatalogRemoveResourcePackagesResult) },
        { },
    };

    static PyType_Spec type_spec_PackageCatalogRemoveResourcePackagesResult =
    {
        "winrt._winrt_windows_applicationmodel.PackageCatalogRemoveResourcePackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveResourcePackagesResult
    };

    // ----- PackageContentGroup class --------------------

    static PyObject* _new_PackageContentGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageContentGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageContentGroup>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageContentGroup(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageContentGroup_get_IsRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"IsRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Name(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_State(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_RequiredGroupName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroup", L"RequiredGroupName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::ApplicationModel::PackageContentGroup::RequiredGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageContentGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageContentGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageContentGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroup[] = {
        { "_assign_array_", _assign_array_PackageContentGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageContentGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageContentGroup[] = {
        { "is_required", reinterpret_cast<getter>(PackageContentGroup_get_IsRequired), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageContentGroup_get_Name), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageContentGroup_get_Package), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PackageContentGroup_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageContentGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageContentGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageContentGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageContentGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageContentGroup) },
        { },
    };

    static PyType_Spec type_spec_PackageContentGroup =
    {
        "winrt._winrt_windows_applicationmodel.PackageContentGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroup
    };

    static PyGetSetDef getset_PackageContentGroup_Static[] = {
        { "required_group_name", reinterpret_cast<getter>(PackageContentGroup_get_RequiredGroupName), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PackageContentGroup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PackageContentGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageContentGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageContentGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageContentGroup_Static =
    {
        "winrt._winrt_windows_applicationmodel.PackageContentGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageContentGroup_Static
    };

    // ----- PackageContentGroupStagingEventArgs class --------------------

    static PyObject* _new_PackageContentGroupStagingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageContentGroupStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"ActivityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ContentGroupName(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"ContentGroupName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"IsComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsContentGroupRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"IsContentGroupRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsContentGroupRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageContentGroupStagingEventArgs", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageContentGroupStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageContentGroupStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroupStagingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageContentGroupStagingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageContentGroupStagingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageContentGroupStagingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "content_group_name", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ContentGroupName), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "is_content_group_required", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_IsContentGroupRequired), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageContentGroupStagingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageContentGroupStagingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageContentGroupStagingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageContentGroupStagingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageContentGroupStagingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageContentGroupStagingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.PackageContentGroupStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroupStagingEventArgs
    };

    // ----- PackageId class --------------------

    static PyObject* _new_PackageId(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageId>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageId>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageId(py::wrapper::Windows::ApplicationModel::PackageId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageId_get_Architecture(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Architecture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Architecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FamilyName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"FamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FullName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"FullName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Name(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Publisher(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Publisher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_PublisherId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"PublisherId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublisherId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ResourceId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"ResourceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Version(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Author(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"Author"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ProductId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageId", L"ProductId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageId[] = {
        { "_assign_array_", _assign_array_PackageId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageId[] = {
        { "architecture", reinterpret_cast<getter>(PackageId_get_Architecture), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(PackageId_get_FamilyName), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(PackageId_get_FullName), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageId_get_Name), nullptr, nullptr, nullptr },
        { "publisher", reinterpret_cast<getter>(PackageId_get_Publisher), nullptr, nullptr, nullptr },
        { "publisher_id", reinterpret_cast<getter>(PackageId_get_PublisherId), nullptr, nullptr, nullptr },
        { "resource_id", reinterpret_cast<getter>(PackageId_get_ResourceId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(PackageId_get_Version), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(PackageId_get_Author), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(PackageId_get_ProductId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageId) },
        { },
    };

    static PyType_Spec type_spec_PackageId =
    {
        "winrt._winrt_windows_applicationmodel.PackageId",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageId
    };

    // ----- PackageInstallingEventArgs class --------------------

    static PyObject* _new_PackageInstallingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageInstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageInstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"ActivityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"IsComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageInstallingEventArgs", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageInstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageInstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageInstallingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageInstallingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageInstallingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageInstallingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageInstallingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageInstallingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageInstallingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageInstallingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageInstallingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageInstallingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageInstallingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageInstallingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageInstallingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageInstallingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageInstallingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.PackageInstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallingEventArgs
    };

    // ----- PackageStagingEventArgs class --------------------

    static PyObject* _new_PackageStagingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"ActivityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"IsComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStagingEventArgs", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageStagingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStagingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageStagingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStagingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStagingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageStagingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageStagingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageStagingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageStagingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageStagingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStagingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageStagingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageStagingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageStagingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageStagingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageStagingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.PackageStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStagingEventArgs
    };

    // ----- PackageStatus class --------------------

    static PyObject* _new_PackageStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageStatus(py::wrapper::Windows::ApplicationModel::PackageStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageStatus_VerifyIsOK(py::wrapper::Windows::ApplicationModel::PackageStatus* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.PackageStatus", L"VerifyIsOK", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.VerifyIsOK());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DataOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"DataOffline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DependencyIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"DependencyIssue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DeploymentInProgress(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"DeploymentInProgress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeploymentInProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Disabled(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Disabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_LicenseIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"LicenseIssue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LicenseIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Modified(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Modified"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Modified());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NeedsRemediation(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"NeedsRemediation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NeedsRemediation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NotAvailable(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"NotAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NotAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_PackageOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"PackageOffline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Servicing(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Servicing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Servicing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Tampered(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"Tampered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tampered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_IsPartiallyStaged(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatus", L"IsPartiallyStaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPartiallyStaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatus[] = {
        { "verify_is_o_k", reinterpret_cast<PyCFunction>(PackageStatus_VerifyIsOK), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStatus[] = {
        { "data_offline", reinterpret_cast<getter>(PackageStatus_get_DataOffline), nullptr, nullptr, nullptr },
        { "dependency_issue", reinterpret_cast<getter>(PackageStatus_get_DependencyIssue), nullptr, nullptr, nullptr },
        { "deployment_in_progress", reinterpret_cast<getter>(PackageStatus_get_DeploymentInProgress), nullptr, nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(PackageStatus_get_Disabled), nullptr, nullptr, nullptr },
        { "license_issue", reinterpret_cast<getter>(PackageStatus_get_LicenseIssue), nullptr, nullptr, nullptr },
        { "modified", reinterpret_cast<getter>(PackageStatus_get_Modified), nullptr, nullptr, nullptr },
        { "needs_remediation", reinterpret_cast<getter>(PackageStatus_get_NeedsRemediation), nullptr, nullptr, nullptr },
        { "not_available", reinterpret_cast<getter>(PackageStatus_get_NotAvailable), nullptr, nullptr, nullptr },
        { "package_offline", reinterpret_cast<getter>(PackageStatus_get_PackageOffline), nullptr, nullptr, nullptr },
        { "servicing", reinterpret_cast<getter>(PackageStatus_get_Servicing), nullptr, nullptr, nullptr },
        { "tampered", reinterpret_cast<getter>(PackageStatus_get_Tampered), nullptr, nullptr, nullptr },
        { "is_partially_staged", reinterpret_cast<getter>(PackageStatus_get_IsPartiallyStaged), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageStatus) },
        { },
    };

    static PyType_Spec type_spec_PackageStatus =
    {
        "winrt._winrt_windows_applicationmodel.PackageStatus",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatus
    };

    // ----- PackageStatusChangedEventArgs class --------------------

    static PyObject* _new_PackageStatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageStatusChangedEventArgs(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageStatusChangedEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageStatusChangedEventArgs", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PackageStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStatusChangedEventArgs[] = {
        { "package", reinterpret_cast<getter>(PackageStatusChangedEventArgs_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStatusChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageStatusChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageStatusChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.PackageStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatusChangedEventArgs
    };

    // ----- PackageUninstallingEventArgs class --------------------

    static PyObject* _new_PackageUninstallingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageUninstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUninstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"ActivityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"IsComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"Package"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUninstallingEventArgs", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUninstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUninstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUninstallingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageUninstallingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUninstallingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUninstallingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUninstallingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUninstallingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUninstallingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUninstallingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUninstallingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageUninstallingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.PackageUninstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUninstallingEventArgs
    };

    // ----- PackageUpdateAvailabilityResult class --------------------

    static PyObject* _new_PackageUpdateAvailabilityResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageUpdateAvailabilityResult(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUpdateAvailabilityResult_get_Availability(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdateAvailabilityResult", L"Availability"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Availability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdateAvailabilityResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdateAvailabilityResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUpdateAvailabilityResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUpdateAvailabilityResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdateAvailabilityResult[] = {
        { "_assign_array_", _assign_array_PackageUpdateAvailabilityResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUpdateAvailabilityResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUpdateAvailabilityResult[] = {
        { "availability", reinterpret_cast<getter>(PackageUpdateAvailabilityResult_get_Availability), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PackageUpdateAvailabilityResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUpdateAvailabilityResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUpdateAvailabilityResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUpdateAvailabilityResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUpdateAvailabilityResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUpdateAvailabilityResult) },
        { },
    };

    static PyType_Spec type_spec_PackageUpdateAvailabilityResult =
    {
        "winrt._winrt_windows_applicationmodel.PackageUpdateAvailabilityResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdateAvailabilityResult
    };

    // ----- PackageUpdatingEventArgs class --------------------

    static PyObject* _new_PackageUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageUpdatingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUpdatingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"ActivityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"IsComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_SourcePackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"SourcePackage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_TargetPackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.PackageUpdatingEventArgs", L"TargetPackage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetPackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdatingEventArgs[] = {
        { "_assign_array_", _assign_array_PackageUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUpdatingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { "source_package", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_SourcePackage), nullptr, nullptr, nullptr },
        { "target_package", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_TargetPackage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PackageUpdatingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.PackageUpdatingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdatingEventArgs
    };

    // ----- StartupTask class --------------------

    static PyObject* _new_StartupTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::StartupTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::StartupTask>::type_name);
        return nullptr;
    }

    static void _dealloc_StartupTask(py::wrapper::Windows::ApplicationModel::StartupTask* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartupTask_Disable(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"Disable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"GetAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetForCurrentPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"GetForCurrentPackageAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetForCurrentPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_RequestEnableAsync(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.StartupTask", L"RequestEnableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestEnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_State(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.StartupTask", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_TaskId(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.StartupTask", L"TaskId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StartupTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::StartupTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StartupTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::StartupTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTask[] = {
        { "disable", reinterpret_cast<PyCFunction>(StartupTask_Disable), METH_VARARGS, nullptr },
        { "request_enable_async", reinterpret_cast<PyCFunction>(StartupTask_RequestEnableAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StartupTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartupTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StartupTask[] = {
        { "state", reinterpret_cast<getter>(StartupTask_get_State), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(StartupTask_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StartupTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StartupTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StartupTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StartupTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StartupTask) },
        { },
    };

    static PyType_Spec type_spec_StartupTask =
    {
        "winrt._winrt_windows_applicationmodel.StartupTask",
        sizeof(py::wrapper::Windows::ApplicationModel::StartupTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTask
    };

    static PyGetSetDef getset_StartupTask_Static[] = {
        { }
    };

    static PyMethodDef methods_StartupTask_Static[] = {
        { "get_async", reinterpret_cast<PyCFunction>(StartupTask_GetAsync), METH_VARARGS, nullptr },
        { "get_for_current_package_async", reinterpret_cast<PyCFunction>(StartupTask_GetForCurrentPackageAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StartupTask_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StartupTask_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StartupTask_Static) },
        { }
    };

    static PyType_Spec type_spec_StartupTask_Static =
    {
        "winrt._winrt_windows_applicationmodel.StartupTask_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StartupTask_Static
    };

    // ----- SuspendingDeferral class --------------------

    static PyObject* _new_SuspendingDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SuspendingDeferral(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.SuspendingDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::SuspendingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SuspendingDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingDeferral) },
        { },
    };

    static PyType_Spec type_spec_SuspendingDeferral =
    {
        "winrt._winrt_windows_applicationmodel.SuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingDeferral
    };

    // ----- SuspendingEventArgs class --------------------

    static PyObject* _new_SuspendingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SuspendingEventArgs(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.SuspendingEventArgs", L"SuspendingOperation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::SuspendingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingEventArgs[] = {
        { "_assign_array_", _assign_array_SuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(SuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SuspendingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.SuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingEventArgs
    };

    // ----- SuspendingOperation class --------------------

    static PyObject* _new_SuspendingOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::SuspendingOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::SuspendingOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.SuspendingOperation", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.SuspendingOperation", L"Deadline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::SuspendingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(SuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingOperation) },
        { },
    };

    static PyType_Spec type_spec_SuspendingOperation =
    {
        "winrt._winrt_windows_applicationmodel.SuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingOperation
    };

    // ----- IEnteredBackgroundEventArgs interface --------------------

    static PyObject* _new_IEnteredBackgroundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IEnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IEnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.IEnteredBackgroundEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IEnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IEnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IEnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IEnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IEnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IEnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IEnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_IEnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IEnteredBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IEnteredBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IEnteredBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IEnteredBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_IEnteredBackgroundEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.IEnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IEnteredBackgroundEventArgs
    };

    // ----- ILeavingBackgroundEventArgs interface --------------------

    static PyObject* _new_ILeavingBackgroundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ILeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ILeavingBackgroundEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ILeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ILeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ILeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILeavingBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILeavingBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILeavingBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILeavingBackgroundEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ILeavingBackgroundEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.ILeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILeavingBackgroundEventArgs
    };

    // ----- IPackageCatalogStatics2 interface --------------------

    static PyObject* _new_IPackageCatalogStatics2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>::type_name);
        return nullptr;
    }

    static void _dealloc_IPackageCatalogStatics2(py::wrapper::Windows::ApplicationModel::IPackageCatalogStatics2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPackageCatalogStatics2_OpenForPackage(py::wrapper::Windows::ApplicationModel::IPackageCatalogStatics2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.IPackageCatalogStatics2", L"OpenForPackage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.OpenForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPackageCatalogStatics2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPackageCatalogStatics2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::IPackageCatalogStatics2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPackageCatalogStatics2[] = {
        { "open_for_package", reinterpret_cast<PyCFunction>(IPackageCatalogStatics2_OpenForPackage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPackageCatalogStatics2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPackageCatalogStatics2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPackageCatalogStatics2[] = {
        { }
    };

    static PyType_Slot _type_slots_IPackageCatalogStatics2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPackageCatalogStatics2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPackageCatalogStatics2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPackageCatalogStatics2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPackageCatalogStatics2) },
        { },
    };

    static PyType_Spec type_spec_IPackageCatalogStatics2 =
    {
        "winrt._winrt_windows_applicationmodel.IPackageCatalogStatics2",
        sizeof(py::wrapper::Windows::ApplicationModel::IPackageCatalogStatics2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPackageCatalogStatics2
    };

    // ----- ISuspendingDeferral interface --------------------

    static PyObject* _new_ISuspendingDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ISuspendingDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ISuspendingDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ISuspendingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ISuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ISuspendingDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISuspendingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISuspendingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISuspendingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISuspendingDeferral) },
        { },
    };

    static PyType_Spec type_spec_ISuspendingDeferral =
    {
        "winrt._winrt_windows_applicationmodel.ISuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingDeferral
    };

    // ----- ISuspendingEventArgs interface --------------------

    static PyObject* _new_ISuspendingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ISuspendingEventArgs(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ISuspendingEventArgs", L"SuspendingOperation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ISuspendingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingEventArgs[] = {
        { "_assign_array_", _assign_array_ISuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(ISuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISuspendingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISuspendingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISuspendingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISuspendingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISuspendingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ISuspendingEventArgs =
    {
        "winrt._winrt_windows_applicationmodel.ISuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingEventArgs
    };

    // ----- ISuspendingOperation interface --------------------

    static PyObject* _new_ISuspendingOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_ISuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ISuspendingOperation", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ISuspendingOperation", L"Deadline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ISuspendingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ISuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISuspendingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(ISuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISuspendingOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISuspendingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISuspendingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISuspendingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISuspendingOperation) },
        { },
    };

    static PyType_Spec type_spec_ISuspendingOperation =
    {
        "winrt._winrt_windows_applicationmodel.ISuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingOperation
    };

    // ----- PackageInstallProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageInstallProgress>* _new_PackageInstallProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageInstallProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_PackageInstallProgress(winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageInstallProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _PercentComplete{};

        static const char* kwlist[] = {"percent_complete", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "I", const_cast<char**>(kwlist), &_PercentComplete))
        {
            return -1;
        }

        try
        {
            self->obj = {_PercentComplete};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_PackageInstallProgress(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PackageInstallProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageInstallProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_PackageInstallProgress[] = {
        { "_assign_array_", _assign_array_PackageInstallProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* PackageInstallProgress_get_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentComplete);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageInstallProgress_set_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentComplete = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageInstallProgress[] = {
        { "percent_complete", reinterpret_cast<getter>(PackageInstallProgress_get_PercentComplete), reinterpret_cast<setter>(PackageInstallProgress_set_PercentComplete), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageInstallProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageInstallProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_PackageInstallProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageInstallProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageInstallProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageInstallProgress) },
        { },
    };

    static PyType_Spec type_spec_PackageInstallProgress =
    {
        "winrt._winrt_windows_applicationmodel.PackageInstallProgress",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallProgress
    };

    // ----- PackageVersion struct --------------------

    winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageVersion>* _new_PackageVersion(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageVersion>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_PackageVersion(winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageVersion>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return -1;
        }

        try
        {
            self->obj = {_Major, _Minor, _Build, _Revision};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_PackageVersion(py::wrapper::Windows::ApplicationModel::PackageVersion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PackageVersion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::PackageVersion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_PackageVersion[] = {
        { "_assign_array_", _assign_array_PackageVersion, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* PackageVersion_get_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageVersion[] = {
        { "major", reinterpret_cast<getter>(PackageVersion_get_Major), reinterpret_cast<setter>(PackageVersion_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(PackageVersion_get_Minor), reinterpret_cast<setter>(PackageVersion_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(PackageVersion_get_Build), reinterpret_cast<setter>(PackageVersion_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(PackageVersion_get_Revision), reinterpret_cast<setter>(PackageVersion_set_Revision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageVersion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageVersion) },
        { Py_tp_init, reinterpret_cast<void*>(_init_PackageVersion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageVersion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageVersion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageVersion) },
        { },
    };

    static PyType_Spec type_spec_PackageVersion =
    {
        "winrt._winrt_windows_applicationmodel.PackageVersion",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageVersion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVersion
    };

    // ----- Windows.ApplicationModel Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppDisplayInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppInfo_Static{PyType_FromSpec(&type_spec_AppInfo_Static)};
    if (!type_AppInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppInstallerInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppInstance_Static{PyType_FromSpec(&type_spec_AppInstance_Static)};
    if (!type_AppInstance_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppInstance, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppInstance_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CameraApplicationManager_Static{PyType_FromSpec(&type_spec_CameraApplicationManager_Static)};
    if (!type_CameraApplicationManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraApplicationManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CameraApplicationManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DesignMode_Static{PyType_FromSpec(&type_spec_DesignMode_Static)};
    if (!type_DesignMode_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DesignMode, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DesignMode_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EnteredBackgroundEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FindRelatedPackagesOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FullTrustProcessLaunchResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FullTrustProcessLauncher_Static{PyType_FromSpec(&type_spec_FullTrustProcessLauncher_Static)};
    if (!type_FullTrustProcessLauncher_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FullTrustProcessLauncher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FullTrustProcessLauncher_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LeavingBackgroundEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LimitedAccessFeatureRequestResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LimitedAccessFeatures_Static{PyType_FromSpec(&type_spec_LimitedAccessFeatures_Static)};
    if (!type_LimitedAccessFeatures_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LimitedAccessFeatures, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LimitedAccessFeatures_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Package_Static{PyType_FromSpec(&type_spec_Package_Static)};
    if (!type_Package_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Package, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Package_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageCatalog_Static{PyType_FromSpec(&type_spec_PackageCatalog_Static)};
    if (!type_PackageCatalog_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageCatalog, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageCatalog_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageCatalogAddOptionalPackageResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageCatalogAddResourcePackageResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageCatalogRemoveOptionalPackagesResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageCatalogRemoveResourcePackagesResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageContentGroup_Static{PyType_FromSpec(&type_spec_PackageContentGroup_Static)};
    if (!type_PackageContentGroup_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageContentGroup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageContentGroup_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageContentGroupStagingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageId, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageInstallingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageStagingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageStatus, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageStatusChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageUninstallingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageUpdateAvailabilityResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageUpdatingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StartupTask_Static{PyType_FromSpec(&type_spec_StartupTask_Static)};
    if (!type_StartupTask_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StartupTask, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StartupTask_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SuspendingDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SuspendingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SuspendingOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IEnteredBackgroundEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ILeavingBackgroundEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPackageCatalogStatics2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISuspendingDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISuspendingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISuspendingOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageInstallProgress, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageVersion, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
