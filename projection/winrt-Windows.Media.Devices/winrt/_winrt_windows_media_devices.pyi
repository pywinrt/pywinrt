# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.devices.enumeration
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.capture
import winrt.windows.media.devices.core
import winrt.windows.media.mediaproperties
import winrt.windows.storage.streams

from winrt.windows.media.devices import AdvancedPhotoMode, AudioDeviceRole, AutoFocusRange, CameraOcclusionKind, CameraStreamState, CaptureSceneMode, CaptureUse, ColorTemperaturePreset, DigitalWindowMode, FocusMode, FocusPreset, HdrVideoMode, InfraredTorchMode, IsoSpeedPreset, ManualFocusDistance, MediaCaptureFocusState, MediaCaptureOptimization, MediaCapturePauseBehavior, OpticalImageStabilizationMode, RegionOfInterestType, SendCommandStatus, TelephonyKey, VideoDeviceControllerGetDevicePropertyStatus, VideoDeviceControllerSetDevicePropertyStatus, VideoTemporalDenoisingMode, ZoomTransitionMode
from winrt.windows.media.devices import CallControlEventHandler, DialRequestedEventHandler, KeypadPressedEventHandler, RedialRequestedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class AdvancedPhotoCaptureSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdvancedPhotoCaptureSettings: ...
    def __new__(cls: typing.Type[AdvancedPhotoCaptureSettings]) -> AdvancedPhotoCaptureSettings:...
    @_property
    def mode(self) -> AdvancedPhotoMode: ...
    @mode.setter
    def mode(self, value: AdvancedPhotoMode) -> None: ...

@typing.final
class AdvancedPhotoControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdvancedPhotoControl: ...
    def configure(self, settings: typing.Optional[AdvancedPhotoCaptureSettings], /) -> None: ...
    @_property
    def mode(self) -> AdvancedPhotoMode: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AdvancedPhotoMode]]: ...

@typing.final
class AudioDeviceController(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceController: ...
    def get_available_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.mediaproperties.IMediaEncodingProperties]]: ...
    def get_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties]: ...
    def set_media_stream_properties_async(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def volume_percent(self) -> winrt.system.Single: ...
    @volume_percent.setter
    def volume_percent(self, value: winrt.system.Single) -> None: ...
    @_property
    def muted(self) -> bool: ...
    @muted.setter
    def muted(self, value: bool) -> None: ...

@typing.final
class AudioDeviceModule(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceModule: ...
    def send_command_async(self, command: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[ModuleCommandResult]: ...
    @_property
    def class_id(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def instance_id(self) -> winrt.system.UInt32: ...
    @_property
    def major_version(self) -> winrt.system.UInt32: ...
    @_property
    def minor_version(self) -> winrt.system.UInt32: ...

@typing.final
class AudioDeviceModuleNotificationEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceModuleNotificationEventArgs: ...
    @_property
    def module(self) -> typing.Optional[AudioDeviceModule]: ...
    @_property
    def notification_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...

@typing.final
class AudioDeviceModulesManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceModulesManager: ...
    def __new__(cls: typing.Type[AudioDeviceModulesManager], device_id: str) -> AudioDeviceModulesManager:...
    def find_all(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioDeviceModule]]: ...
    def find_all_by_id(self, module_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioDeviceModule]]: ...
    def add_module_notification_received(self, handler: winrt.windows.foundation.TypedEventHandler[AudioDeviceModulesManager, AudioDeviceModuleNotificationEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_module_notification_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class CallControl_Static(type):
    def from_id(cls, device_id: str, /) -> typing.Optional[CallControl]: ...
    def get_default(cls) -> typing.Optional[CallControl]: ...

@typing.final
class CallControl(winrt.system.Object, metaclass=CallControl_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CallControl: ...
    def end_call(self, call_token: winrt.system.UInt64, /) -> None: ...
    def indicate_active_call(self, call_token: winrt.system.UInt64, /) -> None: ...
    def indicate_new_incoming_call(self, enable_ringer: bool, caller_id: str, /) -> winrt.system.UInt64: ...
    def indicate_new_outgoing_call(self) -> winrt.system.UInt64: ...
    def add_answer_requested(self, handler: typing.Optional[CallControlEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_answer_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_audio_transfer_requested(self, handler: typing.Optional[CallControlEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_audio_transfer_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_dial_requested(self, handler: typing.Optional[DialRequestedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dial_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_hang_up_requested(self, handler: typing.Optional[CallControlEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_hang_up_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_keypad_pressed(self, handler: typing.Optional[KeypadPressedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_keypad_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_redial_requested(self, handler: typing.Optional[RedialRequestedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_redial_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def has_ringer(self) -> bool: ...

@typing.final
class CameraOcclusionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOcclusionInfo: ...
    def get_state(self) -> typing.Optional[CameraOcclusionState]: ...
    def is_occlusion_kind_supported(self, occlusion_kind: CameraOcclusionKind, /) -> bool: ...
    def add_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CameraOcclusionInfo, CameraOcclusionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class CameraOcclusionState(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOcclusionState: ...
    def is_occlusion_kind(self, occlusion_kind: CameraOcclusionKind, /) -> bool: ...
    @_property
    def is_occluded(self) -> bool: ...

@typing.final
class CameraOcclusionStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOcclusionStateChangedEventArgs: ...
    @_property
    def state(self) -> typing.Optional[CameraOcclusionState]: ...

@typing.final
class DefaultAudioCaptureDeviceChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DefaultAudioCaptureDeviceChangedEventArgs: ...
    @_property
    def id(self) -> str: ...
    @_property
    def role(self) -> AudioDeviceRole: ...

@typing.final
class DefaultAudioRenderDeviceChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DefaultAudioRenderDeviceChangedEventArgs: ...
    @_property
    def id(self) -> str: ...
    @_property
    def role(self) -> AudioDeviceRole: ...

@typing.final
class DialRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DialRequestedEventArgs: ...
    def handled(self) -> None: ...
    @_property
    def contact(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class DigitalWindowBounds(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DigitalWindowBounds: ...
    def __new__(cls: typing.Type[DigitalWindowBounds]) -> DigitalWindowBounds:...
    @_property
    def scale(self) -> winrt.system.Double: ...
    @scale.setter
    def scale(self, value: winrt.system.Double) -> None: ...
    @_property
    def normalized_origin_top(self) -> winrt.system.Double: ...
    @normalized_origin_top.setter
    def normalized_origin_top(self, value: winrt.system.Double) -> None: ...
    @_property
    def normalized_origin_left(self) -> winrt.system.Double: ...
    @normalized_origin_left.setter
    def normalized_origin_left(self, value: winrt.system.Double) -> None: ...

@typing.final
class DigitalWindowCapability(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DigitalWindowCapability: ...
    @_property
    def height(self) -> winrt.system.Int32: ...
    @_property
    def max_scale_value(self) -> winrt.system.Double: ...
    @_property
    def min_scale_value(self) -> winrt.system.Double: ...
    @_property
    def min_scale_value_without_upsampling(self) -> winrt.system.Double: ...
    @_property
    def normalized_field_of_view_limit(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def width(self) -> winrt.system.Int32: ...

@typing.final
class DigitalWindowControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DigitalWindowControl: ...
    @typing.overload
    def configure(self, digital_window_mode: DigitalWindowMode, /) -> None: ...
    @typing.overload
    def configure(self, digital_window_mode: DigitalWindowMode, digital_window_bounds: typing.Optional[DigitalWindowBounds], /) -> None: ...
    def get_bounds(self) -> typing.Optional[DigitalWindowBounds]: ...
    def get_capability_for_size(self, width: winrt.system.Int32, height: winrt.system.Int32, /) -> typing.Optional[DigitalWindowCapability]: ...
    @_property
    def current_mode(self) -> DigitalWindowMode: ...
    @_property
    def is_supported(self) -> bool: ...
    @_property
    def supported_capabilities(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DigitalWindowCapability]]: ...
    @_property
    def supported_modes(self) -> DigitalWindowMode: ...

@typing.final
class ExposureCompensationControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExposureCompensationControl: ...
    def set_value_async(self, value: winrt.system.Single, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def max(self) -> winrt.system.Single: ...
    @_property
    def min(self) -> winrt.system.Single: ...
    @_property
    def step(self) -> winrt.system.Single: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def value(self) -> winrt.system.Single: ...

@typing.final
class ExposureControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExposureControl: ...
    def set_auto_async(self, value: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, shutter_duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def auto(self) -> bool: ...
    @_property
    def max(self) -> datetime.timedelta: ...
    @_property
    def min(self) -> datetime.timedelta: ...
    @_property
    def step(self) -> datetime.timedelta: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def value(self) -> datetime.timedelta: ...

@typing.final
class ExposurePriorityVideoControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExposurePriorityVideoControl: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...
    @_property
    def supported(self) -> bool: ...

@typing.final
class FlashControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlashControl: ...
    @_property
    def red_eye_reduction(self) -> bool: ...
    @red_eye_reduction.setter
    def red_eye_reduction(self, value: bool) -> None: ...
    @_property
    def power_percent(self) -> winrt.system.Single: ...
    @power_percent.setter
    def power_percent(self, value: winrt.system.Single) -> None: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...
    @_property
    def auto(self) -> bool: ...
    @auto.setter
    def auto(self, value: bool) -> None: ...
    @_property
    def power_supported(self) -> bool: ...
    @_property
    def red_eye_reduction_supported(self) -> bool: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def assistant_light_enabled(self) -> bool: ...
    @assistant_light_enabled.setter
    def assistant_light_enabled(self, value: bool) -> None: ...
    @_property
    def assistant_light_supported(self) -> bool: ...

@typing.final
class FocusControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusControl: ...
    def configure(self, settings: typing.Optional[FocusSettings], /) -> None: ...
    def focus_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def lock_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_preset_async(self, preset: FocusPreset, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_preset_async(self, preset: FocusPreset, complete_before_focus: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, focus: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncAction: ...
    def unlock_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def max(self) -> winrt.system.UInt32: ...
    @_property
    def min(self) -> winrt.system.UInt32: ...
    @_property
    def preset(self) -> FocusPreset: ...
    @_property
    def step(self) -> winrt.system.UInt32: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def supported_presets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[FocusPreset]]: ...
    @_property
    def value(self) -> winrt.system.UInt32: ...
    @_property
    def focus_changed_supported(self) -> bool: ...
    @_property
    def focus_state(self) -> MediaCaptureFocusState: ...
    @_property
    def mode(self) -> FocusMode: ...
    @_property
    def supported_focus_distances(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ManualFocusDistance]]: ...
    @_property
    def supported_focus_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[FocusMode]]: ...
    @_property
    def supported_focus_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AutoFocusRange]]: ...
    @_property
    def wait_for_focus_supported(self) -> bool: ...

@typing.final
class FocusSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusSettings: ...
    def __new__(cls: typing.Type[FocusSettings]) -> FocusSettings:...
    @_property
    def wait_for_focus(self) -> bool: ...
    @wait_for_focus.setter
    def wait_for_focus(self, value: bool) -> None: ...
    @_property
    def value(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @value.setter
    def value(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...
    @_property
    def mode(self) -> FocusMode: ...
    @mode.setter
    def mode(self, value: FocusMode) -> None: ...
    @_property
    def distance(self) -> typing.Optional[typing.Optional[ManualFocusDistance]]: ...
    @distance.setter
    def distance(self, value: typing.Optional[typing.Optional[ManualFocusDistance]]) -> None: ...
    @_property
    def disable_driver_fallback(self) -> bool: ...
    @disable_driver_fallback.setter
    def disable_driver_fallback(self, value: bool) -> None: ...
    @_property
    def auto_focus_range(self) -> AutoFocusRange: ...
    @auto_focus_range.setter
    def auto_focus_range(self, value: AutoFocusRange) -> None: ...

@typing.final
class HdrVideoControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HdrVideoControl: ...
    @_property
    def mode(self) -> HdrVideoMode: ...
    @mode.setter
    def mode(self, value: HdrVideoMode) -> None: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[HdrVideoMode]]: ...

@typing.final
class InfraredTorchControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InfraredTorchControl: ...
    @_property
    def power(self) -> winrt.system.Int32: ...
    @power.setter
    def power(self, value: winrt.system.Int32) -> None: ...
    @_property
    def current_mode(self) -> InfraredTorchMode: ...
    @current_mode.setter
    def current_mode(self, value: InfraredTorchMode) -> None: ...
    @_property
    def is_supported(self) -> bool: ...
    @_property
    def max_power(self) -> winrt.system.Int32: ...
    @_property
    def min_power(self) -> winrt.system.Int32: ...
    @_property
    def power_step(self) -> winrt.system.Int32: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InfraredTorchMode]]: ...

@typing.final
class IsoSpeedControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IsoSpeedControl: ...
    def set_auto_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_preset_async(self, preset: IsoSpeedPreset, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, iso_speed: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def preset(self) -> IsoSpeedPreset: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def supported_presets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[IsoSpeedPreset]]: ...
    @_property
    def auto(self) -> bool: ...
    @_property
    def max(self) -> winrt.system.UInt32: ...
    @_property
    def min(self) -> winrt.system.UInt32: ...
    @_property
    def step(self) -> winrt.system.UInt32: ...
    @_property
    def value(self) -> winrt.system.UInt32: ...

@typing.final
class KeypadPressedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeypadPressedEventArgs: ...
    @_property
    def telephony_key(self) -> TelephonyKey: ...

@typing.final
class LowLagPhotoControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagPhotoControl: ...
    def get_current_frame_rate(self) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...
    def get_highest_concurrent_frame_rate(self, capture_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...
    @_property
    def thumbnail_format(self) -> winrt.windows.media.mediaproperties.MediaThumbnailFormat: ...
    @thumbnail_format.setter
    def thumbnail_format(self, value: winrt.windows.media.mediaproperties.MediaThumbnailFormat) -> None: ...
    @_property
    def thumbnail_enabled(self) -> bool: ...
    @thumbnail_enabled.setter
    def thumbnail_enabled(self, value: bool) -> None: ...
    @_property
    def desired_thumbnail_size(self) -> winrt.system.UInt32: ...
    @desired_thumbnail_size.setter
    def desired_thumbnail_size(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def hardware_accelerated_thumbnail_supported(self) -> winrt.system.UInt32: ...

@typing.final
class LowLagPhotoSequenceControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagPhotoSequenceControl: ...
    def get_current_frame_rate(self) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...
    def get_highest_concurrent_frame_rate(self, capture_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...
    @_property
    def thumbnail_format(self) -> winrt.windows.media.mediaproperties.MediaThumbnailFormat: ...
    @thumbnail_format.setter
    def thumbnail_format(self, value: winrt.windows.media.mediaproperties.MediaThumbnailFormat) -> None: ...
    @_property
    def thumbnail_enabled(self) -> bool: ...
    @thumbnail_enabled.setter
    def thumbnail_enabled(self, value: bool) -> None: ...
    @_property
    def photos_per_second_limit(self) -> winrt.system.Single: ...
    @photos_per_second_limit.setter
    def photos_per_second_limit(self, value: winrt.system.Single) -> None: ...
    @_property
    def past_photo_limit(self) -> winrt.system.UInt32: ...
    @past_photo_limit.setter
    def past_photo_limit(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def desired_thumbnail_size(self) -> winrt.system.UInt32: ...
    @desired_thumbnail_size.setter
    def desired_thumbnail_size(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def hardware_accelerated_thumbnail_supported(self) -> winrt.system.UInt32: ...
    @_property
    def max_past_photos(self) -> winrt.system.UInt32: ...
    @_property
    def max_photos_per_second(self) -> winrt.system.Single: ...
    @_property
    def supported(self) -> bool: ...

@typing.final
class MediaDevice_Static(type):
    def get_audio_capture_selector(cls) -> str: ...
    def get_audio_render_selector(cls) -> str: ...
    def get_default_audio_capture_id(cls, role: AudioDeviceRole, /) -> str: ...
    def get_default_audio_render_id(cls, role: AudioDeviceRole, /) -> str: ...
    def get_video_capture_selector(cls) -> str: ...
    def add_default_audio_capture_device_changed(cls, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, DefaultAudioCaptureDeviceChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_default_audio_capture_device_changed(cls, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_default_audio_render_device_changed(cls, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, DefaultAudioRenderDeviceChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_default_audio_render_device_changed(cls, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class MediaDevice(winrt.system.Object, metaclass=MediaDevice_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaDevice: ...

@typing.final
class MediaDeviceControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaDeviceControl: ...
    def try_get_auto(self) -> typing.Tuple[bool, bool]: ...
    def try_get_value(self) -> typing.Tuple[bool, winrt.system.Double]: ...
    def try_set_auto(self, value: bool, /) -> bool: ...
    def try_set_value(self, value: winrt.system.Double, /) -> bool: ...
    @_property
    def capabilities(self) -> typing.Optional[MediaDeviceControlCapabilities]: ...

@typing.final
class MediaDeviceControlCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaDeviceControlCapabilities: ...
    @_property
    def auto_mode_supported(self) -> bool: ...
    @_property
    def default(self) -> winrt.system.Double: ...
    @_property
    def max(self) -> winrt.system.Double: ...
    @_property
    def min(self) -> winrt.system.Double: ...
    @_property
    def step(self) -> winrt.system.Double: ...
    @_property
    def supported(self) -> bool: ...

@typing.final
class ModuleCommandResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ModuleCommandResult: ...
    @_property
    def result(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def status(self) -> SendCommandStatus: ...

@typing.final
class OpticalImageStabilizationControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OpticalImageStabilizationControl: ...
    @_property
    def mode(self) -> OpticalImageStabilizationMode: ...
    @mode.setter
    def mode(self, value: OpticalImageStabilizationMode) -> None: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[OpticalImageStabilizationMode]]: ...

@typing.final
class PanelBasedOptimizationControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PanelBasedOptimizationControl: ...
    @_property
    def panel(self) -> winrt.windows.devices.enumeration.Panel: ...
    @panel.setter
    def panel(self, value: winrt.windows.devices.enumeration.Panel) -> None: ...
    @_property
    def is_supported(self) -> bool: ...

@typing.final
class PhotoConfirmationControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PhotoConfirmationControl: ...
    @_property
    def pixel_format(self) -> winrt.windows.media.mediaproperties.MediaPixelFormat: ...
    @pixel_format.setter
    def pixel_format(self, value: winrt.windows.media.mediaproperties.MediaPixelFormat) -> None: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...
    @_property
    def supported(self) -> bool: ...

@typing.final
class RedialRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RedialRequestedEventArgs: ...
    def handled(self) -> None: ...

@typing.final
class RegionOfInterest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegionOfInterest: ...
    def __new__(cls: typing.Type[RegionOfInterest]) -> RegionOfInterest:...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...
    @bounds.setter
    def bounds(self, value: winrt.windows.foundation.Rect) -> None: ...
    @_property
    def auto_white_balance_enabled(self) -> bool: ...
    @auto_white_balance_enabled.setter
    def auto_white_balance_enabled(self, value: bool) -> None: ...
    @_property
    def auto_focus_enabled(self) -> bool: ...
    @auto_focus_enabled.setter
    def auto_focus_enabled(self, value: bool) -> None: ...
    @_property
    def auto_exposure_enabled(self) -> bool: ...
    @auto_exposure_enabled.setter
    def auto_exposure_enabled(self, value: bool) -> None: ...
    @_property
    def weight(self) -> winrt.system.UInt32: ...
    @weight.setter
    def weight(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def type(self) -> RegionOfInterestType: ...
    @type.setter
    def type(self, value: RegionOfInterestType) -> None: ...
    @_property
    def bounds_normalized(self) -> bool: ...
    @bounds_normalized.setter
    def bounds_normalized(self, value: bool) -> None: ...

@typing.final
class RegionsOfInterestControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegionsOfInterestControl: ...
    def clear_regions_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_regions_async(self, regions: typing.Iterable[RegionOfInterest], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_regions_async(self, regions: typing.Iterable[RegionOfInterest], lock_values: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def auto_exposure_supported(self) -> bool: ...
    @_property
    def auto_focus_supported(self) -> bool: ...
    @_property
    def auto_white_balance_supported(self) -> bool: ...
    @_property
    def max_regions(self) -> winrt.system.UInt32: ...

@typing.final
class SceneModeControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneModeControl: ...
    def set_value_async(self, scene_mode: CaptureSceneMode, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[CaptureSceneMode]]: ...
    @_property
    def value(self) -> CaptureSceneMode: ...

@typing.final
class TorchControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TorchControl: ...
    @_property
    def power_percent(self) -> winrt.system.Single: ...
    @power_percent.setter
    def power_percent(self, value: winrt.system.Single) -> None: ...
    @_property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool) -> None: ...
    @_property
    def power_supported(self) -> bool: ...
    @_property
    def supported(self) -> bool: ...

@typing.final
class VideoDeviceController(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoDeviceController: ...
    def get_available_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.mediaproperties.IMediaEncodingProperties]]: ...
    def get_device_property(self, property_id: str, /) -> typing.Optional[winrt.system.Object]: ...
    def get_device_property_by_extended_id(self, extended_property_id: winrt.system.Array[winrt.system.UInt8], max_property_value_size: typing.Optional[winrt.system.UInt32], /) -> typing.Optional[VideoDeviceControllerGetDevicePropertyResult]: ...
    def get_device_property_by_id(self, property_id: str, max_property_value_size: typing.Optional[winrt.system.UInt32], /) -> typing.Optional[VideoDeviceControllerGetDevicePropertyResult]: ...
    def get_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties]: ...
    def set_device_property(self, property_id: str, property_value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_device_property_by_extended_id(self, extended_property_id: winrt.system.Array[winrt.system.UInt8], property_value: winrt.system.Array[winrt.system.UInt8], /) -> VideoDeviceControllerSetDevicePropertyStatus: ...
    def set_device_property_by_id(self, property_id: str, property_value: typing.Optional[winrt.system.Object], /) -> VideoDeviceControllerSetDevicePropertyStatus: ...
    def set_media_stream_properties_async(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_acquire_exclusive_control(self, device_id: str, mode: winrt.windows.media.capture.MediaCaptureDeviceExclusiveControlReleaseMode, /) -> bool: ...
    def try_get_powerline_frequency(self) -> typing.Tuple[bool, winrt.windows.media.capture.PowerlineFrequency]: ...
    def try_set_powerline_frequency(self, value: winrt.windows.media.capture.PowerlineFrequency, /) -> bool: ...
    @_property
    def camera_occlusion_info(self) -> typing.Optional[CameraOcclusionInfo]: ...
    @_property
    def primary_use(self) -> CaptureUse: ...
    @primary_use.setter
    def primary_use(self, value: CaptureUse) -> None: ...
    @_property
    def focus_control(self) -> typing.Optional[FocusControl]: ...
    @_property
    def iso_speed_control(self) -> typing.Optional[IsoSpeedControl]: ...
    @_property
    def low_lag_photo(self) -> typing.Optional[LowLagPhotoControl]: ...
    @_property
    def white_balance_control(self) -> typing.Optional[WhiteBalanceControl]: ...
    @_property
    def torch_control(self) -> typing.Optional[TorchControl]: ...
    @_property
    def scene_mode_control(self) -> typing.Optional[SceneModeControl]: ...
    @_property
    def regions_of_interest_control(self) -> typing.Optional[RegionsOfInterestControl]: ...
    @_property
    def flash_control(self) -> typing.Optional[FlashControl]: ...
    @_property
    def low_lag_photo_sequence(self) -> typing.Optional[LowLagPhotoSequenceControl]: ...
    @_property
    def exposure_compensation_control(self) -> typing.Optional[ExposureCompensationControl]: ...
    @_property
    def exposure_control(self) -> typing.Optional[ExposureControl]: ...
    @_property
    def zoom_control(self) -> typing.Optional[ZoomControl]: ...
    @_property
    def photo_confirmation_control(self) -> typing.Optional[PhotoConfirmationControl]: ...
    @_property
    def variable_photo_sequence_controller(self) -> typing.Optional[winrt.windows.media.devices.core.VariablePhotoSequenceController]: ...
    @_property
    def desired_optimization(self) -> MediaCaptureOptimization: ...
    @desired_optimization.setter
    def desired_optimization(self, value: MediaCaptureOptimization) -> None: ...
    @_property
    def advanced_photo_control(self) -> typing.Optional[AdvancedPhotoControl]: ...
    @_property
    def exposure_priority_video_control(self) -> typing.Optional[ExposurePriorityVideoControl]: ...
    @_property
    def hdr_video_control(self) -> typing.Optional[HdrVideoControl]: ...
    @_property
    def optical_image_stabilization_control(self) -> typing.Optional[OpticalImageStabilizationControl]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def video_temporal_denoising_control(self) -> typing.Optional[VideoTemporalDenoisingControl]: ...
    @_property
    def infrared_torch_control(self) -> typing.Optional[InfraredTorchControl]: ...
    @_property
    def panel_based_optimization_control(self) -> typing.Optional[PanelBasedOptimizationControl]: ...
    @_property
    def digital_window_control(self) -> typing.Optional[DigitalWindowControl]: ...
    @_property
    def zoom(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def contrast(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def backlight_compensation(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def white_balance(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def brightness(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def exposure(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def tilt(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def roll(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def hue(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def pan(self) -> typing.Optional[MediaDeviceControl]: ...
    @_property
    def focus(self) -> typing.Optional[MediaDeviceControl]: ...

@typing.final
class VideoDeviceControllerGetDevicePropertyResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoDeviceControllerGetDevicePropertyResult: ...
    @_property
    def status(self) -> VideoDeviceControllerGetDevicePropertyStatus: ...
    @_property
    def value(self) -> typing.Optional[winrt.system.Object]: ...

@typing.final
class VideoTemporalDenoisingControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoTemporalDenoisingControl: ...
    @_property
    def mode(self) -> VideoTemporalDenoisingMode: ...
    @mode.setter
    def mode(self, value: VideoTemporalDenoisingMode) -> None: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[VideoTemporalDenoisingMode]]: ...

@typing.final
class WhiteBalanceControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WhiteBalanceControl: ...
    def set_preset_async(self, preset: ColorTemperaturePreset, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, temperature: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def max(self) -> winrt.system.UInt32: ...
    @_property
    def min(self) -> winrt.system.UInt32: ...
    @_property
    def preset(self) -> ColorTemperaturePreset: ...
    @_property
    def step(self) -> winrt.system.UInt32: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def value(self) -> winrt.system.UInt32: ...

@typing.final
class ZoomControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ZoomControl: ...
    def configure(self, settings: typing.Optional[ZoomSettings], /) -> None: ...
    @_property
    def value(self) -> winrt.system.Single: ...
    @value.setter
    def value(self, value: winrt.system.Single) -> None: ...
    @_property
    def max(self) -> winrt.system.Single: ...
    @_property
    def min(self) -> winrt.system.Single: ...
    @_property
    def step(self) -> winrt.system.Single: ...
    @_property
    def supported(self) -> bool: ...
    @_property
    def mode(self) -> ZoomTransitionMode: ...
    @_property
    def supported_modes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ZoomTransitionMode]]: ...

@typing.final
class ZoomSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ZoomSettings: ...
    def __new__(cls: typing.Type[ZoomSettings]) -> ZoomSettings:...
    @_property
    def value(self) -> winrt.system.Single: ...
    @value.setter
    def value(self, value: winrt.system.Single) -> None: ...
    @_property
    def mode(self) -> ZoomTransitionMode: ...
    @mode.setter
    def mode(self, value: ZoomTransitionMode) -> None: ...

@typing.final
class IDefaultAudioDeviceChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDefaultAudioDeviceChangedEventArgs: ...
    @_property
    def id(self) -> str: ...
    @_property
    def role(self) -> AudioDeviceRole: ...

@typing.final
class IMediaDeviceController(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaDeviceController: ...
    def get_available_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.mediaproperties.IMediaEncodingProperties]]: ...
    def get_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties]: ...
    def set_media_stream_properties_async(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> winrt.windows.foundation.IAsyncAction: ...

