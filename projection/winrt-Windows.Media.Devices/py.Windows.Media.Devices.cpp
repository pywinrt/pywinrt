// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Media.Devices.h"


namespace py::cpp::Windows::Media::Devices
{
    // ----- AdvancedPhotoCaptureSettings class --------------------

    static PyObject* _new_AdvancedPhotoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdvancedPhotoCaptureSettings(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdvancedPhotoCaptureSettings_get_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AdvancedPhotoCaptureSettings", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdvancedPhotoCaptureSettings_put_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AdvancedPhotoCaptureSettings", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::AdvancedPhotoMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AdvancedPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdvancedPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCaptureSettings[] = {
        { "_assign_array_", _assign_array_AdvancedPhotoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoCaptureSettings[] = {
        { "mode", reinterpret_cast<getter>(AdvancedPhotoCaptureSettings_get_Mode), reinterpret_cast<setter>(AdvancedPhotoCaptureSettings_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCaptureSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdvancedPhotoCaptureSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdvancedPhotoCaptureSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdvancedPhotoCaptureSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdvancedPhotoCaptureSettings) },
        { },
    };

    static PyType_Spec type_spec_AdvancedPhotoCaptureSettings =
    {
        "winrt._winrt_windows_media_devices.AdvancedPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCaptureSettings
    };

    // ----- AdvancedPhotoControl class --------------------

    static PyObject* _new_AdvancedPhotoControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::AdvancedPhotoControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::AdvancedPhotoControl>::type_name);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoControl(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdvancedPhotoControl_Configure(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AdvancedPhotoControl", L"Configure", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AdvancedPhotoControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_Supported(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AdvancedPhotoControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AdvancedPhotoControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdvancedPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::AdvancedPhotoControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdvancedPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AdvancedPhotoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(AdvancedPhotoControl_Configure), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AdvancedPhotoControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoControl[] = {
        { "mode", reinterpret_cast<getter>(AdvancedPhotoControl_get_Mode), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(AdvancedPhotoControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(AdvancedPhotoControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdvancedPhotoControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdvancedPhotoControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdvancedPhotoControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdvancedPhotoControl) },
        { },
    };

    static PyType_Spec type_spec_AdvancedPhotoControl =
    {
        "winrt._winrt_windows_media_devices.AdvancedPhotoControl",
        sizeof(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoControl
    };

    // ----- AudioDeviceController class --------------------

    static PyObject* _new_AudioDeviceController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::AudioDeviceController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::AudioDeviceController>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceController(py::wrapper::Windows::Media::Devices::AudioDeviceController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AudioDeviceController", L"GetAvailableMediaStreamProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AudioDeviceController", L"GetMediaStreamProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AudioDeviceController", L"SetMediaStreamPropertiesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_get_VolumePercent(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceController", L"VolumePercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VolumePercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceController_put_VolumePercent(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceController", L"VolumePercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.VolumePercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceController_get_Muted(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceController", L"Muted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceController_put_Muted(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceController", L"Muted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Muted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::AudioDeviceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceController[] = {
        { "get_available_media_stream_properties", reinterpret_cast<PyCFunction>(AudioDeviceController_GetAvailableMediaStreamProperties), METH_VARARGS, nullptr },
        { "get_media_stream_properties", reinterpret_cast<PyCFunction>(AudioDeviceController_GetMediaStreamProperties), METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", reinterpret_cast<PyCFunction>(AudioDeviceController_SetMediaStreamPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceController[] = {
        { "volume_percent", reinterpret_cast<getter>(AudioDeviceController_get_VolumePercent), reinterpret_cast<setter>(AudioDeviceController_put_VolumePercent), nullptr, nullptr },
        { "muted", reinterpret_cast<getter>(AudioDeviceController_get_Muted), reinterpret_cast<setter>(AudioDeviceController_put_Muted), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceController) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceController =
    {
        "winrt._winrt_windows_media_devices.AudioDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceController
    };

    // ----- AudioDeviceModule class --------------------

    static PyObject* _new_AudioDeviceModule(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::AudioDeviceModule>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::AudioDeviceModule>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceModule(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceModule_SendCommandAsync(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AudioDeviceModule", L"SendCommandAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendCommandAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_ClassId(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModule", L"ClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_DisplayName(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModule", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_InstanceId(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModule", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_MajorVersion(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModule", L"MajorVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MajorVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_MinorVersion(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModule", L"MinorVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinorVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioDeviceModule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::AudioDeviceModule>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceModule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModule[] = {
        { "send_command_async", reinterpret_cast<PyCFunction>(AudioDeviceModule_SendCommandAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceModule, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceModule), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceModule[] = {
        { "class_id", reinterpret_cast<getter>(AudioDeviceModule_get_ClassId), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AudioDeviceModule_get_DisplayName), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(AudioDeviceModule_get_InstanceId), nullptr, nullptr, nullptr },
        { "major_version", reinterpret_cast<getter>(AudioDeviceModule_get_MajorVersion), nullptr, nullptr, nullptr },
        { "minor_version", reinterpret_cast<getter>(AudioDeviceModule_get_MinorVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceModule[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceModule) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceModule) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceModule) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceModule) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceModule =
    {
        "winrt._winrt_windows_media_devices.AudioDeviceModule",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModule
    };

    // ----- AudioDeviceModuleNotificationEventArgs class --------------------

    static PyObject* _new_AudioDeviceModuleNotificationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceModuleNotificationEventArgs(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceModuleNotificationEventArgs_get_Module(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModuleNotificationEventArgs", L"Module"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Module());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModuleNotificationEventArgs_get_NotificationData(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.AudioDeviceModuleNotificationEventArgs", L"NotificationData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioDeviceModuleNotificationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceModuleNotificationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModuleNotificationEventArgs[] = {
        { "_assign_array_", _assign_array_AudioDeviceModuleNotificationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceModuleNotificationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceModuleNotificationEventArgs[] = {
        { "module", reinterpret_cast<getter>(AudioDeviceModuleNotificationEventArgs_get_Module), nullptr, nullptr, nullptr },
        { "notification_data", reinterpret_cast<getter>(AudioDeviceModuleNotificationEventArgs_get_NotificationData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceModuleNotificationEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceModuleNotificationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceModuleNotificationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceModuleNotificationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceModuleNotificationEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceModuleNotificationEventArgs =
    {
        "winrt._winrt_windows_media_devices.AudioDeviceModuleNotificationEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModuleNotificationEventArgs
    };

    // ----- AudioDeviceModulesManager class --------------------

    static PyObject* _new_AudioDeviceModulesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Devices::AudioDeviceModulesManager instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioDeviceModulesManager(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceModulesManager_FindAll(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AudioDeviceModulesManager", L"FindAll", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindAll());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_FindAllById(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.AudioDeviceModulesManager", L"FindAllById", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAllById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_add_ModuleNotificationReceived(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.AudioDeviceModulesManager", L"ModuleNotificationReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Devices::AudioDeviceModulesManager, winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>>(arg);

            return py::convert(self->obj.ModuleNotificationReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_remove_ModuleNotificationReceived(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.AudioDeviceModulesManager", L"ModuleNotificationReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ModuleNotificationReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioDeviceModulesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::AudioDeviceModulesManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceModulesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModulesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModulesManager[] = {
        { "find_all", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_FindAll), METH_VARARGS, nullptr },
        { "find_all_by_id", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_FindAllById), METH_VARARGS, nullptr },
        { "add_module_notification_received", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_add_ModuleNotificationReceived), METH_O, nullptr },
        { "remove_module_notification_received", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_remove_ModuleNotificationReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceModulesManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceModulesManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceModulesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceModulesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceModulesManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceModulesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceModulesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceModulesManager) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceModulesManager =
    {
        "winrt._winrt_windows_media_devices.AudioDeviceModulesManager",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModulesManager
    };

    // ----- CallControl class --------------------

    static PyObject* _new_CallControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::CallControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::CallControl>::type_name);
        return nullptr;
    }

    static void _dealloc_CallControl(py::wrapper::Windows::Media::Devices::CallControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallControl_EndCall(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CallControl", L"EndCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.EndCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CallControl_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CallControl", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::CallControl::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CallControl_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CallControl", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Devices::CallControl::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CallControl_IndicateActiveCall(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CallControl", L"IndicateActiveCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.IndicateActiveCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CallControl_IndicateNewIncomingCall(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CallControl", L"IndicateNewIncomingCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.IndicateNewIncomingCall(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CallControl_IndicateNewOutgoingCall(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CallControl", L"IndicateNewOutgoingCall", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IndicateNewOutgoingCall());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CallControl_get_HasRinger(py::wrapper::Windows::Media::Devices::CallControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.CallControl", L"HasRinger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasRinger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_add_AnswerRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"AnswerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::CallControlEventHandler>(arg);

            return py::convert(self->obj.AnswerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_remove_AnswerRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"AnswerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnswerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_add_AudioTransferRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"AudioTransferRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::CallControlEventHandler>(arg);

            return py::convert(self->obj.AudioTransferRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_remove_AudioTransferRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"AudioTransferRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioTransferRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_add_DialRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"DialRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::DialRequestedEventHandler>(arg);

            return py::convert(self->obj.DialRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_remove_DialRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"DialRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DialRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_add_HangUpRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"HangUpRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::CallControlEventHandler>(arg);

            return py::convert(self->obj.HangUpRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_remove_HangUpRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"HangUpRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HangUpRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_add_KeypadPressed(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"KeypadPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::KeypadPressedEventHandler>(arg);

            return py::convert(self->obj.KeypadPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_remove_KeypadPressed(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"KeypadPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeypadPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_add_RedialRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"RedialRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::RedialRequestedEventHandler>(arg);

            return py::convert(self->obj.RedialRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CallControl_remove_RedialRequested(py::wrapper::Windows::Media::Devices::CallControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CallControl", L"RedialRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RedialRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::CallControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CallControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallControl[] = {
        { "end_call", reinterpret_cast<PyCFunction>(CallControl_EndCall), METH_VARARGS, nullptr },
        { "from_id", reinterpret_cast<PyCFunction>(CallControl_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(CallControl_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "indicate_active_call", reinterpret_cast<PyCFunction>(CallControl_IndicateActiveCall), METH_VARARGS, nullptr },
        { "indicate_new_incoming_call", reinterpret_cast<PyCFunction>(CallControl_IndicateNewIncomingCall), METH_VARARGS, nullptr },
        { "indicate_new_outgoing_call", reinterpret_cast<PyCFunction>(CallControl_IndicateNewOutgoingCall), METH_VARARGS, nullptr },
        { "add_answer_requested", reinterpret_cast<PyCFunction>(CallControl_add_AnswerRequested), METH_O, nullptr },
        { "remove_answer_requested", reinterpret_cast<PyCFunction>(CallControl_remove_AnswerRequested), METH_O, nullptr },
        { "add_audio_transfer_requested", reinterpret_cast<PyCFunction>(CallControl_add_AudioTransferRequested), METH_O, nullptr },
        { "remove_audio_transfer_requested", reinterpret_cast<PyCFunction>(CallControl_remove_AudioTransferRequested), METH_O, nullptr },
        { "add_dial_requested", reinterpret_cast<PyCFunction>(CallControl_add_DialRequested), METH_O, nullptr },
        { "remove_dial_requested", reinterpret_cast<PyCFunction>(CallControl_remove_DialRequested), METH_O, nullptr },
        { "add_hang_up_requested", reinterpret_cast<PyCFunction>(CallControl_add_HangUpRequested), METH_O, nullptr },
        { "remove_hang_up_requested", reinterpret_cast<PyCFunction>(CallControl_remove_HangUpRequested), METH_O, nullptr },
        { "add_keypad_pressed", reinterpret_cast<PyCFunction>(CallControl_add_KeypadPressed), METH_O, nullptr },
        { "remove_keypad_pressed", reinterpret_cast<PyCFunction>(CallControl_remove_KeypadPressed), METH_O, nullptr },
        { "add_redial_requested", reinterpret_cast<PyCFunction>(CallControl_add_RedialRequested), METH_O, nullptr },
        { "remove_redial_requested", reinterpret_cast<PyCFunction>(CallControl_remove_RedialRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CallControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallControl[] = {
        { "has_ringer", reinterpret_cast<getter>(CallControl_get_HasRinger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallControl) },
        { },
    };

    static PyType_Spec type_spec_CallControl =
    {
        "winrt._winrt_windows_media_devices.CallControl",
        sizeof(py::wrapper::Windows::Media::Devices::CallControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallControl
    };

    // ----- CameraOcclusionInfo class --------------------

    static PyObject* _new_CameraOcclusionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::CameraOcclusionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::CameraOcclusionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionInfo(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraOcclusionInfo_GetState(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CameraOcclusionInfo", L"GetState", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_IsOcclusionKindSupported(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CameraOcclusionInfo", L"IsOcclusionKindSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CameraOcclusionKind>(args, 0);

                return py::convert(self->obj.IsOcclusionKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_add_StateChanged(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CameraOcclusionInfo", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Devices::CameraOcclusionInfo, winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_remove_StateChanged(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.CameraOcclusionInfo", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraOcclusionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::CameraOcclusionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraOcclusionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionInfo[] = {
        { "get_state", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_GetState), METH_VARARGS, nullptr },
        { "is_occlusion_kind_supported", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_IsOcclusionKindSupported), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CameraOcclusionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraOcclusionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOcclusionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_CameraOcclusionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraOcclusionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraOcclusionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraOcclusionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraOcclusionInfo) },
        { },
    };

    static PyType_Spec type_spec_CameraOcclusionInfo =
    {
        "winrt._winrt_windows_media_devices.CameraOcclusionInfo",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionInfo
    };

    // ----- CameraOcclusionState class --------------------

    static PyObject* _new_CameraOcclusionState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::CameraOcclusionState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::CameraOcclusionState>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionState(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraOcclusionState_IsOcclusionKind(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.CameraOcclusionState", L"IsOcclusionKind", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CameraOcclusionKind>(args, 0);

                return py::convert(self->obj.IsOcclusionKind(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionState_get_IsOccluded(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.CameraOcclusionState", L"IsOccluded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOccluded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraOcclusionState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::CameraOcclusionState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraOcclusionState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionState[] = {
        { "is_occlusion_kind", reinterpret_cast<PyCFunction>(CameraOcclusionState_IsOcclusionKind), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CameraOcclusionState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraOcclusionState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOcclusionState[] = {
        { "is_occluded", reinterpret_cast<getter>(CameraOcclusionState_get_IsOccluded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraOcclusionState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraOcclusionState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraOcclusionState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraOcclusionState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraOcclusionState) },
        { },
    };

    static PyType_Spec type_spec_CameraOcclusionState =
    {
        "winrt._winrt_windows_media_devices.CameraOcclusionState",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionState
    };

    // ----- CameraOcclusionStateChangedEventArgs class --------------------

    static PyObject* _new_CameraOcclusionStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionStateChangedEventArgs(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraOcclusionStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.CameraOcclusionStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraOcclusionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraOcclusionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CameraOcclusionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraOcclusionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOcclusionStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(CameraOcclusionStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraOcclusionStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraOcclusionStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraOcclusionStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraOcclusionStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraOcclusionStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CameraOcclusionStateChangedEventArgs =
    {
        "winrt._winrt_windows_media_devices.CameraOcclusionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionStateChangedEventArgs
    };

    // ----- DefaultAudioCaptureDeviceChangedEventArgs class --------------------

    static PyObject* _new_DefaultAudioCaptureDeviceChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DefaultAudioCaptureDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DefaultAudioCaptureDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DefaultAudioCaptureDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs", L"Role"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DefaultAudioCaptureDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DefaultAudioCaptureDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DefaultAudioCaptureDeviceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DefaultAudioCaptureDeviceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DefaultAudioCaptureDeviceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DefaultAudioCaptureDeviceChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(DefaultAudioCaptureDeviceChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "role", reinterpret_cast<getter>(DefaultAudioCaptureDeviceChangedEventArgs_get_Role), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DefaultAudioCaptureDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DefaultAudioCaptureDeviceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DefaultAudioCaptureDeviceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DefaultAudioCaptureDeviceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DefaultAudioCaptureDeviceChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DefaultAudioCaptureDeviceChangedEventArgs =
    {
        "winrt._winrt_windows_media_devices.DefaultAudioCaptureDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DefaultAudioCaptureDeviceChangedEventArgs
    };

    // ----- DefaultAudioRenderDeviceChangedEventArgs class --------------------

    static PyObject* _new_DefaultAudioRenderDeviceChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DefaultAudioRenderDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DefaultAudioRenderDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DefaultAudioRenderDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs", L"Role"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DefaultAudioRenderDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DefaultAudioRenderDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DefaultAudioRenderDeviceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DefaultAudioRenderDeviceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DefaultAudioRenderDeviceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DefaultAudioRenderDeviceChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(DefaultAudioRenderDeviceChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "role", reinterpret_cast<getter>(DefaultAudioRenderDeviceChangedEventArgs_get_Role), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DefaultAudioRenderDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DefaultAudioRenderDeviceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DefaultAudioRenderDeviceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DefaultAudioRenderDeviceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DefaultAudioRenderDeviceChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DefaultAudioRenderDeviceChangedEventArgs =
    {
        "winrt._winrt_windows_media_devices.DefaultAudioRenderDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DefaultAudioRenderDeviceChangedEventArgs
    };

    // ----- DialRequestedEventArgs class --------------------

    static PyObject* _new_DialRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::DialRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::DialRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DialRequestedEventArgs(py::wrapper::Windows::Media::Devices::DialRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DialRequestedEventArgs_Handled(py::wrapper::Windows::Media::Devices::DialRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.DialRequestedEventArgs", L"Handled", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Handled();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DialRequestedEventArgs_get_Contact(py::wrapper::Windows::Media::Devices::DialRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DialRequestedEventArgs", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DialRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::DialRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DialRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DialRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DialRequestedEventArgs[] = {
        { "handled", reinterpret_cast<PyCFunction>(DialRequestedEventArgs_Handled), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DialRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DialRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DialRequestedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(DialRequestedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DialRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DialRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DialRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DialRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DialRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DialRequestedEventArgs =
    {
        "winrt._winrt_windows_media_devices.DialRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DialRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DialRequestedEventArgs
    };

    // ----- DigitalWindowBounds class --------------------

    static PyObject* _new_DigitalWindowBounds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::DigitalWindowBounds instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DigitalWindowBounds(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DigitalWindowBounds_get_Scale(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowBounds", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_Scale(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowBounds", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DigitalWindowBounds_get_NormalizedOriginTop(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowBounds", L"NormalizedOriginTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedOriginTop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_NormalizedOriginTop(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowBounds", L"NormalizedOriginTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.NormalizedOriginTop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DigitalWindowBounds_get_NormalizedOriginLeft(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowBounds", L"NormalizedOriginLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedOriginLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_NormalizedOriginLeft(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowBounds", L"NormalizedOriginLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.NormalizedOriginLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DigitalWindowBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::DigitalWindowBounds>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DigitalWindowBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowBounds>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowBounds[] = {
        { "_assign_array_", _assign_array_DigitalWindowBounds, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DigitalWindowBounds), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DigitalWindowBounds[] = {
        { "scale", reinterpret_cast<getter>(DigitalWindowBounds_get_Scale), reinterpret_cast<setter>(DigitalWindowBounds_put_Scale), nullptr, nullptr },
        { "normalized_origin_top", reinterpret_cast<getter>(DigitalWindowBounds_get_NormalizedOriginTop), reinterpret_cast<setter>(DigitalWindowBounds_put_NormalizedOriginTop), nullptr, nullptr },
        { "normalized_origin_left", reinterpret_cast<getter>(DigitalWindowBounds_get_NormalizedOriginLeft), reinterpret_cast<setter>(DigitalWindowBounds_put_NormalizedOriginLeft), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DigitalWindowBounds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DigitalWindowBounds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DigitalWindowBounds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DigitalWindowBounds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DigitalWindowBounds) },
        { },
    };

    static PyType_Spec type_spec_DigitalWindowBounds =
    {
        "winrt._winrt_windows_media_devices.DigitalWindowBounds",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowBounds
    };

    // ----- DigitalWindowCapability class --------------------

    static PyObject* _new_DigitalWindowCapability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::DigitalWindowCapability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::DigitalWindowCapability>::type_name);
        return nullptr;
    }

    static void _dealloc_DigitalWindowCapability(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DigitalWindowCapability_get_Height(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowCapability", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MaxScaleValue(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowCapability", L"MaxScaleValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScaleValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MinScaleValue(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowCapability", L"MinScaleValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScaleValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MinScaleValueWithoutUpsampling(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowCapability", L"MinScaleValueWithoutUpsampling"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScaleValueWithoutUpsampling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_NormalizedFieldOfViewLimit(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowCapability", L"NormalizedFieldOfViewLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedFieldOfViewLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_Width(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowCapability", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DigitalWindowCapability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::DigitalWindowCapability>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DigitalWindowCapability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowCapability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowCapability[] = {
        { "_assign_array_", _assign_array_DigitalWindowCapability, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DigitalWindowCapability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DigitalWindowCapability[] = {
        { "height", reinterpret_cast<getter>(DigitalWindowCapability_get_Height), nullptr, nullptr, nullptr },
        { "max_scale_value", reinterpret_cast<getter>(DigitalWindowCapability_get_MaxScaleValue), nullptr, nullptr, nullptr },
        { "min_scale_value", reinterpret_cast<getter>(DigitalWindowCapability_get_MinScaleValue), nullptr, nullptr, nullptr },
        { "min_scale_value_without_upsampling", reinterpret_cast<getter>(DigitalWindowCapability_get_MinScaleValueWithoutUpsampling), nullptr, nullptr, nullptr },
        { "normalized_field_of_view_limit", reinterpret_cast<getter>(DigitalWindowCapability_get_NormalizedFieldOfViewLimit), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(DigitalWindowCapability_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DigitalWindowCapability[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DigitalWindowCapability) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DigitalWindowCapability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DigitalWindowCapability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DigitalWindowCapability) },
        { },
    };

    static PyType_Spec type_spec_DigitalWindowCapability =
    {
        "winrt._winrt_windows_media_devices.DigitalWindowCapability",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowCapability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowCapability
    };

    // ----- DigitalWindowControl class --------------------

    static PyObject* _new_DigitalWindowControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::DigitalWindowControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::DigitalWindowControl>::type_name);
        return nullptr;
    }

    static void _dealloc_DigitalWindowControl(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DigitalWindowControl_Configure(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.DigitalWindowControl", L"Configure", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowMode>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.DigitalWindowControl", L"Configure", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowBounds>(args, 1);

                self->obj.Configure(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_GetBounds(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.DigitalWindowControl", L"GetBounds", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetBounds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_GetCapabilityForSize(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.DigitalWindowControl", L"GetCapabilityForSize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetCapabilityForSize(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_CurrentMode(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowControl", L"CurrentMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_IsSupported(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowControl", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_SupportedCapabilities(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowControl", L"SupportedCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.DigitalWindowControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DigitalWindowControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::DigitalWindowControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DigitalWindowControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(DigitalWindowControl_Configure), METH_VARARGS, nullptr },
        { "get_bounds", reinterpret_cast<PyCFunction>(DigitalWindowControl_GetBounds), METH_VARARGS, nullptr },
        { "get_capability_for_size", reinterpret_cast<PyCFunction>(DigitalWindowControl_GetCapabilityForSize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DigitalWindowControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DigitalWindowControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DigitalWindowControl[] = {
        { "current_mode", reinterpret_cast<getter>(DigitalWindowControl_get_CurrentMode), nullptr, nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(DigitalWindowControl_get_IsSupported), nullptr, nullptr, nullptr },
        { "supported_capabilities", reinterpret_cast<getter>(DigitalWindowControl_get_SupportedCapabilities), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(DigitalWindowControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DigitalWindowControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DigitalWindowControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DigitalWindowControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DigitalWindowControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DigitalWindowControl) },
        { },
    };

    static PyType_Spec type_spec_DigitalWindowControl =
    {
        "winrt._winrt_windows_media_devices.DigitalWindowControl",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowControl
    };

    // ----- ExposureCompensationControl class --------------------

    static PyObject* _new_ExposureCompensationControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::ExposureCompensationControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::ExposureCompensationControl>::type_name);
        return nullptr;
    }

    static void _dealloc_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExposureCompensationControl_SetValueAsync(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.ExposureCompensationControl", L"SetValueAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Max(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureCompensationControl", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Min(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureCompensationControl", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Step(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureCompensationControl", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureCompensationControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureCompensationControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::ExposureCompensationControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposureCompensationControl[] = {
        { "set_value_async", reinterpret_cast<PyCFunction>(ExposureCompensationControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ExposureCompensationControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExposureCompensationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExposureCompensationControl[] = {
        { "max", reinterpret_cast<getter>(ExposureCompensationControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(ExposureCompensationControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(ExposureCompensationControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ExposureCompensationControl_get_Supported), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ExposureCompensationControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExposureCompensationControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExposureCompensationControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExposureCompensationControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExposureCompensationControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExposureCompensationControl) },
        { },
    };

    static PyType_Spec type_spec_ExposureCompensationControl =
    {
        "winrt._winrt_windows_media_devices.ExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposureCompensationControl
    };

    // ----- ExposureControl class --------------------

    static PyObject* _new_ExposureControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::ExposureControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::ExposureControl>::type_name);
        return nullptr;
    }

    static void _dealloc_ExposureControl(py::wrapper::Windows::Media::Devices::ExposureControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExposureControl_SetAutoAsync(py::wrapper::Windows::Media::Devices::ExposureControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.ExposureControl", L"SetAutoAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetAutoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureControl_SetValueAsync(py::wrapper::Windows::Media::Devices::ExposureControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.ExposureControl", L"SetValueAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Max(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureControl", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Min(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureControl", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Step(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureControl", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Value(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposureControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::ExposureControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposureControl[] = {
        { "set_auto_async", reinterpret_cast<PyCFunction>(ExposureControl_SetAutoAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(ExposureControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ExposureControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExposureControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExposureControl[] = {
        { "auto", reinterpret_cast<getter>(ExposureControl_get_Auto), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(ExposureControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(ExposureControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(ExposureControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ExposureControl_get_Supported), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ExposureControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExposureControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExposureControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExposureControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExposureControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExposureControl) },
        { },
    };

    static PyType_Spec type_spec_ExposureControl =
    {
        "winrt._winrt_windows_media_devices.ExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposureControl
    };

    // ----- ExposurePriorityVideoControl class --------------------

    static PyObject* _new_ExposurePriorityVideoControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>::type_name);
        return nullptr;
    }

    static void _dealloc_ExposurePriorityVideoControl(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExposurePriorityVideoControl_get_Enabled(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposurePriorityVideoControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ExposurePriorityVideoControl_put_Enabled(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposurePriorityVideoControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ExposurePriorityVideoControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ExposurePriorityVideoControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExposurePriorityVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExposurePriorityVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposurePriorityVideoControl[] = {
        { "_assign_array_", _assign_array_ExposurePriorityVideoControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExposurePriorityVideoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExposurePriorityVideoControl[] = {
        { "enabled", reinterpret_cast<getter>(ExposurePriorityVideoControl_get_Enabled), reinterpret_cast<setter>(ExposurePriorityVideoControl_put_Enabled), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ExposurePriorityVideoControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExposurePriorityVideoControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExposurePriorityVideoControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExposurePriorityVideoControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExposurePriorityVideoControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExposurePriorityVideoControl) },
        { },
    };

    static PyType_Spec type_spec_ExposurePriorityVideoControl =
    {
        "winrt._winrt_windows_media_devices.ExposurePriorityVideoControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposurePriorityVideoControl
    };

    // ----- FlashControl class --------------------

    static PyObject* _new_FlashControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::FlashControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::FlashControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FlashControl(py::wrapper::Windows::Media::Devices::FlashControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"RedEyeReduction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedEyeReduction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"RedEyeReduction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RedEyeReduction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"PowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"PowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_Enabled(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_Enabled(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_Auto(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_Auto(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_PowerSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"PowerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"RedEyeReductionSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedEyeReductionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_Supported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_AssistantLightEnabled(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"AssistantLightEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AssistantLightEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_AssistantLightEnabled(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"AssistantLightEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AssistantLightEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_AssistantLightSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FlashControl", L"AssistantLightSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AssistantLightSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::FlashControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlashControl[] = {
        { "_assign_array_", _assign_array_FlashControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlashControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlashControl[] = {
        { "red_eye_reduction", reinterpret_cast<getter>(FlashControl_get_RedEyeReduction), reinterpret_cast<setter>(FlashControl_put_RedEyeReduction), nullptr, nullptr },
        { "power_percent", reinterpret_cast<getter>(FlashControl_get_PowerPercent), reinterpret_cast<setter>(FlashControl_put_PowerPercent), nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(FlashControl_get_Enabled), reinterpret_cast<setter>(FlashControl_put_Enabled), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FlashControl_get_Auto), reinterpret_cast<setter>(FlashControl_put_Auto), nullptr, nullptr },
        { "power_supported", reinterpret_cast<getter>(FlashControl_get_PowerSupported), nullptr, nullptr, nullptr },
        { "red_eye_reduction_supported", reinterpret_cast<getter>(FlashControl_get_RedEyeReductionSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FlashControl_get_Supported), nullptr, nullptr, nullptr },
        { "assistant_light_enabled", reinterpret_cast<getter>(FlashControl_get_AssistantLightEnabled), reinterpret_cast<setter>(FlashControl_put_AssistantLightEnabled), nullptr, nullptr },
        { "assistant_light_supported", reinterpret_cast<getter>(FlashControl_get_AssistantLightSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlashControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlashControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlashControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlashControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlashControl) },
        { },
    };

    static PyType_Spec type_spec_FlashControl =
    {
        "winrt._winrt_windows_media_devices.FlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::FlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlashControl
    };

    // ----- FocusControl class --------------------

    static PyObject* _new_FocusControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::FocusControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::FocusControl>::type_name);
        return nullptr;
    }

    static void _dealloc_FocusControl(py::wrapper::Windows::Media::Devices::FocusControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusControl_Configure(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"Configure", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_FocusAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"FocusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FocusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_LockAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"LockAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.LockAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"SetPresetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusPreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"SetPresetAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusPreset>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetPresetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_SetValueAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"SetValueAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_UnlockAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.FocusControl", L"UnlockAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnlockAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Max(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Min(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Preset(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Preset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Step(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Supported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedPresets(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"SupportedPresets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPresets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Value(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_FocusChangedSupported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"FocusChangedSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusChangedSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_FocusState(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"FocusState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Mode(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusDistances(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"SupportedFocusDistances"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedFocusDistances());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusModes(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"SupportedFocusModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedFocusModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusRanges(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"SupportedFocusRanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedFocusRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_WaitForFocusSupported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusControl", L"WaitForFocusSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WaitForFocusSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::FocusControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(FocusControl_Configure), METH_VARARGS, nullptr },
        { "focus_async", reinterpret_cast<PyCFunction>(FocusControl_FocusAsync), METH_VARARGS, nullptr },
        { "lock_async", reinterpret_cast<PyCFunction>(FocusControl_LockAsync), METH_VARARGS, nullptr },
        { "set_preset_async", reinterpret_cast<PyCFunction>(FocusControl_SetPresetAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(FocusControl_SetValueAsync), METH_VARARGS, nullptr },
        { "unlock_async", reinterpret_cast<PyCFunction>(FocusControl_UnlockAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FocusControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusControl[] = {
        { "max", reinterpret_cast<getter>(FocusControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FocusControl_get_Min), nullptr, nullptr, nullptr },
        { "preset", reinterpret_cast<getter>(FocusControl_get_Preset), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FocusControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FocusControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_presets", reinterpret_cast<getter>(FocusControl_get_SupportedPresets), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(FocusControl_get_Value), nullptr, nullptr, nullptr },
        { "focus_changed_supported", reinterpret_cast<getter>(FocusControl_get_FocusChangedSupported), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(FocusControl_get_FocusState), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FocusControl_get_Mode), nullptr, nullptr, nullptr },
        { "supported_focus_distances", reinterpret_cast<getter>(FocusControl_get_SupportedFocusDistances), nullptr, nullptr, nullptr },
        { "supported_focus_modes", reinterpret_cast<getter>(FocusControl_get_SupportedFocusModes), nullptr, nullptr, nullptr },
        { "supported_focus_ranges", reinterpret_cast<getter>(FocusControl_get_SupportedFocusRanges), nullptr, nullptr, nullptr },
        { "wait_for_focus_supported", reinterpret_cast<getter>(FocusControl_get_WaitForFocusSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusControl) },
        { },
    };

    static PyType_Spec type_spec_FocusControl =
    {
        "winrt._winrt_windows_media_devices.FocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::FocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusControl
    };

    // ----- FocusSettings class --------------------

    static PyObject* _new_FocusSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::FocusSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FocusSettings(py::wrapper::Windows::Media::Devices::FocusSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSettings_get_WaitForFocus(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"WaitForFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WaitForFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_WaitForFocus(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"WaitForFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WaitForFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Value(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Value(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Mode(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Mode(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Distance(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"Distance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Distance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Distance(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"Distance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Devices::ManualFocusDistance>>(arg);

            self->obj.Distance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_DisableDriverFallback(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"DisableDriverFallback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisableDriverFallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_DisableDriverFallback(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"DisableDriverFallback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableDriverFallback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_AutoFocusRange(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"AutoFocusRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoFocusRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_AutoFocusRange(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.FocusSettings", L"AutoFocusRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::AutoFocusRange>(arg);

            self->obj.AutoFocusRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FocusSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::FocusSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FocusSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FocusSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSettings[] = {
        { "_assign_array_", _assign_array_FocusSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusSettings[] = {
        { "wait_for_focus", reinterpret_cast<getter>(FocusSettings_get_WaitForFocus), reinterpret_cast<setter>(FocusSettings_put_WaitForFocus), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(FocusSettings_get_Value), reinterpret_cast<setter>(FocusSettings_put_Value), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FocusSettings_get_Mode), reinterpret_cast<setter>(FocusSettings_put_Mode), nullptr, nullptr },
        { "distance", reinterpret_cast<getter>(FocusSettings_get_Distance), reinterpret_cast<setter>(FocusSettings_put_Distance), nullptr, nullptr },
        { "disable_driver_fallback", reinterpret_cast<getter>(FocusSettings_get_DisableDriverFallback), reinterpret_cast<setter>(FocusSettings_put_DisableDriverFallback), nullptr, nullptr },
        { "auto_focus_range", reinterpret_cast<getter>(FocusSettings_get_AutoFocusRange), reinterpret_cast<setter>(FocusSettings_put_AutoFocusRange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FocusSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FocusSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FocusSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FocusSettings) },
        { },
    };

    static PyType_Spec type_spec_FocusSettings =
    {
        "winrt._winrt_windows_media_devices.FocusSettings",
        sizeof(py::wrapper::Windows::Media::Devices::FocusSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSettings
    };

    // ----- HdrVideoControl class --------------------

    static PyObject* _new_HdrVideoControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::HdrVideoControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::HdrVideoControl>::type_name);
        return nullptr;
    }

    static void _dealloc_HdrVideoControl(py::wrapper::Windows::Media::Devices::HdrVideoControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HdrVideoControl_get_Mode(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.HdrVideoControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HdrVideoControl_put_Mode(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.HdrVideoControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::HdrVideoMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HdrVideoControl_get_Supported(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.HdrVideoControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HdrVideoControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.HdrVideoControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HdrVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::HdrVideoControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HdrVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::HdrVideoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HdrVideoControl[] = {
        { "_assign_array_", _assign_array_HdrVideoControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HdrVideoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HdrVideoControl[] = {
        { "mode", reinterpret_cast<getter>(HdrVideoControl_get_Mode), reinterpret_cast<setter>(HdrVideoControl_put_Mode), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(HdrVideoControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(HdrVideoControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HdrVideoControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HdrVideoControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HdrVideoControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HdrVideoControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HdrVideoControl) },
        { },
    };

    static PyType_Spec type_spec_HdrVideoControl =
    {
        "winrt._winrt_windows_media_devices.HdrVideoControl",
        sizeof(py::wrapper::Windows::Media::Devices::HdrVideoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HdrVideoControl
    };

    // ----- InfraredTorchControl class --------------------

    static PyObject* _new_InfraredTorchControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::InfraredTorchControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::InfraredTorchControl>::type_name);
        return nullptr;
    }

    static void _dealloc_InfraredTorchControl(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfraredTorchControl_get_Power(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"Power"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Power());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfraredTorchControl_put_Power(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"Power"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Power(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfraredTorchControl_get_CurrentMode(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"CurrentMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfraredTorchControl_put_CurrentMode(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"CurrentMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::InfraredTorchMode>(arg);

            self->obj.CurrentMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfraredTorchControl_get_IsSupported(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_MaxPower(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"MaxPower"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_MinPower(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"MinPower"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_PowerStep(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"PowerStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.InfraredTorchControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfraredTorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::InfraredTorchControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfraredTorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::InfraredTorchControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfraredTorchControl[] = {
        { "_assign_array_", _assign_array_InfraredTorchControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfraredTorchControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InfraredTorchControl[] = {
        { "power", reinterpret_cast<getter>(InfraredTorchControl_get_Power), reinterpret_cast<setter>(InfraredTorchControl_put_Power), nullptr, nullptr },
        { "current_mode", reinterpret_cast<getter>(InfraredTorchControl_get_CurrentMode), reinterpret_cast<setter>(InfraredTorchControl_put_CurrentMode), nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(InfraredTorchControl_get_IsSupported), nullptr, nullptr, nullptr },
        { "max_power", reinterpret_cast<getter>(InfraredTorchControl_get_MaxPower), nullptr, nullptr, nullptr },
        { "min_power", reinterpret_cast<getter>(InfraredTorchControl_get_MinPower), nullptr, nullptr, nullptr },
        { "power_step", reinterpret_cast<getter>(InfraredTorchControl_get_PowerStep), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(InfraredTorchControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InfraredTorchControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfraredTorchControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfraredTorchControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfraredTorchControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfraredTorchControl) },
        { },
    };

    static PyType_Spec type_spec_InfraredTorchControl =
    {
        "winrt._winrt_windows_media_devices.InfraredTorchControl",
        sizeof(py::wrapper::Windows::Media::Devices::InfraredTorchControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InfraredTorchControl
    };

    // ----- IsoSpeedControl class --------------------

    static PyObject* _new_IsoSpeedControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::IsoSpeedControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::IsoSpeedControl>::type_name);
        return nullptr;
    }

    static void _dealloc_IsoSpeedControl(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IsoSpeedControl_SetAutoAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.IsoSpeedControl", L"SetAutoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SetAutoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.IsoSpeedControl", L"SetPresetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::IsoSpeedPreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_SetValueAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.IsoSpeedControl", L"SetValueAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Preset(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Preset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Supported(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_SupportedPresets(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"SupportedPresets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPresets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Max(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Min(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Step(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IsoSpeedControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::IsoSpeedControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsoSpeedControl[] = {
        { "set_auto_async", reinterpret_cast<PyCFunction>(IsoSpeedControl_SetAutoAsync), METH_VARARGS, nullptr },
        { "set_preset_async", reinterpret_cast<PyCFunction>(IsoSpeedControl_SetPresetAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(IsoSpeedControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IsoSpeedControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsoSpeedControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsoSpeedControl[] = {
        { "preset", reinterpret_cast<getter>(IsoSpeedControl_get_Preset), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(IsoSpeedControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_presets", reinterpret_cast<getter>(IsoSpeedControl_get_SupportedPresets), nullptr, nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(IsoSpeedControl_get_Auto), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(IsoSpeedControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(IsoSpeedControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(IsoSpeedControl_get_Step), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IsoSpeedControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsoSpeedControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IsoSpeedControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IsoSpeedControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IsoSpeedControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IsoSpeedControl) },
        { },
    };

    static PyType_Spec type_spec_IsoSpeedControl =
    {
        "winrt._winrt_windows_media_devices.IsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::IsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsoSpeedControl
    };

    // ----- KeypadPressedEventArgs class --------------------

    static PyObject* _new_KeypadPressedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::KeypadPressedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::KeypadPressedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_KeypadPressedEventArgs(py::wrapper::Windows::Media::Devices::KeypadPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeypadPressedEventArgs_get_TelephonyKey(py::wrapper::Windows::Media::Devices::KeypadPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.KeypadPressedEventArgs", L"TelephonyKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TelephonyKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeypadPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::KeypadPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeypadPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::KeypadPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeypadPressedEventArgs[] = {
        { "_assign_array_", _assign_array_KeypadPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeypadPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeypadPressedEventArgs[] = {
        { "telephony_key", reinterpret_cast<getter>(KeypadPressedEventArgs_get_TelephonyKey), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeypadPressedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeypadPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeypadPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeypadPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeypadPressedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_KeypadPressedEventArgs =
    {
        "winrt._winrt_windows_media_devices.KeypadPressedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::KeypadPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeypadPressedEventArgs
    };

    // ----- LowLagPhotoControl class --------------------

    static PyObject* _new_LowLagPhotoControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::LowLagPhotoControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::LowLagPhotoControl>::type_name);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoControl(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagPhotoControl_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"GetCurrentFrameRate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoControl_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"GetHighestConcurrentFrameRate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoControl_get_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"ThumbnailFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThumbnailFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"ThumbnailFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>(arg);

            self->obj.ThumbnailFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"ThumbnailEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThumbnailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"ThumbnailEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ThumbnailEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"DesiredThumbnailSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredThumbnailSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"DesiredThumbnailSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DesiredThumbnailSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_HardwareAcceleratedThumbnailSupported(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoControl", L"HardwareAcceleratedThumbnailSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareAcceleratedThumbnailSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::LowLagPhotoControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::LowLagPhotoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoControl[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoControl_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoControl_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLagPhotoControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoControl[] = {
        { "thumbnail_format", reinterpret_cast<getter>(LowLagPhotoControl_get_ThumbnailFormat), reinterpret_cast<setter>(LowLagPhotoControl_put_ThumbnailFormat), nullptr, nullptr },
        { "thumbnail_enabled", reinterpret_cast<getter>(LowLagPhotoControl_get_ThumbnailEnabled), reinterpret_cast<setter>(LowLagPhotoControl_put_ThumbnailEnabled), nullptr, nullptr },
        { "desired_thumbnail_size", reinterpret_cast<getter>(LowLagPhotoControl_get_DesiredThumbnailSize), reinterpret_cast<setter>(LowLagPhotoControl_put_DesiredThumbnailSize), nullptr, nullptr },
        { "hardware_accelerated_thumbnail_supported", reinterpret_cast<getter>(LowLagPhotoControl_get_HardwareAcceleratedThumbnailSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagPhotoControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagPhotoControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagPhotoControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagPhotoControl) },
        { },
    };

    static PyType_Spec type_spec_LowLagPhotoControl =
    {
        "winrt._winrt_windows_media_devices.LowLagPhotoControl",
        sizeof(py::wrapper::Windows::Media::Devices::LowLagPhotoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoControl
    };

    // ----- LowLagPhotoSequenceControl class --------------------

    static PyObject* _new_LowLagPhotoSequenceControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>::type_name);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceControl(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLagPhotoSequenceControl_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"GetCurrentFrameRate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"GetHighestConcurrentFrameRate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"ThumbnailFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThumbnailFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"ThumbnailFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>(arg);

            self->obj.ThumbnailFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"ThumbnailEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThumbnailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"ThumbnailEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ThumbnailEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"PhotosPerSecondLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotosPerSecondLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"PhotosPerSecondLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PhotosPerSecondLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_PastPhotoLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"PastPhotoLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PastPhotoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_PastPhotoLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"PastPhotoLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PastPhotoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"DesiredThumbnailSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredThumbnailSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"DesiredThumbnailSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DesiredThumbnailSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_HardwareAcceleratedThumbnailSupported(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"HardwareAcceleratedThumbnailSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareAcceleratedThumbnailSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_MaxPastPhotos(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"MaxPastPhotos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPastPhotos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"MaxPhotosPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPhotosPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_Supported(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.LowLagPhotoSequenceControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LowLagPhotoSequenceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LowLagPhotoSequenceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceControl[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceControl_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceControl_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LowLagPhotoSequenceControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoSequenceControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceControl[] = {
        { "thumbnail_format", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_ThumbnailFormat), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_ThumbnailFormat), nullptr, nullptr },
        { "thumbnail_enabled", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_ThumbnailEnabled), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_ThumbnailEnabled), nullptr, nullptr },
        { "photos_per_second_limit", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_PhotosPerSecondLimit), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_PhotosPerSecondLimit), nullptr, nullptr },
        { "past_photo_limit", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_PastPhotoLimit), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_PastPhotoLimit), nullptr, nullptr },
        { "desired_thumbnail_size", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_DesiredThumbnailSize), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_DesiredThumbnailSize), nullptr, nullptr },
        { "hardware_accelerated_thumbnail_supported", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_HardwareAcceleratedThumbnailSupported), nullptr, nullptr, nullptr },
        { "max_past_photos", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_MaxPastPhotos), nullptr, nullptr, nullptr },
        { "max_photos_per_second", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_MaxPhotosPerSecond), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LowLagPhotoSequenceControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LowLagPhotoSequenceControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LowLagPhotoSequenceControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LowLagPhotoSequenceControl) },
        { },
    };

    static PyType_Spec type_spec_LowLagPhotoSequenceControl =
    {
        "winrt._winrt_windows_media_devices.LowLagPhotoSequenceControl",
        sizeof(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceControl
    };

    // ----- MediaDevice class --------------------

    static PyObject* _new_MediaDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::MediaDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::MediaDevice>::type_name);
        return nullptr;
    }

    static PyObject* MediaDevice_GetAudioCaptureSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDevice", L"GetAudioCaptureSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetAudioCaptureSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetAudioRenderSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDevice", L"GetAudioRenderSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetAudioRenderSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetDefaultAudioCaptureId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDevice", L"GetDefaultAudioCaptureId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetDefaultAudioCaptureId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetDefaultAudioRenderId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDevice", L"GetDefaultAudioRenderId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetDefaultAudioRenderId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetVideoCaptureSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDevice", L"GetVideoCaptureSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetVideoCaptureSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_add_DefaultAudioCaptureDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.MediaDevice", L"DefaultAudioCaptureDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Devices::MediaDevice::DefaultAudioCaptureDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_remove_DefaultAudioCaptureDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.MediaDevice", L"DefaultAudioCaptureDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Devices::MediaDevice::DefaultAudioCaptureDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_add_DefaultAudioRenderDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.MediaDevice", L"DefaultAudioRenderDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Devices::MediaDevice::DefaultAudioRenderDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_remove_DefaultAudioRenderDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Devices.MediaDevice", L"DefaultAudioRenderDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Devices::MediaDevice::DefaultAudioRenderDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDevice[] = {
        { "get_audio_capture_selector", reinterpret_cast<PyCFunction>(MediaDevice_GetAudioCaptureSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_audio_render_selector", reinterpret_cast<PyCFunction>(MediaDevice_GetAudioRenderSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_audio_capture_id", reinterpret_cast<PyCFunction>(MediaDevice_GetDefaultAudioCaptureId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_audio_render_id", reinterpret_cast<PyCFunction>(MediaDevice_GetDefaultAudioRenderId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_video_capture_selector", reinterpret_cast<PyCFunction>(MediaDevice_GetVideoCaptureSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_default_audio_capture_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_add_DefaultAudioCaptureDeviceChanged), METH_O | METH_STATIC, nullptr },
        { "remove_default_audio_capture_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_remove_DefaultAudioCaptureDeviceChanged), METH_O | METH_STATIC, nullptr },
        { "add_default_audio_render_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_add_DefaultAudioRenderDeviceChanged), METH_O | METH_STATIC, nullptr },
        { "remove_default_audio_render_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_remove_DefaultAudioRenderDeviceChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaDevice) },
        { },
    };

    static PyType_Spec type_spec_MediaDevice =
    {
        "winrt._winrt_windows_media_devices.MediaDevice",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDevice
    };

    // ----- MediaDeviceControl class --------------------

    static PyObject* _new_MediaDeviceControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::MediaDeviceControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::MediaDeviceControl>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaDeviceControl(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaDeviceControl_TryGetAuto(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDeviceControl", L"TryGetAuto", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                bool param0 {  };

                auto return_value = self->obj.TryGetAuto(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TryGetValue(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDeviceControl", L"TryGetValue", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                double param0 {  };

                auto return_value = self->obj.TryGetValue(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TrySetAuto(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDeviceControl", L"TrySetAuto", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.TrySetAuto(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TrySetValue(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.MediaDeviceControl", L"TrySetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_get_Capabilities(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControl", L"Capabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaDeviceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::MediaDeviceControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaDeviceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::MediaDeviceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDeviceControl[] = {
        { "try_get_auto", reinterpret_cast<PyCFunction>(MediaDeviceControl_TryGetAuto), METH_VARARGS, nullptr },
        { "try_get_value", reinterpret_cast<PyCFunction>(MediaDeviceControl_TryGetValue), METH_VARARGS, nullptr },
        { "try_set_auto", reinterpret_cast<PyCFunction>(MediaDeviceControl_TrySetAuto), METH_VARARGS, nullptr },
        { "try_set_value", reinterpret_cast<PyCFunction>(MediaDeviceControl_TrySetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaDeviceControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaDeviceControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaDeviceControl[] = {
        { "capabilities", reinterpret_cast<getter>(MediaDeviceControl_get_Capabilities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaDeviceControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaDeviceControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaDeviceControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaDeviceControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaDeviceControl) },
        { },
    };

    static PyType_Spec type_spec_MediaDeviceControl =
    {
        "winrt._winrt_windows_media_devices.MediaDeviceControl",
        sizeof(py::wrapper::Windows::Media::Devices::MediaDeviceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDeviceControl
    };

    // ----- MediaDeviceControlCapabilities class --------------------

    static PyObject* _new_MediaDeviceControlCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaDeviceControlCapabilities(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaDeviceControlCapabilities_get_AutoModeSupported(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControlCapabilities", L"AutoModeSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoModeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Default(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControlCapabilities", L"Default"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Max(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControlCapabilities", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Min(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControlCapabilities", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Step(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControlCapabilities", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.MediaDeviceControlCapabilities", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaDeviceControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaDeviceControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDeviceControlCapabilities[] = {
        { "_assign_array_", _assign_array_MediaDeviceControlCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaDeviceControlCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaDeviceControlCapabilities[] = {
        { "auto_mode_supported", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_AutoModeSupported), nullptr, nullptr, nullptr },
        { "default", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Default), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaDeviceControlCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaDeviceControlCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaDeviceControlCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaDeviceControlCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaDeviceControlCapabilities) },
        { },
    };

    static PyType_Spec type_spec_MediaDeviceControlCapabilities =
    {
        "winrt._winrt_windows_media_devices.MediaDeviceControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDeviceControlCapabilities
    };

    // ----- ModuleCommandResult class --------------------

    static PyObject* _new_ModuleCommandResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::ModuleCommandResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::ModuleCommandResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ModuleCommandResult(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ModuleCommandResult_get_Result(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ModuleCommandResult", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ModuleCommandResult_get_Status(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ModuleCommandResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ModuleCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::ModuleCommandResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ModuleCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ModuleCommandResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ModuleCommandResult[] = {
        { "_assign_array_", _assign_array_ModuleCommandResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ModuleCommandResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ModuleCommandResult[] = {
        { "result", reinterpret_cast<getter>(ModuleCommandResult_get_Result), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ModuleCommandResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ModuleCommandResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ModuleCommandResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ModuleCommandResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ModuleCommandResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ModuleCommandResult) },
        { },
    };

    static PyType_Spec type_spec_ModuleCommandResult =
    {
        "winrt._winrt_windows_media_devices.ModuleCommandResult",
        sizeof(py::wrapper::Windows::Media::Devices::ModuleCommandResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ModuleCommandResult
    };

    // ----- OpticalImageStabilizationControl class --------------------

    static PyObject* _new_OpticalImageStabilizationControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>::type_name);
        return nullptr;
    }

    static void _dealloc_OpticalImageStabilizationControl(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OpticalImageStabilizationControl_get_Mode(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.OpticalImageStabilizationControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OpticalImageStabilizationControl_put_Mode(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.OpticalImageStabilizationControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::OpticalImageStabilizationMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OpticalImageStabilizationControl_get_Supported(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.OpticalImageStabilizationControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OpticalImageStabilizationControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.OpticalImageStabilizationControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OpticalImageStabilizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OpticalImageStabilizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OpticalImageStabilizationControl[] = {
        { "_assign_array_", _assign_array_OpticalImageStabilizationControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OpticalImageStabilizationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OpticalImageStabilizationControl[] = {
        { "mode", reinterpret_cast<getter>(OpticalImageStabilizationControl_get_Mode), reinterpret_cast<setter>(OpticalImageStabilizationControl_put_Mode), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(OpticalImageStabilizationControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(OpticalImageStabilizationControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OpticalImageStabilizationControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OpticalImageStabilizationControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OpticalImageStabilizationControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OpticalImageStabilizationControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OpticalImageStabilizationControl) },
        { },
    };

    static PyType_Spec type_spec_OpticalImageStabilizationControl =
    {
        "winrt._winrt_windows_media_devices.OpticalImageStabilizationControl",
        sizeof(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OpticalImageStabilizationControl
    };

    // ----- PanelBasedOptimizationControl class --------------------

    static PyObject* _new_PanelBasedOptimizationControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>::type_name);
        return nullptr;
    }

    static void _dealloc_PanelBasedOptimizationControl(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PanelBasedOptimizationControl_get_Panel(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PanelBasedOptimizationControl", L"Panel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Panel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PanelBasedOptimizationControl_put_Panel(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PanelBasedOptimizationControl", L"Panel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::Panel>(arg);

            self->obj.Panel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PanelBasedOptimizationControl_get_IsSupported(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PanelBasedOptimizationControl", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PanelBasedOptimizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PanelBasedOptimizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PanelBasedOptimizationControl[] = {
        { "_assign_array_", _assign_array_PanelBasedOptimizationControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PanelBasedOptimizationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PanelBasedOptimizationControl[] = {
        { "panel", reinterpret_cast<getter>(PanelBasedOptimizationControl_get_Panel), reinterpret_cast<setter>(PanelBasedOptimizationControl_put_Panel), nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(PanelBasedOptimizationControl_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PanelBasedOptimizationControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PanelBasedOptimizationControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PanelBasedOptimizationControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PanelBasedOptimizationControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PanelBasedOptimizationControl) },
        { },
    };

    static PyType_Spec type_spec_PanelBasedOptimizationControl =
    {
        "winrt._winrt_windows_media_devices.PanelBasedOptimizationControl",
        sizeof(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PanelBasedOptimizationControl
    };

    // ----- PhotoConfirmationControl class --------------------

    static PyObject* _new_PhotoConfirmationControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::PhotoConfirmationControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::PhotoConfirmationControl>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationControl(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoConfirmationControl_get_PixelFormat(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PhotoConfirmationControl", L"PixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoConfirmationControl_put_PixelFormat(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PhotoConfirmationControl", L"PixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(arg);

            self->obj.PixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoConfirmationControl_get_Enabled(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PhotoConfirmationControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoConfirmationControl_put_Enabled(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PhotoConfirmationControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoConfirmationControl_get_Supported(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.PhotoConfirmationControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoConfirmationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::PhotoConfirmationControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoConfirmationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::PhotoConfirmationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationControl[] = {
        { "_assign_array_", _assign_array_PhotoConfirmationControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoConfirmationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoConfirmationControl[] = {
        { "pixel_format", reinterpret_cast<getter>(PhotoConfirmationControl_get_PixelFormat), reinterpret_cast<setter>(PhotoConfirmationControl_put_PixelFormat), nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(PhotoConfirmationControl_get_Enabled), reinterpret_cast<setter>(PhotoConfirmationControl_put_Enabled), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(PhotoConfirmationControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoConfirmationControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoConfirmationControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoConfirmationControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoConfirmationControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoConfirmationControl) },
        { },
    };

    static PyType_Spec type_spec_PhotoConfirmationControl =
    {
        "winrt._winrt_windows_media_devices.PhotoConfirmationControl",
        sizeof(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationControl
    };

    // ----- RedialRequestedEventArgs class --------------------

    static PyObject* _new_RedialRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::RedialRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::RedialRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RedialRequestedEventArgs(py::wrapper::Windows::Media::Devices::RedialRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RedialRequestedEventArgs_Handled(py::wrapper::Windows::Media::Devices::RedialRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.RedialRequestedEventArgs", L"Handled", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Handled();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RedialRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::RedialRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RedialRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RedialRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RedialRequestedEventArgs[] = {
        { "handled", reinterpret_cast<PyCFunction>(RedialRequestedEventArgs_Handled), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RedialRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RedialRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RedialRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_RedialRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RedialRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RedialRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RedialRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RedialRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RedialRequestedEventArgs =
    {
        "winrt._winrt_windows_media_devices.RedialRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::RedialRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RedialRequestedEventArgs
    };

    // ----- RegionOfInterest class --------------------

    static PyObject* _new_RegionOfInterest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::RegionOfInterest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegionOfInterest(py::wrapper::Windows::Media::Devices::RegionOfInterest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RegionOfInterest_get_Bounds(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Bounds(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoWhiteBalanceEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"AutoWhiteBalanceEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoWhiteBalanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoWhiteBalanceEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"AutoWhiteBalanceEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoWhiteBalanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoFocusEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"AutoFocusEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoFocusEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoFocusEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"AutoFocusEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoFocusEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoExposureEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"AutoExposureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoExposureEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"AutoExposureEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoExposureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_Weight(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"Weight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Weight(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"Weight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Weight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_Type(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Type(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::RegionOfInterestType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_BoundsNormalized(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"BoundsNormalized"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BoundsNormalized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_BoundsNormalized(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionOfInterest", L"BoundsNormalized"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.BoundsNormalized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RegionOfInterest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::RegionOfInterest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RegionOfInterest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RegionOfInterest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegionOfInterest[] = {
        { "_assign_array_", _assign_array_RegionOfInterest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RegionOfInterest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegionOfInterest[] = {
        { "bounds", reinterpret_cast<getter>(RegionOfInterest_get_Bounds), reinterpret_cast<setter>(RegionOfInterest_put_Bounds), nullptr, nullptr },
        { "auto_white_balance_enabled", reinterpret_cast<getter>(RegionOfInterest_get_AutoWhiteBalanceEnabled), reinterpret_cast<setter>(RegionOfInterest_put_AutoWhiteBalanceEnabled), nullptr, nullptr },
        { "auto_focus_enabled", reinterpret_cast<getter>(RegionOfInterest_get_AutoFocusEnabled), reinterpret_cast<setter>(RegionOfInterest_put_AutoFocusEnabled), nullptr, nullptr },
        { "auto_exposure_enabled", reinterpret_cast<getter>(RegionOfInterest_get_AutoExposureEnabled), reinterpret_cast<setter>(RegionOfInterest_put_AutoExposureEnabled), nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(RegionOfInterest_get_Weight), reinterpret_cast<setter>(RegionOfInterest_put_Weight), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(RegionOfInterest_get_Type), reinterpret_cast<setter>(RegionOfInterest_put_Type), nullptr, nullptr },
        { "bounds_normalized", reinterpret_cast<getter>(RegionOfInterest_get_BoundsNormalized), reinterpret_cast<setter>(RegionOfInterest_put_BoundsNormalized), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegionOfInterest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RegionOfInterest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RegionOfInterest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RegionOfInterest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RegionOfInterest) },
        { },
    };

    static PyType_Spec type_spec_RegionOfInterest =
    {
        "winrt._winrt_windows_media_devices.RegionOfInterest",
        sizeof(py::wrapper::Windows::Media::Devices::RegionOfInterest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegionOfInterest
    };

    // ----- RegionsOfInterestControl class --------------------

    static PyObject* _new_RegionsOfInterestControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::RegionsOfInterestControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::RegionsOfInterestControl>::type_name);
        return nullptr;
    }

    static void _dealloc_RegionsOfInterestControl(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RegionsOfInterestControl_ClearRegionsAsync(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"ClearRegionsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearRegionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_SetRegionsAsync(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"SetRegionsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Devices::RegionOfInterest>>(args, 0);

                return py::convert(self->obj.SetRegionsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"SetRegionsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Devices::RegionOfInterest>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetRegionsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoExposureSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"AutoExposureSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoExposureSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoFocusSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"AutoFocusSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoFocusSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoWhiteBalanceSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"AutoWhiteBalanceSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoWhiteBalanceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_MaxRegions(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.RegionsOfInterestControl", L"MaxRegions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxRegions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RegionsOfInterestControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::RegionsOfInterestControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RegionsOfInterestControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RegionsOfInterestControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegionsOfInterestControl[] = {
        { "clear_regions_async", reinterpret_cast<PyCFunction>(RegionsOfInterestControl_ClearRegionsAsync), METH_VARARGS, nullptr },
        { "set_regions_async", reinterpret_cast<PyCFunction>(RegionsOfInterestControl_SetRegionsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RegionsOfInterestControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RegionsOfInterestControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegionsOfInterestControl[] = {
        { "auto_exposure_supported", reinterpret_cast<getter>(RegionsOfInterestControl_get_AutoExposureSupported), nullptr, nullptr, nullptr },
        { "auto_focus_supported", reinterpret_cast<getter>(RegionsOfInterestControl_get_AutoFocusSupported), nullptr, nullptr, nullptr },
        { "auto_white_balance_supported", reinterpret_cast<getter>(RegionsOfInterestControl_get_AutoWhiteBalanceSupported), nullptr, nullptr, nullptr },
        { "max_regions", reinterpret_cast<getter>(RegionsOfInterestControl_get_MaxRegions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegionsOfInterestControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RegionsOfInterestControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RegionsOfInterestControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RegionsOfInterestControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RegionsOfInterestControl) },
        { },
    };

    static PyType_Spec type_spec_RegionsOfInterestControl =
    {
        "winrt._winrt_windows_media_devices.RegionsOfInterestControl",
        sizeof(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegionsOfInterestControl
    };

    // ----- SceneModeControl class --------------------

    static PyObject* _new_SceneModeControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::SceneModeControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::SceneModeControl>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneModeControl(py::wrapper::Windows::Media::Devices::SceneModeControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneModeControl_SetValueAsync(py::wrapper::Windows::Media::Devices::SceneModeControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.SceneModeControl", L"SetValueAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CaptureSceneMode>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneModeControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::SceneModeControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.SceneModeControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneModeControl_get_Value(py::wrapper::Windows::Media::Devices::SceneModeControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.SceneModeControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneModeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::SceneModeControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneModeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::SceneModeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneModeControl[] = {
        { "set_value_async", reinterpret_cast<PyCFunction>(SceneModeControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneModeControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneModeControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneModeControl[] = {
        { "supported_modes", reinterpret_cast<getter>(SceneModeControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(SceneModeControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneModeControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneModeControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneModeControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneModeControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneModeControl) },
        { },
    };

    static PyType_Spec type_spec_SceneModeControl =
    {
        "winrt._winrt_windows_media_devices.SceneModeControl",
        sizeof(py::wrapper::Windows::Media::Devices::SceneModeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneModeControl
    };

    // ----- TorchControl class --------------------

    static PyObject* _new_TorchControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::TorchControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::TorchControl>::type_name);
        return nullptr;
    }

    static void _dealloc_TorchControl(py::wrapper::Windows::Media::Devices::TorchControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TorchControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.TorchControl", L"PowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TorchControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::TorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.TorchControl", L"PowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TorchControl_get_Enabled(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.TorchControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TorchControl_put_Enabled(py::wrapper::Windows::Media::Devices::TorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.TorchControl", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TorchControl_get_PowerSupported(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.TorchControl", L"PowerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TorchControl_get_Supported(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.TorchControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::TorchControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::TorchControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TorchControl[] = {
        { "_assign_array_", _assign_array_TorchControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TorchControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TorchControl[] = {
        { "power_percent", reinterpret_cast<getter>(TorchControl_get_PowerPercent), reinterpret_cast<setter>(TorchControl_put_PowerPercent), nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(TorchControl_get_Enabled), reinterpret_cast<setter>(TorchControl_put_Enabled), nullptr, nullptr },
        { "power_supported", reinterpret_cast<getter>(TorchControl_get_PowerSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(TorchControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TorchControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TorchControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TorchControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TorchControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TorchControl) },
        { },
    };

    static PyType_Spec type_spec_TorchControl =
    {
        "winrt._winrt_windows_media_devices.TorchControl",
        sizeof(py::wrapper::Windows::Media::Devices::TorchControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TorchControl
    };

    // ----- VideoDeviceController class --------------------

    static PyObject* _new_VideoDeviceController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::VideoDeviceController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::VideoDeviceController>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoDeviceController(py::wrapper::Windows::Media::Devices::VideoDeviceController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"GetAvailableMediaStreamProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDeviceProperty(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"GetDeviceProperty", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetDeviceProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDevicePropertyByExtendedId(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"GetDevicePropertyByExtendedId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.GetDevicePropertyByExtendedId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDevicePropertyById(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"GetDevicePropertyById", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.GetDevicePropertyById(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"GetMediaStreamProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDeviceProperty(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"SetDeviceProperty", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetDeviceProperty(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDevicePropertyByExtendedId(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"SetDevicePropertyByExtendedId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(self->obj.SetDevicePropertyByExtendedId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDevicePropertyById(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"SetDevicePropertyById", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.SetDevicePropertyById(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"SetMediaStreamPropertiesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TryAcquireExclusiveControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"TryAcquireExclusiveControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlReleaseMode>(args, 1);

                return py::convert(self->obj.TryAcquireExclusiveControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TryGetPowerlineFrequency(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"TryGetPowerlineFrequency", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Media::Capture::PowerlineFrequency param0 {  };

                auto return_value = self->obj.TryGetPowerlineFrequency(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TrySetPowerlineFrequency(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.VideoDeviceController", L"TrySetPowerlineFrequency", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::PowerlineFrequency>(args, 0);

                return py::convert(self->obj.TrySetPowerlineFrequency(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_CameraOcclusionInfo(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"CameraOcclusionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CameraOcclusionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PrimaryUse(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"PrimaryUse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDeviceController_put_PrimaryUse(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"PrimaryUse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::CaptureUse>(arg);

            self->obj.PrimaryUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDeviceController_get_FocusControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"FocusControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"IsoSpeedControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsoSpeedControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_LowLagPhoto(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"LowLagPhoto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowLagPhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_WhiteBalanceControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"WhiteBalanceControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WhiteBalanceControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_TorchControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"TorchControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TorchControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_SceneModeControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"SceneModeControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SceneModeControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_RegionsOfInterestControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"RegionsOfInterestControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegionsOfInterestControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_FlashControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"FlashControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlashControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_LowLagPhotoSequence(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"LowLagPhotoSequence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowLagPhotoSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"ExposureCompensationControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposureCompensationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposureControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"ExposureControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposureControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ZoomControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"ZoomControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PhotoConfirmationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"PhotoConfirmationControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoConfirmationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"VariablePhotoSequenceController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VariablePhotoSequenceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_DesiredOptimization(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"DesiredOptimization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredOptimization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDeviceController_put_DesiredOptimization(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"DesiredOptimization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCaptureOptimization>(arg);

            self->obj.DesiredOptimization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDeviceController_get_AdvancedPhotoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"AdvancedPhotoControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdvancedPhotoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposurePriorityVideoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"ExposurePriorityVideoControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposurePriorityVideoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_HdrVideoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"HdrVideoControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HdrVideoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_OpticalImageStabilizationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"OpticalImageStabilizationControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalImageStabilizationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Id(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_VideoTemporalDenoisingControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"VideoTemporalDenoisingControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoTemporalDenoisingControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_InfraredTorchControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"InfraredTorchControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InfraredTorchControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PanelBasedOptimizationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"PanelBasedOptimizationControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PanelBasedOptimizationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_DigitalWindowControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"DigitalWindowControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DigitalWindowControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Zoom(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Zoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Zoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Contrast(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_BacklightCompensation(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"BacklightCompensation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BacklightCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_WhiteBalance(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"WhiteBalance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Brightness(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Exposure(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Exposure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Tilt(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Tilt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Roll(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Roll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Hue(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Hue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Pan(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Pan"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Focus(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceController", L"Focus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::VideoDeviceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDeviceController[] = {
        { "get_available_media_stream_properties", reinterpret_cast<PyCFunction>(VideoDeviceController_GetAvailableMediaStreamProperties), METH_VARARGS, nullptr },
        { "get_device_property", reinterpret_cast<PyCFunction>(VideoDeviceController_GetDeviceProperty), METH_VARARGS, nullptr },
        { "get_device_property_by_extended_id", reinterpret_cast<PyCFunction>(VideoDeviceController_GetDevicePropertyByExtendedId), METH_VARARGS, nullptr },
        { "get_device_property_by_id", reinterpret_cast<PyCFunction>(VideoDeviceController_GetDevicePropertyById), METH_VARARGS, nullptr },
        { "get_media_stream_properties", reinterpret_cast<PyCFunction>(VideoDeviceController_GetMediaStreamProperties), METH_VARARGS, nullptr },
        { "set_device_property", reinterpret_cast<PyCFunction>(VideoDeviceController_SetDeviceProperty), METH_VARARGS, nullptr },
        { "set_device_property_by_extended_id", reinterpret_cast<PyCFunction>(VideoDeviceController_SetDevicePropertyByExtendedId), METH_VARARGS, nullptr },
        { "set_device_property_by_id", reinterpret_cast<PyCFunction>(VideoDeviceController_SetDevicePropertyById), METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", reinterpret_cast<PyCFunction>(VideoDeviceController_SetMediaStreamPropertiesAsync), METH_VARARGS, nullptr },
        { "try_acquire_exclusive_control", reinterpret_cast<PyCFunction>(VideoDeviceController_TryAcquireExclusiveControl), METH_VARARGS, nullptr },
        { "try_get_powerline_frequency", reinterpret_cast<PyCFunction>(VideoDeviceController_TryGetPowerlineFrequency), METH_VARARGS, nullptr },
        { "try_set_powerline_frequency", reinterpret_cast<PyCFunction>(VideoDeviceController_TrySetPowerlineFrequency), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VideoDeviceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoDeviceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoDeviceController[] = {
        { "camera_occlusion_info", reinterpret_cast<getter>(VideoDeviceController_get_CameraOcclusionInfo), nullptr, nullptr, nullptr },
        { "primary_use", reinterpret_cast<getter>(VideoDeviceController_get_PrimaryUse), reinterpret_cast<setter>(VideoDeviceController_put_PrimaryUse), nullptr, nullptr },
        { "focus_control", reinterpret_cast<getter>(VideoDeviceController_get_FocusControl), nullptr, nullptr, nullptr },
        { "iso_speed_control", reinterpret_cast<getter>(VideoDeviceController_get_IsoSpeedControl), nullptr, nullptr, nullptr },
        { "low_lag_photo", reinterpret_cast<getter>(VideoDeviceController_get_LowLagPhoto), nullptr, nullptr, nullptr },
        { "white_balance_control", reinterpret_cast<getter>(VideoDeviceController_get_WhiteBalanceControl), nullptr, nullptr, nullptr },
        { "torch_control", reinterpret_cast<getter>(VideoDeviceController_get_TorchControl), nullptr, nullptr, nullptr },
        { "scene_mode_control", reinterpret_cast<getter>(VideoDeviceController_get_SceneModeControl), nullptr, nullptr, nullptr },
        { "regions_of_interest_control", reinterpret_cast<getter>(VideoDeviceController_get_RegionsOfInterestControl), nullptr, nullptr, nullptr },
        { "flash_control", reinterpret_cast<getter>(VideoDeviceController_get_FlashControl), nullptr, nullptr, nullptr },
        { "low_lag_photo_sequence", reinterpret_cast<getter>(VideoDeviceController_get_LowLagPhotoSequence), nullptr, nullptr, nullptr },
        { "exposure_compensation_control", reinterpret_cast<getter>(VideoDeviceController_get_ExposureCompensationControl), nullptr, nullptr, nullptr },
        { "exposure_control", reinterpret_cast<getter>(VideoDeviceController_get_ExposureControl), nullptr, nullptr, nullptr },
        { "zoom_control", reinterpret_cast<getter>(VideoDeviceController_get_ZoomControl), nullptr, nullptr, nullptr },
        { "photo_confirmation_control", reinterpret_cast<getter>(VideoDeviceController_get_PhotoConfirmationControl), nullptr, nullptr, nullptr },
        { "variable_photo_sequence_controller", reinterpret_cast<getter>(VideoDeviceController_get_VariablePhotoSequenceController), nullptr, nullptr, nullptr },
        { "desired_optimization", reinterpret_cast<getter>(VideoDeviceController_get_DesiredOptimization), reinterpret_cast<setter>(VideoDeviceController_put_DesiredOptimization), nullptr, nullptr },
        { "advanced_photo_control", reinterpret_cast<getter>(VideoDeviceController_get_AdvancedPhotoControl), nullptr, nullptr, nullptr },
        { "exposure_priority_video_control", reinterpret_cast<getter>(VideoDeviceController_get_ExposurePriorityVideoControl), nullptr, nullptr, nullptr },
        { "hdr_video_control", reinterpret_cast<getter>(VideoDeviceController_get_HdrVideoControl), nullptr, nullptr, nullptr },
        { "optical_image_stabilization_control", reinterpret_cast<getter>(VideoDeviceController_get_OpticalImageStabilizationControl), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VideoDeviceController_get_Id), nullptr, nullptr, nullptr },
        { "video_temporal_denoising_control", reinterpret_cast<getter>(VideoDeviceController_get_VideoTemporalDenoisingControl), nullptr, nullptr, nullptr },
        { "infrared_torch_control", reinterpret_cast<getter>(VideoDeviceController_get_InfraredTorchControl), nullptr, nullptr, nullptr },
        { "panel_based_optimization_control", reinterpret_cast<getter>(VideoDeviceController_get_PanelBasedOptimizationControl), nullptr, nullptr, nullptr },
        { "digital_window_control", reinterpret_cast<getter>(VideoDeviceController_get_DigitalWindowControl), nullptr, nullptr, nullptr },
        { "zoom", reinterpret_cast<getter>(VideoDeviceController_get_Zoom), nullptr, nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(VideoDeviceController_get_Contrast), nullptr, nullptr, nullptr },
        { "backlight_compensation", reinterpret_cast<getter>(VideoDeviceController_get_BacklightCompensation), nullptr, nullptr, nullptr },
        { "white_balance", reinterpret_cast<getter>(VideoDeviceController_get_WhiteBalance), nullptr, nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(VideoDeviceController_get_Brightness), nullptr, nullptr, nullptr },
        { "exposure", reinterpret_cast<getter>(VideoDeviceController_get_Exposure), nullptr, nullptr, nullptr },
        { "tilt", reinterpret_cast<getter>(VideoDeviceController_get_Tilt), nullptr, nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(VideoDeviceController_get_Roll), nullptr, nullptr, nullptr },
        { "hue", reinterpret_cast<getter>(VideoDeviceController_get_Hue), nullptr, nullptr, nullptr },
        { "pan", reinterpret_cast<getter>(VideoDeviceController_get_Pan), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(VideoDeviceController_get_Focus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoDeviceController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoDeviceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoDeviceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoDeviceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoDeviceController) },
        { },
    };

    static PyType_Spec type_spec_VideoDeviceController =
    {
        "winrt._winrt_windows_media_devices.VideoDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::VideoDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDeviceController
    };

    // ----- VideoDeviceControllerGetDevicePropertyResult class --------------------

    static PyObject* _new_VideoDeviceControllerGetDevicePropertyResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoDeviceControllerGetDevicePropertyResult(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoDeviceControllerGetDevicePropertyResult_get_Status(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceControllerGetDevicePropertyResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceControllerGetDevicePropertyResult_get_Value(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoDeviceControllerGetDevicePropertyResult", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoDeviceControllerGetDevicePropertyResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoDeviceControllerGetDevicePropertyResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDeviceControllerGetDevicePropertyResult[] = {
        { "_assign_array_", _assign_array_VideoDeviceControllerGetDevicePropertyResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoDeviceControllerGetDevicePropertyResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoDeviceControllerGetDevicePropertyResult[] = {
        { "status", reinterpret_cast<getter>(VideoDeviceControllerGetDevicePropertyResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(VideoDeviceControllerGetDevicePropertyResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoDeviceControllerGetDevicePropertyResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoDeviceControllerGetDevicePropertyResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoDeviceControllerGetDevicePropertyResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoDeviceControllerGetDevicePropertyResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoDeviceControllerGetDevicePropertyResult) },
        { },
    };

    static PyType_Spec type_spec_VideoDeviceControllerGetDevicePropertyResult =
    {
        "winrt._winrt_windows_media_devices.VideoDeviceControllerGetDevicePropertyResult",
        sizeof(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDeviceControllerGetDevicePropertyResult
    };

    // ----- VideoTemporalDenoisingControl class --------------------

    static PyObject* _new_VideoTemporalDenoisingControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoTemporalDenoisingControl(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTemporalDenoisingControl_get_Mode(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoTemporalDenoisingControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTemporalDenoisingControl_put_Mode(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoTemporalDenoisingControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoTemporalDenoisingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTemporalDenoisingControl_get_Supported(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoTemporalDenoisingControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTemporalDenoisingControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.VideoTemporalDenoisingControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTemporalDenoisingControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTemporalDenoisingControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTemporalDenoisingControl[] = {
        { "_assign_array_", _assign_array_VideoTemporalDenoisingControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTemporalDenoisingControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTemporalDenoisingControl[] = {
        { "mode", reinterpret_cast<getter>(VideoTemporalDenoisingControl_get_Mode), reinterpret_cast<setter>(VideoTemporalDenoisingControl_put_Mode), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(VideoTemporalDenoisingControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(VideoTemporalDenoisingControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTemporalDenoisingControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTemporalDenoisingControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTemporalDenoisingControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTemporalDenoisingControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTemporalDenoisingControl) },
        { },
    };

    static PyType_Spec type_spec_VideoTemporalDenoisingControl =
    {
        "winrt._winrt_windows_media_devices.VideoTemporalDenoisingControl",
        sizeof(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTemporalDenoisingControl
    };

    // ----- WhiteBalanceControl class --------------------

    static PyObject* _new_WhiteBalanceControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::WhiteBalanceControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::WhiteBalanceControl>::type_name);
        return nullptr;
    }

    static void _dealloc_WhiteBalanceControl(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WhiteBalanceControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"SetPresetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::ColorTemperaturePreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_SetValueAsync(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"SetValueAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Max(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Min(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Preset(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"Preset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Step(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Supported(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Value(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.WhiteBalanceControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WhiteBalanceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::WhiteBalanceControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WhiteBalanceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::WhiteBalanceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WhiteBalanceControl[] = {
        { "set_preset_async", reinterpret_cast<PyCFunction>(WhiteBalanceControl_SetPresetAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(WhiteBalanceControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WhiteBalanceControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WhiteBalanceControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WhiteBalanceControl[] = {
        { "max", reinterpret_cast<getter>(WhiteBalanceControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(WhiteBalanceControl_get_Min), nullptr, nullptr, nullptr },
        { "preset", reinterpret_cast<getter>(WhiteBalanceControl_get_Preset), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(WhiteBalanceControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(WhiteBalanceControl_get_Supported), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WhiteBalanceControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WhiteBalanceControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WhiteBalanceControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WhiteBalanceControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WhiteBalanceControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WhiteBalanceControl) },
        { },
    };

    static PyType_Spec type_spec_WhiteBalanceControl =
    {
        "winrt._winrt_windows_media_devices.WhiteBalanceControl",
        sizeof(py::wrapper::Windows::Media::Devices::WhiteBalanceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceControl
    };

    // ----- ZoomControl class --------------------

    static PyObject* _new_ZoomControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::ZoomControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::ZoomControl>::type_name);
        return nullptr;
    }

    static void _dealloc_ZoomControl(py::wrapper::Windows::Media::Devices::ZoomControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ZoomControl_Configure(py::wrapper::Windows::Media::Devices::ZoomControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.ZoomControl", L"Configure", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::ZoomSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Value(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomControl_put_Value(py::wrapper::Windows::Media::Devices::ZoomControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ZoomControl_get_Max(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Min(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Step(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Supported(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Mode(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomControl", L"SupportedModes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ZoomControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::ZoomControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ZoomControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ZoomControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(ZoomControl_Configure), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ZoomControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomControl[] = {
        { "value", reinterpret_cast<getter>(ZoomControl_get_Value), reinterpret_cast<setter>(ZoomControl_put_Value), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(ZoomControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(ZoomControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(ZoomControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ZoomControl_get_Supported), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ZoomControl_get_Mode), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(ZoomControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ZoomControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ZoomControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ZoomControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ZoomControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ZoomControl) },
        { },
    };

    static PyType_Spec type_spec_ZoomControl =
    {
        "winrt._winrt_windows_media_devices.ZoomControl",
        sizeof(py::wrapper::Windows::Media::Devices::ZoomControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomControl
    };

    // ----- ZoomSettings class --------------------

    static PyObject* _new_ZoomSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::ZoomSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ZoomSettings(py::wrapper::Windows::Media::Devices::ZoomSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ZoomSettings_get_Value(py::wrapper::Windows::Media::Devices::ZoomSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomSettings", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomSettings_put_Value(py::wrapper::Windows::Media::Devices::ZoomSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomSettings", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ZoomSettings_get_Mode(py::wrapper::Windows::Media::Devices::ZoomSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomSettings", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomSettings_put_Mode(py::wrapper::Windows::Media::Devices::ZoomSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.ZoomSettings", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::ZoomTransitionMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ZoomSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::ZoomSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ZoomSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ZoomSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSettings[] = {
        { "_assign_array_", _assign_array_ZoomSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomSettings[] = {
        { "value", reinterpret_cast<getter>(ZoomSettings_get_Value), reinterpret_cast<setter>(ZoomSettings_put_Value), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ZoomSettings_get_Mode), reinterpret_cast<setter>(ZoomSettings_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ZoomSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ZoomSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ZoomSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ZoomSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ZoomSettings) },
        { },
    };

    static PyType_Spec type_spec_ZoomSettings =
    {
        "winrt._winrt_windows_media_devices.ZoomSettings",
        sizeof(py::wrapper::Windows::Media::Devices::ZoomSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomSettings
    };

    // ----- IDefaultAudioDeviceChangedEventArgs interface --------------------

    static PyObject* _new_IDefaultAudioDeviceChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IDefaultAudioDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDefaultAudioDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IDefaultAudioDeviceChangedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDefaultAudioDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.IDefaultAudioDeviceChangedEventArgs", L"Role"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDefaultAudioDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDefaultAudioDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDefaultAudioDeviceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_IDefaultAudioDeviceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDefaultAudioDeviceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDefaultAudioDeviceChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(IDefaultAudioDeviceChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "role", reinterpret_cast<getter>(IDefaultAudioDeviceChangedEventArgs_get_Role), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDefaultAudioDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDefaultAudioDeviceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDefaultAudioDeviceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDefaultAudioDeviceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDefaultAudioDeviceChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_IDefaultAudioDeviceChangedEventArgs =
    {
        "winrt._winrt_windows_media_devices.IDefaultAudioDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDefaultAudioDeviceChangedEventArgs
    };

    // ----- IMediaDeviceController interface --------------------

    static PyObject* _new_IMediaDeviceController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Devices::IMediaDeviceController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Devices::IMediaDeviceController>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaDeviceController(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.IMediaDeviceController", L"GetAvailableMediaStreamProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.IMediaDeviceController", L"GetMediaStreamProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.IMediaDeviceController", L"SetMediaStreamPropertiesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::IMediaDeviceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IMediaDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaDeviceController[] = {
        { "get_available_media_stream_properties", reinterpret_cast<PyCFunction>(IMediaDeviceController_GetAvailableMediaStreamProperties), METH_VARARGS, nullptr },
        { "get_media_stream_properties", reinterpret_cast<PyCFunction>(IMediaDeviceController_GetMediaStreamProperties), METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", reinterpret_cast<PyCFunction>(IMediaDeviceController_SetMediaStreamPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMediaDeviceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaDeviceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaDeviceController[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaDeviceController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaDeviceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaDeviceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaDeviceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaDeviceController) },
        { },
    };

    static PyType_Spec type_spec_IMediaDeviceController =
    {
        "winrt._winrt_windows_media_devices.IMediaDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::IMediaDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaDeviceController
    };

    // ----- Windows.Media.Devices Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Devices");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_devices",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Devices

PyMODINIT_FUNC PyInit__winrt_windows_media_devices(void) noexcept
{
    using namespace py::cpp::Windows::Media::Devices;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AdvancedPhotoCaptureSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AdvancedPhotoControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioDeviceController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioDeviceModule, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioDeviceModuleNotificationEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioDeviceModulesManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CallControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraOcclusionInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraOcclusionState, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CameraOcclusionStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DefaultAudioCaptureDeviceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DefaultAudioRenderDeviceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DialRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DigitalWindowBounds, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DigitalWindowCapability, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DigitalWindowControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ExposureCompensationControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ExposureControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ExposurePriorityVideoControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FlashControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FocusSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HdrVideoControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InfraredTorchControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IsoSpeedControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeypadPressedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LowLagPhotoControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LowLagPhotoSequenceControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaDevice, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaDeviceControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaDeviceControlCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ModuleCommandResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OpticalImageStabilizationControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PanelBasedOptimizationControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhotoConfirmationControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RedialRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RegionOfInterest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RegionsOfInterestControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SceneModeControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TorchControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoDeviceController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoDeviceControllerGetDevicePropertyResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoTemporalDenoisingControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WhiteBalanceControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ZoomControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ZoomSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDefaultAudioDeviceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMediaDeviceController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
