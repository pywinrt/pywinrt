// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Microsoft.UI.Windowing.h"


namespace py::cpp::Microsoft::UI::Windowing
{
    // ----- AppWindow class --------------------

    static PyObject* _new_AppWindow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::AppWindow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::AppWindow>::type_name);
        return nullptr;
    }

    static void _dealloc_AppWindow(py::wrapper::Microsoft::UI::Windowing::AppWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppWindow_AssociateWithDispatcherQueue(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"AssociateWithDispatcherQueue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(args, 0);

                self->obj.AssociateWithDispatcherQueue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::AppWindow::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::AppWindowPresenter>(args, 0);

                return py::convert(winrt::Microsoft::UI::Windowing::AppWindow::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Create", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::AppWindowPresenter>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 1);

                return py::convert(winrt::Microsoft::UI::Windowing::AppWindow::Create(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Create", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::AppWindowPresenter>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(args, 2);

                return py::convert(winrt::Microsoft::UI::Windowing::AppWindow::Create(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_Destroy(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Destroy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Destroy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_GetFromWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"GetFromWindowId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                return py::convert(winrt::Microsoft::UI::Windowing::AppWindow::GetFromWindowId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_Hide(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Hide", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_Move(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Move", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);

                self->obj.Move(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_MoveAndResize(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"MoveAndResize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 0);

                self->obj.MoveAndResize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"MoveAndResize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Windowing::DisplayArea>(args, 1);

                self->obj.MoveAndResize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_MoveInZOrderAtBottom(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"MoveInZOrderAtBottom", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MoveInZOrderAtBottom();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_MoveInZOrderAtTop(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"MoveInZOrderAtTop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MoveInZOrderAtTop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_MoveInZOrderBelow(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"MoveInZOrderBelow", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                self->obj.MoveInZOrderBelow(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_Resize(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Resize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 0);

                self->obj.Resize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_ResizeClient(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"ResizeClient", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 0);

                self->obj.ResizeClient(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_SetIcon(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"SetIcon", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetIcon(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_SetPresenter(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"SetPresenter", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::AppWindowPresenter>(args, 0);

                self->obj.SetPresenter(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_Show(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Show", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Show();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_ShowOnceWithRequestedStartupState(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindow", L"ShowOnceWithRequestedStartupState", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowOnceWithRequestedStartupState();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_Title(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindow_put_Title(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindow_get_IsShownInSwitchers(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"IsShownInSwitchers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsShownInSwitchers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindow_put_IsShownInSwitchers(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"IsShownInSwitchers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsShownInSwitchers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindow_get_Id(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_IsVisible(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"IsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_OwnerWindowId(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"OwnerWindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OwnerWindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_Position(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_Presenter(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"Presenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Presenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_Size(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_TitleBar(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"TitleBar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TitleBar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_ClientSize(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"ClientSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_get_DispatcherQueue(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindow", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_add_Changed(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.AppWindow", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_remove_Changed(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.AppWindow", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_add_Closing(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.AppWindow", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs>>(arg);

            return py::convert(self->obj.Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_remove_Closing(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.AppWindow", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_add_Destroying(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.AppWindow", L"Destroying"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Destroying(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindow_remove_Destroying(py::wrapper::Microsoft::UI::Windowing::AppWindow* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.AppWindow", L"Destroying"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Destroying(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::AppWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::AppWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppWindow[] = {
        { "associate_with_dispatcher_queue", reinterpret_cast<PyCFunction>(AppWindow_AssociateWithDispatcherQueue), METH_VARARGS, nullptr },
        { "destroy", reinterpret_cast<PyCFunction>(AppWindow_Destroy), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(AppWindow_Hide), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(AppWindow_Move), METH_VARARGS, nullptr },
        { "move_and_resize", reinterpret_cast<PyCFunction>(AppWindow_MoveAndResize), METH_VARARGS, nullptr },
        { "move_in_z_order_at_bottom", reinterpret_cast<PyCFunction>(AppWindow_MoveInZOrderAtBottom), METH_VARARGS, nullptr },
        { "move_in_z_order_at_top", reinterpret_cast<PyCFunction>(AppWindow_MoveInZOrderAtTop), METH_VARARGS, nullptr },
        { "move_in_z_order_below", reinterpret_cast<PyCFunction>(AppWindow_MoveInZOrderBelow), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(AppWindow_Resize), METH_VARARGS, nullptr },
        { "resize_client", reinterpret_cast<PyCFunction>(AppWindow_ResizeClient), METH_VARARGS, nullptr },
        { "set_icon", reinterpret_cast<PyCFunction>(AppWindow_SetIcon), METH_VARARGS, nullptr },
        { "set_presenter", reinterpret_cast<PyCFunction>(AppWindow_SetPresenter), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(AppWindow_Show), METH_VARARGS, nullptr },
        { "show_once_with_requested_startup_state", reinterpret_cast<PyCFunction>(AppWindow_ShowOnceWithRequestedStartupState), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(AppWindow_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(AppWindow_remove_Changed), METH_O, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(AppWindow_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(AppWindow_remove_Closing), METH_O, nullptr },
        { "add_destroying", reinterpret_cast<PyCFunction>(AppWindow_add_Destroying), METH_O, nullptr },
        { "remove_destroying", reinterpret_cast<PyCFunction>(AppWindow_remove_Destroying), METH_O, nullptr },
        { "_assign_array_", _assign_array_AppWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppWindow[] = {
        { "title", reinterpret_cast<getter>(AppWindow_get_Title), reinterpret_cast<setter>(AppWindow_put_Title), nullptr, nullptr },
        { "is_shown_in_switchers", reinterpret_cast<getter>(AppWindow_get_IsShownInSwitchers), reinterpret_cast<setter>(AppWindow_put_IsShownInSwitchers), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AppWindow_get_Id), nullptr, nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(AppWindow_get_IsVisible), nullptr, nullptr, nullptr },
        { "owner_window_id", reinterpret_cast<getter>(AppWindow_get_OwnerWindowId), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AppWindow_get_Position), nullptr, nullptr, nullptr },
        { "presenter", reinterpret_cast<getter>(AppWindow_get_Presenter), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(AppWindow_get_Size), nullptr, nullptr, nullptr },
        { "title_bar", reinterpret_cast<getter>(AppWindow_get_TitleBar), nullptr, nullptr, nullptr },
        { "client_size", reinterpret_cast<getter>(AppWindow_get_ClientSize), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(AppWindow_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppWindow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppWindow) },
        { },
    };

    static PyType_Spec type_spec_AppWindow =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindow",
        sizeof(py::wrapper::Microsoft::UI::Windowing::AppWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppWindow
    };

    static PyGetSetDef getset_AppWindow_Static[] = {
        { }
    };

    static PyMethodDef methods_AppWindow_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(AppWindow_Create), METH_VARARGS, nullptr },
        { "get_from_window_id", reinterpret_cast<PyCFunction>(AppWindow_GetFromWindowId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppWindow_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppWindow_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppWindow_Static) },
        { }
    };

    static PyType_Spec type_spec_AppWindow_Static =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindow_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppWindow_Static
    };

    // ----- AppWindowChangedEventArgs class --------------------

    static PyObject* _new_AppWindowChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppWindowChangedEventArgs(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppWindowChangedEventArgs_get_DidPositionChange(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"DidPositionChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidPositionChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_DidPresenterChange(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"DidPresenterChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidPresenterChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_DidSizeChange(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"DidSizeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidSizeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_DidVisibilityChange(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"DidVisibilityChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidVisibilityChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_DidZOrderChange(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"DidZOrderChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidZOrderChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_IsZOrderAtBottom(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"IsZOrderAtBottom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsZOrderAtBottom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_IsZOrderAtTop(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"IsZOrderAtTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsZOrderAtTop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowChangedEventArgs_get_ZOrderBelowWindowId(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowChangedEventArgs", L"ZOrderBelowWindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZOrderBelowWindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppWindowChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppWindowChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppWindowChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AppWindowChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppWindowChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppWindowChangedEventArgs[] = {
        { "did_position_change", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_DidPositionChange), nullptr, nullptr, nullptr },
        { "did_presenter_change", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_DidPresenterChange), nullptr, nullptr, nullptr },
        { "did_size_change", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_DidSizeChange), nullptr, nullptr, nullptr },
        { "did_visibility_change", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_DidVisibilityChange), nullptr, nullptr, nullptr },
        { "did_z_order_change", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_DidZOrderChange), nullptr, nullptr, nullptr },
        { "is_z_order_at_bottom", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_IsZOrderAtBottom), nullptr, nullptr, nullptr },
        { "is_z_order_at_top", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_IsZOrderAtTop), nullptr, nullptr, nullptr },
        { "z_order_below_window_id", reinterpret_cast<getter>(AppWindowChangedEventArgs_get_ZOrderBelowWindowId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppWindowChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppWindowChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppWindowChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppWindowChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppWindowChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppWindowChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindowChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Windowing::AppWindowChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppWindowChangedEventArgs
    };

    // ----- AppWindowClosingEventArgs class --------------------

    static PyObject* _new_AppWindowClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AppWindowClosingEventArgs(py::wrapper::Microsoft::UI::Windowing::AppWindowClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppWindowClosingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Windowing::AppWindowClosingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowClosingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowClosingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Windowing::AppWindowClosingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowClosingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppWindowClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppWindowClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppWindowClosingEventArgs[] = {
        { "_assign_array_", _assign_array_AppWindowClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppWindowClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppWindowClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(AppWindowClosingEventArgs_get_Cancel), reinterpret_cast<setter>(AppWindowClosingEventArgs_put_Cancel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppWindowClosingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppWindowClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppWindowClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppWindowClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppWindowClosingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AppWindowClosingEventArgs =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindowClosingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Windowing::AppWindowClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppWindowClosingEventArgs
    };

    // ----- AppWindowPresenter class --------------------

    static PyObject* _new_AppWindowPresenter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowPresenter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowPresenter>::type_name);
        return nullptr;
    }

    static void _dealloc_AppWindowPresenter(py::wrapper::Microsoft::UI::Windowing::AppWindowPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppWindowPresenter_get_Kind(py::wrapper::Microsoft::UI::Windowing::AppWindowPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowPresenter", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppWindowPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::AppWindowPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppWindowPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::AppWindowPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppWindowPresenter[] = {
        { "_assign_array_", _assign_array_AppWindowPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppWindowPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppWindowPresenter[] = {
        { "kind", reinterpret_cast<getter>(AppWindowPresenter_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppWindowPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppWindowPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppWindowPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppWindowPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppWindowPresenter) },
        { },
    };

    static PyType_Spec type_spec_AppWindowPresenter =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindowPresenter",
        sizeof(py::wrapper::Microsoft::UI::Windowing::AppWindowPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppWindowPresenter
    };

    // ----- AppWindowTitleBar class --------------------

    static PyObject* _new_AppWindowTitleBar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>::type_name);
        return nullptr;
    }

    static void _dealloc_AppWindowTitleBar(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppWindowTitleBar_IsCustomizationSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"IsCustomizationSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::AppWindowTitleBar::IsCustomizationSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindowTitleBar_ResetToDefault(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ResetToDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ResetToDefault();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindowTitleBar_SetDragRectangles(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"SetDragRectangles", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Graphics::RectInt32, false>>(args, 0);

                self->obj.SetDragRectangles(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppWindowTitleBar_get_InactiveForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"InactiveForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InactiveForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_InactiveForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"InactiveForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.InactiveForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_InactiveBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"InactiveBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InactiveBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_InactiveBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"InactiveBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.InactiveBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_IconShowOptions(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"IconShowOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IconShowOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_IconShowOptions(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"IconShowOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::IconShowOptions>(arg);

            self->obj.IconShowOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ExtendsContentIntoTitleBar(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ExtendsContentIntoTitleBar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendsContentIntoTitleBar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ExtendsContentIntoTitleBar(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ExtendsContentIntoTitleBar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExtendsContentIntoTitleBar(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonPressedForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonPressedForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonPressedForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonPressedForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonPressedForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonPressedForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonPressedBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonPressedBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonPressedBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonPressedBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonPressedBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonPressedBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonInactiveForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonInactiveForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonInactiveForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonInactiveForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonInactiveForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonInactiveForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonInactiveBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonInactiveBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonInactiveBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonInactiveBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonInactiveBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonInactiveBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonHoverForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonHoverForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonHoverForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonHoverForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonHoverForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonHoverForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonHoverBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonHoverBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonHoverBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonHoverBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonHoverBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonHoverBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonForegroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_ButtonBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_ButtonBackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"ButtonBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_BackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_BackgroundColor(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppWindowTitleBar_get_Height(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowTitleBar_get_LeftInset(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"LeftInset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowTitleBar_get_RightInset(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"RightInset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppWindowTitleBar_get_PreferredHeightOption(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"PreferredHeightOption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredHeightOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppWindowTitleBar_put_PreferredHeightOption(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.AppWindowTitleBar", L"PreferredHeightOption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::TitleBarHeightOption>(arg);

            self->obj.PreferredHeightOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppWindowTitleBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppWindowTitleBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppWindowTitleBar[] = {
        { "reset_to_default", reinterpret_cast<PyCFunction>(AppWindowTitleBar_ResetToDefault), METH_VARARGS, nullptr },
        { "set_drag_rectangles", reinterpret_cast<PyCFunction>(AppWindowTitleBar_SetDragRectangles), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppWindowTitleBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppWindowTitleBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppWindowTitleBar[] = {
        { "inactive_foreground_color", reinterpret_cast<getter>(AppWindowTitleBar_get_InactiveForegroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_InactiveForegroundColor), nullptr, nullptr },
        { "inactive_background_color", reinterpret_cast<getter>(AppWindowTitleBar_get_InactiveBackgroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_InactiveBackgroundColor), nullptr, nullptr },
        { "icon_show_options", reinterpret_cast<getter>(AppWindowTitleBar_get_IconShowOptions), reinterpret_cast<setter>(AppWindowTitleBar_put_IconShowOptions), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ForegroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ForegroundColor), nullptr, nullptr },
        { "extends_content_into_title_bar", reinterpret_cast<getter>(AppWindowTitleBar_get_ExtendsContentIntoTitleBar), reinterpret_cast<setter>(AppWindowTitleBar_put_ExtendsContentIntoTitleBar), nullptr, nullptr },
        { "button_pressed_foreground_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonPressedForegroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonPressedForegroundColor), nullptr, nullptr },
        { "button_pressed_background_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonPressedBackgroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonPressedBackgroundColor), nullptr, nullptr },
        { "button_inactive_foreground_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonInactiveForegroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonInactiveForegroundColor), nullptr, nullptr },
        { "button_inactive_background_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonInactiveBackgroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonInactiveBackgroundColor), nullptr, nullptr },
        { "button_hover_foreground_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonHoverForegroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonHoverForegroundColor), nullptr, nullptr },
        { "button_hover_background_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonHoverBackgroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonHoverBackgroundColor), nullptr, nullptr },
        { "button_foreground_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonForegroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonForegroundColor), nullptr, nullptr },
        { "button_background_color", reinterpret_cast<getter>(AppWindowTitleBar_get_ButtonBackgroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_ButtonBackgroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(AppWindowTitleBar_get_BackgroundColor), reinterpret_cast<setter>(AppWindowTitleBar_put_BackgroundColor), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(AppWindowTitleBar_get_Height), nullptr, nullptr, nullptr },
        { "left_inset", reinterpret_cast<getter>(AppWindowTitleBar_get_LeftInset), nullptr, nullptr, nullptr },
        { "right_inset", reinterpret_cast<getter>(AppWindowTitleBar_get_RightInset), nullptr, nullptr, nullptr },
        { "preferred_height_option", reinterpret_cast<getter>(AppWindowTitleBar_get_PreferredHeightOption), reinterpret_cast<setter>(AppWindowTitleBar_put_PreferredHeightOption), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppWindowTitleBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppWindowTitleBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppWindowTitleBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppWindowTitleBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppWindowTitleBar) },
        { },
    };

    static PyType_Spec type_spec_AppWindowTitleBar =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindowTitleBar",
        sizeof(py::wrapper::Microsoft::UI::Windowing::AppWindowTitleBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppWindowTitleBar
    };

    static PyGetSetDef getset_AppWindowTitleBar_Static[] = {
        { }
    };

    static PyMethodDef methods_AppWindowTitleBar_Static[] = {
        { "is_customization_supported", reinterpret_cast<PyCFunction>(AppWindowTitleBar_IsCustomizationSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppWindowTitleBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppWindowTitleBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppWindowTitleBar_Static) },
        { }
    };

    static PyType_Spec type_spec_AppWindowTitleBar_Static =
    {
        "winrt._winrt_microsoft_ui_windowing.AppWindowTitleBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppWindowTitleBar_Static
    };

    // ----- CompactOverlayPresenter class --------------------

    static PyObject* _new_CompactOverlayPresenter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>::type_name);
        return nullptr;
    }

    static void _dealloc_CompactOverlayPresenter(py::wrapper::Microsoft::UI::Windowing::CompactOverlayPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompactOverlayPresenter_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.CompactOverlayPresenter", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::CompactOverlayPresenter::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompactOverlayPresenter_get_InitialSize(py::wrapper::Microsoft::UI::Windowing::CompactOverlayPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.CompactOverlayPresenter", L"InitialSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitialSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompactOverlayPresenter_put_InitialSize(py::wrapper::Microsoft::UI::Windowing::CompactOverlayPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.CompactOverlayPresenter", L"InitialSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Windowing::CompactOverlaySize>(arg);

            self->obj.InitialSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompactOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompactOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompactOverlayPresenter[] = {
        { "_assign_array_", _assign_array_CompactOverlayPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompactOverlayPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompactOverlayPresenter[] = {
        { "initial_size", reinterpret_cast<getter>(CompactOverlayPresenter_get_InitialSize), reinterpret_cast<setter>(CompactOverlayPresenter_put_InitialSize), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompactOverlayPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompactOverlayPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompactOverlayPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompactOverlayPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompactOverlayPresenter) },
        { },
    };

    static PyType_Spec type_spec_CompactOverlayPresenter =
    {
        "winrt._winrt_microsoft_ui_windowing.CompactOverlayPresenter",
        sizeof(py::wrapper::Microsoft::UI::Windowing::CompactOverlayPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompactOverlayPresenter
    };

    static PyGetSetDef getset_CompactOverlayPresenter_Static[] = {
        { }
    };

    static PyMethodDef methods_CompactOverlayPresenter_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(CompactOverlayPresenter_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CompactOverlayPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompactOverlayPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompactOverlayPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_CompactOverlayPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_windowing.CompactOverlayPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompactOverlayPresenter_Static
    };

    // ----- DisplayArea class --------------------

    static PyObject* _new_DisplayArea(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::DisplayArea>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::DisplayArea>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayArea(py::wrapper::Microsoft::UI::Windowing::DisplayArea* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayArea_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayArea", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayArea_FindAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayArea", L"FindAll", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::FindAll());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayArea_GetFromDisplayId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayArea", L"GetFromDisplayId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::DisplayId>(args, 0);

                return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::GetFromDisplayId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayArea_GetFromPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayArea", L"GetFromPoint", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Windowing::DisplayAreaFallback>(args, 1);

                return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::GetFromPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayArea_GetFromRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayArea", L"GetFromRect", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Windowing::DisplayAreaFallback>(args, 1);

                return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::GetFromRect(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayArea_GetFromWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayArea", L"GetFromWindowId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Windowing::DisplayAreaFallback>(args, 1);

                return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::GetFromWindowId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayArea_get_DisplayId(py::wrapper::Microsoft::UI::Windowing::DisplayArea* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.DisplayArea", L"DisplayId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayArea_get_IsPrimary(py::wrapper::Microsoft::UI::Windowing::DisplayArea* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.DisplayArea", L"IsPrimary"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPrimary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayArea_get_OuterBounds(py::wrapper::Microsoft::UI::Windowing::DisplayArea* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.DisplayArea", L"OuterBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OuterBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayArea_get_WorkArea(py::wrapper::Microsoft::UI::Windowing::DisplayArea* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.DisplayArea", L"WorkArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WorkArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayArea_get_Primary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.DisplayArea", L"Primary"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Windowing::DisplayArea::Primary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayArea(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::DisplayArea>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayArea(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::DisplayArea>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayArea[] = {
        { "_assign_array_", _assign_array_DisplayArea, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayArea), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayArea[] = {
        { "display_id", reinterpret_cast<getter>(DisplayArea_get_DisplayId), nullptr, nullptr, nullptr },
        { "is_primary", reinterpret_cast<getter>(DisplayArea_get_IsPrimary), nullptr, nullptr, nullptr },
        { "outer_bounds", reinterpret_cast<getter>(DisplayArea_get_OuterBounds), nullptr, nullptr, nullptr },
        { "work_area", reinterpret_cast<getter>(DisplayArea_get_WorkArea), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayArea[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayArea) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayArea) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayArea) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayArea) },
        { },
    };

    static PyType_Spec type_spec_DisplayArea =
    {
        "winrt._winrt_microsoft_ui_windowing.DisplayArea",
        sizeof(py::wrapper::Microsoft::UI::Windowing::DisplayArea),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayArea
    };

    static PyGetSetDef getset_DisplayArea_Static[] = {
        { "primary", reinterpret_cast<getter>(DisplayArea_get_Primary), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DisplayArea_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(DisplayArea_CreateWatcher), METH_VARARGS, nullptr },
        { "find_all", reinterpret_cast<PyCFunction>(DisplayArea_FindAll), METH_VARARGS, nullptr },
        { "get_from_display_id", reinterpret_cast<PyCFunction>(DisplayArea_GetFromDisplayId), METH_VARARGS, nullptr },
        { "get_from_point", reinterpret_cast<PyCFunction>(DisplayArea_GetFromPoint), METH_VARARGS, nullptr },
        { "get_from_rect", reinterpret_cast<PyCFunction>(DisplayArea_GetFromRect), METH_VARARGS, nullptr },
        { "get_from_window_id", reinterpret_cast<PyCFunction>(DisplayArea_GetFromWindowId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DisplayArea_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DisplayArea_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DisplayArea_Static) },
        { }
    };

    static PyType_Spec type_spec_DisplayArea_Static =
    {
        "winrt._winrt_microsoft_ui_windowing.DisplayArea_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DisplayArea_Static
    };

    // ----- DisplayAreaWatcher class --------------------

    static PyObject* _new_DisplayAreaWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayAreaWatcher(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayAreaWatcher_Start(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_Stop(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_get_Status(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_add_Added(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_remove_Added(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_add_EnumerationCompleted(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_remove_EnumerationCompleted(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_add_Removed(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_remove_Removed(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_add_Stopped(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_remove_Stopped(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_add_Updated(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAreaWatcher_remove_Updated(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Windowing.DisplayAreaWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayAreaWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayAreaWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayAreaWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(DisplayAreaWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_DisplayAreaWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayAreaWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayAreaWatcher[] = {
        { "status", reinterpret_cast<getter>(DisplayAreaWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayAreaWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayAreaWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayAreaWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayAreaWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayAreaWatcher) },
        { },
    };

    static PyType_Spec type_spec_DisplayAreaWatcher =
    {
        "winrt._winrt_microsoft_ui_windowing.DisplayAreaWatcher",
        sizeof(py::wrapper::Microsoft::UI::Windowing::DisplayAreaWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAreaWatcher
    };

    // ----- FullScreenPresenter class --------------------

    static PyObject* _new_FullScreenPresenter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::FullScreenPresenter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::FullScreenPresenter>::type_name);
        return nullptr;
    }

    static void _dealloc_FullScreenPresenter(py::wrapper::Microsoft::UI::Windowing::FullScreenPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FullScreenPresenter_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.FullScreenPresenter", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::FullScreenPresenter::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FullScreenPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::FullScreenPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FullScreenPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::FullScreenPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullScreenPresenter[] = {
        { "_assign_array_", _assign_array_FullScreenPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FullScreenPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FullScreenPresenter[] = {
        { }
    };

    static PyType_Slot _type_slots_FullScreenPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FullScreenPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FullScreenPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FullScreenPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FullScreenPresenter) },
        { },
    };

    static PyType_Spec type_spec_FullScreenPresenter =
    {
        "winrt._winrt_microsoft_ui_windowing.FullScreenPresenter",
        sizeof(py::wrapper::Microsoft::UI::Windowing::FullScreenPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullScreenPresenter
    };

    static PyGetSetDef getset_FullScreenPresenter_Static[] = {
        { }
    };

    static PyMethodDef methods_FullScreenPresenter_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(FullScreenPresenter_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FullScreenPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FullScreenPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FullScreenPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_FullScreenPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_windowing.FullScreenPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FullScreenPresenter_Static
    };

    // ----- OverlappedPresenter class --------------------

    static PyObject* _new_OverlappedPresenter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Windowing::OverlappedPresenter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Windowing::OverlappedPresenter>::type_name);
        return nullptr;
    }

    static void _dealloc_OverlappedPresenter(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OverlappedPresenter_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"Create", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::OverlappedPresenter::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_CreateForContextMenu(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"CreateForContextMenu", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::OverlappedPresenter::CreateForContextMenu());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_CreateForDialog(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"CreateForDialog", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::OverlappedPresenter::CreateForDialog());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_CreateForToolWindow(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"CreateForToolWindow", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Windowing::OverlappedPresenter::CreateForToolWindow());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_Maximize(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"Maximize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Maximize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_Minimize(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"Minimize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Minimize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"Minimize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Minimize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_Restore(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"Restore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Restore();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"Restore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Restore(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_SetBorderAndTitleBar(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"SetBorderAndTitleBar", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetBorderAndTitleBar(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_get_IsResizable(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsResizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsResizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OverlappedPresenter_put_IsResizable(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsResizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResizable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OverlappedPresenter_get_IsModal(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsModal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OverlappedPresenter_put_IsModal(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsModal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsModal(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OverlappedPresenter_get_IsMinimizable(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsMinimizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMinimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OverlappedPresenter_put_IsMinimizable(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsMinimizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMinimizable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OverlappedPresenter_get_IsMaximizable(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsMaximizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMaximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OverlappedPresenter_put_IsMaximizable(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsMaximizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMaximizable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OverlappedPresenter_get_IsAlwaysOnTop(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsAlwaysOnTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAlwaysOnTop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OverlappedPresenter_put_IsAlwaysOnTop(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"IsAlwaysOnTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAlwaysOnTop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OverlappedPresenter_get_HasBorder(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"HasBorder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasBorder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_get_HasTitleBar(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"HasTitleBar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasTitleBar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_get_State(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OverlappedPresenter_get_RequestedStartupState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Windowing.OverlappedPresenter", L"RequestedStartupState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Windowing::OverlappedPresenter::RequestedStartupState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OverlappedPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Windowing::OverlappedPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OverlappedPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Windowing::OverlappedPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OverlappedPresenter[] = {
        { "maximize", reinterpret_cast<PyCFunction>(OverlappedPresenter_Maximize), METH_VARARGS, nullptr },
        { "minimize", reinterpret_cast<PyCFunction>(OverlappedPresenter_Minimize), METH_VARARGS, nullptr },
        { "restore", reinterpret_cast<PyCFunction>(OverlappedPresenter_Restore), METH_VARARGS, nullptr },
        { "set_border_and_title_bar", reinterpret_cast<PyCFunction>(OverlappedPresenter_SetBorderAndTitleBar), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_OverlappedPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OverlappedPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OverlappedPresenter[] = {
        { "is_resizable", reinterpret_cast<getter>(OverlappedPresenter_get_IsResizable), reinterpret_cast<setter>(OverlappedPresenter_put_IsResizable), nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(OverlappedPresenter_get_IsModal), reinterpret_cast<setter>(OverlappedPresenter_put_IsModal), nullptr, nullptr },
        { "is_minimizable", reinterpret_cast<getter>(OverlappedPresenter_get_IsMinimizable), reinterpret_cast<setter>(OverlappedPresenter_put_IsMinimizable), nullptr, nullptr },
        { "is_maximizable", reinterpret_cast<getter>(OverlappedPresenter_get_IsMaximizable), reinterpret_cast<setter>(OverlappedPresenter_put_IsMaximizable), nullptr, nullptr },
        { "is_always_on_top", reinterpret_cast<getter>(OverlappedPresenter_get_IsAlwaysOnTop), reinterpret_cast<setter>(OverlappedPresenter_put_IsAlwaysOnTop), nullptr, nullptr },
        { "has_border", reinterpret_cast<getter>(OverlappedPresenter_get_HasBorder), nullptr, nullptr, nullptr },
        { "has_title_bar", reinterpret_cast<getter>(OverlappedPresenter_get_HasTitleBar), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(OverlappedPresenter_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OverlappedPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OverlappedPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OverlappedPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OverlappedPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OverlappedPresenter) },
        { },
    };

    static PyType_Spec type_spec_OverlappedPresenter =
    {
        "winrt._winrt_microsoft_ui_windowing.OverlappedPresenter",
        sizeof(py::wrapper::Microsoft::UI::Windowing::OverlappedPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OverlappedPresenter
    };

    static PyGetSetDef getset_OverlappedPresenter_Static[] = {
        { "requested_startup_state", reinterpret_cast<getter>(OverlappedPresenter_get_RequestedStartupState), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_OverlappedPresenter_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(OverlappedPresenter_Create), METH_VARARGS, nullptr },
        { "create_for_context_menu", reinterpret_cast<PyCFunction>(OverlappedPresenter_CreateForContextMenu), METH_VARARGS, nullptr },
        { "create_for_dialog", reinterpret_cast<PyCFunction>(OverlappedPresenter_CreateForDialog), METH_VARARGS, nullptr },
        { "create_for_tool_window", reinterpret_cast<PyCFunction>(OverlappedPresenter_CreateForToolWindow), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_OverlappedPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_OverlappedPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_OverlappedPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_OverlappedPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_windowing.OverlappedPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_OverlappedPresenter_Static
    };

    // ----- Microsoft.UI.Windowing Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Windowing");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_windowing",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Windowing

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_windowing(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Windowing;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppWindow_Static{PyType_FromSpec(&type_spec_AppWindow_Static)};
    if (!type_AppWindow_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppWindow, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppWindow_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppWindowChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppWindowClosingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppWindowPresenter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppWindowTitleBar_Static{PyType_FromSpec(&type_spec_AppWindowTitleBar_Static)};
    if (!type_AppWindowTitleBar_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppWindowTitleBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppWindowTitleBar_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompactOverlayPresenter_Static{PyType_FromSpec(&type_spec_CompactOverlayPresenter_Static)};
    if (!type_CompactOverlayPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompactOverlayPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompactOverlayPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DisplayArea_Static{PyType_FromSpec(&type_spec_DisplayArea_Static)};
    if (!type_DisplayArea_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DisplayArea, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DisplayArea_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DisplayAreaWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FullScreenPresenter_Static{PyType_FromSpec(&type_spec_FullScreenPresenter_Static)};
    if (!type_FullScreenPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FullScreenPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FullScreenPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_OverlappedPresenter_Static{PyType_FromSpec(&type_spec_OverlappedPresenter_Static)};
    if (!type_OverlappedPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OverlappedPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_OverlappedPresenter_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
