# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.background
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.networking.connectivity
import winrt.windows.security.credentials
import winrt.windows.security.cryptography.certificates
import winrt.windows.storage.streams
import winrt.windows.web

from winrt.windows.networking.sockets import ControlChannelTriggerResetReason, ControlChannelTriggerResourceType, ControlChannelTriggerStatus, MessageWebSocketReceiveMode, SocketActivityConnectedStandbyAction, SocketActivityKind, SocketActivityTriggerReason, SocketErrorStatus, SocketMessageType, SocketProtectionLevel, SocketQualityOfService, SocketSslErrorSeverity

Self = typing.TypeVar('Self')

@typing.final
class BandwidthStatistics:
    outbound_bits_per_second: winrt.system.UInt64
    inbound_bits_per_second: winrt.system.UInt64
    outbound_bits_per_second_instability: winrt.system.UInt64
    inbound_bits_per_second_instability: winrt.system.UInt64
    outbound_bandwidth_peaked: bool
    inbound_bandwidth_peaked: bool
    def __init__(self, outbound_bits_per_second: winrt.system.UInt64, inbound_bits_per_second: winrt.system.UInt64, outbound_bits_per_second_instability: winrt.system.UInt64, inbound_bits_per_second_instability: winrt.system.UInt64, outbound_bandwidth_peaked: bool, inbound_bandwidth_peaked: bool) -> None: ...

@typing.final
class RoundTripTimeStatistics:
    variance: winrt.system.UInt32
    max: winrt.system.UInt32
    min: winrt.system.UInt32
    sum: winrt.system.UInt32
    def __init__(self, variance: winrt.system.UInt32, max: winrt.system.UInt32, min: winrt.system.UInt32, sum: winrt.system.UInt32) -> None: ...

@typing.final
class ControlChannelTrigger(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ControlChannelTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ControlChannelTrigger], channel_id: str, server_keep_alive_interval_in_minutes: winrt.system.UInt32) -> ControlChannelTrigger:...
    @typing.overload
    def __new__(cls: typing.Type[ControlChannelTrigger], channel_id: str, server_keep_alive_interval_in_minutes: winrt.system.UInt32, resource_request_type: ControlChannelTriggerResourceType) -> ControlChannelTrigger:...
    def close(self) -> None: ...
    def decrease_network_keep_alive_interval(self) -> None: ...
    def flush_transport(self) -> None: ...
    def using_transport(self, transport: typing.Optional[winrt.system.Object], /) -> None: ...
    def wait_for_push_enabled(self) -> ControlChannelTriggerStatus: ...
    @_property
    def server_keep_alive_interval_in_minutes(self) -> winrt.system.UInt32: ...
    @server_keep_alive_interval_in_minutes.setter
    def server_keep_alive_interval_in_minutes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def control_channel_trigger_id(self) -> str: ...
    @_property
    def current_keep_alive_interval_in_minutes(self) -> winrt.system.UInt32: ...
    @_property
    def keep_alive_trigger(self) -> typing.Optional[winrt.windows.applicationmodel.background.IBackgroundTrigger]: ...
    @_property
    def push_notification_trigger(self) -> typing.Optional[winrt.windows.applicationmodel.background.IBackgroundTrigger]: ...
    @_property
    def transport_object(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def is_wake_from_low_power_supported(self) -> bool: ...

@typing.final
class DatagramSocket_Static(type):
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.EndpointPair]]: ...
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, sort_options: winrt.windows.networking.HostNameSortOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.EndpointPair]]: ...

@typing.final
class DatagramSocket(winrt.system.Object, metaclass=DatagramSocket_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocket: ...
    def __new__(cls: typing.Type[DatagramSocket]) -> DatagramSocket:...
    def bind_endpoint_async(self, local_host_name: typing.Optional[winrt.windows.networking.HostName], local_service_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter], /) -> winrt.windows.foundation.IAsyncAction: ...
    def cancel_i_o_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def connect_async(self, endpoint_pair: typing.Optional[winrt.windows.networking.EndpointPair], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, /) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction, /) -> None: ...
    @typing.overload
    def get_output_stream_async(self, endpoint_pair: typing.Optional[winrt.windows.networking.EndpointPair], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IOutputStream]: ...
    @typing.overload
    def get_output_stream_async(self, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IOutputStream]: ...
    def join_multicast_group(self, host: typing.Optional[winrt.windows.networking.HostName], /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], keep_alive_time: datetime.timedelta, /) -> None: ...
    def add_message_received(self, event_handler: winrt.windows.foundation.TypedEventHandler[DatagramSocket, DatagramSocketMessageReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_received(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[DatagramSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[DatagramSocketInformation]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class DatagramSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocketControl: ...
    @_property
    def quality_of_service(self) -> SocketQualityOfService: ...
    @quality_of_service.setter
    def quality_of_service(self, value: SocketQualityOfService) -> None: ...
    @_property
    def outbound_unicast_hop_limit(self) -> winrt.system.UInt8: ...
    @outbound_unicast_hop_limit.setter
    def outbound_unicast_hop_limit(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def inbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @inbound_buffer_size_in_bytes.setter
    def inbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def dont_fragment(self) -> bool: ...
    @dont_fragment.setter
    def dont_fragment(self, value: bool) -> None: ...
    @_property
    def multicast_only(self) -> bool: ...
    @multicast_only.setter
    def multicast_only(self, value: bool) -> None: ...

@typing.final
class DatagramSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocketInformation: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def local_port(self) -> str: ...
    @_property
    def remote_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def remote_port(self) -> str: ...

@typing.final
class DatagramSocketMessageReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocketMessageReceivedEventArgs: ...
    def get_data_reader(self) -> typing.Optional[winrt.windows.storage.streams.DataReader]: ...
    def get_data_stream(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def remote_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def remote_port(self) -> str: ...

@typing.final
class MessageWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocket: ...
    def __new__(cls: typing.Type[MessageWebSocket]) -> MessageWebSocket:...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def connect_async(self, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncAction: ...
    def send_final_frame_async(self, data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def send_nonfinal_frame_async(self, data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def set_request_header(self, header_name: str, header_value: str, /) -> None: ...
    def add_message_received(self, event_handler: winrt.windows.foundation.TypedEventHandler[MessageWebSocket, MessageWebSocketMessageReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_received(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, event_handler: winrt.windows.foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_server_custom_validation_requested(self, event_handler: winrt.windows.foundation.TypedEventHandler[MessageWebSocket, WebSocketServerCustomValidationRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_server_custom_validation_requested(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[MessageWebSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[MessageWebSocketInformation]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class MessageWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocketControl: ...
    @_property
    def message_type(self) -> SocketMessageType: ...
    @message_type.setter
    def message_type(self, value: SocketMessageType) -> None: ...
    @_property
    def max_message_size(self) -> winrt.system.UInt32: ...
    @max_message_size.setter
    def max_message_size(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def receive_mode(self) -> MessageWebSocketReceiveMode: ...
    @receive_mode.setter
    def receive_mode(self, value: MessageWebSocketReceiveMode) -> None: ...
    @_property
    def desired_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @desired_unsolicited_pong_interval.setter
    def desired_unsolicited_pong_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def client_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]) -> None: ...
    @_property
    def actual_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @_property
    def server_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...

@typing.final
class MessageWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...
    @_property
    def server_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.Certificate]]: ...

@typing.final
class MessageWebSocketMessageReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocketMessageReceivedEventArgs: ...
    def get_data_reader(self) -> typing.Optional[winrt.windows.storage.streams.DataReader]: ...
    def get_data_stream(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @_property
    def message_type(self) -> SocketMessageType: ...
    @_property
    def is_message_complete(self) -> bool: ...

@typing.final
class ServerMessageWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerMessageWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def add_closed(self, value: winrt.windows.foundation.TypedEventHandler[ServerMessageWebSocket, WebSocketClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_message_received(self, value: winrt.windows.foundation.TypedEventHandler[ServerMessageWebSocket, MessageWebSocketMessageReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[ServerMessageWebSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[ServerMessageWebSocketInformation]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class ServerMessageWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerMessageWebSocketControl: ...
    @_property
    def message_type(self) -> SocketMessageType: ...
    @message_type.setter
    def message_type(self, value: SocketMessageType) -> None: ...

@typing.final
class ServerMessageWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerMessageWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

@typing.final
class ServerStreamWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerStreamWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def add_closed(self, value: winrt.windows.foundation.TypedEventHandler[ServerStreamWebSocket, WebSocketClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def information(self) -> typing.Optional[ServerStreamWebSocketInformation]: ...
    @_property
    def input_stream(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class ServerStreamWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerStreamWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

@typing.final
class SocketActivityContext(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityContext: ...
    def __new__(cls: typing.Type[SocketActivityContext], data: typing.Optional[winrt.windows.storage.streams.IBuffer]) -> SocketActivityContext:...
    @_property
    def data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...

@typing.final
class SocketActivityInformation_Static(type):
    @_property
    def all_sockets(cls) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, SocketActivityInformation]]: ...

@typing.final
class SocketActivityInformation(winrt.system.Object, metaclass=SocketActivityInformation_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityInformation: ...
    @_property
    def context(self) -> typing.Optional[SocketActivityContext]: ...
    @_property
    def datagram_socket(self) -> typing.Optional[DatagramSocket]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def socket_kind(self) -> SocketActivityKind: ...
    @_property
    def stream_socket(self) -> typing.Optional[StreamSocket]: ...
    @_property
    def stream_socket_listener(self) -> typing.Optional[StreamSocketListener]: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class SocketActivityTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityTriggerDetails: ...
    @_property
    def reason(self) -> SocketActivityTriggerReason: ...
    @_property
    def socket_information(self) -> typing.Optional[SocketActivityInformation]: ...

@typing.final
class SocketError_Static(type):
    def get_status(cls, hresult: winrt.system.Int32, /) -> SocketErrorStatus: ...

@typing.final
class SocketError(winrt.system.Object, metaclass=SocketError_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketError: ...

@typing.final
class StreamSocket_Static(type):
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.EndpointPair]]: ...
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, sort_options: winrt.windows.networking.HostNameSortOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.EndpointPair]]: ...

@typing.final
class StreamSocket(winrt.system.Object, metaclass=StreamSocket_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocket: ...
    def __new__(cls: typing.Type[StreamSocket]) -> StreamSocket:...
    def cancel_i_o_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def connect_async(self, endpoint_pair: typing.Optional[winrt.windows.networking.EndpointPair], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, protection_level: SocketProtectionLevel, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winrt.windows.networking.HostName], remote_service_name: str, protection_level: SocketProtectionLevel, adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, /) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], keep_alive_time: datetime.timedelta, /) -> None: ...
    def upgrade_to_ssl_async(self, protection_level: SocketProtectionLevel, validation_host_name: typing.Optional[winrt.windows.networking.HostName], /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def control(self) -> typing.Optional[StreamSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[StreamSocketInformation]: ...
    @_property
    def input_stream(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class StreamSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketControl: ...
    @_property
    def quality_of_service(self) -> SocketQualityOfService: ...
    @quality_of_service.setter
    def quality_of_service(self, value: SocketQualityOfService) -> None: ...
    @_property
    def outbound_unicast_hop_limit(self) -> winrt.system.UInt8: ...
    @outbound_unicast_hop_limit.setter
    def outbound_unicast_hop_limit(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def no_delay(self) -> bool: ...
    @no_delay.setter
    def no_delay(self, value: bool) -> None: ...
    @_property
    def keep_alive(self) -> bool: ...
    @keep_alive.setter
    def keep_alive(self, value: bool) -> None: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def serialize_connection_attempts(self) -> bool: ...
    @serialize_connection_attempts.setter
    def serialize_connection_attempts(self, value: bool) -> None: ...
    @_property
    def client_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]) -> None: ...
    @_property
    def min_protection_level(self) -> SocketProtectionLevel: ...
    @min_protection_level.setter
    def min_protection_level(self, value: SocketProtectionLevel) -> None: ...

@typing.final
class StreamSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def local_port(self) -> str: ...
    @_property
    def protection_level(self) -> SocketProtectionLevel: ...
    @_property
    def remote_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def remote_host_name(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def remote_port(self) -> str: ...
    @_property
    def remote_service_name(self) -> str: ...
    @_property
    def round_trip_time_statistics(self) -> RoundTripTimeStatistics: ...
    @_property
    def session_key(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def server_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.Certificate]]: ...

@typing.final
class StreamSocketListener(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListener: ...
    def __new__(cls: typing.Type[StreamSocketListener]) -> StreamSocketListener:...
    def bind_endpoint_async(self, local_host_name: typing.Optional[winrt.windows.networking.HostName], local_service_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, protection_level: SocketProtectionLevel, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, protection_level: SocketProtectionLevel, adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter], /) -> winrt.windows.foundation.IAsyncAction: ...
    def cancel_i_o_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, /) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], /) -> None: ...
    def add_connection_received(self, event_handler: winrt.windows.foundation.TypedEventHandler[StreamSocketListener, StreamSocketListenerConnectionReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_connection_received(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[StreamSocketListenerControl]: ...
    @_property
    def information(self) -> typing.Optional[StreamSocketListenerInformation]: ...

@typing.final
class StreamSocketListenerConnectionReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListenerConnectionReceivedEventArgs: ...
    @_property
    def socket(self) -> typing.Optional[StreamSocket]: ...

@typing.final
class StreamSocketListenerControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListenerControl: ...
    @_property
    def quality_of_service(self) -> SocketQualityOfService: ...
    @quality_of_service.setter
    def quality_of_service(self, value: SocketQualityOfService) -> None: ...
    @_property
    def outbound_unicast_hop_limit(self) -> winrt.system.UInt8: ...
    @outbound_unicast_hop_limit.setter
    def outbound_unicast_hop_limit(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def no_delay(self) -> bool: ...
    @no_delay.setter
    def no_delay(self, value: bool) -> None: ...
    @_property
    def keep_alive(self) -> bool: ...
    @keep_alive.setter
    def keep_alive(self, value: bool) -> None: ...

@typing.final
class StreamSocketListenerInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListenerInformation: ...
    @_property
    def local_port(self) -> str: ...

@typing.final
class StreamWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamWebSocket: ...
    def __new__(cls: typing.Type[StreamWebSocket]) -> StreamWebSocket:...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def connect_async(self, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_request_header(self, header_name: str, header_value: str, /) -> None: ...
    def add_closed(self, event_handler: winrt.windows.foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_server_custom_validation_requested(self, event_handler: winrt.windows.foundation.TypedEventHandler[StreamWebSocket, WebSocketServerCustomValidationRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_server_custom_validation_requested(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[StreamWebSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[StreamWebSocketInformation]: ...
    @_property
    def input_stream(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class StreamWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamWebSocketControl: ...
    @_property
    def no_delay(self) -> bool: ...
    @no_delay.setter
    def no_delay(self, value: bool) -> None: ...
    @_property
    def desired_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @desired_unsolicited_pong_interval.setter
    def desired_unsolicited_pong_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def client_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]) -> None: ...
    @_property
    def actual_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @_property
    def server_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...

@typing.final
class StreamWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...
    @_property
    def server_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.Certificate]]: ...

@typing.final
class WebSocketClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketClosedEventArgs: ...
    @_property
    def code(self) -> winrt.system.UInt16: ...
    @_property
    def reason(self) -> str: ...

@typing.final
class WebSocketError_Static(type):
    def get_status(cls, hresult: winrt.system.Int32, /) -> winrt.windows.web.WebErrorStatus: ...

@typing.final
class WebSocketError(winrt.system.Object, metaclass=WebSocketError_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketError: ...

@typing.final
class WebSocketKeepAlive(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketKeepAlive: ...
    def __new__(cls: typing.Type[WebSocketKeepAlive]) -> WebSocketKeepAlive:...
    def run(self, task_instance: typing.Optional[winrt.windows.applicationmodel.background.IBackgroundTaskInstance], /) -> None: ...

@typing.final
class WebSocketServerCustomValidationRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketServerCustomValidationRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    def reject(self) -> None: ...
    @_property
    def server_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.Certificate]]: ...

@typing.final
class IControlChannelTriggerEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IControlChannelTriggerEventDetails: ...
    @_property
    def control_channel_trigger(self) -> typing.Optional[ControlChannelTrigger]: ...

@typing.final
class IControlChannelTriggerResetEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IControlChannelTriggerResetEventDetails: ...
    @_property
    def hardware_slot_reset(self) -> bool: ...
    @_property
    def reset_reason(self) -> ControlChannelTriggerResetReason: ...
    @_property
    def software_slot_reset(self) -> bool: ...

@typing.final
class IWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocket: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    def connect_async(self, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_request_header(self, header_name: str, header_value: str, /) -> None: ...
    def add_closed(self, event_handler: winrt.windows.foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...

@typing.final
class IWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketControl: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def server_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class IWebSocketControl2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketControl2: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def server_credential(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class IWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

@typing.final
class IWebSocketInformation2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketInformation2: ...
    @_property
    def server_certificate(self) -> typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.Certificate]]: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

