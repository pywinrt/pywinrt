# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.background as windows_applicationmodel_background
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.networking as windows_networking
import winrt.windows.networking.connectivity as windows_networking_connectivity
import winrt.windows.security.credentials as windows_security_credentials
import winrt.windows.security.cryptography.certificates as windows_security_cryptography_certificates
import winrt.windows.storage.streams as windows_storage_streams
import winrt.windows.web as windows_web

from winrt.windows.networking.sockets import ControlChannelTriggerResetReason, ControlChannelTriggerResourceType, ControlChannelTriggerStatus, MessageWebSocketReceiveMode, SocketActivityConnectedStandbyAction, SocketActivityKind, SocketActivityTriggerReason, SocketErrorStatus, SocketMessageType, SocketProtectionLevel, SocketQualityOfService, SocketSslErrorSeverity

Self = typing.TypeVar('Self')

@typing.final
class BandwidthStatistics:
    outbound_bits_per_second: winrt.system.UInt64
    inbound_bits_per_second: winrt.system.UInt64
    outbound_bits_per_second_instability: winrt.system.UInt64
    inbound_bits_per_second_instability: winrt.system.UInt64
    outbound_bandwidth_peaked: bool
    inbound_bandwidth_peaked: bool
    def __init__(self, outbound_bits_per_second: winrt.system.UInt64, inbound_bits_per_second: winrt.system.UInt64, outbound_bits_per_second_instability: winrt.system.UInt64, inbound_bits_per_second_instability: winrt.system.UInt64, outbound_bandwidth_peaked: bool, inbound_bandwidth_peaked: bool) -> None: ...

@typing.final
class RoundTripTimeStatistics:
    variance: winrt.system.UInt32
    max: winrt.system.UInt32
    min: winrt.system.UInt32
    sum: winrt.system.UInt32
    def __init__(self, variance: winrt.system.UInt32, max: winrt.system.UInt32, min: winrt.system.UInt32, sum: winrt.system.UInt32) -> None: ...

@typing.final
class ControlChannelTrigger(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ControlChannelTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ControlChannelTrigger], channel_id: str, server_keep_alive_interval_in_minutes: winrt.system.UInt32) -> ControlChannelTrigger: ...
    @typing.overload
    def __new__(cls: typing.Type[ControlChannelTrigger], channel_id: str, server_keep_alive_interval_in_minutes: winrt.system.UInt32, resource_request_type: ControlChannelTriggerResourceType) -> ControlChannelTrigger: ...
    def close(self) -> None: ...
    def decrease_network_keep_alive_interval(self) -> None: ...
    def flush_transport(self) -> None: ...
    def using_transport(self, transport: typing.Optional[winrt.system.Object], /) -> None: ...
    def wait_for_push_enabled(self) -> ControlChannelTriggerStatus: ...
    @_property
    def server_keep_alive_interval_in_minutes(self) -> winrt.system.UInt32: ...
    @server_keep_alive_interval_in_minutes.setter
    def server_keep_alive_interval_in_minutes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def control_channel_trigger_id(self) -> str: ...
    @_property
    def current_keep_alive_interval_in_minutes(self) -> winrt.system.UInt32: ...
    @_property
    def keep_alive_trigger(self) -> typing.Optional[windows_applicationmodel_background.IBackgroundTrigger]: ...
    @_property
    def push_notification_trigger(self) -> typing.Optional[windows_applicationmodel_background.IBackgroundTrigger]: ...
    @_property
    def transport_object(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def is_wake_from_low_power_supported(self) -> bool: ...

@typing.final
class DatagramSocket_Static(type):
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[windows_networking.EndpointPair]]: ...
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, sort_options: windows_networking.HostNameSortOptions, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[windows_networking.EndpointPair]]: ...

@typing.final
class DatagramSocket(winrt.system.Object, metaclass=DatagramSocket_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocket: ...
    def __new__(cls: typing.Type[DatagramSocket]) -> DatagramSocket: ...
    def bind_endpoint_async(self, local_host_name: typing.Optional[windows_networking.HostName], local_service_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, adapter: typing.Optional[windows_networking_connectivity.NetworkAdapter], /) -> windows_foundation.IAsyncAction: ...
    def cancel_i_o_async(self) -> windows_foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def connect_async(self, endpoint_pair: typing.Optional[windows_networking.EndpointPair], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, /) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction, /) -> None: ...
    @typing.overload
    def get_output_stream_async(self, endpoint_pair: typing.Optional[windows_networking.EndpointPair], /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IOutputStream]: ...
    @typing.overload
    def get_output_stream_async(self, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, /) -> windows_foundation.IAsyncOperation[windows_storage_streams.IOutputStream]: ...
    def join_multicast_group(self, host: typing.Optional[windows_networking.HostName], /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], keep_alive_time: datetime.timedelta, /) -> None: ...
    def add_message_received(self, event_handler: windows_foundation.TypedEventHandler[DatagramSocket, DatagramSocketMessageReceivedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_message_received(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[DatagramSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[DatagramSocketInformation]: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class DatagramSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocketControl: ...
    @_property
    def quality_of_service(self) -> SocketQualityOfService: ...
    @quality_of_service.setter
    def quality_of_service(self, value: SocketQualityOfService) -> None: ...
    @_property
    def outbound_unicast_hop_limit(self) -> winrt.system.UInt8: ...
    @outbound_unicast_hop_limit.setter
    def outbound_unicast_hop_limit(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def inbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @inbound_buffer_size_in_bytes.setter
    def inbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def dont_fragment(self) -> bool: ...
    @dont_fragment.setter
    def dont_fragment(self, value: bool) -> None: ...
    @_property
    def multicast_only(self) -> bool: ...
    @multicast_only.setter
    def multicast_only(self, value: bool) -> None: ...

@typing.final
class DatagramSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocketInformation: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def local_port(self) -> str: ...
    @_property
    def remote_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def remote_port(self) -> str: ...

@typing.final
class DatagramSocketMessageReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatagramSocketMessageReceivedEventArgs: ...
    def get_data_reader(self) -> typing.Optional[windows_storage_streams.DataReader]: ...
    def get_data_stream(self) -> typing.Optional[windows_storage_streams.IInputStream]: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def remote_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def remote_port(self) -> str: ...

@typing.final
class MessageWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocket: ...
    def __new__(cls: typing.Type[MessageWebSocket]) -> MessageWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def connect_async(self, uri: typing.Optional[windows_foundation.Uri], /) -> windows_foundation.IAsyncAction: ...
    def send_final_frame_async(self, data: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def send_nonfinal_frame_async(self, data: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def set_request_header(self, header_name: str, header_value: str, /) -> None: ...
    def add_message_received(self, event_handler: windows_foundation.TypedEventHandler[MessageWebSocket, MessageWebSocketMessageReceivedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_message_received(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, event_handler: windows_foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_server_custom_validation_requested(self, event_handler: windows_foundation.TypedEventHandler[MessageWebSocket, WebSocketServerCustomValidationRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_server_custom_validation_requested(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[MessageWebSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[MessageWebSocketInformation]: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class MessageWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocketControl: ...
    @_property
    def message_type(self) -> SocketMessageType: ...
    @message_type.setter
    def message_type(self, value: SocketMessageType) -> None: ...
    @_property
    def max_message_size(self) -> winrt.system.UInt32: ...
    @max_message_size.setter
    def max_message_size(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def receive_mode(self) -> MessageWebSocketReceiveMode: ...
    @receive_mode.setter
    def receive_mode(self, value: MessageWebSocketReceiveMode) -> None: ...
    @_property
    def desired_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @desired_unsolicited_pong_interval.setter
    def desired_unsolicited_pong_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def client_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[windows_security_cryptography_certificates.Certificate]) -> None: ...
    @_property
    def actual_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @_property
    def server_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[windows_foundation_collections.IVector[str]]: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVector[windows_security_cryptography_certificates.ChainValidationResult]]: ...

@typing.final
class MessageWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...
    @_property
    def server_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.Certificate]]: ...

@typing.final
class MessageWebSocketMessageReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MessageWebSocketMessageReceivedEventArgs: ...
    def get_data_reader(self) -> typing.Optional[windows_storage_streams.DataReader]: ...
    def get_data_stream(self) -> typing.Optional[windows_storage_streams.IInputStream]: ...
    @_property
    def message_type(self) -> SocketMessageType: ...
    @_property
    def is_message_complete(self) -> bool: ...

@typing.final
class ServerMessageWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerMessageWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def add_closed(self, value: windows_foundation.TypedEventHandler[ServerMessageWebSocket, WebSocketClosedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_closed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_message_received(self, value: windows_foundation.TypedEventHandler[ServerMessageWebSocket, MessageWebSocketMessageReceivedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_message_received(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[ServerMessageWebSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[ServerMessageWebSocketInformation]: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class ServerMessageWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerMessageWebSocketControl: ...
    @_property
    def message_type(self) -> SocketMessageType: ...
    @message_type.setter
    def message_type(self, value: SocketMessageType) -> None: ...

@typing.final
class ServerMessageWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerMessageWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

@typing.final
class ServerStreamWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerStreamWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def add_closed(self, value: windows_foundation.TypedEventHandler[ServerStreamWebSocket, WebSocketClosedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_closed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def information(self) -> typing.Optional[ServerStreamWebSocketInformation]: ...
    @_property
    def input_stream(self) -> typing.Optional[windows_storage_streams.IInputStream]: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class ServerStreamWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ServerStreamWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

@typing.final
class SocketActivityContext(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityContext: ...
    def __new__(cls: typing.Type[SocketActivityContext], data: typing.Optional[windows_storage_streams.IBuffer]) -> SocketActivityContext: ...
    @_property
    def data(self) -> typing.Optional[windows_storage_streams.IBuffer]: ...

@typing.final
class SocketActivityInformation_Static(type):
    @_property
    def all_sockets(cls) -> typing.Optional[windows_foundation_collections.IMapView[str, SocketActivityInformation]]: ...

@typing.final
class SocketActivityInformation(winrt.system.Object, metaclass=SocketActivityInformation_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityInformation: ...
    @_property
    def context(self) -> typing.Optional[SocketActivityContext]: ...
    @_property
    def datagram_socket(self) -> typing.Optional[DatagramSocket]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def socket_kind(self) -> SocketActivityKind: ...
    @_property
    def stream_socket(self) -> typing.Optional[StreamSocket]: ...
    @_property
    def stream_socket_listener(self) -> typing.Optional[StreamSocketListener]: ...
    @_property
    def task_id(self) -> _uuid.UUID: ...

@typing.final
class SocketActivityTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SocketActivityTriggerDetails: ...
    @_property
    def reason(self) -> SocketActivityTriggerReason: ...
    @_property
    def socket_information(self) -> typing.Optional[SocketActivityInformation]: ...

@typing.final
class SocketError_Static(type):
    def get_status(cls, hresult: winrt.system.Int32, /) -> SocketErrorStatus: ...

@typing.final
class SocketError(winrt.system.Object, metaclass=SocketError_Static):
    pass

@typing.final
class StreamSocket_Static(type):
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[windows_networking.EndpointPair]]: ...
    @typing.overload
    def get_endpoint_pairs_async(cls, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, sort_options: windows_networking.HostNameSortOptions, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[windows_networking.EndpointPair]]: ...

@typing.final
class StreamSocket(winrt.system.Object, metaclass=StreamSocket_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocket: ...
    def __new__(cls: typing.Type[StreamSocket]) -> StreamSocket: ...
    def cancel_i_o_async(self) -> windows_foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def connect_async(self, endpoint_pair: typing.Optional[windows_networking.EndpointPair], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, protection_level: SocketProtectionLevel, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[windows_networking.HostName], remote_service_name: str, protection_level: SocketProtectionLevel, adapter: typing.Optional[windows_networking_connectivity.NetworkAdapter], /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, /) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], keep_alive_time: datetime.timedelta, /) -> None: ...
    def upgrade_to_ssl_async(self, protection_level: SocketProtectionLevel, validation_host_name: typing.Optional[windows_networking.HostName], /) -> windows_foundation.IAsyncAction: ...
    @_property
    def control(self) -> typing.Optional[StreamSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[StreamSocketInformation]: ...
    @_property
    def input_stream(self) -> typing.Optional[windows_storage_streams.IInputStream]: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class StreamSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketControl: ...
    @_property
    def quality_of_service(self) -> SocketQualityOfService: ...
    @quality_of_service.setter
    def quality_of_service(self, value: SocketQualityOfService) -> None: ...
    @_property
    def outbound_unicast_hop_limit(self) -> winrt.system.UInt8: ...
    @outbound_unicast_hop_limit.setter
    def outbound_unicast_hop_limit(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def no_delay(self) -> bool: ...
    @no_delay.setter
    def no_delay(self, value: bool) -> None: ...
    @_property
    def keep_alive(self) -> bool: ...
    @keep_alive.setter
    def keep_alive(self, value: bool) -> None: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVector[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def serialize_connection_attempts(self) -> bool: ...
    @serialize_connection_attempts.setter
    def serialize_connection_attempts(self, value: bool) -> None: ...
    @_property
    def client_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[windows_security_cryptography_certificates.Certificate]) -> None: ...
    @_property
    def min_protection_level(self) -> SocketProtectionLevel: ...
    @min_protection_level.setter
    def min_protection_level(self, value: SocketProtectionLevel) -> None: ...

@typing.final
class StreamSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def local_port(self) -> str: ...
    @_property
    def protection_level(self) -> SocketProtectionLevel: ...
    @_property
    def remote_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def remote_host_name(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def remote_port(self) -> str: ...
    @_property
    def remote_service_name(self) -> str: ...
    @_property
    def round_trip_time_statistics(self) -> RoundTripTimeStatistics: ...
    @_property
    def session_key(self) -> typing.Optional[windows_storage_streams.IBuffer]: ...
    @_property
    def server_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.Certificate]]: ...

@typing.final
class StreamSocketListener(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListener: ...
    def __new__(cls: typing.Type[StreamSocketListener]) -> StreamSocketListener: ...
    def bind_endpoint_async(self, local_host_name: typing.Optional[windows_networking.HostName], local_service_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, protection_level: SocketProtectionLevel, /) -> windows_foundation.IAsyncAction: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, protection_level: SocketProtectionLevel, adapter: typing.Optional[windows_networking_connectivity.NetworkAdapter], /) -> windows_foundation.IAsyncAction: ...
    def cancel_i_o_async(self) -> windows_foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, /) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: _uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, /) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], /) -> None: ...
    def add_connection_received(self, event_handler: windows_foundation.TypedEventHandler[StreamSocketListener, StreamSocketListenerConnectionReceivedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_connection_received(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[StreamSocketListenerControl]: ...
    @_property
    def information(self) -> typing.Optional[StreamSocketListenerInformation]: ...

@typing.final
class StreamSocketListenerConnectionReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListenerConnectionReceivedEventArgs: ...
    @_property
    def socket(self) -> typing.Optional[StreamSocket]: ...

@typing.final
class StreamSocketListenerControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListenerControl: ...
    @_property
    def quality_of_service(self) -> SocketQualityOfService: ...
    @quality_of_service.setter
    def quality_of_service(self, value: SocketQualityOfService) -> None: ...
    @_property
    def outbound_unicast_hop_limit(self) -> winrt.system.UInt8: ...
    @outbound_unicast_hop_limit.setter
    def outbound_unicast_hop_limit(self, value: winrt.system.UInt8) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def no_delay(self) -> bool: ...
    @no_delay.setter
    def no_delay(self, value: bool) -> None: ...
    @_property
    def keep_alive(self) -> bool: ...
    @keep_alive.setter
    def keep_alive(self, value: bool) -> None: ...

@typing.final
class StreamSocketListenerInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamSocketListenerInformation: ...
    @_property
    def local_port(self) -> str: ...

@typing.final
class StreamWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamWebSocket: ...
    def __new__(cls: typing.Type[StreamWebSocket]) -> StreamWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def connect_async(self, uri: typing.Optional[windows_foundation.Uri], /) -> windows_foundation.IAsyncAction: ...
    def set_request_header(self, header_name: str, header_value: str, /) -> None: ...
    def add_closed(self, event_handler: windows_foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_server_custom_validation_requested(self, event_handler: windows_foundation.TypedEventHandler[StreamWebSocket, WebSocketServerCustomValidationRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_server_custom_validation_requested(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def control(self) -> typing.Optional[StreamWebSocketControl]: ...
    @_property
    def information(self) -> typing.Optional[StreamWebSocketInformation]: ...
    @_property
    def input_stream(self) -> typing.Optional[windows_storage_streams.IInputStream]: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class StreamWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamWebSocketControl: ...
    @_property
    def no_delay(self) -> bool: ...
    @no_delay.setter
    def no_delay(self, value: bool) -> None: ...
    @_property
    def desired_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @desired_unsolicited_pong_interval.setter
    def desired_unsolicited_pong_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def client_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[windows_security_cryptography_certificates.Certificate]) -> None: ...
    @_property
    def actual_unsolicited_pong_interval(self) -> datetime.timedelta: ...
    @_property
    def server_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[windows_foundation_collections.IVector[str]]: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVector[windows_security_cryptography_certificates.ChainValidationResult]]: ...

@typing.final
class StreamWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...
    @_property
    def server_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.Certificate]]: ...

@typing.final
class WebSocketClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketClosedEventArgs: ...
    @_property
    def code(self) -> winrt.system.UInt16: ...
    @_property
    def reason(self) -> str: ...

@typing.final
class WebSocketError_Static(type):
    def get_status(cls, hresult: winrt.system.Int32, /) -> windows_web.WebErrorStatus: ...

@typing.final
class WebSocketError(winrt.system.Object, metaclass=WebSocketError_Static):
    pass

@typing.final
class WebSocketKeepAlive(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketKeepAlive: ...
    def __new__(cls: typing.Type[WebSocketKeepAlive]) -> WebSocketKeepAlive: ...
    def run(self, task_instance: typing.Optional[windows_applicationmodel_background.IBackgroundTaskInstance], /) -> None: ...

@typing.final
class WebSocketServerCustomValidationRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebSocketServerCustomValidationRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[windows_foundation.Deferral]: ...
    def reject(self) -> None: ...
    @_property
    def server_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.Certificate]]: ...

@typing.final
class IControlChannelTriggerEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IControlChannelTriggerEventDetails: ...
    @_property
    def control_channel_trigger(self) -> typing.Optional[ControlChannelTrigger]: ...

@typing.final
class IControlChannelTriggerResetEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IControlChannelTriggerResetEventDetails: ...
    @_property
    def hardware_slot_reset(self) -> bool: ...
    @_property
    def reset_reason(self) -> ControlChannelTriggerResetReason: ...
    @_property
    def software_slot_reset(self) -> bool: ...

@typing.final
class IWebSocket(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: winrt.system.UInt16, reason: str, /) -> None: ...
    def connect_async(self, uri: typing.Optional[windows_foundation.Uri], /) -> windows_foundation.IAsyncAction: ...
    def set_request_header(self, header_name: str, header_value: str, /) -> None: ...
    def add_closed(self, event_handler: windows_foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def output_stream(self) -> typing.Optional[windows_storage_streams.IOutputStream]: ...

@typing.final
class IWebSocketControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketControl: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def server_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[windows_foundation_collections.IVector[str]]: ...

@typing.final
class IWebSocketControl2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketControl2: ...
    @_property
    def ignorable_server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVector[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def outbound_buffer_size_in_bytes(self) -> winrt.system.UInt32: ...
    @outbound_buffer_size_in_bytes.setter
    def outbound_buffer_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def proxy_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @proxy_credential.setter
    def proxy_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def server_credential(self) -> typing.Optional[windows_security_credentials.PasswordCredential]: ...
    @server_credential.setter
    def server_credential(self, value: typing.Optional[windows_security_credentials.PasswordCredential]) -> None: ...
    @_property
    def supported_protocols(self) -> typing.Optional[windows_foundation_collections.IVector[str]]: ...

@typing.final
class IWebSocketInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketInformation: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

@typing.final
class IWebSocketInformation2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IWebSocketInformation2: ...
    @_property
    def server_certificate(self) -> typing.Optional[windows_security_cryptography_certificates.Certificate]: ...
    @_property
    def server_certificate_error_severity(self) -> SocketSslErrorSeverity: ...
    @_property
    def server_certificate_errors(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.ChainValidationResult]]: ...
    @_property
    def server_intermediate_certificates(self) -> typing.Optional[windows_foundation_collections.IVectorView[windows_security_cryptography_certificates.Certificate]]: ...
    @_property
    def bandwidth_statistics(self) -> BandwidthStatistics: ...
    @_property
    def local_address(self) -> typing.Optional[windows_networking.HostName]: ...
    @_property
    def protocol(self) -> str: ...

