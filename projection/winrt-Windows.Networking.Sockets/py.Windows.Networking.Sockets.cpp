// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Networking.Sockets.h"

namespace py::cpp::Windows::Networking::Sockets
{
    // ----- ControlChannelTrigger class --------------------

    static PyObject* _new_ControlChannelTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::ControlChannelTriggerResourceType>(args, 2);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ControlChannelTrigger_Close(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_DecreaseNetworkKeepAliveInterval(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"DecreaseNetworkKeepAliveInterval", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.DecreaseNetworkKeepAliveInterval();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_FlushTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"FlushTransport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.FlushTransport();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_UsingTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"UsingTransport", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.UsingTransport(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_WaitForPushEnabled(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"WaitForPushEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.WaitForPushEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"ServerKeepAliveIntervalInMinutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"ServerKeepAliveIntervalInMinutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ServerKeepAliveIntervalInMinutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ControlChannelTrigger_get_ControlChannelTriggerId(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"ControlChannelTriggerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControlChannelTriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"CurrentKeepAliveIntervalInMinutes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_KeepAliveTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"KeepAliveTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeepAliveTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_PushNotificationTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"PushNotificationTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PushNotificationTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_TransportObject(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"TransportObject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportObject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ControlChannelTrigger", L"IsWakeFromLowPowerSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ControlChannelTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ControlChannelTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ControlChannelTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ControlChannelTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ControlChannelTrigger[] = {
        { "close", reinterpret_cast<PyCFunction>(ControlChannelTrigger_Close), METH_VARARGS, nullptr },
        { "decrease_network_keep_alive_interval", reinterpret_cast<PyCFunction>(ControlChannelTrigger_DecreaseNetworkKeepAliveInterval), METH_VARARGS, nullptr },
        { "flush_transport", reinterpret_cast<PyCFunction>(ControlChannelTrigger_FlushTransport), METH_VARARGS, nullptr },
        { "using_transport", reinterpret_cast<PyCFunction>(ControlChannelTrigger_UsingTransport), METH_VARARGS, nullptr },
        { "wait_for_push_enabled", reinterpret_cast<PyCFunction>(ControlChannelTrigger_WaitForPushEnabled), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ControlChannelTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ControlChannelTrigger), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ControlChannelTrigger), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ControlChannelTrigger), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ControlChannelTrigger[] = {
        { "server_keep_alive_interval_in_minutes", reinterpret_cast<getter>(ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes), reinterpret_cast<setter>(ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes), nullptr, nullptr },
        { "control_channel_trigger_id", reinterpret_cast<getter>(ControlChannelTrigger_get_ControlChannelTriggerId), nullptr, nullptr, nullptr },
        { "current_keep_alive_interval_in_minutes", reinterpret_cast<getter>(ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes), nullptr, nullptr, nullptr },
        { "keep_alive_trigger", reinterpret_cast<getter>(ControlChannelTrigger_get_KeepAliveTrigger), nullptr, nullptr, nullptr },
        { "push_notification_trigger", reinterpret_cast<getter>(ControlChannelTrigger_get_PushNotificationTrigger), nullptr, nullptr, nullptr },
        { "transport_object", reinterpret_cast<getter>(ControlChannelTrigger_get_TransportObject), nullptr, nullptr, nullptr },
        { "is_wake_from_low_power_supported", reinterpret_cast<getter>(ControlChannelTrigger_get_IsWakeFromLowPowerSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ControlChannelTrigger[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ControlChannelTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ControlChannelTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ControlChannelTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ControlChannelTrigger) },
        { }
    };

    static PyType_Spec type_spec_ControlChannelTrigger = {
        "winrt._winrt_windows_networking_sockets.ControlChannelTrigger",
        sizeof(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ControlChannelTrigger};

    // ----- DatagramSocket class --------------------

    static PyObject* _new_DatagramSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::DatagramSocket instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocket_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"BindEndpointAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"BindServiceNameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"BindServiceNameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"CancelIOAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_Close(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"ConnectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"ConnectAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"EnableTransferOwnership", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"EnableTransferOwnership", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetEndpointPairsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetEndpointPairsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetOutputStreamAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetOutputStreamAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.GetOutputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"GetOutputStreamAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetOutputStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_JoinMulticastGroup(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"JoinMulticastGroup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.JoinMulticastGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"TransferOwnership", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"TransferOwnership", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocket", L"TransferOwnership", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Control(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocket", L"Control");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Information(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocket", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.DatagramSocket", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::DatagramSocket, winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.DatagramSocket", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatagramSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocket[] = {
        { "bind_endpoint_async", reinterpret_cast<PyCFunction>(DatagramSocket_BindEndpointAsync), METH_VARARGS, nullptr },
        { "bind_service_name_async", reinterpret_cast<PyCFunction>(DatagramSocket_BindServiceNameAsync), METH_VARARGS, nullptr },
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(DatagramSocket_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DatagramSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(DatagramSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(DatagramSocket_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "get_output_stream_async", reinterpret_cast<PyCFunction>(DatagramSocket_GetOutputStreamAsync), METH_VARARGS, nullptr },
        { "join_multicast_group", reinterpret_cast<PyCFunction>(DatagramSocket_JoinMulticastGroup), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(DatagramSocket_TransferOwnership), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(DatagramSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(DatagramSocket_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_DatagramSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DatagramSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_DatagramSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocket[] = {
        { "control", reinterpret_cast<getter>(DatagramSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(DatagramSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(DatagramSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocket) },
        { }
    };

    static PyType_Spec type_spec_DatagramSocket = {
        "winrt._winrt_windows_networking_sockets.DatagramSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocket};

    static PyGetSetDef getset_DatagramSocket_Static[] = {
        { }
    };

    static PyMethodDef methods_DatagramSocket_Static[] = {
        { "get_endpoint_pairs_async", reinterpret_cast<PyCFunction>(DatagramSocket_GetEndpointPairsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DatagramSocket_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DatagramSocket_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DatagramSocket_Static) },
        { }
    };

    static PyType_Spec type_spec_DatagramSocket_Static =
    {
        "winrt._winrt_windows_networking_sockets.DatagramSocket_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DatagramSocket_Static
    };

    // ----- DatagramSocketControl class --------------------

    static PyObject* _new_DatagramSocketControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::type_name);
        return nullptr;
    }

    static void _dealloc_DatagramSocketControl(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"QualityOfService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"QualityOfService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"OutboundUnicastHopLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"OutboundUnicastHopLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"InboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"InboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.InboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"DontFragment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DontFragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"DontFragment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DontFragment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"MulticastOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MulticastOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketControl", L"MulticastOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MulticastOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DatagramSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketControl[] = {
        { "_assign_array_", _assign_array_DatagramSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(DatagramSocketControl_get_QualityOfService), reinterpret_cast<setter>(DatagramSocketControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(DatagramSocketControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(DatagramSocketControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "inbound_buffer_size_in_bytes", reinterpret_cast<getter>(DatagramSocketControl_get_InboundBufferSizeInBytes), reinterpret_cast<setter>(DatagramSocketControl_put_InboundBufferSizeInBytes), nullptr, nullptr },
        { "dont_fragment", reinterpret_cast<getter>(DatagramSocketControl_get_DontFragment), reinterpret_cast<setter>(DatagramSocketControl_put_DontFragment), nullptr, nullptr },
        { "multicast_only", reinterpret_cast<getter>(DatagramSocketControl_get_MulticastOnly), reinterpret_cast<setter>(DatagramSocketControl_put_MulticastOnly), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocketControl) },
        { }
    };

    static PyType_Spec type_spec_DatagramSocketControl = {
        "winrt._winrt_windows_networking_sockets.DatagramSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketControl};

    // ----- DatagramSocketInformation class --------------------

    static PyObject* _new_DatagramSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_DatagramSocketInformation(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"LocalPort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"RemoteAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketInformation", L"RemotePort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatagramSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketInformation[] = {
        { "_assign_array_", _assign_array_DatagramSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketInformation[] = {
        { "local_address", reinterpret_cast<getter>(DatagramSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(DatagramSocketInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(DatagramSocketInformation_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(DatagramSocketInformation_get_RemotePort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_DatagramSocketInformation = {
        "winrt._winrt_windows_networking_sockets.DatagramSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketInformation};

    // ----- DatagramSocketMessageReceivedEventArgs class --------------------

    static PyObject* _new_DatagramSocketMessageReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DatagramSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"GetDataReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"GetDataStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"RemoteAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs", L"RemotePort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatagramSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatagramSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", reinterpret_cast<PyCFunction>(DatagramSocketMessageReceivedEventArgs_GetDataReader), METH_VARARGS, nullptr },
        { "get_data_stream", reinterpret_cast<PyCFunction>(DatagramSocketMessageReceivedEventArgs_GetDataStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DatagramSocketMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketMessageReceivedEventArgs[] = {
        { "local_address", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_LocalAddress), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_RemotePort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketMessageReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatagramSocketMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatagramSocketMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatagramSocketMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatagramSocketMessageReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DatagramSocketMessageReceivedEventArgs = {
        "winrt._winrt_windows_networking_sockets.DatagramSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketMessageReceivedEventArgs};

    // ----- MessageWebSocket class --------------------

    static PyObject* _new_MessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::MessageWebSocket instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Close", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"ConnectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendFinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"SendFinalFrameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendFinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendNonfinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"SendNonfinalFrameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendNonfinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Control");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"ServerCustomValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.MessageWebSocket", L"ServerCustomValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(MessageWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(MessageWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "send_final_frame_async", reinterpret_cast<PyCFunction>(MessageWebSocket_SendFinalFrameAsync), METH_VARARGS, nullptr },
        { "send_nonfinal_frame_async", reinterpret_cast<PyCFunction>(MessageWebSocket_SendNonfinalFrameAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(MessageWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(MessageWebSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_MessageReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MessageWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_Closed), METH_O, nullptr },
        { "add_server_custom_validation_requested", reinterpret_cast<PyCFunction>(MessageWebSocket_add_ServerCustomValidationRequested), METH_O, nullptr },
        { "remove_server_custom_validation_requested", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_ServerCustomValidationRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_MessageWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MessageWebSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MessageWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocket[] = {
        { "control", reinterpret_cast<getter>(MessageWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(MessageWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(MessageWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocket) },
        { }
    };

    static PyType_Spec type_spec_MessageWebSocket = {
        "winrt._winrt_windows_networking_sockets.MessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocket};

    // ----- MessageWebSocketControl class --------------------

    static PyObject* _new_MessageWebSocketControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::type_name);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MaxMessageSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxMessageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"MaxMessageSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxMessageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ReceiveMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReceiveMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ReceiveMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::MessageWebSocketReceiveMode>(arg);

            self->obj.ReceiveMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"DesiredUnsolicitedPongInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"DesiredUnsolicitedPongInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ClientCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ClientCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ActualUnsolicitedPongInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"SupportedProtocols");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketControl", L"IgnorableServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketControl[] = {
        { "_assign_array_", _assign_array_MessageWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketControl[] = {
        { "message_type", reinterpret_cast<getter>(MessageWebSocketControl_get_MessageType), reinterpret_cast<setter>(MessageWebSocketControl_put_MessageType), nullptr, nullptr },
        { "max_message_size", reinterpret_cast<getter>(MessageWebSocketControl_get_MaxMessageSize), reinterpret_cast<setter>(MessageWebSocketControl_put_MaxMessageSize), nullptr, nullptr },
        { "receive_mode", reinterpret_cast<getter>(MessageWebSocketControl_get_ReceiveMode), reinterpret_cast<setter>(MessageWebSocketControl_put_ReceiveMode), nullptr, nullptr },
        { "desired_unsolicited_pong_interval", reinterpret_cast<getter>(MessageWebSocketControl_get_DesiredUnsolicitedPongInterval), reinterpret_cast<setter>(MessageWebSocketControl_put_DesiredUnsolicitedPongInterval), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(MessageWebSocketControl_get_ClientCertificate), reinterpret_cast<setter>(MessageWebSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "actual_unsolicited_pong_interval", reinterpret_cast<getter>(MessageWebSocketControl_get_ActualUnsolicitedPongInterval), nullptr, nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(MessageWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(MessageWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(MessageWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(MessageWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(MessageWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(MessageWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(MessageWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(MessageWebSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocketControl) },
        { }
    };

    static PyType_Spec type_spec_MessageWebSocketControl = {
        "winrt._winrt_windows_networking_sockets.MessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketControl};

    // ----- MessageWebSocketInformation class --------------------

    static PyObject* _new_MessageWebSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerCertificateErrorSeverity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketInformation", L"ServerIntermediateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketInformation[] = {
        { "_assign_array_", _assign_array_MessageWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(MessageWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(MessageWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(MessageWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_MessageWebSocketInformation = {
        "winrt._winrt_windows_networking_sockets.MessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketInformation};

    // ----- MessageWebSocketMessageReceivedEventArgs class --------------------

    static PyObject* _new_MessageWebSocketMessageReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"GetDataReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"GetDataStream", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs", L"IsMessageComplete");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMessageComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MessageWebSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MessageWebSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", reinterpret_cast<PyCFunction>(MessageWebSocketMessageReceivedEventArgs_GetDataReader), METH_VARARGS, nullptr },
        { "get_data_stream", reinterpret_cast<PyCFunction>(MessageWebSocketMessageReceivedEventArgs_GetDataStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MessageWebSocketMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketMessageReceivedEventArgs[] = {
        { "message_type", reinterpret_cast<getter>(MessageWebSocketMessageReceivedEventArgs_get_MessageType), nullptr, nullptr, nullptr },
        { "is_message_complete", reinterpret_cast<getter>(MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketMessageReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MessageWebSocketMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MessageWebSocketMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MessageWebSocketMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MessageWebSocketMessageReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MessageWebSocketMessageReceivedEventArgs = {
        "winrt._winrt_windows_networking_sockets.MessageWebSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketMessageReceivedEventArgs};

    // ----- ServerMessageWebSocket class --------------------

    static PyObject* _new_ServerMessageWebSocket(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::type_name);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerMessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Close", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Control");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerMessageWebSocket", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerMessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerMessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_remove_Closed), METH_O, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_ServerMessageWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ServerMessageWebSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ServerMessageWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocket[] = {
        { "control", reinterpret_cast<getter>(ServerMessageWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(ServerMessageWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(ServerMessageWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerMessageWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerMessageWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerMessageWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerMessageWebSocket) },
        { }
    };

    static PyType_Spec type_spec_ServerMessageWebSocket = {
        "winrt._winrt_windows_networking_sockets.ServerMessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocket};

    // ----- ServerMessageWebSocketControl class --------------------

    static PyObject* _new_ServerMessageWebSocketControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::type_name);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerMessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketControl", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ServerMessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketControl", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ServerMessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerMessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketControl[] = {
        { "_assign_array_", _assign_array_ServerMessageWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketControl[] = {
        { "message_type", reinterpret_cast<getter>(ServerMessageWebSocketControl_get_MessageType), reinterpret_cast<setter>(ServerMessageWebSocketControl_put_MessageType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerMessageWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerMessageWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerMessageWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerMessageWebSocketControl) },
        { }
    };

    static PyType_Spec type_spec_ServerMessageWebSocketControl = {
        "winrt._winrt_windows_networking_sockets.ServerMessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketControl};

    // ----- ServerMessageWebSocketInformation class --------------------

    static PyObject* _new_ServerMessageWebSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerMessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerMessageWebSocketInformation", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerMessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerMessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketInformation[] = {
        { "_assign_array_", _assign_array_ServerMessageWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerMessageWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerMessageWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerMessageWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerMessageWebSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_ServerMessageWebSocketInformation = {
        "winrt._winrt_windows_networking_sockets.ServerMessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketInformation};

    // ----- ServerStreamWebSocket class --------------------

    static PyObject* _new_ServerStreamWebSocket(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::type_name);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerStreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Close", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"InputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerStreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.ServerStreamWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerStreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerStreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ServerStreamWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerStreamWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ServerStreamWebSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ServerStreamWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerStreamWebSocket[] = {
        { "information", reinterpret_cast<getter>(ServerStreamWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(ServerStreamWebSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(ServerStreamWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerStreamWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerStreamWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerStreamWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerStreamWebSocket) },
        { }
    };

    static PyType_Spec type_spec_ServerStreamWebSocket = {
        "winrt._winrt_windows_networking_sockets.ServerStreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocket};

    // ----- ServerStreamWebSocketInformation class --------------------

    static PyObject* _new_ServerStreamWebSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ServerStreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.ServerStreamWebSocketInformation", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ServerStreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ServerStreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocketInformation[] = {
        { "_assign_array_", _assign_array_ServerStreamWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerStreamWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerStreamWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ServerStreamWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ServerStreamWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ServerStreamWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ServerStreamWebSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_ServerStreamWebSocketInformation = {
        "winrt._winrt_windows_networking_sockets.ServerStreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocketInformation};

    // ----- SocketActivityContext class --------------------

    static PyObject* _new_SocketActivityContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Networking::Sockets::SocketActivityContext instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityContext(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityContext_get_Data(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityContext", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::SocketActivityContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityContext[] = {
        { "_assign_array_", _assign_array_SocketActivityContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityContext[] = {
        { "data", reinterpret_cast<getter>(SocketActivityContext_get_Data), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityContext) },
        { }
    };

    static PyType_Spec type_spec_SocketActivityContext = {
        "winrt._winrt_windows_networking_sockets.SocketActivityContext",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityContext};

    // ----- SocketActivityInformation class --------------------

    static PyObject* _new_SocketActivityInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_SocketActivityInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityInformation_get_Context(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"Context");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_DatagramSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"DatagramSocket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DatagramSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_Id(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_SocketKind(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"SocketKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SocketKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"StreamSocket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"StreamSocketListener");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamSocketListener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_TaskId(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"TaskId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_AllSockets(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityInformation", L"AllSockets");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::Sockets::SocketActivityInformation::AllSockets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::SocketActivityInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityInformation[] = {
        { "_assign_array_", _assign_array_SocketActivityInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityInformation[] = {
        { "context", reinterpret_cast<getter>(SocketActivityInformation_get_Context), nullptr, nullptr, nullptr },
        { "datagram_socket", reinterpret_cast<getter>(SocketActivityInformation_get_DatagramSocket), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SocketActivityInformation_get_Id), nullptr, nullptr, nullptr },
        { "socket_kind", reinterpret_cast<getter>(SocketActivityInformation_get_SocketKind), nullptr, nullptr, nullptr },
        { "stream_socket", reinterpret_cast<getter>(SocketActivityInformation_get_StreamSocket), nullptr, nullptr, nullptr },
        { "stream_socket_listener", reinterpret_cast<getter>(SocketActivityInformation_get_StreamSocketListener), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(SocketActivityInformation_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityInformation) },
        { }
    };

    static PyType_Spec type_spec_SocketActivityInformation = {
        "winrt._winrt_windows_networking_sockets.SocketActivityInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityInformation};

    static PyGetSetDef getset_SocketActivityInformation_Static[] = {
        { "all_sockets", reinterpret_cast<getter>(SocketActivityInformation_get_AllSockets), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SocketActivityInformation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SocketActivityInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SocketActivityInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SocketActivityInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_SocketActivityInformation_Static =
    {
        "winrt._winrt_windows_networking_sockets.SocketActivityInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SocketActivityInformation_Static
    };

    // ----- SocketActivityTriggerDetails class --------------------

    static PyObject* _new_SocketActivityTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SocketActivityTriggerDetails(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SocketActivityTriggerDetails_get_Reason(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityTriggerDetails", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityTriggerDetails_get_SocketInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.SocketActivityTriggerDetails", L"SocketInformation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SocketInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SocketActivityTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SocketActivityTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTriggerDetails[] = {
        { "_assign_array_", _assign_array_SocketActivityTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityTriggerDetails[] = {
        { "reason", reinterpret_cast<getter>(SocketActivityTriggerDetails_get_Reason), nullptr, nullptr, nullptr },
        { "socket_information", reinterpret_cast<getter>(SocketActivityTriggerDetails_get_SocketInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketActivityTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SocketActivityTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketActivityTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketActivityTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_SocketActivityTriggerDetails = {
        "winrt._winrt_windows_networking_sockets.SocketActivityTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTriggerDetails};

    // ----- SocketError class --------------------

    static PyObject* _new_SocketError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::SocketError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::SocketError>::type_name);
        return nullptr;
    }

    static PyObject* SocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.SocketError", L"GetStatus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::SocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketError[] = {
        { }
    };

    static PyGetSetDef _getset_SocketError[] = {
        { }
    };

    static PyType_Slot _type_slots_SocketError[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SocketError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SocketError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SocketError) },
        { }
    };

    static PyType_Spec type_spec_SocketError = {
        "winrt._winrt_windows_networking_sockets.SocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketError};

    static PyGetSetDef getset_SocketError_Static[] = {
        { }
    };

    static PyMethodDef methods_SocketError_Static[] = {
        { "get_status", reinterpret_cast<PyCFunction>(SocketError_GetStatus), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SocketError_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SocketError_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SocketError_Static) },
        { }
    };

    static PyType_Spec type_spec_SocketError_Static =
    {
        "winrt._winrt_windows_networking_sockets.SocketError_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SocketError_Static
    };

    // ----- StreamSocket class --------------------

    static PyObject* _new_StreamSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocket instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"CancelIOAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"ConnectAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 3);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"EnableTransferOwnership", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"EnableTransferOwnership", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"GetEndpointPairsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"GetEndpointPairsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"TransferOwnership", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"TransferOwnership", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"TransferOwnership", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_UpgradeToSslAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocket", L"UpgradeToSslAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                return py::convert(self->obj.UpgradeToSslAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"Control");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"InputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocket[] = {
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(StreamSocket_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(StreamSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(StreamSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocket_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocket_TransferOwnership), METH_VARARGS, nullptr },
        { "upgrade_to_ssl_async", reinterpret_cast<PyCFunction>(StreamSocket_UpgradeToSslAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StreamSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_StreamSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocket[] = {
        { "control", reinterpret_cast<getter>(StreamSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(StreamSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(StreamSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocket) },
        { }
    };

    static PyType_Spec type_spec_StreamSocket = {
        "winrt._winrt_windows_networking_sockets.StreamSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocket};

    static PyGetSetDef getset_StreamSocket_Static[] = {
        { }
    };

    static PyMethodDef methods_StreamSocket_Static[] = {
        { "get_endpoint_pairs_async", reinterpret_cast<PyCFunction>(StreamSocket_GetEndpointPairsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StreamSocket_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StreamSocket_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StreamSocket_Static) },
        { }
    };

    static PyType_Spec type_spec_StreamSocket_Static =
    {
        "winrt._winrt_windows_networking_sockets.StreamSocket_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StreamSocket_Static
    };

    // ----- StreamSocketControl class --------------------

    static PyObject* _new_StreamSocketControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamSocketControl(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"QualityOfService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"QualityOfService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundUnicastHopLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundUnicastHopLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"NoDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"NoDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"KeepAlive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"KeepAlive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"IgnorableServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketControl_get_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"SerializeConnectionAttempts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SerializeConnectionAttempts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"SerializeConnectionAttempts");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SerializeConnectionAttempts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"ClientCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"ClientCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"MinProtectionLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketControl", L"MinProtectionLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.MinProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StreamSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketControl[] = {
        { "_assign_array_", _assign_array_StreamSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(StreamSocketControl_get_QualityOfService), reinterpret_cast<setter>(StreamSocketControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(StreamSocketControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(StreamSocketControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "no_delay", reinterpret_cast<getter>(StreamSocketControl_get_NoDelay), reinterpret_cast<setter>(StreamSocketControl_put_NoDelay), nullptr, nullptr },
        { "keep_alive", reinterpret_cast<getter>(StreamSocketControl_get_KeepAlive), reinterpret_cast<setter>(StreamSocketControl_put_KeepAlive), nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(StreamSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { "serialize_connection_attempts", reinterpret_cast<getter>(StreamSocketControl_get_SerializeConnectionAttempts), reinterpret_cast<setter>(StreamSocketControl_put_SerializeConnectionAttempts), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(StreamSocketControl_get_ClientCertificate), reinterpret_cast<setter>(StreamSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "min_protection_level", reinterpret_cast<getter>(StreamSocketControl_get_MinProtectionLevel), reinterpret_cast<setter>(StreamSocketControl_put_MinProtectionLevel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketControl) },
        { }
    };

    static PyType_Spec type_spec_StreamSocketControl = {
        "winrt._winrt_windows_networking_sockets.StreamSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketControl};

    // ----- StreamSocketInformation class --------------------

    static PyObject* _new_StreamSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"LocalPort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ProtectionLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemoteAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteHostName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemoteHostName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemotePort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteServiceName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RemoteServiceName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"RoundTripTimeStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RoundTripTimeStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_SessionKey(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"SessionKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerCertificateErrorSeverity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketInformation", L"ServerIntermediateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketInformation[] = {
        { "_assign_array_", _assign_array_StreamSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(StreamSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(StreamSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(StreamSocketInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(StreamSocketInformation_get_ProtectionLevel), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_host_name", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteHostName), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(StreamSocketInformation_get_RemotePort), nullptr, nullptr, nullptr },
        { "remote_service_name", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteServiceName), nullptr, nullptr, nullptr },
        { "round_trip_time_statistics", reinterpret_cast<getter>(StreamSocketInformation_get_RoundTripTimeStatistics), nullptr, nullptr, nullptr },
        { "session_key", reinterpret_cast<getter>(StreamSocketInformation_get_SessionKey), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(StreamSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_StreamSocketInformation = {
        "winrt._winrt_windows_networking_sockets.StreamSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketInformation};

    // ----- StreamSocketListener class --------------------

    static PyObject* _new_StreamSocketListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocketListener instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListener_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindEndpointAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindServiceNameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindServiceNameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"BindServiceNameAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 2);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"CancelIOAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_Close(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"EnableTransferOwnership", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"EnableTransferOwnership", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"TransferOwnership", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"TransferOwnership", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"Control");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_add_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"ConnectionReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamSocketListener, winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_remove_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamSocketListener", L"ConnectionReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListener[] = {
        { "bind_endpoint_async", reinterpret_cast<PyCFunction>(StreamSocketListener_BindEndpointAsync), METH_VARARGS, nullptr },
        { "bind_service_name_async", reinterpret_cast<PyCFunction>(StreamSocketListener_BindServiceNameAsync), METH_VARARGS, nullptr },
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(StreamSocketListener_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(StreamSocketListener_Close), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocketListener_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocketListener_TransferOwnership), METH_VARARGS, nullptr },
        { "add_connection_received", reinterpret_cast<PyCFunction>(StreamSocketListener_add_ConnectionReceived), METH_O, nullptr },
        { "remove_connection_received", reinterpret_cast<PyCFunction>(StreamSocketListener_remove_ConnectionReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_StreamSocketListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListener), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamSocketListener), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_StreamSocketListener), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListener[] = {
        { "control", reinterpret_cast<getter>(StreamSocketListener_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamSocketListener_get_Information), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListener) },
        { }
    };

    static PyType_Spec type_spec_StreamSocketListener = {
        "winrt._winrt_windows_networking_sockets.StreamSocketListener",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListener};

    // ----- StreamSocketListenerConnectionReceivedEventArgs class --------------------

    static PyObject* _new_StreamSocketListenerConnectionReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerConnectionReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListenerConnectionReceivedEventArgs_get_Socket(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs", L"Socket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Socket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketListenerConnectionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListenerConnectionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_StreamSocketListenerConnectionReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerConnectionReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "socket", reinterpret_cast<getter>(StreamSocketListenerConnectionReceivedEventArgs_get_Socket), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListenerConnectionReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListenerConnectionReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListenerConnectionReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListenerConnectionReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_StreamSocketListenerConnectionReceivedEventArgs = {
        "winrt._winrt_windows_networking_sockets.StreamSocketListenerConnectionReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerConnectionReceivedEventArgs};

    // ----- StreamSocketListenerControl class --------------------

    static PyObject* _new_StreamSocketListenerControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerControl(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListenerControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"QualityOfService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"QualityOfService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundUnicastHopLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundUnicastHopLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"NoDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"NoDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"KeepAlive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerControl", L"KeepAlive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StreamSocketListenerControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListenerControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerControl[] = {
        { "_assign_array_", _assign_array_StreamSocketListenerControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(StreamSocketListenerControl_get_QualityOfService), reinterpret_cast<setter>(StreamSocketListenerControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(StreamSocketListenerControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(StreamSocketListenerControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamSocketListenerControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamSocketListenerControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "no_delay", reinterpret_cast<getter>(StreamSocketListenerControl_get_NoDelay), reinterpret_cast<setter>(StreamSocketListenerControl_put_NoDelay), nullptr, nullptr },
        { "keep_alive", reinterpret_cast<getter>(StreamSocketListenerControl_get_KeepAlive), reinterpret_cast<setter>(StreamSocketListenerControl_put_KeepAlive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListenerControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListenerControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListenerControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListenerControl) },
        { }
    };

    static PyType_Spec type_spec_StreamSocketListenerControl = {
        "winrt._winrt_windows_networking_sockets.StreamSocketListenerControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerControl};

    // ----- StreamSocketListenerInformation class --------------------

    static PyObject* _new_StreamSocketListenerInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamSocketListenerInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamSocketListenerInformation", L"LocalPort");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamSocketListenerInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamSocketListenerInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerInformation[] = {
        { "_assign_array_", _assign_array_StreamSocketListenerInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerInformation[] = {
        { "local_port", reinterpret_cast<getter>(StreamSocketListenerInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamSocketListenerInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamSocketListenerInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamSocketListenerInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamSocketListenerInformation) },
        { }
    };

    static PyType_Spec type_spec_StreamSocketListenerInformation = {
        "winrt._winrt_windows_networking_sockets.StreamSocketListenerInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerInformation};

    // ----- StreamWebSocket class --------------------

    static PyObject* _new_StreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamWebSocket instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Close", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"ConnectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Control");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Information");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"InputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"ServerCustomValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.StreamWebSocket", L"ServerCustomValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(StreamWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(StreamWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(StreamWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(StreamWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(StreamWebSocket_remove_Closed), METH_O, nullptr },
        { "add_server_custom_validation_requested", reinterpret_cast<PyCFunction>(StreamWebSocket_add_ServerCustomValidationRequested), METH_O, nullptr },
        { "remove_server_custom_validation_requested", reinterpret_cast<PyCFunction>(StreamWebSocket_remove_ServerCustomValidationRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_StreamWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamWebSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_StreamWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocket[] = {
        { "control", reinterpret_cast<getter>(StreamWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(StreamWebSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(StreamWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamWebSocket) },
        { }
    };

    static PyType_Spec type_spec_StreamWebSocket = {
        "winrt._winrt_windows_networking_sockets.StreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocket};

    // ----- StreamWebSocketControl class --------------------

    static PyObject* _new_StreamWebSocketControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketControl(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamWebSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"NoDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"NoDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"DesiredUnsolicitedPongInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"DesiredUnsolicitedPongInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ClientCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ClientCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ActualUnsolicitedPongInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"SupportedProtocols");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketControl", L"IgnorableServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketControl[] = {
        { "_assign_array_", _assign_array_StreamWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocketControl[] = {
        { "no_delay", reinterpret_cast<getter>(StreamWebSocketControl_get_NoDelay), reinterpret_cast<setter>(StreamWebSocketControl_put_NoDelay), nullptr, nullptr },
        { "desired_unsolicited_pong_interval", reinterpret_cast<getter>(StreamWebSocketControl_get_DesiredUnsolicitedPongInterval), reinterpret_cast<setter>(StreamWebSocketControl_put_DesiredUnsolicitedPongInterval), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(StreamWebSocketControl_get_ClientCertificate), reinterpret_cast<setter>(StreamWebSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "actual_unsolicited_pong_interval", reinterpret_cast<getter>(StreamWebSocketControl_get_ActualUnsolicitedPongInterval), nullptr, nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(StreamWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(StreamWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(StreamWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(StreamWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(StreamWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(StreamWebSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocketControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamWebSocketControl) },
        { }
    };

    static PyType_Spec type_spec_StreamWebSocketControl = {
        "winrt._winrt_windows_networking_sockets.StreamWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketControl};

    // ----- StreamWebSocketInformation class --------------------

    static PyObject* _new_StreamWebSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerCertificateErrorSeverity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.StreamWebSocketInformation", L"ServerIntermediateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketInformation[] = {
        { "_assign_array_", _assign_array_StreamWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(StreamWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(StreamWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(StreamWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreamWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreamWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreamWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreamWebSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_StreamWebSocketInformation = {
        "winrt._winrt_windows_networking_sockets.StreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketInformation};

    // ----- WebSocketClosedEventArgs class --------------------

    static PyObject* _new_WebSocketClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebSocketClosedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebSocketClosedEventArgs_get_Code(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketClosedEventArgs", L"Code");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketClosedEventArgs_get_Reason(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketClosedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebSocketClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebSocketClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketClosedEventArgs[] = {
        { "_assign_array_", _assign_array_WebSocketClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketClosedEventArgs[] = {
        { "code", reinterpret_cast<getter>(WebSocketClosedEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(WebSocketClosedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebSocketClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebSocketClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WebSocketClosedEventArgs = {
        "winrt._winrt_windows_networking_sockets.WebSocketClosedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketClosedEventArgs};

    // ----- WebSocketError class --------------------

    static PyObject* _new_WebSocketError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::WebSocketError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::WebSocketError>::type_name);
        return nullptr;
    }

    static PyObject* WebSocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketError", L"GetStatus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::WebSocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketError[] = {
        { }
    };

    static PyGetSetDef _getset_WebSocketError[] = {
        { }
    };

    static PyType_Slot _type_slots_WebSocketError[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketError) },
        { }
    };

    static PyType_Spec type_spec_WebSocketError = {
        "winrt._winrt_windows_networking_sockets.WebSocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketError};

    static PyGetSetDef getset_WebSocketError_Static[] = {
        { }
    };

    static PyMethodDef methods_WebSocketError_Static[] = {
        { "get_status", reinterpret_cast<PyCFunction>(WebSocketError_GetStatus), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_WebSocketError_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebSocketError_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WebSocketError_Static) },
        { }
    };

    static PyType_Spec type_spec_WebSocketError_Static =
    {
        "winrt._winrt_windows_networking_sockets.WebSocketError_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WebSocketError_Static
    };

    // ----- WebSocketKeepAlive class --------------------

    static PyObject* _new_WebSocketKeepAlive(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::WebSocketKeepAlive instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebSocketKeepAlive(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebSocketKeepAlive_Run(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketKeepAlive", L"Run", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebSocketKeepAlive(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebSocketKeepAlive(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketKeepAlive[] = {
        { "run", reinterpret_cast<PyCFunction>(WebSocketKeepAlive_Run), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebSocketKeepAlive, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketKeepAlive), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketKeepAlive[] = {
        { }
    };

    static PyType_Slot _type_slots_WebSocketKeepAlive[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketKeepAlive) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebSocketKeepAlive) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketKeepAlive) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketKeepAlive) },
        { }
    };

    static PyType_Spec type_spec_WebSocketKeepAlive = {
        "winrt._winrt_windows_networking_sockets.WebSocketKeepAlive",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketKeepAlive};

    // ----- WebSocketServerCustomValidationRequestedEventArgs class --------------------

    static PyObject* _new_WebSocketServerCustomValidationRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebSocketServerCustomValidationRequestedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_Reject(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"Reject", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Reject();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerCertificateErrorSeverity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.WebSocketServerCustomValidationRequestedEventArgs", L"ServerIntermediateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebSocketServerCustomValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebSocketServerCustomValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebSocketServerCustomValidationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "reject", reinterpret_cast<PyCFunction>(WebSocketServerCustomValidationRequestedEventArgs_Reject), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebSocketServerCustomValidationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketServerCustomValidationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "server_certificate", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebSocketServerCustomValidationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebSocketServerCustomValidationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebSocketServerCustomValidationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebSocketServerCustomValidationRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_WebSocketServerCustomValidationRequestedEventArgs = {
        "winrt._winrt_windows_networking_sockets.WebSocketServerCustomValidationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketServerCustomValidationRequestedEventArgs};

    // ----- IControlChannelTriggerEventDetails interface --------------------

    static PyObject* _new_IControlChannelTriggerEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IControlChannelTriggerEventDetails_get_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerEventDetails", L"ControlChannelTrigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControlChannelTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IControlChannelTriggerEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IControlChannelTriggerEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerEventDetails[] = {
        { "_assign_array_", _assign_array_IControlChannelTriggerEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IControlChannelTriggerEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IControlChannelTriggerEventDetails[] = {
        { "control_channel_trigger", reinterpret_cast<getter>(IControlChannelTriggerEventDetails_get_ControlChannelTrigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerEventDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IControlChannelTriggerEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IControlChannelTriggerEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IControlChannelTriggerEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IControlChannelTriggerEventDetails) },
        { }
    };

    static PyType_Spec type_spec_IControlChannelTriggerEventDetails = {
        "winrt._winrt_windows_networking_sockets.IControlChannelTriggerEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerEventDetails};

    // ----- IControlChannelTriggerResetEventDetails interface --------------------

    static PyObject* _new_IControlChannelTriggerResetEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerResetEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_HardwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerResetEventDetails", L"HardwareSlotReset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HardwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_ResetReason(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerResetEventDetails", L"ResetReason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResetReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IControlChannelTriggerResetEventDetails", L"SoftwareSlotReset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SoftwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IControlChannelTriggerResetEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IControlChannelTriggerResetEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerResetEventDetails[] = {
        { "_assign_array_", _assign_array_IControlChannelTriggerResetEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IControlChannelTriggerResetEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IControlChannelTriggerResetEventDetails[] = {
        { "hardware_slot_reset", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_HardwareSlotReset), nullptr, nullptr, nullptr },
        { "reset_reason", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_ResetReason), nullptr, nullptr, nullptr },
        { "software_slot_reset", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerResetEventDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IControlChannelTriggerResetEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IControlChannelTriggerResetEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IControlChannelTriggerResetEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IControlChannelTriggerResetEventDetails) },
        { }
    };

    static PyType_Spec type_spec_IControlChannelTriggerResetEventDetails = {
        "winrt._winrt_windows_networking_sockets.IControlChannelTriggerResetEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerResetEventDetails};

    // ----- IWebSocket interface --------------------

    static PyObject* _new_IWebSocket(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IWebSocket>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IWebSocket>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocket_Close(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.IWebSocket", L"Close", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.IWebSocket", L"ConnectAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Sockets.IWebSocket", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocket", L"OutputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.IWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Sockets.IWebSocket", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocket>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(IWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(IWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(IWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(IWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(IWebSocket_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_IWebSocket, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IWebSocket), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocket[] = {
        { "output_stream", reinterpret_cast<getter>(IWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocket[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocket) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocket) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocket) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocket) },
        { }
    };

    static PyType_Spec type_spec_IWebSocket = {
        "winrt._winrt_windows_networking_sockets.IWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocket};

    // ----- IWebSocketControl interface --------------------

    static PyObject* _new_IWebSocketControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"SupportedProtocols");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl[] = {
        { "_assign_array_", _assign_array_IWebSocketControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketControl[] = {
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(IWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(IWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(IWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(IWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(IWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketControl) },
        { }
    };

    static PyType_Spec type_spec_IWebSocketControl = {
        "winrt._winrt_windows_networking_sockets.IWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl};

    // ----- IWebSocketControl2 interface --------------------

    static PyObject* _new_IWebSocketControl2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl2(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketControl2_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl2", L"IgnorableServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketControl2_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"OutboundBufferSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketControl", L"SupportedProtocols");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketControl2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl2[] = {
        { "_assign_array_", _assign_array_IWebSocketControl2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketControl2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketControl2[] = {
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(IWebSocketControl2_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(IWebSocketControl2_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(IWebSocketControl2_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IWebSocketControl2_get_ProxyCredential), reinterpret_cast<setter>(IWebSocketControl2_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IWebSocketControl2_get_ServerCredential), reinterpret_cast<setter>(IWebSocketControl2_put_ServerCredential), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(IWebSocketControl2_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketControl2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketControl2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketControl2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketControl2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketControl2) },
        { }
    };

    static PyType_Spec type_spec_IWebSocketControl2 = {
        "winrt._winrt_windows_networking_sockets.IWebSocketControl2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl2};

    // ----- IWebSocketInformation interface --------------------

    static PyObject* _new_IWebSocketInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation[] = {
        { "_assign_array_", _assign_array_IWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(IWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(IWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(IWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketInformation) },
        { }
    };

    static PyType_Spec type_spec_IWebSocketInformation = {
        "winrt._winrt_windows_networking_sockets.IWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation};

    // ----- IWebSocketInformation2 interface --------------------

    static PyObject* _new_IWebSocketInformation2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation2(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerCertificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerCertificateErrorSeverity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerCertificateErrors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation2", L"ServerIntermediateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"BandwidthStatistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"LocalAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Sockets.IWebSocketInformation", L"Protocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebSocketInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::IWebSocketInformation2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebSocketInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation2[] = {
        { "_assign_array_", _assign_array_IWebSocketInformation2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketInformation2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketInformation2[] = {
        { "server_certificate", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { "bandwidth_statistics", reinterpret_cast<getter>(IWebSocketInformation2_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(IWebSocketInformation2_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(IWebSocketInformation2_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketInformation2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebSocketInformation2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebSocketInformation2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebSocketInformation2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebSocketInformation2) },
        { }
    };

    static PyType_Spec type_spec_IWebSocketInformation2 = {
        "winrt._winrt_windows_networking_sockets.IWebSocketInformation2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation2};

    // ----- BandwidthStatistics struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::Sockets::BandwidthStatistics>* _new_BandwidthStatistics(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::Sockets::BandwidthStatistics>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BandwidthStatistics(winrt_struct_wrapper<winrt::Windows::Networking::Sockets::BandwidthStatistics>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _OutboundBitsPerSecond{};
        uint64_t _InboundBitsPerSecond{};
        uint64_t _OutboundBitsPerSecondInstability{};
        uint64_t _InboundBitsPerSecondInstability{};
        int _OutboundBandwidthPeaked{};
        int _InboundBandwidthPeaked{};

        static const char* kwlist[] = {"outbound_bits_per_second", "inbound_bits_per_second", "outbound_bits_per_second_instability", "inbound_bits_per_second_instability", "outbound_bandwidth_peaked", "inbound_bandwidth_peaked", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKpp", const_cast<char**>(kwlist), &_OutboundBitsPerSecond, &_InboundBitsPerSecond, &_OutboundBitsPerSecondInstability, &_InboundBitsPerSecondInstability, &_OutboundBandwidthPeaked, &_InboundBandwidthPeaked))
        {
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecond = _OutboundBitsPerSecond;
            self->obj.InboundBitsPerSecond = _InboundBitsPerSecond;
            self->obj.OutboundBitsPerSecondInstability = _OutboundBitsPerSecondInstability;
            self->obj.InboundBitsPerSecondInstability = _InboundBitsPerSecondInstability;
            self->obj.OutboundBandwidthPeaked = _OutboundBandwidthPeaked;
            self->obj.InboundBandwidthPeaked = _InboundBandwidthPeaked;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BandwidthStatistics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::BandwidthStatistics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BandwidthStatistics[] = {
        { "_assign_array_", _assign_array_BandwidthStatistics, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OutboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BandwidthStatistics[] = {
        { "outbound_bits_per_second", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBitsPerSecond), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBitsPerSecond), nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBitsPerSecond), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBitsPerSecond), nullptr, nullptr },
        { "outbound_bits_per_second_instability", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBitsPerSecondInstability), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBitsPerSecondInstability), nullptr, nullptr },
        { "inbound_bits_per_second_instability", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBitsPerSecondInstability), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBitsPerSecondInstability), nullptr, nullptr },
        { "outbound_bandwidth_peaked", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBandwidthPeaked), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBandwidthPeaked), nullptr, nullptr },
        { "inbound_bandwidth_peaked", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBandwidthPeaked), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBandwidthPeaked), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_BandwidthStatistics(PyObject* self) noexcept
    {
        py::pyobj_handle OutboundBitsPerSecond{PyObject_GetAttrString(self, "outbound_bits_per_second")};
        if (!OutboundBitsPerSecond)
        {
            return nullptr;
        }

        py::pyobj_handle InboundBitsPerSecond{PyObject_GetAttrString(self, "inbound_bits_per_second")};
        if (!InboundBitsPerSecond)
        {
            return nullptr;
        }

        py::pyobj_handle OutboundBitsPerSecondInstability{PyObject_GetAttrString(self, "outbound_bits_per_second_instability")};
        if (!OutboundBitsPerSecondInstability)
        {
            return nullptr;
        }

        py::pyobj_handle InboundBitsPerSecondInstability{PyObject_GetAttrString(self, "inbound_bits_per_second_instability")};
        if (!InboundBitsPerSecondInstability)
        {
            return nullptr;
        }

        py::pyobj_handle OutboundBandwidthPeaked{PyObject_GetAttrString(self, "outbound_bandwidth_peaked")};
        if (!OutboundBandwidthPeaked)
        {
            return nullptr;
        }

        py::pyobj_handle InboundBandwidthPeaked{PyObject_GetAttrString(self, "inbound_bandwidth_peaked")};
        if (!InboundBandwidthPeaked)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("BandwidthStatistics(outbound_bits_per_second=%R, inbound_bits_per_second=%R, outbound_bits_per_second_instability=%R, inbound_bits_per_second_instability=%R, outbound_bandwidth_peaked=%R, inbound_bandwidth_peaked=%R)", OutboundBitsPerSecond.get(), InboundBitsPerSecond.get(), OutboundBitsPerSecondInstability.get(), InboundBitsPerSecondInstability.get(), OutboundBandwidthPeaked.get(), InboundBandwidthPeaked.get());
    }

    static PyType_Slot _type_slots_BandwidthStatistics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BandwidthStatistics) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BandwidthStatistics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BandwidthStatistics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BandwidthStatistics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BandwidthStatistics) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_BandwidthStatistics) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_BandwidthStatistics) },
        { }
    };

    static PyType_Spec type_spec_BandwidthStatistics = {
        "winrt._winrt_windows_networking_sockets.BandwidthStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BandwidthStatistics};

    // ----- RoundTripTimeStatistics struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>* _new_RoundTripTimeStatistics(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_RoundTripTimeStatistics(winrt_struct_wrapper<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Variance{};
        uint32_t _Max{};
        uint32_t _Min{};
        uint32_t _Sum{};

        static const char* kwlist[] = {"variance", "max", "min", "sum", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_Variance, &_Max, &_Min, &_Sum))
        {
            return -1;
        }

        try
        {
            self->obj.Variance = _Variance;
            self->obj.Max = _Max;
            self->obj.Min = _Min;
            self->obj.Sum = _Sum;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RoundTripTimeStatistics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_RoundTripTimeStatistics[] = {
        { "_assign_array_", _assign_array_RoundTripTimeStatistics, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* RoundTripTimeStatistics_get_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Variance);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Variance = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Max = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Min = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sum);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Sum = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RoundTripTimeStatistics[] = {
        { "variance", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Variance), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Variance), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Max), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Max), nullptr, nullptr },
        { "min", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Min), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Min), nullptr, nullptr },
        { "sum", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Sum), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Sum), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_RoundTripTimeStatistics(PyObject* self) noexcept
    {
        py::pyobj_handle Variance{PyObject_GetAttrString(self, "variance")};
        if (!Variance)
        {
            return nullptr;
        }

        py::pyobj_handle Max{PyObject_GetAttrString(self, "max")};
        if (!Max)
        {
            return nullptr;
        }

        py::pyobj_handle Min{PyObject_GetAttrString(self, "min")};
        if (!Min)
        {
            return nullptr;
        }

        py::pyobj_handle Sum{PyObject_GetAttrString(self, "sum")};
        if (!Sum)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("RoundTripTimeStatistics(variance=%R, max=%R, min=%R, sum=%R)", Variance.get(), Max.get(), Min.get(), Sum.get());
    }

    static PyType_Slot _type_slots_RoundTripTimeStatistics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RoundTripTimeStatistics) },
        { Py_tp_init, reinterpret_cast<void*>(_init_RoundTripTimeStatistics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RoundTripTimeStatistics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RoundTripTimeStatistics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RoundTripTimeStatistics) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_RoundTripTimeStatistics) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_RoundTripTimeStatistics) },
        { }
    };

    static PyType_Spec type_spec_RoundTripTimeStatistics = {
        "winrt._winrt_windows_networking_sockets.RoundTripTimeStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoundTripTimeStatistics};

    // ----- Windows.Networking.Sockets Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Networking.Sockets");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_networking_sockets",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Networking::Sockets

PyMODINIT_FUNC PyInit__winrt_windows_networking_sockets(void) noexcept
{
    using namespace py::cpp::Windows::Networking::Sockets;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle ControlChannelTrigger_type{py::register_python_type(module.get(), &type_spec_ControlChannelTrigger, object_bases.get(), nullptr)};
    if (!ControlChannelTrigger_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DatagramSocket_Static{PyType_FromSpec(&type_spec_DatagramSocket_Static)};
    if (!type_DatagramSocket_Static)
    {
        return nullptr;
    }

    py::pytype_handle DatagramSocket_type{py::register_python_type(module.get(), &type_spec_DatagramSocket, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DatagramSocket_Static.get()))};
    if (!DatagramSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle DatagramSocketControl_type{py::register_python_type(module.get(), &type_spec_DatagramSocketControl, object_bases.get(), nullptr)};
    if (!DatagramSocketControl_type)
    {
        return nullptr;
    }

    py::pytype_handle DatagramSocketInformation_type{py::register_python_type(module.get(), &type_spec_DatagramSocketInformation, object_bases.get(), nullptr)};
    if (!DatagramSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle DatagramSocketMessageReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_DatagramSocketMessageReceivedEventArgs, object_bases.get(), nullptr)};
    if (!DatagramSocketMessageReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MessageWebSocket_type{py::register_python_type(module.get(), &type_spec_MessageWebSocket, object_bases.get(), nullptr)};
    if (!MessageWebSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle MessageWebSocketControl_type{py::register_python_type(module.get(), &type_spec_MessageWebSocketControl, object_bases.get(), nullptr)};
    if (!MessageWebSocketControl_type)
    {
        return nullptr;
    }

    py::pytype_handle MessageWebSocketInformation_type{py::register_python_type(module.get(), &type_spec_MessageWebSocketInformation, object_bases.get(), nullptr)};
    if (!MessageWebSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle MessageWebSocketMessageReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_MessageWebSocketMessageReceivedEventArgs, object_bases.get(), nullptr)};
    if (!MessageWebSocketMessageReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ServerMessageWebSocket_type{py::register_python_type(module.get(), &type_spec_ServerMessageWebSocket, object_bases.get(), nullptr)};
    if (!ServerMessageWebSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle ServerMessageWebSocketControl_type{py::register_python_type(module.get(), &type_spec_ServerMessageWebSocketControl, object_bases.get(), nullptr)};
    if (!ServerMessageWebSocketControl_type)
    {
        return nullptr;
    }

    py::pytype_handle ServerMessageWebSocketInformation_type{py::register_python_type(module.get(), &type_spec_ServerMessageWebSocketInformation, object_bases.get(), nullptr)};
    if (!ServerMessageWebSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle ServerStreamWebSocket_type{py::register_python_type(module.get(), &type_spec_ServerStreamWebSocket, object_bases.get(), nullptr)};
    if (!ServerStreamWebSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle ServerStreamWebSocketInformation_type{py::register_python_type(module.get(), &type_spec_ServerStreamWebSocketInformation, object_bases.get(), nullptr)};
    if (!ServerStreamWebSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle SocketActivityContext_type{py::register_python_type(module.get(), &type_spec_SocketActivityContext, object_bases.get(), nullptr)};
    if (!SocketActivityContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SocketActivityInformation_Static{PyType_FromSpec(&type_spec_SocketActivityInformation_Static)};
    if (!type_SocketActivityInformation_Static)
    {
        return nullptr;
    }

    py::pytype_handle SocketActivityInformation_type{py::register_python_type(module.get(), &type_spec_SocketActivityInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SocketActivityInformation_Static.get()))};
    if (!SocketActivityInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle SocketActivityTriggerDetails_type{py::register_python_type(module.get(), &type_spec_SocketActivityTriggerDetails, object_bases.get(), nullptr)};
    if (!SocketActivityTriggerDetails_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SocketError_Static{PyType_FromSpec(&type_spec_SocketError_Static)};
    if (!type_SocketError_Static)
    {
        return nullptr;
    }

    py::pytype_handle SocketError_type{py::register_python_type(module.get(), &type_spec_SocketError, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SocketError_Static.get()))};
    if (!SocketError_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_StreamSocket_Static{PyType_FromSpec(&type_spec_StreamSocket_Static)};
    if (!type_StreamSocket_Static)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocket_type{py::register_python_type(module.get(), &type_spec_StreamSocket, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StreamSocket_Static.get()))};
    if (!StreamSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocketControl_type{py::register_python_type(module.get(), &type_spec_StreamSocketControl, object_bases.get(), nullptr)};
    if (!StreamSocketControl_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocketInformation_type{py::register_python_type(module.get(), &type_spec_StreamSocketInformation, object_bases.get(), nullptr)};
    if (!StreamSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocketListener_type{py::register_python_type(module.get(), &type_spec_StreamSocketListener, object_bases.get(), nullptr)};
    if (!StreamSocketListener_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocketListenerConnectionReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_StreamSocketListenerConnectionReceivedEventArgs, object_bases.get(), nullptr)};
    if (!StreamSocketListenerConnectionReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocketListenerControl_type{py::register_python_type(module.get(), &type_spec_StreamSocketListenerControl, object_bases.get(), nullptr)};
    if (!StreamSocketListenerControl_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamSocketListenerInformation_type{py::register_python_type(module.get(), &type_spec_StreamSocketListenerInformation, object_bases.get(), nullptr)};
    if (!StreamSocketListenerInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamWebSocket_type{py::register_python_type(module.get(), &type_spec_StreamWebSocket, object_bases.get(), nullptr)};
    if (!StreamWebSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamWebSocketControl_type{py::register_python_type(module.get(), &type_spec_StreamWebSocketControl, object_bases.get(), nullptr)};
    if (!StreamWebSocketControl_type)
    {
        return nullptr;
    }

    py::pytype_handle StreamWebSocketInformation_type{py::register_python_type(module.get(), &type_spec_StreamWebSocketInformation, object_bases.get(), nullptr)};
    if (!StreamWebSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle WebSocketClosedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebSocketClosedEventArgs, object_bases.get(), nullptr)};
    if (!WebSocketClosedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebSocketError_Static{PyType_FromSpec(&type_spec_WebSocketError_Static)};
    if (!type_WebSocketError_Static)
    {
        return nullptr;
    }

    py::pytype_handle WebSocketError_type{py::register_python_type(module.get(), &type_spec_WebSocketError, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WebSocketError_Static.get()))};
    if (!WebSocketError_type)
    {
        return nullptr;
    }

    py::pytype_handle WebSocketKeepAlive_type{py::register_python_type(module.get(), &type_spec_WebSocketKeepAlive, object_bases.get(), nullptr)};
    if (!WebSocketKeepAlive_type)
    {
        return nullptr;
    }

    py::pytype_handle WebSocketServerCustomValidationRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebSocketServerCustomValidationRequestedEventArgs, object_bases.get(), nullptr)};
    if (!WebSocketServerCustomValidationRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IControlChannelTriggerEventDetails_type{py::register_python_type(module.get(), &type_spec_IControlChannelTriggerEventDetails, object_bases.get(), nullptr)};
    if (!IControlChannelTriggerEventDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle IControlChannelTriggerResetEventDetails_type{py::register_python_type(module.get(), &type_spec_IControlChannelTriggerResetEventDetails, object_bases.get(), nullptr)};
    if (!IControlChannelTriggerResetEventDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebSocket_type{py::register_python_type(module.get(), &type_spec_IWebSocket, object_bases.get(), nullptr)};
    if (!IWebSocket_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebSocketControl_type{py::register_python_type(module.get(), &type_spec_IWebSocketControl, object_bases.get(), nullptr)};
    if (!IWebSocketControl_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebSocketControl2_type{py::register_python_type(module.get(), &type_spec_IWebSocketControl2, object_bases.get(), nullptr)};
    if (!IWebSocketControl2_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebSocketInformation_type{py::register_python_type(module.get(), &type_spec_IWebSocketInformation, object_bases.get(), nullptr)};
    if (!IWebSocketInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle IWebSocketInformation2_type{py::register_python_type(module.get(), &type_spec_IWebSocketInformation2, object_bases.get(), nullptr)};
    if (!IWebSocketInformation2_type)
    {
        return nullptr;
    }

    py::pytype_handle BandwidthStatistics_type{py::register_python_type(module.get(), &type_spec_BandwidthStatistics, nullptr, nullptr)};
    if (!BandwidthStatistics_type)
    {
        return nullptr;
    }

    py::pytype_handle RoundTripTimeStatistics_type{py::register_python_type(module.get(), &type_spec_RoundTripTimeStatistics, nullptr, nullptr)};
    if (!RoundTripTimeStatistics_type)
    {
        return nullptr;
    }


    return module.detach();
}
