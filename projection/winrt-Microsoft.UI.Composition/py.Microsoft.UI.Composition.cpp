// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Composition.h"

namespace py::cpp::Microsoft::UI::Composition
{
    // ----- AmbientLight class --------------------

    static PyObject* _new_AmbientLight(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::AmbientLight>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::AmbientLight>::type_name);
        return nullptr;
    }

    static void _dealloc_AmbientLight(py::wrapper::Microsoft::UI::Composition::AmbientLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AmbientLight_get_Color(py::wrapper::Microsoft::UI::Composition::AmbientLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AmbientLight", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AmbientLight_put_Color(py::wrapper::Microsoft::UI::Composition::AmbientLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AmbientLight", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AmbientLight_get_Intensity(py::wrapper::Microsoft::UI::Composition::AmbientLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AmbientLight", L"Intensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Intensity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AmbientLight_put_Intensity(py::wrapper::Microsoft::UI::Composition::AmbientLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AmbientLight", L"Intensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Intensity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AmbientLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::AmbientLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AmbientLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::AmbientLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AmbientLight[] = {
        { "_assign_array_", _assign_array_AmbientLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AmbientLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AmbientLight[] = {
        { "color", reinterpret_cast<getter>(AmbientLight_get_Color), reinterpret_cast<setter>(AmbientLight_put_Color), nullptr, nullptr },
        { "intensity", reinterpret_cast<getter>(AmbientLight_get_Intensity), reinterpret_cast<setter>(AmbientLight_put_Intensity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AmbientLight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AmbientLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AmbientLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AmbientLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AmbientLight) },
        { }
    };

    static PyType_Spec type_spec_AmbientLight = {
        "winrt._winrt_microsoft_ui_composition.AmbientLight",
        sizeof(py::wrapper::Microsoft::UI::Composition::AmbientLight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AmbientLight};

    // ----- AnimationController class --------------------

    static PyObject* _new_AnimationController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::AnimationController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::AnimationController>::type_name);
        return nullptr;
    }

    static void _dealloc_AnimationController(py::wrapper::Microsoft::UI::Composition::AnimationController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimationController_Pause(py::wrapper::Microsoft::UI::Composition::AnimationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.AnimationController", L"Pause", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimationController_Resume(py::wrapper::Microsoft::UI::Composition::AnimationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.AnimationController", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimationController_get_ProgressBehavior(py::wrapper::Microsoft::UI::Composition::AnimationController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"ProgressBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgressBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimationController_put_ProgressBehavior(py::wrapper::Microsoft::UI::Composition::AnimationController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"ProgressBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationControllerProgressBehavior>(arg);

            self->obj.ProgressBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimationController_get_Progress(py::wrapper::Microsoft::UI::Composition::AnimationController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimationController_put_Progress(py::wrapper::Microsoft::UI::Composition::AnimationController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimationController_get_PlaybackRate(py::wrapper::Microsoft::UI::Composition::AnimationController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"PlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimationController_put_PlaybackRate(py::wrapper::Microsoft::UI::Composition::AnimationController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"PlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AnimationController_get_MaxPlaybackRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"MaxPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Composition::AnimationController::MaxPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnimationController_get_MinPlaybackRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationController", L"MinPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Composition::AnimationController::MinPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnimationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::AnimationController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::AnimationController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimationController[] = {
        { "pause", reinterpret_cast<PyCFunction>(AnimationController_Pause), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(AnimationController_Resume), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimationController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimationController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnimationController[] = {
        { "progress_behavior", reinterpret_cast<getter>(AnimationController_get_ProgressBehavior), reinterpret_cast<setter>(AnimationController_put_ProgressBehavior), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(AnimationController_get_Progress), reinterpret_cast<setter>(AnimationController_put_Progress), nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(AnimationController_get_PlaybackRate), reinterpret_cast<setter>(AnimationController_put_PlaybackRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AnimationController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimationController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimationController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimationController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimationController) },
        { }
    };

    static PyType_Spec type_spec_AnimationController = {
        "winrt._winrt_microsoft_ui_composition.AnimationController",
        sizeof(py::wrapper::Microsoft::UI::Composition::AnimationController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimationController};

    static PyGetSetDef getset_AnimationController_Static[] = {
        { "max_playback_rate", reinterpret_cast<getter>(AnimationController_get_MaxPlaybackRate), nullptr, nullptr, nullptr },
        { "min_playback_rate", reinterpret_cast<getter>(AnimationController_get_MinPlaybackRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AnimationController_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AnimationController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnimationController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnimationController_Static) },
        { }
    };

    static PyType_Spec type_spec_AnimationController_Static =
    {
        "winrt._winrt_microsoft_ui_composition.AnimationController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AnimationController_Static
    };

    // ----- AnimationPropertyInfo class --------------------

    static PyObject* _new_AnimationPropertyInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AnimationPropertyInfo(py::wrapper::Microsoft::UI::Composition::AnimationPropertyInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnimationPropertyInfo_GetResolvedCompositionObject(py::wrapper::Microsoft::UI::Composition::AnimationPropertyInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.AnimationPropertyInfo", L"GetResolvedCompositionObject", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResolvedCompositionObject());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimationPropertyInfo_GetResolvedCompositionObjectProperty(py::wrapper::Microsoft::UI::Composition::AnimationPropertyInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.AnimationPropertyInfo", L"GetResolvedCompositionObjectProperty", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResolvedCompositionObjectProperty());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnimationPropertyInfo_get_AccessMode(py::wrapper::Microsoft::UI::Composition::AnimationPropertyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationPropertyInfo", L"AccessMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccessMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AnimationPropertyInfo_put_AccessMode(py::wrapper::Microsoft::UI::Composition::AnimationPropertyInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.AnimationPropertyInfo", L"AccessMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationPropertyAccessMode>(arg);

            self->obj.AccessMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AnimationPropertyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimationPropertyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimationPropertyInfo[] = {
        { "get_resolved_composition_object", reinterpret_cast<PyCFunction>(AnimationPropertyInfo_GetResolvedCompositionObject), METH_VARARGS, nullptr },
        { "get_resolved_composition_object_property", reinterpret_cast<PyCFunction>(AnimationPropertyInfo_GetResolvedCompositionObjectProperty), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AnimationPropertyInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimationPropertyInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnimationPropertyInfo[] = {
        { "access_mode", reinterpret_cast<getter>(AnimationPropertyInfo_get_AccessMode), reinterpret_cast<setter>(AnimationPropertyInfo_put_AccessMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AnimationPropertyInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimationPropertyInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimationPropertyInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimationPropertyInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimationPropertyInfo) },
        { }
    };

    static PyType_Spec type_spec_AnimationPropertyInfo = {
        "winrt._winrt_microsoft_ui_composition.AnimationPropertyInfo",
        sizeof(py::wrapper::Microsoft::UI::Composition::AnimationPropertyInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimationPropertyInfo};

    // ----- BackEasingFunction class --------------------

    static PyObject* _new_BackEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::BackEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::BackEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_BackEasingFunction(py::wrapper::Microsoft::UI::Composition::BackEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackEasingFunction_get_Amplitude(py::wrapper::Microsoft::UI::Composition::BackEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BackEasingFunction", L"Amplitude");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Amplitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::BackEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BackEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::BackEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::BackEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackEasingFunction[] = {
        { "_assign_array_", _assign_array_BackEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackEasingFunction[] = {
        { "amplitude", reinterpret_cast<getter>(BackEasingFunction_get_Amplitude), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(BackEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_BackEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.BackEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::BackEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackEasingFunction};

    // ----- BooleanKeyFrameAnimation class --------------------

    static PyObject* _new_BooleanKeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::BooleanKeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::BooleanKeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_BooleanKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::BooleanKeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BooleanKeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::BooleanKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.BooleanKeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BooleanKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::BooleanKeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BooleanKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::BooleanKeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BooleanKeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(BooleanKeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BooleanKeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BooleanKeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BooleanKeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_BooleanKeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BooleanKeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BooleanKeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BooleanKeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BooleanKeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_BooleanKeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.BooleanKeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::BooleanKeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BooleanKeyFrameAnimation};

    // ----- BounceEasingFunction class --------------------

    static PyObject* _new_BounceEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::BounceEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::BounceEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_BounceEasingFunction(py::wrapper::Microsoft::UI::Composition::BounceEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BounceEasingFunction_get_Bounces(py::wrapper::Microsoft::UI::Composition::BounceEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceEasingFunction", L"Bounces");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bounces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BounceEasingFunction_get_Bounciness(py::wrapper::Microsoft::UI::Composition::BounceEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceEasingFunction", L"Bounciness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bounciness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BounceEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::BounceEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BounceEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::BounceEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BounceEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::BounceEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BounceEasingFunction[] = {
        { "_assign_array_", _assign_array_BounceEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BounceEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BounceEasingFunction[] = {
        { "bounces", reinterpret_cast<getter>(BounceEasingFunction_get_Bounces), nullptr, nullptr, nullptr },
        { "bounciness", reinterpret_cast<getter>(BounceEasingFunction_get_Bounciness), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(BounceEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BounceEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BounceEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BounceEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BounceEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BounceEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_BounceEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.BounceEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::BounceEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BounceEasingFunction};

    // ----- BounceScalarNaturalMotionAnimation class --------------------

    static PyObject* _new_BounceScalarNaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_BounceScalarNaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BounceScalarNaturalMotionAnimation_get_Restitution(py::wrapper::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceScalarNaturalMotionAnimation", L"Restitution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Restitution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceScalarNaturalMotionAnimation_put_Restitution(py::wrapper::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceScalarNaturalMotionAnimation", L"Restitution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Restitution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BounceScalarNaturalMotionAnimation_get_Acceleration(py::wrapper::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceScalarNaturalMotionAnimation", L"Acceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Acceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceScalarNaturalMotionAnimation_put_Acceleration(py::wrapper::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceScalarNaturalMotionAnimation", L"Acceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Acceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BounceScalarNaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BounceScalarNaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BounceScalarNaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_BounceScalarNaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BounceScalarNaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BounceScalarNaturalMotionAnimation[] = {
        { "restitution", reinterpret_cast<getter>(BounceScalarNaturalMotionAnimation_get_Restitution), reinterpret_cast<setter>(BounceScalarNaturalMotionAnimation_put_Restitution), nullptr, nullptr },
        { "acceleration", reinterpret_cast<getter>(BounceScalarNaturalMotionAnimation_get_Acceleration), reinterpret_cast<setter>(BounceScalarNaturalMotionAnimation_put_Acceleration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BounceScalarNaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BounceScalarNaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BounceScalarNaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BounceScalarNaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BounceScalarNaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_BounceScalarNaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.BounceScalarNaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::BounceScalarNaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BounceScalarNaturalMotionAnimation};

    // ----- BounceVector2NaturalMotionAnimation class --------------------

    static PyObject* _new_BounceVector2NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_BounceVector2NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BounceVector2NaturalMotionAnimation_get_Restitution(py::wrapper::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector2NaturalMotionAnimation", L"Restitution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Restitution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceVector2NaturalMotionAnimation_put_Restitution(py::wrapper::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector2NaturalMotionAnimation", L"Restitution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Restitution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BounceVector2NaturalMotionAnimation_get_Acceleration(py::wrapper::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector2NaturalMotionAnimation", L"Acceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Acceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceVector2NaturalMotionAnimation_put_Acceleration(py::wrapper::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector2NaturalMotionAnimation", L"Acceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Acceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BounceVector2NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BounceVector2NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BounceVector2NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_BounceVector2NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BounceVector2NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BounceVector2NaturalMotionAnimation[] = {
        { "restitution", reinterpret_cast<getter>(BounceVector2NaturalMotionAnimation_get_Restitution), reinterpret_cast<setter>(BounceVector2NaturalMotionAnimation_put_Restitution), nullptr, nullptr },
        { "acceleration", reinterpret_cast<getter>(BounceVector2NaturalMotionAnimation_get_Acceleration), reinterpret_cast<setter>(BounceVector2NaturalMotionAnimation_put_Acceleration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BounceVector2NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BounceVector2NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BounceVector2NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BounceVector2NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BounceVector2NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_BounceVector2NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.BounceVector2NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::BounceVector2NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BounceVector2NaturalMotionAnimation};

    // ----- BounceVector3NaturalMotionAnimation class --------------------

    static PyObject* _new_BounceVector3NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_BounceVector3NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BounceVector3NaturalMotionAnimation_get_Restitution(py::wrapper::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector3NaturalMotionAnimation", L"Restitution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Restitution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceVector3NaturalMotionAnimation_put_Restitution(py::wrapper::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector3NaturalMotionAnimation", L"Restitution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Restitution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BounceVector3NaturalMotionAnimation_get_Acceleration(py::wrapper::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector3NaturalMotionAnimation", L"Acceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Acceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceVector3NaturalMotionAnimation_put_Acceleration(py::wrapper::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.BounceVector3NaturalMotionAnimation", L"Acceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Acceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BounceVector3NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BounceVector3NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BounceVector3NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_BounceVector3NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BounceVector3NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BounceVector3NaturalMotionAnimation[] = {
        { "restitution", reinterpret_cast<getter>(BounceVector3NaturalMotionAnimation_get_Restitution), reinterpret_cast<setter>(BounceVector3NaturalMotionAnimation_put_Restitution), nullptr, nullptr },
        { "acceleration", reinterpret_cast<getter>(BounceVector3NaturalMotionAnimation_get_Acceleration), reinterpret_cast<setter>(BounceVector3NaturalMotionAnimation_put_Acceleration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BounceVector3NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BounceVector3NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BounceVector3NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BounceVector3NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BounceVector3NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_BounceVector3NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.BounceVector3NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::BounceVector3NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BounceVector3NaturalMotionAnimation};

    // ----- CircleEasingFunction class --------------------

    static PyObject* _new_CircleEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CircleEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CircleEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_CircleEasingFunction(py::wrapper::Microsoft::UI::Composition::CircleEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CircleEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::CircleEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CircleEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CircleEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CircleEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CircleEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CircleEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CircleEasingFunction[] = {
        { "_assign_array_", _assign_array_CircleEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CircleEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CircleEasingFunction[] = {
        { "mode", reinterpret_cast<getter>(CircleEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CircleEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CircleEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CircleEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CircleEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CircleEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_CircleEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.CircleEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::CircleEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CircleEasingFunction};

    // ----- ColorKeyFrameAnimation class --------------------

    static PyObject* _new_ColorKeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ColorKeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ColorKeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_ColorKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::ColorKeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorKeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::ColorKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ColorKeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::ColorKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ColorKeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameAnimation_get_InterpolationColorSpace(py::wrapper::Microsoft::UI::Composition::ColorKeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ColorKeyFrameAnimation", L"InterpolationColorSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InterpolationColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorKeyFrameAnimation_put_InterpolationColorSpace(py::wrapper::Microsoft::UI::Composition::ColorKeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ColorKeyFrameAnimation", L"InterpolationColorSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorSpace>(arg);

            self->obj.InterpolationColorSpace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ColorKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ColorKeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ColorKeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorKeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(ColorKeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(ColorKeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ColorKeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorKeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorKeyFrameAnimation[] = {
        { "interpolation_color_space", reinterpret_cast<getter>(ColorKeyFrameAnimation_get_InterpolationColorSpace), reinterpret_cast<setter>(ColorKeyFrameAnimation_put_InterpolationColorSpace), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorKeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorKeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorKeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorKeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorKeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_ColorKeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.ColorKeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::ColorKeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorKeyFrameAnimation};

    // ----- CompositionAnimation class --------------------

    static PyObject* _new_CompositionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionAnimation(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionAnimation_ClearAllParameters(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"ClearAllParameters", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().ClearAllParameters();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_ClearParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"ClearParameter", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().ClearParameter(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetBooleanParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetBooleanParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetBooleanParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetColorParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetColorParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetColorParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetExpressionReferenceParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetExpressionReferenceParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::IAnimationObject>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetExpressionReferenceParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetMatrix3x2Parameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetMatrix3x2Parameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetMatrix3x2Parameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetMatrix4x4Parameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetMatrix4x4Parameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetMatrix4x4Parameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetQuaternionParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetQuaternionParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetQuaternionParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetReferenceParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetReferenceParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionObject>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetReferenceParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetScalarParameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetScalarParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetScalarParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetVector2Parameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetVector2Parameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetVector2Parameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetVector3Parameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetVector3Parameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetVector3Parameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_SetVector4Parameter(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"SetVector4Parameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().SetVector4Parameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimation_get_Target(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionAnimation_put_Target(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().Target(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionAnimation_get_InitialValueExpressions(py::wrapper::Microsoft::UI::Composition::CompositionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionAnimation", L"InitialValueExpressions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionAnimation>().InitialValueExpressions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionAnimation[] = {
        { "clear_all_parameters", reinterpret_cast<PyCFunction>(CompositionAnimation_ClearAllParameters), METH_VARARGS, nullptr },
        { "clear_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_ClearParameter), METH_VARARGS, nullptr },
        { "set_boolean_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetBooleanParameter), METH_VARARGS, nullptr },
        { "set_color_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetColorParameter), METH_VARARGS, nullptr },
        { "set_expression_reference_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetExpressionReferenceParameter), METH_VARARGS, nullptr },
        { "set_matrix3x2_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetMatrix3x2Parameter), METH_VARARGS, nullptr },
        { "set_matrix4x4_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetMatrix4x4Parameter), METH_VARARGS, nullptr },
        { "set_quaternion_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetQuaternionParameter), METH_VARARGS, nullptr },
        { "set_reference_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetReferenceParameter), METH_VARARGS, nullptr },
        { "set_scalar_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetScalarParameter), METH_VARARGS, nullptr },
        { "set_vector2_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetVector2Parameter), METH_VARARGS, nullptr },
        { "set_vector3_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetVector3Parameter), METH_VARARGS, nullptr },
        { "set_vector4_parameter", reinterpret_cast<PyCFunction>(CompositionAnimation_SetVector4Parameter), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionAnimation[] = {
        { "target", reinterpret_cast<getter>(CompositionAnimation_get_Target), reinterpret_cast<setter>(CompositionAnimation_put_Target), nullptr, nullptr },
        { "initial_value_expressions", reinterpret_cast<getter>(CompositionAnimation_get_InitialValueExpressions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionAnimation) },
        { }
    };

    static PyType_Spec type_spec_CompositionAnimation = {
        "winrt._winrt_microsoft_ui_composition.CompositionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionAnimation),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionAnimation};

    static PyGetSetDef getset_CompositionAnimation_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionAnimation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionAnimation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionAnimation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionAnimation_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionAnimation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionAnimation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionAnimation_Static
    };

    // ----- CompositionAnimationGroup class --------------------

    static PyObject* _new_CompositionAnimationGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionAnimationGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionAnimationGroup>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionAnimationGroup(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionAnimationGroup_Add(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimationGroup", L"Add", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimationGroup_First(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimationGroup", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimationGroup_Remove(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimationGroup", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimationGroup_RemoveAll(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionAnimationGroup", L"RemoveAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionAnimationGroup_get_Count(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionAnimationGroup", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Count());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionAnimationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionAnimationGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionAnimationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionAnimationGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionAnimationGroup(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionAnimationGroup[] = {
        { "add", reinterpret_cast<PyCFunction>(CompositionAnimationGroup_Add), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionAnimationGroup_First), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(CompositionAnimationGroup_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(CompositionAnimationGroup_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionAnimationGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionAnimationGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionAnimationGroup[] = {
        { "count", reinterpret_cast<getter>(CompositionAnimationGroup_get_Count), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionAnimationGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionAnimationGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionAnimationGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionAnimationGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionAnimationGroup) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionAnimationGroup) },
        { }
    };

    static PyType_Spec type_spec_CompositionAnimationGroup = {
        "winrt._winrt_microsoft_ui_composition.CompositionAnimationGroup",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionAnimationGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionAnimationGroup};

    // ----- CompositionApiInformation class --------------------

    static PyObject* _new_CompositionApiInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionApiInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionApiInformation>::type_name);
        return nullptr;
    }

    static PyObject* CompositionApiInformation_get_ApiVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionApiInformation", L"ApiVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Composition::CompositionApiInformation::ApiVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionApiInformation[] = {
        { }
    };

    static PyGetSetDef _getset_CompositionApiInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionApiInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionApiInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionApiInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionApiInformation) },
        { }
    };

    static PyType_Spec type_spec_CompositionApiInformation = {
        "winrt._winrt_microsoft_ui_composition.CompositionApiInformation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionApiInformation};

    static PyGetSetDef getset_CompositionApiInformation_Static[] = {
        { "api_version", reinterpret_cast<getter>(CompositionApiInformation_get_ApiVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CompositionApiInformation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionApiInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionApiInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionApiInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionApiInformation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionApiInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositionApiInformation_Static
    };

    // ----- CompositionBackdropBrush class --------------------

    static PyObject* _new_CompositionBackdropBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionBackdropBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionBackdropBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionBackdropBrush(py::wrapper::Microsoft::UI::Composition::CompositionBackdropBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CompositionBackdropBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionBackdropBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionBackdropBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionBackdropBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionBackdropBrush[] = {
        { "_assign_array_", _assign_array_CompositionBackdropBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionBackdropBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionBackdropBrush[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionBackdropBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionBackdropBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionBackdropBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionBackdropBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionBackdropBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionBackdropBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionBackdropBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionBackdropBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionBackdropBrush};

    // ----- CompositionBatchCompletedEventArgs class --------------------

    static PyObject* _new_CompositionBatchCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionBatchCompletedEventArgs(py::wrapper::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CompositionBatchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionBatchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionBatchCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_CompositionBatchCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionBatchCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionBatchCompletedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionBatchCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionBatchCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionBatchCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionBatchCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionBatchCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CompositionBatchCompletedEventArgs = {
        "winrt._winrt_microsoft_ui_composition.CompositionBatchCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionBatchCompletedEventArgs};

    // ----- CompositionBrush class --------------------

    static PyObject* _new_CompositionBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionBrush(py::wrapper::Microsoft::UI::Composition::CompositionBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CompositionBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionBrush[] = {
        { "_assign_array_", _assign_array_CompositionBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionBrush[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionBrush};

    static PyGetSetDef getset_CompositionBrush_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionBrush_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionBrush_Static
    };

    // ----- CompositionCapabilities class --------------------

    static PyObject* _new_CompositionCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Composition::CompositionCapabilities instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CompositionCapabilities(py::wrapper::Microsoft::UI::Composition::CompositionCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionCapabilities_AreEffectsFast(py::wrapper::Microsoft::UI::Composition::CompositionCapabilities* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionCapabilities", L"AreEffectsFast", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AreEffectsFast());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionCapabilities_AreEffectsSupported(py::wrapper::Microsoft::UI::Composition::CompositionCapabilities* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionCapabilities", L"AreEffectsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AreEffectsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionCapabilities_add_Changed(py::wrapper::Microsoft::UI::Composition::CompositionCapabilities* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionCapabilities", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Composition::CompositionCapabilities, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionCapabilities_remove_Changed(py::wrapper::Microsoft::UI::Composition::CompositionCapabilities* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionCapabilities", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionCapabilities[] = {
        { "are_effects_fast", reinterpret_cast<PyCFunction>(CompositionCapabilities_AreEffectsFast), METH_VARARGS, nullptr },
        { "are_effects_supported", reinterpret_cast<PyCFunction>(CompositionCapabilities_AreEffectsSupported), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(CompositionCapabilities_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(CompositionCapabilities_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_CompositionCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionCapabilities[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionCapabilities) },
        { }
    };

    static PyType_Spec type_spec_CompositionCapabilities = {
        "winrt._winrt_microsoft_ui_composition.CompositionCapabilities",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionCapabilities};

    // ----- CompositionClip class --------------------

    static PyObject* _new_CompositionClip(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionClip>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionClip>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionClip(py::wrapper::Microsoft::UI::Composition::CompositionClip* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionClip_get_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionClip_get_Scale(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_Scale(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionClip_get_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().RotationAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().RotationAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionClip_get_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionClip_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionClip_get_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionClip_get_AnchorPoint(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().AnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionClip_put_AnchorPoint(py::wrapper::Microsoft::UI::Composition::CompositionClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionClip", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionClip>().AnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionClip>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionClip>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionClip[] = {
        { "_assign_array_", _assign_array_CompositionClip, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionClip), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionClip[] = {
        { "transform_matrix", reinterpret_cast<getter>(CompositionClip_get_TransformMatrix), reinterpret_cast<setter>(CompositionClip_put_TransformMatrix), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(CompositionClip_get_Scale), reinterpret_cast<setter>(CompositionClip_put_Scale), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(CompositionClip_get_RotationAngleInDegrees), reinterpret_cast<setter>(CompositionClip_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(CompositionClip_get_RotationAngle), reinterpret_cast<setter>(CompositionClip_put_RotationAngle), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionClip_get_Offset), reinterpret_cast<setter>(CompositionClip_put_Offset), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(CompositionClip_get_CenterPoint), reinterpret_cast<setter>(CompositionClip_put_CenterPoint), nullptr, nullptr },
        { "anchor_point", reinterpret_cast<getter>(CompositionClip_get_AnchorPoint), reinterpret_cast<setter>(CompositionClip_put_AnchorPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionClip[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionClip) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionClip) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionClip) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionClip) },
        { }
    };

    static PyType_Spec type_spec_CompositionClip = {
        "winrt._winrt_microsoft_ui_composition.CompositionClip",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionClip),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionClip};

    static PyGetSetDef getset_CompositionClip_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionClip_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionClip_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionClip_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionClip_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionClip_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionClip_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionClip_Static
    };

    // ----- CompositionColorBrush class --------------------

    static PyObject* _new_CompositionColorBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionColorBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionColorBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionColorBrush(py::wrapper::Microsoft::UI::Composition::CompositionColorBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionColorBrush_get_Color(py::wrapper::Microsoft::UI::Composition::CompositionColorBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorBrush", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionColorBrush_put_Color(py::wrapper::Microsoft::UI::Composition::CompositionColorBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorBrush", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionColorBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionColorBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionColorBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionColorBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionColorBrush[] = {
        { "_assign_array_", _assign_array_CompositionColorBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionColorBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionColorBrush[] = {
        { "color", reinterpret_cast<getter>(CompositionColorBrush_get_Color), reinterpret_cast<setter>(CompositionColorBrush_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionColorBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionColorBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionColorBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionColorBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionColorBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionColorBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionColorBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionColorBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionColorBrush};

    // ----- CompositionColorGradientStop class --------------------

    static PyObject* _new_CompositionColorGradientStop(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionColorGradientStop(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionColorGradientStop_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStop* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorGradientStop", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionColorGradientStop_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorGradientStop", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionColorGradientStop_get_Color(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStop* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorGradientStop", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionColorGradientStop_put_Color(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorGradientStop", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionColorGradientStop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionColorGradientStop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionColorGradientStop[] = {
        { "_assign_array_", _assign_array_CompositionColorGradientStop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionColorGradientStop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionColorGradientStop[] = {
        { "offset", reinterpret_cast<getter>(CompositionColorGradientStop_get_Offset), reinterpret_cast<setter>(CompositionColorGradientStop_put_Offset), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(CompositionColorGradientStop_get_Color), reinterpret_cast<setter>(CompositionColorGradientStop_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionColorGradientStop[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionColorGradientStop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionColorGradientStop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionColorGradientStop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionColorGradientStop) },
        { }
    };

    static PyType_Spec type_spec_CompositionColorGradientStop = {
        "winrt._winrt_microsoft_ui_composition.CompositionColorGradientStop",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionColorGradientStop};

    // ----- CompositionColorGradientStopCollection class --------------------

    static PyObject* _new_CompositionColorGradientStopCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionColorGradientStopCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionColorGradientStopCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionColorGradientStopCollection(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionColorGradientStopCollection_Append(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_Clear(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_First(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_GetAt(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_GetMany(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Composition::CompositionColorGradientStop, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_GetView(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_IndexOf(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_InsertAt(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_RemoveAt(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_ReplaceAll(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Composition::CompositionColorGradientStop, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_SetAt(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionColorGradientStopCollection_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionColorGradientStopCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionColorGradientStopCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionColorGradientStopCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionColorGradientStopCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionColorGradientStopCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionColorGradientStopCollection(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_CompositionColorGradientStopCollection(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_CompositionColorGradientStopCollection(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_CompositionColorGradientStopCollection(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_CompositionColorGradientStopCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Composition::CompositionColorGradientStop> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_CompositionColorGradientStopCollection(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorGradientStop>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_CompositionColorGradientStopCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(CompositionColorGradientStopCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionColorGradientStopCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionColorGradientStopCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionColorGradientStopCollection[] = {
        { "size", reinterpret_cast<getter>(CompositionColorGradientStopCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionColorGradientStopCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionColorGradientStopCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionColorGradientStopCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionColorGradientStopCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionColorGradientStopCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionColorGradientStopCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_CompositionColorGradientStopCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_CompositionColorGradientStopCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_CompositionColorGradientStopCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_CompositionColorGradientStopCollection) },
        { }
    };

    static PyType_Spec type_spec_CompositionColorGradientStopCollection = {
        "winrt._winrt_microsoft_ui_composition.CompositionColorGradientStopCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionColorGradientStopCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionColorGradientStopCollection};

    // ----- CompositionCommitBatch class --------------------

    static PyObject* _new_CompositionCommitBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionCommitBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionCommitBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionCommitBatch(py::wrapper::Microsoft::UI::Composition::CompositionCommitBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionCommitBatch_get_IsActive(py::wrapper::Microsoft::UI::Composition::CompositionCommitBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionCommitBatch", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionCommitBatch_get_IsEnded(py::wrapper::Microsoft::UI::Composition::CompositionCommitBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionCommitBatch", L"IsEnded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionCommitBatch_add_Completed(py::wrapper::Microsoft::UI::Composition::CompositionCommitBatch* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionCommitBatch", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionCommitBatch_remove_Completed(py::wrapper::Microsoft::UI::Composition::CompositionCommitBatch* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionCommitBatch", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionCommitBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionCommitBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionCommitBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionCommitBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionCommitBatch[] = {
        { "add_completed", reinterpret_cast<PyCFunction>(CompositionCommitBatch_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(CompositionCommitBatch_remove_Completed), METH_O, nullptr },
        { "_assign_array_", _assign_array_CompositionCommitBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionCommitBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionCommitBatch[] = {
        { "is_active", reinterpret_cast<getter>(CompositionCommitBatch_get_IsActive), nullptr, nullptr, nullptr },
        { "is_ended", reinterpret_cast<getter>(CompositionCommitBatch_get_IsEnded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionCommitBatch[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionCommitBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionCommitBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionCommitBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionCommitBatch) },
        { }
    };

    static PyType_Spec type_spec_CompositionCommitBatch = {
        "winrt._winrt_microsoft_ui_composition.CompositionCommitBatch",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionCommitBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionCommitBatch};

    // ----- CompositionContainerShape class --------------------

    static PyObject* _new_CompositionContainerShape(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionContainerShape>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionContainerShape>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionContainerShape(py::wrapper::Microsoft::UI::Composition::CompositionContainerShape* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionContainerShape_get_Shapes(py::wrapper::Microsoft::UI::Composition::CompositionContainerShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionContainerShape", L"Shapes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shapes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionContainerShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionContainerShape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionContainerShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionContainerShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionContainerShape[] = {
        { "_assign_array_", _assign_array_CompositionContainerShape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionContainerShape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionContainerShape[] = {
        { "shapes", reinterpret_cast<getter>(CompositionContainerShape_get_Shapes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionContainerShape[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionContainerShape) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionContainerShape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionContainerShape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionContainerShape) },
        { }
    };

    static PyType_Spec type_spec_CompositionContainerShape = {
        "winrt._winrt_microsoft_ui_composition.CompositionContainerShape",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionContainerShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionContainerShape};

    // ----- CompositionDrawingSurface class --------------------

    static PyObject* _new_CompositionDrawingSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionDrawingSurface(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionDrawingSurface_Resize(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"Resize", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().Resize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_Scroll(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"Scroll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().Scroll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_ScrollRect(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_ScrollRectWithClip(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"ScrollWithClip", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 2);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().ScrollWithClip(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_ScrollWithClip(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"ScrollWithClip", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().ScrollWithClip(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_get_AlphaMode(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"AlphaMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().AlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_get_PixelFormat(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"PixelFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().PixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionDrawingSurface_get_SizeInt32(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionDrawingSurface", L"SizeInt32");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>().SizeInt32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionDrawingSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionDrawingSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionDrawingSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionDrawingSurface[] = {
        { "resize", reinterpret_cast<PyCFunction>(CompositionDrawingSurface_Resize), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(CompositionDrawingSurface_Scroll), METH_VARARGS, nullptr },
        { "scroll_rect", reinterpret_cast<PyCFunction>(CompositionDrawingSurface_ScrollRect), METH_VARARGS, nullptr },
        { "scroll_rect_with_clip", reinterpret_cast<PyCFunction>(CompositionDrawingSurface_ScrollRectWithClip), METH_VARARGS, nullptr },
        { "scroll_with_clip", reinterpret_cast<PyCFunction>(CompositionDrawingSurface_ScrollWithClip), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionDrawingSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionDrawingSurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionDrawingSurface[] = {
        { "alpha_mode", reinterpret_cast<getter>(CompositionDrawingSurface_get_AlphaMode), nullptr, nullptr, nullptr },
        { "pixel_format", reinterpret_cast<getter>(CompositionDrawingSurface_get_PixelFormat), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(CompositionDrawingSurface_get_Size), nullptr, nullptr, nullptr },
        { "size_int32", reinterpret_cast<getter>(CompositionDrawingSurface_get_SizeInt32), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionDrawingSurface[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionDrawingSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionDrawingSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionDrawingSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionDrawingSurface) },
        { }
    };

    static PyType_Spec type_spec_CompositionDrawingSurface = {
        "winrt._winrt_microsoft_ui_composition.CompositionDrawingSurface",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionDrawingSurface),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionDrawingSurface};

    static PyGetSetDef getset_CompositionDrawingSurface_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionDrawingSurface_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionDrawingSurface_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionDrawingSurface_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionDrawingSurface_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionDrawingSurface_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionDrawingSurface_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionDrawingSurface_Static
    };

    // ----- CompositionEasingFunction class --------------------

    static PyObject* _new_CompositionEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionEasingFunction(py::wrapper::Microsoft::UI::Composition::CompositionEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionEasingFunction_CreateBackEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateBackEasingFunction", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateBackEasingFunction(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateBounceEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateBounceEasingFunction", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateBounceEasingFunction(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateCircleEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateCircleEasingFunction", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateCircleEasingFunction(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateCubicBezierEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateCubicBezierEasingFunction", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 2);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateCubicBezierEasingFunction(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateElasticEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateElasticEasingFunction", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateElasticEasingFunction(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateExponentialEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateExponentialEasingFunction", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateExponentialEasingFunction(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateLinearEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateLinearEasingFunction", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateLinearEasingFunction(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreatePowerEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreatePowerEasingFunction", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreatePowerEasingFunction(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateSineEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateSineEasingFunction", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunctionMode>(args, 1);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateSineEasingFunction(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateStepEasingFunction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateStepEasingFunction", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateStepEasingFunction(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEasingFunction_CreateStepEasingFunctionWithStepCount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEasingFunction", L"CreateStepEasingFunction", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Microsoft::UI::Composition::CompositionEasingFunction::CreateStepEasingFunction(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionEasingFunction[] = {
        { "_assign_array_", _assign_array_CompositionEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionEasingFunction[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_CompositionEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.CompositionEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionEasingFunction};

    static PyGetSetDef getset_CompositionEasingFunction_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionEasingFunction_Static[] = {
        { "create_back_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateBackEasingFunction), METH_VARARGS, nullptr },
        { "create_bounce_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateBounceEasingFunction), METH_VARARGS, nullptr },
        { "create_circle_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateCircleEasingFunction), METH_VARARGS, nullptr },
        { "create_cubic_bezier_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateCubicBezierEasingFunction), METH_VARARGS, nullptr },
        { "create_elastic_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateElasticEasingFunction), METH_VARARGS, nullptr },
        { "create_exponential_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateExponentialEasingFunction), METH_VARARGS, nullptr },
        { "create_linear_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateLinearEasingFunction), METH_VARARGS, nullptr },
        { "create_power_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreatePowerEasingFunction), METH_VARARGS, nullptr },
        { "create_sine_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateSineEasingFunction), METH_VARARGS, nullptr },
        { "create_step_easing_function", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateStepEasingFunction), METH_VARARGS, nullptr },
        { "create_step_easing_function_with_step_count", reinterpret_cast<PyCFunction>(CompositionEasingFunction_CreateStepEasingFunctionWithStepCount), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CompositionEasingFunction_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionEasingFunction_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionEasingFunction_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionEasingFunction_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionEasingFunction_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionEasingFunction_Static
    };

    // ----- CompositionEffectBrush class --------------------

    static PyObject* _new_CompositionEffectBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionEffectBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionEffectBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionEffectBrush(py::wrapper::Microsoft::UI::Composition::CompositionEffectBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionEffectBrush_GetSourceParameter(py::wrapper::Microsoft::UI::Composition::CompositionEffectBrush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEffectBrush", L"GetSourceParameter", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSourceParameter(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEffectBrush_SetSourceParameter(py::wrapper::Microsoft::UI::Composition::CompositionEffectBrush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEffectBrush", L"SetSourceParameter", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(args, 1);

                self->obj.SetSourceParameter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionEffectBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionEffectBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionEffectBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionEffectBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionEffectBrush[] = {
        { "get_source_parameter", reinterpret_cast<PyCFunction>(CompositionEffectBrush_GetSourceParameter), METH_VARARGS, nullptr },
        { "set_source_parameter", reinterpret_cast<PyCFunction>(CompositionEffectBrush_SetSourceParameter), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionEffectBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionEffectBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionEffectBrush[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionEffectBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionEffectBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionEffectBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionEffectBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionEffectBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionEffectBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionEffectBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionEffectBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionEffectBrush};

    // ----- CompositionEffectFactory class --------------------

    static PyObject* _new_CompositionEffectFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionEffectFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionEffectFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionEffectFactory(py::wrapper::Microsoft::UI::Composition::CompositionEffectFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionEffectFactory_CreateBrush(py::wrapper::Microsoft::UI::Composition::CompositionEffectFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionEffectFactory", L"CreateBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionEffectFactory_get_ExtendedError(py::wrapper::Microsoft::UI::Composition::CompositionEffectFactory* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEffectFactory", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionEffectFactory_get_LoadStatus(py::wrapper::Microsoft::UI::Composition::CompositionEffectFactory* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEffectFactory", L"LoadStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LoadStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionEffectFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionEffectFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionEffectFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionEffectFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionEffectFactory[] = {
        { "create_brush", reinterpret_cast<PyCFunction>(CompositionEffectFactory_CreateBrush), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionEffectFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionEffectFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionEffectFactory[] = {
        { "extended_error", reinterpret_cast<getter>(CompositionEffectFactory_get_ExtendedError), nullptr, nullptr, nullptr },
        { "load_status", reinterpret_cast<getter>(CompositionEffectFactory_get_LoadStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionEffectFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionEffectFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionEffectFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionEffectFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionEffectFactory) },
        { }
    };

    static PyType_Spec type_spec_CompositionEffectFactory = {
        "winrt._winrt_microsoft_ui_composition.CompositionEffectFactory",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionEffectFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionEffectFactory};

    // ----- CompositionEffectSourceParameter class --------------------

    static PyObject* _new_CompositionEffectSourceParameter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::UI::Composition::CompositionEffectSourceParameter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CompositionEffectSourceParameter(py::wrapper::Microsoft::UI::Composition::CompositionEffectSourceParameter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionEffectSourceParameter_get_Name(py::wrapper::Microsoft::UI::Composition::CompositionEffectSourceParameter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEffectSourceParameter", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionEffectSourceParameter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionEffectSourceParameter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionEffectSourceParameter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionEffectSourceParameter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionEffectSourceParameter[] = {
        { "_assign_array_", _assign_array_CompositionEffectSourceParameter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionEffectSourceParameter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionEffectSourceParameter[] = {
        { "name", reinterpret_cast<getter>(CompositionEffectSourceParameter_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionEffectSourceParameter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionEffectSourceParameter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionEffectSourceParameter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionEffectSourceParameter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionEffectSourceParameter) },
        { }
    };

    static PyType_Spec type_spec_CompositionEffectSourceParameter = {
        "winrt._winrt_microsoft_ui_composition.CompositionEffectSourceParameter",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionEffectSourceParameter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionEffectSourceParameter};

    // ----- CompositionEllipseGeometry class --------------------

    static PyObject* _new_CompositionEllipseGeometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionEllipseGeometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionEllipseGeometry>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionEllipseGeometry(py::wrapper::Microsoft::UI::Composition::CompositionEllipseGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionEllipseGeometry_get_Radius(py::wrapper::Microsoft::UI::Composition::CompositionEllipseGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEllipseGeometry", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Radius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionEllipseGeometry_put_Radius(py::wrapper::Microsoft::UI::Composition::CompositionEllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEllipseGeometry", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Radius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionEllipseGeometry_get_Center(py::wrapper::Microsoft::UI::Composition::CompositionEllipseGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEllipseGeometry", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionEllipseGeometry_put_Center(py::wrapper::Microsoft::UI::Composition::CompositionEllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionEllipseGeometry", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionEllipseGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionEllipseGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionEllipseGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionEllipseGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionEllipseGeometry[] = {
        { "_assign_array_", _assign_array_CompositionEllipseGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionEllipseGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionEllipseGeometry[] = {
        { "radius", reinterpret_cast<getter>(CompositionEllipseGeometry_get_Radius), reinterpret_cast<setter>(CompositionEllipseGeometry_put_Radius), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(CompositionEllipseGeometry_get_Center), reinterpret_cast<setter>(CompositionEllipseGeometry_put_Center), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionEllipseGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionEllipseGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionEllipseGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionEllipseGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionEllipseGeometry) },
        { }
    };

    static PyType_Spec type_spec_CompositionEllipseGeometry = {
        "winrt._winrt_microsoft_ui_composition.CompositionEllipseGeometry",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionEllipseGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionEllipseGeometry};

    // ----- CompositionGeometricClip class --------------------

    static PyObject* _new_CompositionGeometricClip(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionGeometricClip>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionGeometricClip>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionGeometricClip(py::wrapper::Microsoft::UI::Composition::CompositionGeometricClip* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionGeometricClip_get_ViewBox(py::wrapper::Microsoft::UI::Composition::CompositionGeometricClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometricClip", L"ViewBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewBox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGeometricClip_put_ViewBox(py::wrapper::Microsoft::UI::Composition::CompositionGeometricClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometricClip", L"ViewBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionViewBox>(arg);

            self->obj.ViewBox(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGeometricClip_get_Geometry(py::wrapper::Microsoft::UI::Composition::CompositionGeometricClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometricClip", L"Geometry");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Geometry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGeometricClip_put_Geometry(py::wrapper::Microsoft::UI::Composition::CompositionGeometricClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometricClip", L"Geometry");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionGeometry>(arg);

            self->obj.Geometry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionGeometricClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionGeometricClip>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionGeometricClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionGeometricClip>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionGeometricClip[] = {
        { "_assign_array_", _assign_array_CompositionGeometricClip, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionGeometricClip), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionGeometricClip[] = {
        { "view_box", reinterpret_cast<getter>(CompositionGeometricClip_get_ViewBox), reinterpret_cast<setter>(CompositionGeometricClip_put_ViewBox), nullptr, nullptr },
        { "geometry", reinterpret_cast<getter>(CompositionGeometricClip_get_Geometry), reinterpret_cast<setter>(CompositionGeometricClip_put_Geometry), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionGeometricClip[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionGeometricClip) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionGeometricClip) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionGeometricClip) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionGeometricClip) },
        { }
    };

    static PyType_Spec type_spec_CompositionGeometricClip = {
        "winrt._winrt_microsoft_ui_composition.CompositionGeometricClip",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionGeometricClip),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionGeometricClip};

    // ----- CompositionGeometry class --------------------

    static PyObject* _new_CompositionGeometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionGeometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionGeometry>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionGeometry(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionGeometry_get_TrimStart(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometry", L"TrimStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGeometry>().TrimStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGeometry_put_TrimStart(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometry", L"TrimStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGeometry>().TrimStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGeometry_get_TrimOffset(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometry", L"TrimOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGeometry>().TrimOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGeometry_put_TrimOffset(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometry", L"TrimOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGeometry>().TrimOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGeometry_get_TrimEnd(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometry", L"TrimEnd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGeometry>().TrimEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGeometry_put_TrimEnd(py::wrapper::Microsoft::UI::Composition::CompositionGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGeometry", L"TrimEnd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGeometry>().TrimEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionGeometry[] = {
        { "_assign_array_", _assign_array_CompositionGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionGeometry[] = {
        { "trim_start", reinterpret_cast<getter>(CompositionGeometry_get_TrimStart), reinterpret_cast<setter>(CompositionGeometry_put_TrimStart), nullptr, nullptr },
        { "trim_offset", reinterpret_cast<getter>(CompositionGeometry_get_TrimOffset), reinterpret_cast<setter>(CompositionGeometry_put_TrimOffset), nullptr, nullptr },
        { "trim_end", reinterpret_cast<getter>(CompositionGeometry_get_TrimEnd), reinterpret_cast<setter>(CompositionGeometry_put_TrimEnd), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionGeometry) },
        { }
    };

    static PyType_Spec type_spec_CompositionGeometry = {
        "winrt._winrt_microsoft_ui_composition.CompositionGeometry",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionGeometry),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionGeometry};

    static PyGetSetDef getset_CompositionGeometry_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionGeometry_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionGeometry_Static
    };

    // ----- CompositionGradientBrush class --------------------

    static PyObject* _new_CompositionGradientBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionGradientBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionGradientBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionGradientBrush(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionGradientBrush_get_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_Scale(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_Scale(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().RotationAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().RotationAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_InterpolationSpace(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"InterpolationSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().InterpolationSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_InterpolationSpace(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"InterpolationSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorSpace>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().InterpolationSpace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_ExtendMode(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"ExtendMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().ExtendMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_ExtendMode(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"ExtendMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionGradientExtendMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().ExtendMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_AnchorPoint(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().AnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_AnchorPoint(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().AnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionGradientBrush_get_ColorStops(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"ColorStops");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().ColorStops());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionGradientBrush_get_MappingMode(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"MappingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().MappingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionGradientBrush_put_MappingMode(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionGradientBrush", L"MappingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionMappingMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>().MappingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionGradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionGradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionGradientBrush[] = {
        { "_assign_array_", _assign_array_CompositionGradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionGradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionGradientBrush[] = {
        { "transform_matrix", reinterpret_cast<getter>(CompositionGradientBrush_get_TransformMatrix), reinterpret_cast<setter>(CompositionGradientBrush_put_TransformMatrix), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(CompositionGradientBrush_get_Scale), reinterpret_cast<setter>(CompositionGradientBrush_put_Scale), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(CompositionGradientBrush_get_RotationAngleInDegrees), reinterpret_cast<setter>(CompositionGradientBrush_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(CompositionGradientBrush_get_RotationAngle), reinterpret_cast<setter>(CompositionGradientBrush_put_RotationAngle), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionGradientBrush_get_Offset), reinterpret_cast<setter>(CompositionGradientBrush_put_Offset), nullptr, nullptr },
        { "interpolation_space", reinterpret_cast<getter>(CompositionGradientBrush_get_InterpolationSpace), reinterpret_cast<setter>(CompositionGradientBrush_put_InterpolationSpace), nullptr, nullptr },
        { "extend_mode", reinterpret_cast<getter>(CompositionGradientBrush_get_ExtendMode), reinterpret_cast<setter>(CompositionGradientBrush_put_ExtendMode), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(CompositionGradientBrush_get_CenterPoint), reinterpret_cast<setter>(CompositionGradientBrush_put_CenterPoint), nullptr, nullptr },
        { "anchor_point", reinterpret_cast<getter>(CompositionGradientBrush_get_AnchorPoint), reinterpret_cast<setter>(CompositionGradientBrush_put_AnchorPoint), nullptr, nullptr },
        { "color_stops", reinterpret_cast<getter>(CompositionGradientBrush_get_ColorStops), nullptr, nullptr, nullptr },
        { "mapping_mode", reinterpret_cast<getter>(CompositionGradientBrush_get_MappingMode), reinterpret_cast<setter>(CompositionGradientBrush_put_MappingMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionGradientBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionGradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionGradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionGradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionGradientBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionGradientBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionGradientBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionGradientBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionGradientBrush};

    static PyGetSetDef getset_CompositionGradientBrush_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionGradientBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionGradientBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionGradientBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionGradientBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionGradientBrush_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionGradientBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionGradientBrush_Static
    };

    // ----- CompositionGraphicsDevice class --------------------

    static PyObject* _new_CompositionGraphicsDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionGraphicsDevice(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionGraphicsDevice_CaptureAsync(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"CaptureAsync", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXPixelFormat>(args, 2);
                auto param3 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXAlphaMode>(args, 3);
                auto param4 = py::convert_to<float>(args, 4);

                return py::convert(self->obj.CaptureAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_CreateDrawingSurface(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"CreateDrawingSurface", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXAlphaMode>(args, 2);

                return py::convert(self->obj.CreateDrawingSurface(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_CreateDrawingSurface2(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"CreateDrawingSurface2", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXAlphaMode>(args, 2);

                return py::convert(self->obj.CreateDrawingSurface2(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_CreateMipmapSurface(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"CreateMipmapSurface", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXAlphaMode>(args, 2);

                return py::convert(self->obj.CreateMipmapSurface(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_CreateVirtualDrawingSurface(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"CreateVirtualDrawingSurface", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Graphics::DirectX::DirectXAlphaMode>(args, 2);

                return py::convert(self->obj.CreateVirtualDrawingSurface(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_Trim(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"Trim", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Trim();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_add_RenderingDeviceReplaced(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"RenderingDeviceReplaced");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice, winrt::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs>>(arg);

            return py::convert(self->obj.RenderingDeviceReplaced(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionGraphicsDevice_remove_RenderingDeviceReplaced(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionGraphicsDevice", L"RenderingDeviceReplaced");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RenderingDeviceReplaced(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionGraphicsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionGraphicsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionGraphicsDevice[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_CaptureAsync), METH_VARARGS, nullptr },
        { "create_drawing_surface", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_CreateDrawingSurface), METH_VARARGS, nullptr },
        { "create_drawing_surface2", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_CreateDrawingSurface2), METH_VARARGS, nullptr },
        { "create_mipmap_surface", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_CreateMipmapSurface), METH_VARARGS, nullptr },
        { "create_virtual_drawing_surface", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_CreateVirtualDrawingSurface), METH_VARARGS, nullptr },
        { "trim", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_Trim), METH_VARARGS, nullptr },
        { "add_rendering_device_replaced", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_add_RenderingDeviceReplaced), METH_O, nullptr },
        { "remove_rendering_device_replaced", reinterpret_cast<PyCFunction>(CompositionGraphicsDevice_remove_RenderingDeviceReplaced), METH_O, nullptr },
        { "_assign_array_", _assign_array_CompositionGraphicsDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionGraphicsDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionGraphicsDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionGraphicsDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionGraphicsDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionGraphicsDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionGraphicsDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionGraphicsDevice) },
        { }
    };

    static PyType_Spec type_spec_CompositionGraphicsDevice = {
        "winrt._winrt_microsoft_ui_composition.CompositionGraphicsDevice",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionGraphicsDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionGraphicsDevice};

    // ----- CompositionLight class --------------------

    static PyObject* _new_CompositionLight(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionLight>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionLight>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionLight(py::wrapper::Microsoft::UI::Composition::CompositionLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionLight_get_Targets(py::wrapper::Microsoft::UI::Composition::CompositionLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLight", L"Targets");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionLight>().Targets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionLight_get_ExclusionsFromTargets(py::wrapper::Microsoft::UI::Composition::CompositionLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLight", L"ExclusionsFromTargets");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionLight>().ExclusionsFromTargets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionLight_get_IsEnabled(py::wrapper::Microsoft::UI::Composition::CompositionLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLight", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionLight>().IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionLight_put_IsEnabled(py::wrapper::Microsoft::UI::Composition::CompositionLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLight", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionLight>().IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionLight[] = {
        { "_assign_array_", _assign_array_CompositionLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionLight[] = {
        { "targets", reinterpret_cast<getter>(CompositionLight_get_Targets), nullptr, nullptr, nullptr },
        { "exclusions_from_targets", reinterpret_cast<getter>(CompositionLight_get_ExclusionsFromTargets), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(CompositionLight_get_IsEnabled), reinterpret_cast<setter>(CompositionLight_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionLight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionLight) },
        { }
    };

    static PyType_Spec type_spec_CompositionLight = {
        "winrt._winrt_microsoft_ui_composition.CompositionLight",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionLight),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionLight};

    static PyGetSetDef getset_CompositionLight_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionLight_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionLight_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionLight_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionLight_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionLight_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionLight_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionLight_Static
    };

    // ----- CompositionLineGeometry class --------------------

    static PyObject* _new_CompositionLineGeometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionLineGeometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionLineGeometry>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionLineGeometry(py::wrapper::Microsoft::UI::Composition::CompositionLineGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionLineGeometry_get_Start(py::wrapper::Microsoft::UI::Composition::CompositionLineGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLineGeometry", L"Start");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Start());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionLineGeometry_put_Start(py::wrapper::Microsoft::UI::Composition::CompositionLineGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLineGeometry", L"Start");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Start(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionLineGeometry_get_End(py::wrapper::Microsoft::UI::Composition::CompositionLineGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLineGeometry", L"End");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.End());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionLineGeometry_put_End(py::wrapper::Microsoft::UI::Composition::CompositionLineGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLineGeometry", L"End");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.End(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionLineGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionLineGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionLineGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionLineGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionLineGeometry[] = {
        { "_assign_array_", _assign_array_CompositionLineGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionLineGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionLineGeometry[] = {
        { "start", reinterpret_cast<getter>(CompositionLineGeometry_get_Start), reinterpret_cast<setter>(CompositionLineGeometry_put_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(CompositionLineGeometry_get_End), reinterpret_cast<setter>(CompositionLineGeometry_put_End), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionLineGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionLineGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionLineGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionLineGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionLineGeometry) },
        { }
    };

    static PyType_Spec type_spec_CompositionLineGeometry = {
        "winrt._winrt_microsoft_ui_composition.CompositionLineGeometry",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionLineGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionLineGeometry};

    // ----- CompositionLinearGradientBrush class --------------------

    static PyObject* _new_CompositionLinearGradientBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionLinearGradientBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionLinearGradientBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionLinearGradientBrush(py::wrapper::Microsoft::UI::Composition::CompositionLinearGradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionLinearGradientBrush_get_StartPoint(py::wrapper::Microsoft::UI::Composition::CompositionLinearGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLinearGradientBrush", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionLinearGradientBrush_put_StartPoint(py::wrapper::Microsoft::UI::Composition::CompositionLinearGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLinearGradientBrush", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionLinearGradientBrush_get_EndPoint(py::wrapper::Microsoft::UI::Composition::CompositionLinearGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLinearGradientBrush", L"EndPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionLinearGradientBrush_put_EndPoint(py::wrapper::Microsoft::UI::Composition::CompositionLinearGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionLinearGradientBrush", L"EndPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.EndPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionLinearGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionLinearGradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionLinearGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionLinearGradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionLinearGradientBrush[] = {
        { "_assign_array_", _assign_array_CompositionLinearGradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionLinearGradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionLinearGradientBrush[] = {
        { "start_point", reinterpret_cast<getter>(CompositionLinearGradientBrush_get_StartPoint), reinterpret_cast<setter>(CompositionLinearGradientBrush_put_StartPoint), nullptr, nullptr },
        { "end_point", reinterpret_cast<getter>(CompositionLinearGradientBrush_get_EndPoint), reinterpret_cast<setter>(CompositionLinearGradientBrush_put_EndPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionLinearGradientBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionLinearGradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionLinearGradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionLinearGradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionLinearGradientBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionLinearGradientBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionLinearGradientBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionLinearGradientBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionLinearGradientBrush};

    // ----- CompositionMaskBrush class --------------------

    static PyObject* _new_CompositionMaskBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionMaskBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionMaskBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionMaskBrush(py::wrapper::Microsoft::UI::Composition::CompositionMaskBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionMaskBrush_get_Source(py::wrapper::Microsoft::UI::Composition::CompositionMaskBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMaskBrush", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionMaskBrush_put_Source(py::wrapper::Microsoft::UI::Composition::CompositionMaskBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMaskBrush", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionMaskBrush_get_Mask(py::wrapper::Microsoft::UI::Composition::CompositionMaskBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMaskBrush", L"Mask");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionMaskBrush_put_Mask(py::wrapper::Microsoft::UI::Composition::CompositionMaskBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMaskBrush", L"Mask");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.Mask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionMaskBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionMaskBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionMaskBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionMaskBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionMaskBrush[] = {
        { "_assign_array_", _assign_array_CompositionMaskBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionMaskBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionMaskBrush[] = {
        { "source", reinterpret_cast<getter>(CompositionMaskBrush_get_Source), reinterpret_cast<setter>(CompositionMaskBrush_put_Source), nullptr, nullptr },
        { "mask", reinterpret_cast<getter>(CompositionMaskBrush_get_Mask), reinterpret_cast<setter>(CompositionMaskBrush_put_Mask), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionMaskBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionMaskBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionMaskBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionMaskBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionMaskBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionMaskBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionMaskBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionMaskBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionMaskBrush};

    // ----- CompositionMipmapSurface class --------------------

    static PyObject* _new_CompositionMipmapSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionMipmapSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionMipmapSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionMipmapSurface(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionMipmapSurface_GetDrawingSurfaceForLevel(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionMipmapSurface", L"GetDrawingSurfaceForLevel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetDrawingSurfaceForLevel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionMipmapSurface_get_AlphaMode(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMipmapSurface", L"AlphaMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionMipmapSurface_get_LevelCount(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMipmapSurface", L"LevelCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LevelCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionMipmapSurface_get_PixelFormat(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMipmapSurface", L"PixelFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionMipmapSurface_get_SizeInt32(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionMipmapSurface", L"SizeInt32");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SizeInt32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionMipmapSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionMipmapSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionMipmapSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionMipmapSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionMipmapSurface[] = {
        { "get_drawing_surface_for_level", reinterpret_cast<PyCFunction>(CompositionMipmapSurface_GetDrawingSurfaceForLevel), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionMipmapSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionMipmapSurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionMipmapSurface[] = {
        { "alpha_mode", reinterpret_cast<getter>(CompositionMipmapSurface_get_AlphaMode), nullptr, nullptr, nullptr },
        { "level_count", reinterpret_cast<getter>(CompositionMipmapSurface_get_LevelCount), nullptr, nullptr, nullptr },
        { "pixel_format", reinterpret_cast<getter>(CompositionMipmapSurface_get_PixelFormat), nullptr, nullptr, nullptr },
        { "size_int32", reinterpret_cast<getter>(CompositionMipmapSurface_get_SizeInt32), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionMipmapSurface[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionMipmapSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionMipmapSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionMipmapSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionMipmapSurface) },
        { }
    };

    static PyType_Spec type_spec_CompositionMipmapSurface = {
        "winrt._winrt_microsoft_ui_composition.CompositionMipmapSurface",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionMipmapSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionMipmapSurface};

    // ----- CompositionNineGridBrush class --------------------

    static PyObject* _new_CompositionNineGridBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionNineGridBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionNineGridBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionNineGridBrush(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionNineGridBrush_SetInsetScales(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"SetInsetScales", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                self->obj.SetInsetScales(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionNineGridBrush_SetInsetScalesWithValues(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"SetInsetScales", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                self->obj.SetInsetScales(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionNineGridBrush_SetInsets(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"SetInsets", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                self->obj.SetInsets(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionNineGridBrush_SetInsetsWithValues(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"SetInsets", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                self->obj.SetInsets(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionNineGridBrush_get_TopInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"TopInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TopInsetScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_TopInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"TopInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.TopInsetScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_TopInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"TopInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TopInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_TopInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"TopInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.TopInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_Source(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_Source(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_RightInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"RightInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RightInsetScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_RightInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"RightInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RightInsetScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_RightInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"RightInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RightInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_RightInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"RightInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RightInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_LeftInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"LeftInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LeftInsetScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_LeftInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"LeftInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.LeftInsetScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_LeftInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"LeftInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LeftInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_LeftInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"LeftInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.LeftInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_IsCenterHollow(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"IsCenterHollow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCenterHollow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_IsCenterHollow(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"IsCenterHollow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCenterHollow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_BottomInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"BottomInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BottomInsetScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_BottomInsetScale(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"BottomInsetScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.BottomInsetScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionNineGridBrush_get_BottomInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"BottomInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BottomInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionNineGridBrush_put_BottomInset(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionNineGridBrush", L"BottomInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.BottomInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionNineGridBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionNineGridBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionNineGridBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionNineGridBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionNineGridBrush[] = {
        { "set_inset_scales", reinterpret_cast<PyCFunction>(CompositionNineGridBrush_SetInsetScales), METH_VARARGS, nullptr },
        { "set_inset_scales_with_values", reinterpret_cast<PyCFunction>(CompositionNineGridBrush_SetInsetScalesWithValues), METH_VARARGS, nullptr },
        { "set_insets", reinterpret_cast<PyCFunction>(CompositionNineGridBrush_SetInsets), METH_VARARGS, nullptr },
        { "set_insets_with_values", reinterpret_cast<PyCFunction>(CompositionNineGridBrush_SetInsetsWithValues), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionNineGridBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionNineGridBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionNineGridBrush[] = {
        { "top_inset_scale", reinterpret_cast<getter>(CompositionNineGridBrush_get_TopInsetScale), reinterpret_cast<setter>(CompositionNineGridBrush_put_TopInsetScale), nullptr, nullptr },
        { "top_inset", reinterpret_cast<getter>(CompositionNineGridBrush_get_TopInset), reinterpret_cast<setter>(CompositionNineGridBrush_put_TopInset), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CompositionNineGridBrush_get_Source), reinterpret_cast<setter>(CompositionNineGridBrush_put_Source), nullptr, nullptr },
        { "right_inset_scale", reinterpret_cast<getter>(CompositionNineGridBrush_get_RightInsetScale), reinterpret_cast<setter>(CompositionNineGridBrush_put_RightInsetScale), nullptr, nullptr },
        { "right_inset", reinterpret_cast<getter>(CompositionNineGridBrush_get_RightInset), reinterpret_cast<setter>(CompositionNineGridBrush_put_RightInset), nullptr, nullptr },
        { "left_inset_scale", reinterpret_cast<getter>(CompositionNineGridBrush_get_LeftInsetScale), reinterpret_cast<setter>(CompositionNineGridBrush_put_LeftInsetScale), nullptr, nullptr },
        { "left_inset", reinterpret_cast<getter>(CompositionNineGridBrush_get_LeftInset), reinterpret_cast<setter>(CompositionNineGridBrush_put_LeftInset), nullptr, nullptr },
        { "is_center_hollow", reinterpret_cast<getter>(CompositionNineGridBrush_get_IsCenterHollow), reinterpret_cast<setter>(CompositionNineGridBrush_put_IsCenterHollow), nullptr, nullptr },
        { "bottom_inset_scale", reinterpret_cast<getter>(CompositionNineGridBrush_get_BottomInsetScale), reinterpret_cast<setter>(CompositionNineGridBrush_put_BottomInsetScale), nullptr, nullptr },
        { "bottom_inset", reinterpret_cast<getter>(CompositionNineGridBrush_get_BottomInset), reinterpret_cast<setter>(CompositionNineGridBrush_put_BottomInset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionNineGridBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionNineGridBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionNineGridBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionNineGridBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionNineGridBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionNineGridBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionNineGridBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionNineGridBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionNineGridBrush};

    // ----- CompositionObject class --------------------

    static PyObject* _new_CompositionObject(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionObject>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionObject>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionObject(py::wrapper::Microsoft::UI::Composition::CompositionObject* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionObject_Close(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_PopulatePropertyInfo(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"PopulatePropertyInfo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().PopulatePropertyInfo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StartAnimation(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StartAnimation", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().StartAnimation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StartAnimationGroup(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StartAnimationGroup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().StartAnimationGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StartAnimationGroupWithIAnimationObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StartAnimationGroupWithIAnimationObject", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::IAnimationObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>(args, 1);

                winrt::Microsoft::UI::Composition::CompositionObject::StartAnimationGroupWithIAnimationObject(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StartAnimationWithController(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StartAnimation", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationController>(args, 2);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().StartAnimation(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StartAnimationWithIAnimationObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StartAnimationWithIAnimationObject", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::IAnimationObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 2);

                winrt::Microsoft::UI::Composition::CompositionObject::StartAnimationWithIAnimationObject(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StopAnimation(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StopAnimation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().StopAnimation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_StopAnimationGroup(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"StopAnimationGroup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().StopAnimationGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_TryGetAnimationController(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionObject", L"TryGetAnimationController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().TryGetAnimationController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionObject_get_Compositor(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"Compositor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().Compositor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionObject_get_Properties(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionObject_get_ImplicitAnimations(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"ImplicitAnimations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().ImplicitAnimations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionObject_put_ImplicitAnimations(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"ImplicitAnimations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ImplicitAnimationCollection>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().ImplicitAnimations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionObject_get_Comment(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionObject_put_Comment(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().Comment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionObject_get_DispatcherQueue(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionObject", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionObject>().DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CompositionObject(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_CompositionObject(py::wrapper::Microsoft::UI::Composition::CompositionObject* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionObject[] = {
        { "close", reinterpret_cast<PyCFunction>(CompositionObject_Close), METH_VARARGS, nullptr },
        { "populate_property_info", reinterpret_cast<PyCFunction>(CompositionObject_PopulatePropertyInfo), METH_VARARGS, nullptr },
        { "start_animation", reinterpret_cast<PyCFunction>(CompositionObject_StartAnimation), METH_VARARGS, nullptr },
        { "start_animation_group", reinterpret_cast<PyCFunction>(CompositionObject_StartAnimationGroup), METH_VARARGS, nullptr },
        { "start_animation_with_controller", reinterpret_cast<PyCFunction>(CompositionObject_StartAnimationWithController), METH_VARARGS, nullptr },
        { "stop_animation", reinterpret_cast<PyCFunction>(CompositionObject_StopAnimation), METH_VARARGS, nullptr },
        { "stop_animation_group", reinterpret_cast<PyCFunction>(CompositionObject_StopAnimationGroup), METH_VARARGS, nullptr },
        { "try_get_animation_controller", reinterpret_cast<PyCFunction>(CompositionObject_TryGetAnimationController), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionObject), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CompositionObject), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_CompositionObject), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionObject[] = {
        { "compositor", reinterpret_cast<getter>(CompositionObject_get_Compositor), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(CompositionObject_get_Properties), nullptr, nullptr, nullptr },
        { "implicit_animations", reinterpret_cast<getter>(CompositionObject_get_ImplicitAnimations), reinterpret_cast<setter>(CompositionObject_put_ImplicitAnimations), nullptr, nullptr },
        { "comment", reinterpret_cast<getter>(CompositionObject_get_Comment), reinterpret_cast<setter>(CompositionObject_put_Comment), nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(CompositionObject_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionObject[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionObject) },
        { }
    };

    static PyType_Spec type_spec_CompositionObject = {
        "winrt._winrt_microsoft_ui_composition.CompositionObject",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionObject),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionObject};

    static PyGetSetDef getset_CompositionObject_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionObject_Static[] = {
        { "start_animation_group_with_ianimation_object", reinterpret_cast<PyCFunction>(CompositionObject_StartAnimationGroupWithIAnimationObject), METH_VARARGS, nullptr },
        { "start_animation_with_ianimation_object", reinterpret_cast<PyCFunction>(CompositionObject_StartAnimationWithIAnimationObject), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CompositionObject_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionObject_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionObject_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionObject_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionObject_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionObject_Static
    };

    // ----- CompositionPath class --------------------

    static PyObject* _new_CompositionPath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::IGeometrySource2D>(args, 0);

                winrt::Microsoft::UI::Composition::CompositionPath instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CompositionPath(py::wrapper::Microsoft::UI::Composition::CompositionPath* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CompositionPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionPath>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionPath[] = {
        { "_assign_array_", _assign_array_CompositionPath, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionPath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionPath[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionPath[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionPath) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionPath) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionPath) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionPath) },
        { }
    };

    static PyType_Spec type_spec_CompositionPath = {
        "winrt._winrt_microsoft_ui_composition.CompositionPath",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionPath};

    // ----- CompositionPathGeometry class --------------------

    static PyObject* _new_CompositionPathGeometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionPathGeometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionPathGeometry>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionPathGeometry(py::wrapper::Microsoft::UI::Composition::CompositionPathGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionPathGeometry_get_Path(py::wrapper::Microsoft::UI::Composition::CompositionPathGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionPathGeometry", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionPathGeometry_put_Path(py::wrapper::Microsoft::UI::Composition::CompositionPathGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionPathGeometry", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionPath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionPathGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionPathGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionPathGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionPathGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionPathGeometry[] = {
        { "_assign_array_", _assign_array_CompositionPathGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionPathGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionPathGeometry[] = {
        { "path", reinterpret_cast<getter>(CompositionPathGeometry_get_Path), reinterpret_cast<setter>(CompositionPathGeometry_put_Path), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionPathGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionPathGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionPathGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionPathGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionPathGeometry) },
        { }
    };

    static PyType_Spec type_spec_CompositionPathGeometry = {
        "winrt._winrt_microsoft_ui_composition.CompositionPathGeometry",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionPathGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionPathGeometry};

    // ----- CompositionProjectedShadow class --------------------

    static PyObject* _new_CompositionProjectedShadow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadow>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionProjectedShadow(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionProjectedShadow_get_MinBlurRadius(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"MinBlurRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinBlurRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadow_put_MinBlurRadius(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"MinBlurRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MinBlurRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionProjectedShadow_get_MaxBlurRadius(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"MaxBlurRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBlurRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadow_put_MaxBlurRadius(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"MaxBlurRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxBlurRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionProjectedShadow_get_LightSource(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"LightSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LightSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadow_put_LightSource(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"LightSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionLight>(arg);

            self->obj.LightSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionProjectedShadow_get_BlurRadiusMultiplier(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"BlurRadiusMultiplier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BlurRadiusMultiplier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadow_put_BlurRadiusMultiplier(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"BlurRadiusMultiplier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.BlurRadiusMultiplier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionProjectedShadow_get_Casters(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"Casters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Casters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadow_get_Receivers(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadow", L"Receivers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Receivers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionProjectedShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionProjectedShadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionProjectedShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionProjectedShadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionProjectedShadow[] = {
        { "_assign_array_", _assign_array_CompositionProjectedShadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionProjectedShadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionProjectedShadow[] = {
        { "min_blur_radius", reinterpret_cast<getter>(CompositionProjectedShadow_get_MinBlurRadius), reinterpret_cast<setter>(CompositionProjectedShadow_put_MinBlurRadius), nullptr, nullptr },
        { "max_blur_radius", reinterpret_cast<getter>(CompositionProjectedShadow_get_MaxBlurRadius), reinterpret_cast<setter>(CompositionProjectedShadow_put_MaxBlurRadius), nullptr, nullptr },
        { "light_source", reinterpret_cast<getter>(CompositionProjectedShadow_get_LightSource), reinterpret_cast<setter>(CompositionProjectedShadow_put_LightSource), nullptr, nullptr },
        { "blur_radius_multiplier", reinterpret_cast<getter>(CompositionProjectedShadow_get_BlurRadiusMultiplier), reinterpret_cast<setter>(CompositionProjectedShadow_put_BlurRadiusMultiplier), nullptr, nullptr },
        { "casters", reinterpret_cast<getter>(CompositionProjectedShadow_get_Casters), nullptr, nullptr, nullptr },
        { "receivers", reinterpret_cast<getter>(CompositionProjectedShadow_get_Receivers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionProjectedShadow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionProjectedShadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionProjectedShadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionProjectedShadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionProjectedShadow) },
        { }
    };

    static PyType_Spec type_spec_CompositionProjectedShadow = {
        "winrt._winrt_microsoft_ui_composition.CompositionProjectedShadow",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionProjectedShadow};

    // ----- CompositionProjectedShadowCaster class --------------------

    static PyObject* _new_CompositionProjectedShadowCaster(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionProjectedShadowCaster(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCaster* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionProjectedShadowCaster_get_CastingVisual(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCaster* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCaster", L"CastingVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CastingVisual());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadowCaster_put_CastingVisual(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCaster* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCaster", L"CastingVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.CastingVisual(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionProjectedShadowCaster_get_Brush(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCaster* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCaster", L"Brush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Brush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadowCaster_put_Brush(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCaster* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCaster", L"Brush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.Brush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionProjectedShadowCaster(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionProjectedShadowCaster(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionProjectedShadowCaster[] = {
        { "_assign_array_", _assign_array_CompositionProjectedShadowCaster, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionProjectedShadowCaster), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionProjectedShadowCaster[] = {
        { "casting_visual", reinterpret_cast<getter>(CompositionProjectedShadowCaster_get_CastingVisual), reinterpret_cast<setter>(CompositionProjectedShadowCaster_put_CastingVisual), nullptr, nullptr },
        { "brush", reinterpret_cast<getter>(CompositionProjectedShadowCaster_get_Brush), reinterpret_cast<setter>(CompositionProjectedShadowCaster_put_Brush), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionProjectedShadowCaster[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionProjectedShadowCaster) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionProjectedShadowCaster) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionProjectedShadowCaster) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionProjectedShadowCaster) },
        { }
    };

    static PyType_Spec type_spec_CompositionProjectedShadowCaster = {
        "winrt._winrt_microsoft_ui_composition.CompositionProjectedShadowCaster",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCaster),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionProjectedShadowCaster};

    // ----- CompositionProjectedShadowCasterCollection class --------------------

    static PyObject* _new_CompositionProjectedShadowCasterCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionProjectedShadowCasterCollection(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionProjectedShadowCasterCollection_First(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_InsertAbove(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"InsertAbove", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 1);

                self->obj.InsertAbove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_InsertAtBottom(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"InsertAtBottom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 0);

                self->obj.InsertAtBottom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_InsertAtTop(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"InsertAtTop", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 0);

                self->obj.InsertAtTop(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_InsertBelow(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"InsertBelow", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 1);

                self->obj.InsertBelow(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_Remove(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCaster>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_RemoveAll(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"RemoveAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_get_Count(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Count());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowCasterCollection_get_MaxRespectedCasters(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowCasterCollection", L"MaxRespectedCasters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection::MaxRespectedCasters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionProjectedShadowCasterCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionProjectedShadowCasterCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionProjectedShadowCasterCollection(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionProjectedShadowCasterCollection[] = {
        { "first", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_First), METH_VARARGS, nullptr },
        { "insert_above", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_InsertAbove), METH_VARARGS, nullptr },
        { "insert_at_bottom", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_InsertAtBottom), METH_VARARGS, nullptr },
        { "insert_at_top", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_InsertAtTop), METH_VARARGS, nullptr },
        { "insert_below", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_InsertBelow), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(CompositionProjectedShadowCasterCollection_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionProjectedShadowCasterCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionProjectedShadowCasterCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionProjectedShadowCasterCollection[] = {
        { "count", reinterpret_cast<getter>(CompositionProjectedShadowCasterCollection_get_Count), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionProjectedShadowCasterCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionProjectedShadowCasterCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionProjectedShadowCasterCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionProjectedShadowCasterCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionProjectedShadowCasterCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionProjectedShadowCasterCollection) },
        { }
    };

    static PyType_Spec type_spec_CompositionProjectedShadowCasterCollection = {
        "winrt._winrt_microsoft_ui_composition.CompositionProjectedShadowCasterCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowCasterCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionProjectedShadowCasterCollection};

    static PyGetSetDef getset_CompositionProjectedShadowCasterCollection_Static[] = {
        { "max_respected_casters", reinterpret_cast<getter>(CompositionProjectedShadowCasterCollection_get_MaxRespectedCasters), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CompositionProjectedShadowCasterCollection_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionProjectedShadowCasterCollection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionProjectedShadowCasterCollection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionProjectedShadowCasterCollection_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionProjectedShadowCasterCollection_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionProjectedShadowCasterCollection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositionProjectedShadowCasterCollection_Static
    };

    // ----- CompositionProjectedShadowReceiver class --------------------

    static PyObject* _new_CompositionProjectedShadowReceiver(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiver>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiver>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionProjectedShadowReceiver(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiver* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionProjectedShadowReceiver_get_ReceivingVisual(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiver", L"ReceivingVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReceivingVisual());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionProjectedShadowReceiver_put_ReceivingVisual(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiver", L"ReceivingVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.ReceivingVisual(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionProjectedShadowReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionProjectedShadowReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionProjectedShadowReceiver[] = {
        { "_assign_array_", _assign_array_CompositionProjectedShadowReceiver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionProjectedShadowReceiver), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionProjectedShadowReceiver[] = {
        { "receiving_visual", reinterpret_cast<getter>(CompositionProjectedShadowReceiver_get_ReceivingVisual), reinterpret_cast<setter>(CompositionProjectedShadowReceiver_put_ReceivingVisual), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionProjectedShadowReceiver[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionProjectedShadowReceiver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionProjectedShadowReceiver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionProjectedShadowReceiver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionProjectedShadowReceiver) },
        { }
    };

    static PyType_Spec type_spec_CompositionProjectedShadowReceiver = {
        "winrt._winrt_microsoft_ui_composition.CompositionProjectedShadowReceiver",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionProjectedShadowReceiver};

    // ----- CompositionProjectedShadowReceiverUnorderedCollection class --------------------

    static PyObject* _new_CompositionProjectedShadowReceiverUnorderedCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionProjectedShadowReceiverUnorderedCollection(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionProjectedShadowReceiverUnorderedCollection_Add(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection", L"Add", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiver>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowReceiverUnorderedCollection_First(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowReceiverUnorderedCollection_Remove(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiver>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowReceiverUnorderedCollection_RemoveAll(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection", L"RemoveAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionProjectedShadowReceiverUnorderedCollection_get_Count(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Count());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionProjectedShadowReceiverUnorderedCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionProjectedShadowReceiverUnorderedCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionProjectedShadowReceiverUnorderedCollection(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionProjectedShadowReceiverUnorderedCollection[] = {
        { "add", reinterpret_cast<PyCFunction>(CompositionProjectedShadowReceiverUnorderedCollection_Add), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionProjectedShadowReceiverUnorderedCollection_First), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(CompositionProjectedShadowReceiverUnorderedCollection_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(CompositionProjectedShadowReceiverUnorderedCollection_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionProjectedShadowReceiverUnorderedCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionProjectedShadowReceiverUnorderedCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionProjectedShadowReceiverUnorderedCollection[] = {
        { "count", reinterpret_cast<getter>(CompositionProjectedShadowReceiverUnorderedCollection_get_Count), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionProjectedShadowReceiverUnorderedCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionProjectedShadowReceiverUnorderedCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionProjectedShadowReceiverUnorderedCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionProjectedShadowReceiverUnorderedCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionProjectedShadowReceiverUnorderedCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionProjectedShadowReceiverUnorderedCollection) },
        { }
    };

    static PyType_Spec type_spec_CompositionProjectedShadowReceiverUnorderedCollection = {
        "winrt._winrt_microsoft_ui_composition.CompositionProjectedShadowReceiverUnorderedCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionProjectedShadowReceiverUnorderedCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionProjectedShadowReceiverUnorderedCollection};

    // ----- CompositionPropertySet class --------------------

    static PyObject* _new_CompositionPropertySet(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionPropertySet>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionPropertySet>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionPropertySet(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionPropertySet_InsertBoolean(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertBoolean", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.InsertBoolean(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertColor(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertColor", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                self->obj.InsertColor(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertMatrix3x2(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertMatrix3x2", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);

                self->obj.InsertMatrix3x2(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertMatrix4x4(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertMatrix4x4", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(args, 1);

                self->obj.InsertMatrix4x4(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertQuaternion(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertQuaternion", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 1);

                self->obj.InsertQuaternion(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertScalar(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertScalar", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.InsertScalar(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertVector2(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertVector2", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);

                self->obj.InsertVector2(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertVector3(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertVector3", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                self->obj.InsertVector3(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_InsertVector4(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"InsertVector4", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 1);

                self->obj.InsertVector4(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetBoolean(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetBoolean", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                bool param1{};

                auto return_value = self->obj.TryGetBoolean(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetColor(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetColor", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::UI::Color param1{};

                auto return_value = self->obj.TryGetColor(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetMatrix3x2(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetMatrix3x2", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float3x2 param1{};

                auto return_value = self->obj.TryGetMatrix3x2(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetMatrix4x4(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetMatrix4x4", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1{};

                auto return_value = self->obj.TryGetMatrix4x4(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetQuaternion(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetQuaternion", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::quaternion param1{};

                auto return_value = self->obj.TryGetQuaternion(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetScalar(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetScalar", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                float param1{};

                auto return_value = self->obj.TryGetScalar(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetVector2(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetVector2", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float2 param1{};

                auto return_value = self->obj.TryGetVector2(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetVector3(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetVector3", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float3 param1{};

                auto return_value = self->obj.TryGetVector3(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionPropertySet_TryGetVector4(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionPropertySet", L"TryGetVector4", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4 param1{};

                auto return_value = self->obj.TryGetVector4(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionPropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionPropertySet[] = {
        { "insert_boolean", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertBoolean), METH_VARARGS, nullptr },
        { "insert_color", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertColor), METH_VARARGS, nullptr },
        { "insert_matrix3x2", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertMatrix3x2), METH_VARARGS, nullptr },
        { "insert_matrix4x4", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertMatrix4x4), METH_VARARGS, nullptr },
        { "insert_quaternion", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertQuaternion), METH_VARARGS, nullptr },
        { "insert_scalar", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertScalar), METH_VARARGS, nullptr },
        { "insert_vector2", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertVector2), METH_VARARGS, nullptr },
        { "insert_vector3", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertVector3), METH_VARARGS, nullptr },
        { "insert_vector4", reinterpret_cast<PyCFunction>(CompositionPropertySet_InsertVector4), METH_VARARGS, nullptr },
        { "try_get_boolean", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetBoolean), METH_VARARGS, nullptr },
        { "try_get_color", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetColor), METH_VARARGS, nullptr },
        { "try_get_matrix3x2", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetMatrix3x2), METH_VARARGS, nullptr },
        { "try_get_matrix4x4", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetMatrix4x4), METH_VARARGS, nullptr },
        { "try_get_quaternion", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetQuaternion), METH_VARARGS, nullptr },
        { "try_get_scalar", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetScalar), METH_VARARGS, nullptr },
        { "try_get_vector2", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetVector2), METH_VARARGS, nullptr },
        { "try_get_vector3", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetVector3), METH_VARARGS, nullptr },
        { "try_get_vector4", reinterpret_cast<PyCFunction>(CompositionPropertySet_TryGetVector4), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionPropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionPropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionPropertySet[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionPropertySet[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionPropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionPropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionPropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionPropertySet) },
        { }
    };

    static PyType_Spec type_spec_CompositionPropertySet = {
        "winrt._winrt_microsoft_ui_composition.CompositionPropertySet",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionPropertySet};

    // ----- CompositionRadialGradientBrush class --------------------

    static PyObject* _new_CompositionRadialGradientBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionRadialGradientBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionRadialGradientBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionRadialGradientBrush(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionRadialGradientBrush_get_GradientOriginOffset(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRadialGradientBrush", L"GradientOriginOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GradientOriginOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRadialGradientBrush_put_GradientOriginOffset(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRadialGradientBrush", L"GradientOriginOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.GradientOriginOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionRadialGradientBrush_get_EllipseRadius(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRadialGradientBrush", L"EllipseRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRadialGradientBrush_put_EllipseRadius(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRadialGradientBrush", L"EllipseRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.EllipseRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionRadialGradientBrush_get_EllipseCenter(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRadialGradientBrush", L"EllipseCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRadialGradientBrush_put_EllipseCenter(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRadialGradientBrush", L"EllipseCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.EllipseCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionRadialGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionRadialGradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionRadialGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionRadialGradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionRadialGradientBrush[] = {
        { "_assign_array_", _assign_array_CompositionRadialGradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionRadialGradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionRadialGradientBrush[] = {
        { "gradient_origin_offset", reinterpret_cast<getter>(CompositionRadialGradientBrush_get_GradientOriginOffset), reinterpret_cast<setter>(CompositionRadialGradientBrush_put_GradientOriginOffset), nullptr, nullptr },
        { "ellipse_radius", reinterpret_cast<getter>(CompositionRadialGradientBrush_get_EllipseRadius), reinterpret_cast<setter>(CompositionRadialGradientBrush_put_EllipseRadius), nullptr, nullptr },
        { "ellipse_center", reinterpret_cast<getter>(CompositionRadialGradientBrush_get_EllipseCenter), reinterpret_cast<setter>(CompositionRadialGradientBrush_put_EllipseCenter), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionRadialGradientBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionRadialGradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionRadialGradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionRadialGradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionRadialGradientBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionRadialGradientBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionRadialGradientBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionRadialGradientBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionRadialGradientBrush};

    // ----- CompositionRectangleGeometry class --------------------

    static PyObject* _new_CompositionRectangleGeometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionRectangleGeometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionRectangleGeometry>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionRectangleGeometry(py::wrapper::Microsoft::UI::Composition::CompositionRectangleGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionRectangleGeometry_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionRectangleGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRectangleGeometry", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRectangleGeometry_put_Size(py::wrapper::Microsoft::UI::Composition::CompositionRectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRectangleGeometry", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionRectangleGeometry_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionRectangleGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRectangleGeometry", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRectangleGeometry_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionRectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRectangleGeometry", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionRectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionRectangleGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionRectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionRectangleGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionRectangleGeometry[] = {
        { "_assign_array_", _assign_array_CompositionRectangleGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionRectangleGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionRectangleGeometry[] = {
        { "size", reinterpret_cast<getter>(CompositionRectangleGeometry_get_Size), reinterpret_cast<setter>(CompositionRectangleGeometry_put_Size), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionRectangleGeometry_get_Offset), reinterpret_cast<setter>(CompositionRectangleGeometry_put_Offset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionRectangleGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionRectangleGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionRectangleGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionRectangleGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionRectangleGeometry) },
        { }
    };

    static PyType_Spec type_spec_CompositionRectangleGeometry = {
        "winrt._winrt_microsoft_ui_composition.CompositionRectangleGeometry",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionRectangleGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionRectangleGeometry};

    // ----- CompositionRoundedRectangleGeometry class --------------------

    static PyObject* _new_CompositionRoundedRectangleGeometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionRoundedRectangleGeometry(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionRoundedRectangleGeometry_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRoundedRectangleGeometry", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRoundedRectangleGeometry_put_Size(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRoundedRectangleGeometry", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionRoundedRectangleGeometry_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRoundedRectangleGeometry", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRoundedRectangleGeometry_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRoundedRectangleGeometry", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionRoundedRectangleGeometry_get_CornerRadius(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRoundedRectangleGeometry", L"CornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CornerRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionRoundedRectangleGeometry_put_CornerRadius(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionRoundedRectangleGeometry", L"CornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.CornerRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionRoundedRectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionRoundedRectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionRoundedRectangleGeometry[] = {
        { "_assign_array_", _assign_array_CompositionRoundedRectangleGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionRoundedRectangleGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionRoundedRectangleGeometry[] = {
        { "size", reinterpret_cast<getter>(CompositionRoundedRectangleGeometry_get_Size), reinterpret_cast<setter>(CompositionRoundedRectangleGeometry_put_Size), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionRoundedRectangleGeometry_get_Offset), reinterpret_cast<setter>(CompositionRoundedRectangleGeometry_put_Offset), nullptr, nullptr },
        { "corner_radius", reinterpret_cast<getter>(CompositionRoundedRectangleGeometry_get_CornerRadius), reinterpret_cast<setter>(CompositionRoundedRectangleGeometry_put_CornerRadius), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionRoundedRectangleGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionRoundedRectangleGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionRoundedRectangleGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionRoundedRectangleGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionRoundedRectangleGeometry) },
        { }
    };

    static PyType_Spec type_spec_CompositionRoundedRectangleGeometry = {
        "winrt._winrt_microsoft_ui_composition.CompositionRoundedRectangleGeometry",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionRoundedRectangleGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionRoundedRectangleGeometry};

    // ----- CompositionScopedBatch class --------------------

    static PyObject* _new_CompositionScopedBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionScopedBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionScopedBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionScopedBatch(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionScopedBatch_End(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"End", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.End();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionScopedBatch_Resume(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionScopedBatch_Suspend(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"Suspend", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Suspend();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionScopedBatch_get_IsActive(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionScopedBatch_get_IsEnded(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"IsEnded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionScopedBatch_add_Completed(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Microsoft::UI::Composition::CompositionBatchCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionScopedBatch_remove_Completed(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Composition.CompositionScopedBatch", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionScopedBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionScopedBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionScopedBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionScopedBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionScopedBatch[] = {
        { "end", reinterpret_cast<PyCFunction>(CompositionScopedBatch_End), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(CompositionScopedBatch_Resume), METH_VARARGS, nullptr },
        { "suspend", reinterpret_cast<PyCFunction>(CompositionScopedBatch_Suspend), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(CompositionScopedBatch_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(CompositionScopedBatch_remove_Completed), METH_O, nullptr },
        { "_assign_array_", _assign_array_CompositionScopedBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionScopedBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionScopedBatch[] = {
        { "is_active", reinterpret_cast<getter>(CompositionScopedBatch_get_IsActive), nullptr, nullptr, nullptr },
        { "is_ended", reinterpret_cast<getter>(CompositionScopedBatch_get_IsEnded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionScopedBatch[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionScopedBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionScopedBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionScopedBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionScopedBatch) },
        { }
    };

    static PyType_Spec type_spec_CompositionScopedBatch = {
        "winrt._winrt_microsoft_ui_composition.CompositionScopedBatch",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionScopedBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionScopedBatch};

    // ----- CompositionShadow class --------------------

    static PyObject* _new_CompositionShadow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionShadow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionShadow>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionShadow(py::wrapper::Microsoft::UI::Composition::CompositionShadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CompositionShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionShadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionShadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionShadow[] = {
        { "_assign_array_", _assign_array_CompositionShadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionShadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionShadow[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionShadow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionShadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionShadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionShadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionShadow) },
        { }
    };

    static PyType_Spec type_spec_CompositionShadow = {
        "winrt._winrt_microsoft_ui_composition.CompositionShadow",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionShadow),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionShadow};

    static PyGetSetDef getset_CompositionShadow_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionShadow_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionShadow_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionShadow_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionShadow_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionShadow_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionShadow_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionShadow_Static
    };

    // ----- CompositionShape class --------------------

    static PyObject* _new_CompositionShape(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionShape>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionShape>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionShape(py::wrapper::Microsoft::UI::Composition::CompositionShape* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionShape_get_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionShape_put_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionShape_get_Scale(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionShape_put_Scale(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionShape_get_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().RotationAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionShape_put_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().RotationAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionShape_get_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionShape_put_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionShape_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionShape_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionShape_get_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionShape_put_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShape", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionShape>().CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionShape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionShape[] = {
        { "_assign_array_", _assign_array_CompositionShape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionShape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionShape[] = {
        { "transform_matrix", reinterpret_cast<getter>(CompositionShape_get_TransformMatrix), reinterpret_cast<setter>(CompositionShape_put_TransformMatrix), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(CompositionShape_get_Scale), reinterpret_cast<setter>(CompositionShape_put_Scale), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(CompositionShape_get_RotationAngleInDegrees), reinterpret_cast<setter>(CompositionShape_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(CompositionShape_get_RotationAngle), reinterpret_cast<setter>(CompositionShape_put_RotationAngle), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionShape_get_Offset), reinterpret_cast<setter>(CompositionShape_put_Offset), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(CompositionShape_get_CenterPoint), reinterpret_cast<setter>(CompositionShape_put_CenterPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionShape[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionShape) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionShape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionShape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionShape) },
        { }
    };

    static PyType_Spec type_spec_CompositionShape = {
        "winrt._winrt_microsoft_ui_composition.CompositionShape",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionShape),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionShape};

    static PyGetSetDef getset_CompositionShape_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionShape_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionShape_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionShape_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionShape_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionShape_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionShape_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionShape_Static
    };

    // ----- CompositionShapeCollection class --------------------

    static PyObject* _new_CompositionShapeCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionShapeCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionShapeCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionShapeCollection(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionShapeCollection_Append(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionShape>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_Clear(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_First(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_GetAt(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_GetMany(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Composition::CompositionShape, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_GetView(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_IndexOf(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionShape>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_InsertAt(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionShape>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_RemoveAt(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_ReplaceAll(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Composition::CompositionShape, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_SetAt(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionShape>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionShapeCollection_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionShapeCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionShapeCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionShapeCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionShapeCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionShapeCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionShapeCollection(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_CompositionShapeCollection(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_CompositionShapeCollection(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_CompositionShapeCollection(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_CompositionShapeCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Composition::CompositionShape> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Composition::CompositionShape>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_CompositionShapeCollection(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Composition::CompositionShape>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_CompositionShapeCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(CompositionShapeCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(CompositionShapeCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionShapeCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(CompositionShapeCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(CompositionShapeCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(CompositionShapeCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(CompositionShapeCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(CompositionShapeCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(CompositionShapeCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(CompositionShapeCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(CompositionShapeCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(CompositionShapeCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionShapeCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionShapeCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionShapeCollection[] = {
        { "size", reinterpret_cast<getter>(CompositionShapeCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionShapeCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionShapeCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionShapeCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionShapeCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionShapeCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionShapeCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_CompositionShapeCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_CompositionShapeCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_CompositionShapeCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_CompositionShapeCollection) },
        { }
    };

    static PyType_Spec type_spec_CompositionShapeCollection = {
        "winrt._winrt_microsoft_ui_composition.CompositionShapeCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionShapeCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionShapeCollection};

    // ----- CompositionSpriteShape class --------------------

    static PyObject* _new_CompositionSpriteShape(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionSpriteShape>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionSpriteShape>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionSpriteShape(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionSpriteShape_get_StrokeThickness(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeThickness(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.StrokeThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeStartCap(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeStartCap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeStartCap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeStartCap(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeStartCap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionStrokeCap>(arg);

            self->obj.StrokeStartCap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeMiterLimit(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeMiterLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeMiterLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeMiterLimit(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeMiterLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.StrokeMiterLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeLineJoin(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeLineJoin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeLineJoin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeLineJoin(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeLineJoin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionStrokeLineJoin>(arg);

            self->obj.StrokeLineJoin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeEndCap(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeEndCap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeEndCap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeEndCap(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeEndCap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionStrokeCap>(arg);

            self->obj.StrokeEndCap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeDashOffset(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeDashOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeDashOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeDashOffset(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeDashOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.StrokeDashOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeDashCap(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeDashCap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeDashCap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeDashCap(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeDashCap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionStrokeCap>(arg);

            self->obj.StrokeDashCap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeBrush(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_StrokeBrush(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.StrokeBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_IsStrokeNonScaling(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"IsStrokeNonScaling");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStrokeNonScaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_IsStrokeNonScaling(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"IsStrokeNonScaling");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStrokeNonScaling(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_Geometry(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"Geometry");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Geometry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_Geometry(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"Geometry");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionGeometry>(arg);

            self->obj.Geometry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_FillBrush(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"FillBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FillBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSpriteShape_put_FillBrush(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"FillBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.FillBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSpriteShape_get_StrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSpriteShape", L"StrokeDashArray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeDashArray());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionSpriteShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionSpriteShape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionSpriteShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionSpriteShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionSpriteShape[] = {
        { "_assign_array_", _assign_array_CompositionSpriteShape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionSpriteShape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionSpriteShape[] = {
        { "stroke_thickness", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeThickness), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeThickness), nullptr, nullptr },
        { "stroke_start_cap", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeStartCap), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeStartCap), nullptr, nullptr },
        { "stroke_miter_limit", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeMiterLimit), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeMiterLimit), nullptr, nullptr },
        { "stroke_line_join", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeLineJoin), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeLineJoin), nullptr, nullptr },
        { "stroke_end_cap", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeEndCap), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeEndCap), nullptr, nullptr },
        { "stroke_dash_offset", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeDashOffset), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeDashOffset), nullptr, nullptr },
        { "stroke_dash_cap", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeDashCap), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeDashCap), nullptr, nullptr },
        { "stroke_brush", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeBrush), reinterpret_cast<setter>(CompositionSpriteShape_put_StrokeBrush), nullptr, nullptr },
        { "is_stroke_non_scaling", reinterpret_cast<getter>(CompositionSpriteShape_get_IsStrokeNonScaling), reinterpret_cast<setter>(CompositionSpriteShape_put_IsStrokeNonScaling), nullptr, nullptr },
        { "geometry", reinterpret_cast<getter>(CompositionSpriteShape_get_Geometry), reinterpret_cast<setter>(CompositionSpriteShape_put_Geometry), nullptr, nullptr },
        { "fill_brush", reinterpret_cast<getter>(CompositionSpriteShape_get_FillBrush), reinterpret_cast<setter>(CompositionSpriteShape_put_FillBrush), nullptr, nullptr },
        { "stroke_dash_array", reinterpret_cast<getter>(CompositionSpriteShape_get_StrokeDashArray), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionSpriteShape[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionSpriteShape) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionSpriteShape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionSpriteShape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionSpriteShape) },
        { }
    };

    static PyType_Spec type_spec_CompositionSpriteShape = {
        "winrt._winrt_microsoft_ui_composition.CompositionSpriteShape",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionSpriteShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionSpriteShape};

    // ----- CompositionStrokeDashArray class --------------------

    static PyObject* _new_CompositionStrokeDashArray(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionStrokeDashArray>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionStrokeDashArray>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionStrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionStrokeDashArray_Append(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_Clear(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_First(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_GetAt(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_GetMany(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_GetView(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_IndexOf(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_InsertAt(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_RemoveAt(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_RemoveAtEnd(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_ReplaceAll(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<float, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_SetAt(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionStrokeDashArray_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionStrokeDashArray", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionStrokeDashArray(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionStrokeDashArray>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionStrokeDashArray(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionStrokeDashArray>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionStrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_CompositionStrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_CompositionStrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_CompositionStrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_CompositionStrokeDashArray(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<float> items(static_cast<uint32_t>(length), empty_instance<float>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_CompositionStrokeDashArray(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<float>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_CompositionStrokeDashArray[] = {
        { "append", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(CompositionStrokeDashArray_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionStrokeDashArray, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionStrokeDashArray), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionStrokeDashArray[] = {
        { "size", reinterpret_cast<getter>(CompositionStrokeDashArray_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionStrokeDashArray[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionStrokeDashArray) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionStrokeDashArray) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionStrokeDashArray) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionStrokeDashArray) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionStrokeDashArray) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_CompositionStrokeDashArray) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_CompositionStrokeDashArray) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_CompositionStrokeDashArray) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_CompositionStrokeDashArray) },
        { }
    };

    static PyType_Spec type_spec_CompositionStrokeDashArray = {
        "winrt._winrt_microsoft_ui_composition.CompositionStrokeDashArray",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionStrokeDashArray),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionStrokeDashArray};

    // ----- CompositionSurfaceBrush class --------------------

    static PyObject* _new_CompositionSurfaceBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionSurfaceBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionSurfaceBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionSurfaceBrush(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionSurfaceBrush_get_VerticalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"VerticalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_VerticalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"VerticalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.VerticalAlignmentRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_Surface(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Surface");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_Surface(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Surface");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionSurface>(arg);

            self->obj.Surface(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_Stretch(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Stretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_Stretch(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionStretch>(arg);

            self->obj.Stretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_HorizontalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"HorizontalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_HorizontalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"HorizontalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.HorizontalAlignmentRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_BitmapInterpolationMode(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"BitmapInterpolationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitmapInterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_BitmapInterpolationMode(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"BitmapInterpolationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBitmapInterpolationMode>(arg);

            self->obj.BitmapInterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_TransformMatrix(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_Scale(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_Scale(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RotationAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_RotationAngle(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_CenterPoint(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_AnchorPoint(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_AnchorPoint(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.AnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionSurfaceBrush_get_SnapToPixels(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"SnapToPixels");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SnapToPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionSurfaceBrush_put_SnapToPixels(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionSurfaceBrush", L"SnapToPixels");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SnapToPixels(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionSurfaceBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionSurfaceBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionSurfaceBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionSurfaceBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionSurfaceBrush[] = {
        { "_assign_array_", _assign_array_CompositionSurfaceBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionSurfaceBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionSurfaceBrush[] = {
        { "vertical_alignment_ratio", reinterpret_cast<getter>(CompositionSurfaceBrush_get_VerticalAlignmentRatio), reinterpret_cast<setter>(CompositionSurfaceBrush_put_VerticalAlignmentRatio), nullptr, nullptr },
        { "surface", reinterpret_cast<getter>(CompositionSurfaceBrush_get_Surface), reinterpret_cast<setter>(CompositionSurfaceBrush_put_Surface), nullptr, nullptr },
        { "stretch", reinterpret_cast<getter>(CompositionSurfaceBrush_get_Stretch), reinterpret_cast<setter>(CompositionSurfaceBrush_put_Stretch), nullptr, nullptr },
        { "horizontal_alignment_ratio", reinterpret_cast<getter>(CompositionSurfaceBrush_get_HorizontalAlignmentRatio), reinterpret_cast<setter>(CompositionSurfaceBrush_put_HorizontalAlignmentRatio), nullptr, nullptr },
        { "bitmap_interpolation_mode", reinterpret_cast<getter>(CompositionSurfaceBrush_get_BitmapInterpolationMode), reinterpret_cast<setter>(CompositionSurfaceBrush_put_BitmapInterpolationMode), nullptr, nullptr },
        { "transform_matrix", reinterpret_cast<getter>(CompositionSurfaceBrush_get_TransformMatrix), reinterpret_cast<setter>(CompositionSurfaceBrush_put_TransformMatrix), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(CompositionSurfaceBrush_get_Scale), reinterpret_cast<setter>(CompositionSurfaceBrush_put_Scale), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(CompositionSurfaceBrush_get_RotationAngleInDegrees), reinterpret_cast<setter>(CompositionSurfaceBrush_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(CompositionSurfaceBrush_get_RotationAngle), reinterpret_cast<setter>(CompositionSurfaceBrush_put_RotationAngle), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionSurfaceBrush_get_Offset), reinterpret_cast<setter>(CompositionSurfaceBrush_put_Offset), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(CompositionSurfaceBrush_get_CenterPoint), reinterpret_cast<setter>(CompositionSurfaceBrush_put_CenterPoint), nullptr, nullptr },
        { "anchor_point", reinterpret_cast<getter>(CompositionSurfaceBrush_get_AnchorPoint), reinterpret_cast<setter>(CompositionSurfaceBrush_put_AnchorPoint), nullptr, nullptr },
        { "snap_to_pixels", reinterpret_cast<getter>(CompositionSurfaceBrush_get_SnapToPixels), reinterpret_cast<setter>(CompositionSurfaceBrush_put_SnapToPixels), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionSurfaceBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionSurfaceBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionSurfaceBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionSurfaceBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionSurfaceBrush) },
        { }
    };

    static PyType_Spec type_spec_CompositionSurfaceBrush = {
        "winrt._winrt_microsoft_ui_composition.CompositionSurfaceBrush",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionSurfaceBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionSurfaceBrush};

    // ----- CompositionTransform class --------------------

    static PyObject* _new_CompositionTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionTransform(py::wrapper::Microsoft::UI::Composition::CompositionTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CompositionTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionTransform[] = {
        { "_assign_array_", _assign_array_CompositionTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionTransform[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionTransform) },
        { }
    };

    static PyType_Spec type_spec_CompositionTransform = {
        "winrt._winrt_microsoft_ui_composition.CompositionTransform",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionTransform),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionTransform};

    static PyGetSetDef getset_CompositionTransform_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionTransform_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionTransform_Static
    };

    // ----- CompositionViewBox class --------------------

    static PyObject* _new_CompositionViewBox(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionViewBox>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionViewBox>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionViewBox(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionViewBox_get_VerticalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"VerticalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionViewBox_put_VerticalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"VerticalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.VerticalAlignmentRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionViewBox_get_Stretch(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Stretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionViewBox_put_Stretch(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionStretch>(arg);

            self->obj.Stretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionViewBox_get_Size(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionViewBox_put_Size(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionViewBox_get_Offset(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionViewBox_put_Offset(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionViewBox_get_HorizontalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"HorizontalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionViewBox_put_HorizontalAlignmentRatio(py::wrapper::Microsoft::UI::Composition::CompositionViewBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionViewBox", L"HorizontalAlignmentRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.HorizontalAlignmentRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionViewBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionViewBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionViewBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionViewBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionViewBox[] = {
        { "_assign_array_", _assign_array_CompositionViewBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionViewBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionViewBox[] = {
        { "vertical_alignment_ratio", reinterpret_cast<getter>(CompositionViewBox_get_VerticalAlignmentRatio), reinterpret_cast<setter>(CompositionViewBox_put_VerticalAlignmentRatio), nullptr, nullptr },
        { "stretch", reinterpret_cast<getter>(CompositionViewBox_get_Stretch), reinterpret_cast<setter>(CompositionViewBox_put_Stretch), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(CompositionViewBox_get_Size), reinterpret_cast<setter>(CompositionViewBox_put_Size), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(CompositionViewBox_get_Offset), reinterpret_cast<setter>(CompositionViewBox_put_Offset), nullptr, nullptr },
        { "horizontal_alignment_ratio", reinterpret_cast<getter>(CompositionViewBox_get_HorizontalAlignmentRatio), reinterpret_cast<setter>(CompositionViewBox_put_HorizontalAlignmentRatio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionViewBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionViewBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionViewBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionViewBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionViewBox) },
        { }
    };

    static PyType_Spec type_spec_CompositionViewBox = {
        "winrt._winrt_microsoft_ui_composition.CompositionViewBox",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionViewBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionViewBox};

    // ----- CompositionVirtualDrawingSurface class --------------------

    static PyObject* _new_CompositionVirtualDrawingSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionVirtualDrawingSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionVirtualDrawingSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionVirtualDrawingSurface(py::wrapper::Microsoft::UI::Composition::CompositionVirtualDrawingSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionVirtualDrawingSurface_Trim(py::wrapper::Microsoft::UI::Composition::CompositionVirtualDrawingSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.CompositionVirtualDrawingSurface", L"Trim", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Graphics::RectInt32, false>>(args, 0);

                self->obj.try_as<winrt::Microsoft::UI::Composition::CompositionVirtualDrawingSurface>().Trim(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionVirtualDrawingSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionVirtualDrawingSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionVirtualDrawingSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionVirtualDrawingSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionVirtualDrawingSurface[] = {
        { "trim", reinterpret_cast<PyCFunction>(CompositionVirtualDrawingSurface_Trim), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionVirtualDrawingSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionVirtualDrawingSurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionVirtualDrawingSurface[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionVirtualDrawingSurface[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionVirtualDrawingSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionVirtualDrawingSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionVirtualDrawingSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionVirtualDrawingSurface) },
        { }
    };

    static PyType_Spec type_spec_CompositionVirtualDrawingSurface = {
        "winrt._winrt_microsoft_ui_composition.CompositionVirtualDrawingSurface",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionVirtualDrawingSurface),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CompositionVirtualDrawingSurface};

    static PyGetSetDef getset_CompositionVirtualDrawingSurface_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionVirtualDrawingSurface_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositionVirtualDrawingSurface_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionVirtualDrawingSurface_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionVirtualDrawingSurface_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionVirtualDrawingSurface_Static =
    {
        "winrt._winrt_microsoft_ui_composition.CompositionVirtualDrawingSurface_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CompositionVirtualDrawingSurface_Static
    };

    // ----- CompositionVisualSurface class --------------------

    static PyObject* _new_CompositionVisualSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CompositionVisualSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CompositionVisualSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionVisualSurface(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionVisualSurface_get_SourceVisual(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionVisualSurface", L"SourceVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceVisual());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionVisualSurface_put_SourceVisual(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionVisualSurface", L"SourceVisual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.SourceVisual(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionVisualSurface_get_SourceSize(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionVisualSurface", L"SourceSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionVisualSurface_put_SourceSize(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionVisualSurface", L"SourceSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.SourceSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionVisualSurface_get_SourceOffset(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionVisualSurface", L"SourceOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionVisualSurface_put_SourceOffset(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CompositionVisualSurface", L"SourceOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.SourceOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionVisualSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CompositionVisualSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionVisualSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CompositionVisualSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionVisualSurface[] = {
        { "_assign_array_", _assign_array_CompositionVisualSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionVisualSurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionVisualSurface[] = {
        { "source_visual", reinterpret_cast<getter>(CompositionVisualSurface_get_SourceVisual), reinterpret_cast<setter>(CompositionVisualSurface_put_SourceVisual), nullptr, nullptr },
        { "source_size", reinterpret_cast<getter>(CompositionVisualSurface_get_SourceSize), reinterpret_cast<setter>(CompositionVisualSurface_put_SourceSize), nullptr, nullptr },
        { "source_offset", reinterpret_cast<getter>(CompositionVisualSurface_get_SourceOffset), reinterpret_cast<setter>(CompositionVisualSurface_put_SourceOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositionVisualSurface[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionVisualSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionVisualSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionVisualSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionVisualSurface) },
        { }
    };

    static PyType_Spec type_spec_CompositionVisualSurface = {
        "winrt._winrt_microsoft_ui_composition.CompositionVisualSurface",
        sizeof(py::wrapper::Microsoft::UI::Composition::CompositionVisualSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionVisualSurface};

    // ----- Compositor class --------------------

    static PyObject* _new_Compositor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Composition::Compositor instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Compositor(py::wrapper::Microsoft::UI::Composition::Compositor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Compositor_Close(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateAmbientLight(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateAmbientLight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateAmbientLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateAnimationController(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateAnimationController", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateAnimationController());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateAnimationGroup(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateAnimationGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateAnimationGroup());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateAnimationPropertyInfo(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateAnimationPropertyInfo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateAnimationPropertyInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateBackdropBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateBackdropBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateBackdropBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateBooleanKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateBooleanKeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateBooleanKeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateBounceScalarAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateBounceScalarAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateBounceScalarAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateBounceVector2Animation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateBounceVector2Animation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateBounceVector2Animation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateBounceVector3Animation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateBounceVector3Animation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateBounceVector3Animation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateColorBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateColorBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateColorBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateColorBrushWithColor(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateColorBrush", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                return py::convert(self->obj.CreateColorBrush(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateColorGradientStop(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateColorGradientStop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateColorGradientStop());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateColorGradientStopWithOffsetAndColor(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateColorGradientStop", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                return py::convert(self->obj.CreateColorGradientStop(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateColorKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateColorKeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateColorKeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateContainerShape(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateContainerShape", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateContainerShape());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateContainerVisual(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateContainerVisual", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateContainerVisual());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateCubicBezierEasingFunction(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateCubicBezierEasingFunction", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);

                return py::convert(self->obj.CreateCubicBezierEasingFunction(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateDistantLight(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateDistantLight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateDistantLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateDropShadow(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateDropShadow", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateDropShadow());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateEffectFactory(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateEffectFactory", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Effects::IGraphicsEffect>(args, 0);

                return py::convert(self->obj.CreateEffectFactory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateEffectFactoryWithProperties(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateEffectFactory", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Effects::IGraphicsEffect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.CreateEffectFactory(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateEllipseGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateEllipseGeometry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateEllipseGeometry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateExpressionAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateExpressionAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateExpressionAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateExpressionAnimationWithExpression(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateExpressionAnimation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateExpressionAnimation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateGeometricClip(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateGeometricClip", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateGeometricClip());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateGeometricClipWithGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateGeometricClip", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionGeometry>(args, 0);

                return py::convert(self->obj.CreateGeometricClip(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateImplicitAnimationCollection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateImplicitAnimationCollection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateInsetClip(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateInsetClip", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateInsetClip());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateInsetClipWithInsets(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateInsetClip", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                return py::convert(self->obj.CreateInsetClip(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateLayerVisual(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateLayerVisual", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLayerVisual());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateLineGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateLineGeometry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLineGeometry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateLinearEasingFunction(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateLinearEasingFunction", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLinearEasingFunction());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateLinearGradientBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateLinearGradientBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateLinearGradientBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateMaskBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateMaskBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateMaskBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateNineGridBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateNineGridBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateNineGridBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreatePathGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreatePathGeometry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreatePathGeometry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreatePathGeometryWithPath(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreatePathGeometry", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionPath>(args, 0);

                return py::convert(self->obj.CreatePathGeometry(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreatePathKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreatePathKeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreatePathKeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreatePointLight(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreatePointLight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreatePointLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateProjectedShadow(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateProjectedShadow", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateProjectedShadow());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateProjectedShadowCaster(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateProjectedShadowCaster", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateProjectedShadowCaster());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateProjectedShadowReceiver(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateProjectedShadowReceiver", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateProjectedShadowReceiver());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreatePropertySet(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreatePropertySet", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreatePropertySet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateQuaternionKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateQuaternionKeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateQuaternionKeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRadialGradientBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRadialGradientBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateRadialGradientBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRectangleClip(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRectangleClip", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateRectangleClip());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRectangleClipWithSides(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRectangleClip", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                return py::convert(self->obj.CreateRectangleClip(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRectangleClipWithSidesAndRadius(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 8)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRectangleClip", 8);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(8);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 7);

                return py::convert(self->obj.CreateRectangleClip(param0, param1, param2, param3, param4, param5, param6, param7));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRectangleGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRectangleGeometry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateRectangleGeometry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRedirectVisual(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRedirectVisual", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateRedirectVisual());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRedirectVisualWithSourceVisual(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRedirectVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert(self->obj.CreateRedirectVisual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateRoundedRectangleGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateRoundedRectangleGeometry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateRoundedRectangleGeometry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateScalarKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateScalarKeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateScalarKeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateScopedBatch(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateScopedBatch", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBatchTypes>(args, 0);

                return py::convert(self->obj.CreateScopedBatch(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateShapeVisual(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateShapeVisual", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateShapeVisual());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpotLight(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpotLight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSpotLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpringScalarAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpringScalarAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSpringScalarAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpringVector2Animation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpringVector2Animation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSpringVector2Animation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpringVector3Animation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpringVector3Animation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSpringVector3Animation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpriteShape(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpriteShape", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSpriteShape());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpriteShapeWithGeometry(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpriteShape", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionGeometry>(args, 0);

                return py::convert(self->obj.CreateSpriteShape(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSpriteVisual(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSpriteVisual", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSpriteVisual());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateStepEasingFunction(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateStepEasingFunction", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateStepEasingFunction());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateStepEasingFunctionWithStepCount(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateStepEasingFunction", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CreateStepEasingFunction(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSurfaceBrush(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSurfaceBrush", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSurfaceBrush());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateSurfaceBrushWithSurface(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateSurfaceBrush", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionSurface>(args, 0);

                return py::convert(self->obj.CreateSurfaceBrush(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateVector2KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateVector2KeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateVector2KeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateVector3KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateVector3KeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateVector3KeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateVector4KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateVector4KeyFrameAnimation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateVector4KeyFrameAnimation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateViewBox(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateViewBox", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateViewBox());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_CreateVisualSurface(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"CreateVisualSurface", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateVisualSurface());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_GetCommitBatch(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"GetCommitBatch", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBatchTypes>(args, 0);

                return py::convert(self->obj.GetCommitBatch(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_RequestCommitAsync(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Compositor", L"RequestCommitAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestCommitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compositor_get_GlobalPlaybackRate(py::wrapper::Microsoft::UI::Composition::Compositor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"GlobalPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlobalPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compositor_put_GlobalPlaybackRate(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"GlobalPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.GlobalPlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compositor_get_Comment(py::wrapper::Microsoft::UI::Composition::Compositor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compositor_put_Comment(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Comment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compositor_get_DispatcherQueue(py::wrapper::Microsoft::UI::Composition::Compositor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compositor_get_MaxGlobalPlaybackRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"MaxGlobalPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Composition::Compositor::MaxGlobalPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compositor_get_MinGlobalPlaybackRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Compositor", L"MinGlobalPlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Composition::Compositor::MinGlobalPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Compositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Compositor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Compositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Compositor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_Compositor(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_Compositor(py::wrapper::Microsoft::UI::Composition::Compositor* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Compositor[] = {
        { "close", reinterpret_cast<PyCFunction>(Compositor_Close), METH_VARARGS, nullptr },
        { "create_ambient_light", reinterpret_cast<PyCFunction>(Compositor_CreateAmbientLight), METH_VARARGS, nullptr },
        { "create_animation_controller", reinterpret_cast<PyCFunction>(Compositor_CreateAnimationController), METH_VARARGS, nullptr },
        { "create_animation_group", reinterpret_cast<PyCFunction>(Compositor_CreateAnimationGroup), METH_VARARGS, nullptr },
        { "create_animation_property_info", reinterpret_cast<PyCFunction>(Compositor_CreateAnimationPropertyInfo), METH_VARARGS, nullptr },
        { "create_backdrop_brush", reinterpret_cast<PyCFunction>(Compositor_CreateBackdropBrush), METH_VARARGS, nullptr },
        { "create_boolean_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateBooleanKeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_bounce_scalar_animation", reinterpret_cast<PyCFunction>(Compositor_CreateBounceScalarAnimation), METH_VARARGS, nullptr },
        { "create_bounce_vector2_animation", reinterpret_cast<PyCFunction>(Compositor_CreateBounceVector2Animation), METH_VARARGS, nullptr },
        { "create_bounce_vector3_animation", reinterpret_cast<PyCFunction>(Compositor_CreateBounceVector3Animation), METH_VARARGS, nullptr },
        { "create_color_brush", reinterpret_cast<PyCFunction>(Compositor_CreateColorBrush), METH_VARARGS, nullptr },
        { "create_color_brush_with_color", reinterpret_cast<PyCFunction>(Compositor_CreateColorBrushWithColor), METH_VARARGS, nullptr },
        { "create_color_gradient_stop", reinterpret_cast<PyCFunction>(Compositor_CreateColorGradientStop), METH_VARARGS, nullptr },
        { "create_color_gradient_stop_with_offset_and_color", reinterpret_cast<PyCFunction>(Compositor_CreateColorGradientStopWithOffsetAndColor), METH_VARARGS, nullptr },
        { "create_color_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateColorKeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_container_shape", reinterpret_cast<PyCFunction>(Compositor_CreateContainerShape), METH_VARARGS, nullptr },
        { "create_container_visual", reinterpret_cast<PyCFunction>(Compositor_CreateContainerVisual), METH_VARARGS, nullptr },
        { "create_cubic_bezier_easing_function", reinterpret_cast<PyCFunction>(Compositor_CreateCubicBezierEasingFunction), METH_VARARGS, nullptr },
        { "create_distant_light", reinterpret_cast<PyCFunction>(Compositor_CreateDistantLight), METH_VARARGS, nullptr },
        { "create_drop_shadow", reinterpret_cast<PyCFunction>(Compositor_CreateDropShadow), METH_VARARGS, nullptr },
        { "create_effect_factory", reinterpret_cast<PyCFunction>(Compositor_CreateEffectFactory), METH_VARARGS, nullptr },
        { "create_effect_factory_with_properties", reinterpret_cast<PyCFunction>(Compositor_CreateEffectFactoryWithProperties), METH_VARARGS, nullptr },
        { "create_ellipse_geometry", reinterpret_cast<PyCFunction>(Compositor_CreateEllipseGeometry), METH_VARARGS, nullptr },
        { "create_expression_animation", reinterpret_cast<PyCFunction>(Compositor_CreateExpressionAnimation), METH_VARARGS, nullptr },
        { "create_expression_animation_with_expression", reinterpret_cast<PyCFunction>(Compositor_CreateExpressionAnimationWithExpression), METH_VARARGS, nullptr },
        { "create_geometric_clip", reinterpret_cast<PyCFunction>(Compositor_CreateGeometricClip), METH_VARARGS, nullptr },
        { "create_geometric_clip_with_geometry", reinterpret_cast<PyCFunction>(Compositor_CreateGeometricClipWithGeometry), METH_VARARGS, nullptr },
        { "create_implicit_animation_collection", reinterpret_cast<PyCFunction>(Compositor_CreateImplicitAnimationCollection), METH_VARARGS, nullptr },
        { "create_inset_clip", reinterpret_cast<PyCFunction>(Compositor_CreateInsetClip), METH_VARARGS, nullptr },
        { "create_inset_clip_with_insets", reinterpret_cast<PyCFunction>(Compositor_CreateInsetClipWithInsets), METH_VARARGS, nullptr },
        { "create_layer_visual", reinterpret_cast<PyCFunction>(Compositor_CreateLayerVisual), METH_VARARGS, nullptr },
        { "create_line_geometry", reinterpret_cast<PyCFunction>(Compositor_CreateLineGeometry), METH_VARARGS, nullptr },
        { "create_linear_easing_function", reinterpret_cast<PyCFunction>(Compositor_CreateLinearEasingFunction), METH_VARARGS, nullptr },
        { "create_linear_gradient_brush", reinterpret_cast<PyCFunction>(Compositor_CreateLinearGradientBrush), METH_VARARGS, nullptr },
        { "create_mask_brush", reinterpret_cast<PyCFunction>(Compositor_CreateMaskBrush), METH_VARARGS, nullptr },
        { "create_nine_grid_brush", reinterpret_cast<PyCFunction>(Compositor_CreateNineGridBrush), METH_VARARGS, nullptr },
        { "create_path_geometry", reinterpret_cast<PyCFunction>(Compositor_CreatePathGeometry), METH_VARARGS, nullptr },
        { "create_path_geometry_with_path", reinterpret_cast<PyCFunction>(Compositor_CreatePathGeometryWithPath), METH_VARARGS, nullptr },
        { "create_path_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreatePathKeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_point_light", reinterpret_cast<PyCFunction>(Compositor_CreatePointLight), METH_VARARGS, nullptr },
        { "create_projected_shadow", reinterpret_cast<PyCFunction>(Compositor_CreateProjectedShadow), METH_VARARGS, nullptr },
        { "create_projected_shadow_caster", reinterpret_cast<PyCFunction>(Compositor_CreateProjectedShadowCaster), METH_VARARGS, nullptr },
        { "create_projected_shadow_receiver", reinterpret_cast<PyCFunction>(Compositor_CreateProjectedShadowReceiver), METH_VARARGS, nullptr },
        { "create_property_set", reinterpret_cast<PyCFunction>(Compositor_CreatePropertySet), METH_VARARGS, nullptr },
        { "create_quaternion_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateQuaternionKeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_radial_gradient_brush", reinterpret_cast<PyCFunction>(Compositor_CreateRadialGradientBrush), METH_VARARGS, nullptr },
        { "create_rectangle_clip", reinterpret_cast<PyCFunction>(Compositor_CreateRectangleClip), METH_VARARGS, nullptr },
        { "create_rectangle_clip_with_sides", reinterpret_cast<PyCFunction>(Compositor_CreateRectangleClipWithSides), METH_VARARGS, nullptr },
        { "create_rectangle_clip_with_sides_and_radius", reinterpret_cast<PyCFunction>(Compositor_CreateRectangleClipWithSidesAndRadius), METH_VARARGS, nullptr },
        { "create_rectangle_geometry", reinterpret_cast<PyCFunction>(Compositor_CreateRectangleGeometry), METH_VARARGS, nullptr },
        { "create_redirect_visual", reinterpret_cast<PyCFunction>(Compositor_CreateRedirectVisual), METH_VARARGS, nullptr },
        { "create_redirect_visual_with_source_visual", reinterpret_cast<PyCFunction>(Compositor_CreateRedirectVisualWithSourceVisual), METH_VARARGS, nullptr },
        { "create_rounded_rectangle_geometry", reinterpret_cast<PyCFunction>(Compositor_CreateRoundedRectangleGeometry), METH_VARARGS, nullptr },
        { "create_scalar_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateScalarKeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_scoped_batch", reinterpret_cast<PyCFunction>(Compositor_CreateScopedBatch), METH_VARARGS, nullptr },
        { "create_shape_visual", reinterpret_cast<PyCFunction>(Compositor_CreateShapeVisual), METH_VARARGS, nullptr },
        { "create_spot_light", reinterpret_cast<PyCFunction>(Compositor_CreateSpotLight), METH_VARARGS, nullptr },
        { "create_spring_scalar_animation", reinterpret_cast<PyCFunction>(Compositor_CreateSpringScalarAnimation), METH_VARARGS, nullptr },
        { "create_spring_vector2_animation", reinterpret_cast<PyCFunction>(Compositor_CreateSpringVector2Animation), METH_VARARGS, nullptr },
        { "create_spring_vector3_animation", reinterpret_cast<PyCFunction>(Compositor_CreateSpringVector3Animation), METH_VARARGS, nullptr },
        { "create_sprite_shape", reinterpret_cast<PyCFunction>(Compositor_CreateSpriteShape), METH_VARARGS, nullptr },
        { "create_sprite_shape_with_geometry", reinterpret_cast<PyCFunction>(Compositor_CreateSpriteShapeWithGeometry), METH_VARARGS, nullptr },
        { "create_sprite_visual", reinterpret_cast<PyCFunction>(Compositor_CreateSpriteVisual), METH_VARARGS, nullptr },
        { "create_step_easing_function", reinterpret_cast<PyCFunction>(Compositor_CreateStepEasingFunction), METH_VARARGS, nullptr },
        { "create_step_easing_function_with_step_count", reinterpret_cast<PyCFunction>(Compositor_CreateStepEasingFunctionWithStepCount), METH_VARARGS, nullptr },
        { "create_surface_brush", reinterpret_cast<PyCFunction>(Compositor_CreateSurfaceBrush), METH_VARARGS, nullptr },
        { "create_surface_brush_with_surface", reinterpret_cast<PyCFunction>(Compositor_CreateSurfaceBrushWithSurface), METH_VARARGS, nullptr },
        { "create_vector2_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateVector2KeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_vector3_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateVector3KeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_vector4_key_frame_animation", reinterpret_cast<PyCFunction>(Compositor_CreateVector4KeyFrameAnimation), METH_VARARGS, nullptr },
        { "create_view_box", reinterpret_cast<PyCFunction>(Compositor_CreateViewBox), METH_VARARGS, nullptr },
        { "create_visual_surface", reinterpret_cast<PyCFunction>(Compositor_CreateVisualSurface), METH_VARARGS, nullptr },
        { "get_commit_batch", reinterpret_cast<PyCFunction>(Compositor_GetCommitBatch), METH_VARARGS, nullptr },
        { "request_commit_async", reinterpret_cast<PyCFunction>(Compositor_RequestCommitAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Compositor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Compositor), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_Compositor), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_Compositor), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_Compositor[] = {
        { "global_playback_rate", reinterpret_cast<getter>(Compositor_get_GlobalPlaybackRate), reinterpret_cast<setter>(Compositor_put_GlobalPlaybackRate), nullptr, nullptr },
        { "comment", reinterpret_cast<getter>(Compositor_get_Comment), reinterpret_cast<setter>(Compositor_put_Comment), nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(Compositor_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Compositor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Compositor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Compositor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Compositor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Compositor) },
        { }
    };

    static PyType_Spec type_spec_Compositor = {
        "winrt._winrt_microsoft_ui_composition.Compositor",
        sizeof(py::wrapper::Microsoft::UI::Composition::Compositor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Compositor};

    static PyGetSetDef getset_Compositor_Static[] = {
        { "max_global_playback_rate", reinterpret_cast<getter>(Compositor_get_MaxGlobalPlaybackRate), nullptr, nullptr, nullptr },
        { "min_global_playback_rate", reinterpret_cast<getter>(Compositor_get_MinGlobalPlaybackRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Compositor_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Compositor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Compositor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Compositor_Static) },
        { }
    };

    static PyType_Spec type_spec_Compositor_Static =
    {
        "winrt._winrt_microsoft_ui_composition.Compositor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Compositor_Static
    };

    // ----- ContainerVisual class --------------------

    static PyObject* _new_ContainerVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ContainerVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ContainerVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_ContainerVisual(py::wrapper::Microsoft::UI::Composition::ContainerVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContainerVisual_get_Children(py::wrapper::Microsoft::UI::Composition::ContainerVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ContainerVisual", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::ContainerVisual>().Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContainerVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ContainerVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContainerVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ContainerVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContainerVisual[] = {
        { "_assign_array_", _assign_array_ContainerVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContainerVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContainerVisual[] = {
        { "children", reinterpret_cast<getter>(ContainerVisual_get_Children), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContainerVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContainerVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContainerVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContainerVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContainerVisual) },
        { }
    };

    static PyType_Spec type_spec_ContainerVisual = {
        "winrt._winrt_microsoft_ui_composition.ContainerVisual",
        sizeof(py::wrapper::Microsoft::UI::Composition::ContainerVisual),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContainerVisual};

    static PyGetSetDef getset_ContainerVisual_Static[] = {
        { }
    };

    static PyMethodDef methods_ContainerVisual_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ContainerVisual_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContainerVisual_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContainerVisual_Static) },
        { }
    };

    static PyType_Spec type_spec_ContainerVisual_Static =
    {
        "winrt._winrt_microsoft_ui_composition.ContainerVisual_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContainerVisual_Static
    };

    // ----- CubicBezierEasingFunction class --------------------

    static PyObject* _new_CubicBezierEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::CubicBezierEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::CubicBezierEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_CubicBezierEasingFunction(py::wrapper::Microsoft::UI::Composition::CubicBezierEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CubicBezierEasingFunction_get_ControlPoint1(py::wrapper::Microsoft::UI::Composition::CubicBezierEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CubicBezierEasingFunction", L"ControlPoint1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControlPoint1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CubicBezierEasingFunction_get_ControlPoint2(py::wrapper::Microsoft::UI::Composition::CubicBezierEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.CubicBezierEasingFunction", L"ControlPoint2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControlPoint2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CubicBezierEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::CubicBezierEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CubicBezierEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::CubicBezierEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CubicBezierEasingFunction[] = {
        { "_assign_array_", _assign_array_CubicBezierEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CubicBezierEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CubicBezierEasingFunction[] = {
        { "control_point1", reinterpret_cast<getter>(CubicBezierEasingFunction_get_ControlPoint1), nullptr, nullptr, nullptr },
        { "control_point2", reinterpret_cast<getter>(CubicBezierEasingFunction_get_ControlPoint2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CubicBezierEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CubicBezierEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CubicBezierEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CubicBezierEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CubicBezierEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_CubicBezierEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.CubicBezierEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::CubicBezierEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CubicBezierEasingFunction};

    // ----- DistantLight class --------------------

    static PyObject* _new_DistantLight(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::DistantLight>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::DistantLight>::type_name);
        return nullptr;
    }

    static void _dealloc_DistantLight(py::wrapper::Microsoft::UI::Composition::DistantLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DistantLight_get_Direction(py::wrapper::Microsoft::UI::Composition::DistantLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DistantLight_put_Direction(py::wrapper::Microsoft::UI::Composition::DistantLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DistantLight_get_CoordinateSpace(py::wrapper::Microsoft::UI::Composition::DistantLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"CoordinateSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CoordinateSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DistantLight_put_CoordinateSpace(py::wrapper::Microsoft::UI::Composition::DistantLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"CoordinateSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.CoordinateSpace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DistantLight_get_Color(py::wrapper::Microsoft::UI::Composition::DistantLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DistantLight_put_Color(py::wrapper::Microsoft::UI::Composition::DistantLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DistantLight_get_Intensity(py::wrapper::Microsoft::UI::Composition::DistantLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"Intensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Intensity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DistantLight_put_Intensity(py::wrapper::Microsoft::UI::Composition::DistantLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DistantLight", L"Intensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Intensity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DistantLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::DistantLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DistantLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::DistantLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DistantLight[] = {
        { "_assign_array_", _assign_array_DistantLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DistantLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DistantLight[] = {
        { "direction", reinterpret_cast<getter>(DistantLight_get_Direction), reinterpret_cast<setter>(DistantLight_put_Direction), nullptr, nullptr },
        { "coordinate_space", reinterpret_cast<getter>(DistantLight_get_CoordinateSpace), reinterpret_cast<setter>(DistantLight_put_CoordinateSpace), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(DistantLight_get_Color), reinterpret_cast<setter>(DistantLight_put_Color), nullptr, nullptr },
        { "intensity", reinterpret_cast<getter>(DistantLight_get_Intensity), reinterpret_cast<setter>(DistantLight_put_Intensity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DistantLight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DistantLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DistantLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DistantLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DistantLight) },
        { }
    };

    static PyType_Spec type_spec_DistantLight = {
        "winrt._winrt_microsoft_ui_composition.DistantLight",
        sizeof(py::wrapper::Microsoft::UI::Composition::DistantLight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DistantLight};

    // ----- DropShadow class --------------------

    static PyObject* _new_DropShadow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::DropShadow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::DropShadow>::type_name);
        return nullptr;
    }

    static void _dealloc_DropShadow(py::wrapper::Microsoft::UI::Composition::DropShadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DropShadow_get_Opacity(py::wrapper::Microsoft::UI::Composition::DropShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropShadow_put_Opacity(py::wrapper::Microsoft::UI::Composition::DropShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DropShadow_get_Offset(py::wrapper::Microsoft::UI::Composition::DropShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropShadow_put_Offset(py::wrapper::Microsoft::UI::Composition::DropShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DropShadow_get_Mask(py::wrapper::Microsoft::UI::Composition::DropShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Mask");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropShadow_put_Mask(py::wrapper::Microsoft::UI::Composition::DropShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Mask");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.Mask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DropShadow_get_Color(py::wrapper::Microsoft::UI::Composition::DropShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropShadow_put_Color(py::wrapper::Microsoft::UI::Composition::DropShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DropShadow_get_BlurRadius(py::wrapper::Microsoft::UI::Composition::DropShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"BlurRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BlurRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropShadow_put_BlurRadius(py::wrapper::Microsoft::UI::Composition::DropShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"BlurRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.BlurRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DropShadow_get_SourcePolicy(py::wrapper::Microsoft::UI::Composition::DropShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"SourcePolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourcePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropShadow_put_SourcePolicy(py::wrapper::Microsoft::UI::Composition::DropShadow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.DropShadow", L"SourcePolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionDropShadowSourcePolicy>(arg);

            self->obj.SourcePolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DropShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::DropShadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::DropShadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropShadow[] = {
        { "_assign_array_", _assign_array_DropShadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropShadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropShadow[] = {
        { "opacity", reinterpret_cast<getter>(DropShadow_get_Opacity), reinterpret_cast<setter>(DropShadow_put_Opacity), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(DropShadow_get_Offset), reinterpret_cast<setter>(DropShadow_put_Offset), nullptr, nullptr },
        { "mask", reinterpret_cast<getter>(DropShadow_get_Mask), reinterpret_cast<setter>(DropShadow_put_Mask), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(DropShadow_get_Color), reinterpret_cast<setter>(DropShadow_put_Color), nullptr, nullptr },
        { "blur_radius", reinterpret_cast<getter>(DropShadow_get_BlurRadius), reinterpret_cast<setter>(DropShadow_put_BlurRadius), nullptr, nullptr },
        { "source_policy", reinterpret_cast<getter>(DropShadow_get_SourcePolicy), reinterpret_cast<setter>(DropShadow_put_SourcePolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DropShadow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropShadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropShadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropShadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropShadow) },
        { }
    };

    static PyType_Spec type_spec_DropShadow = {
        "winrt._winrt_microsoft_ui_composition.DropShadow",
        sizeof(py::wrapper::Microsoft::UI::Composition::DropShadow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropShadow};

    // ----- ElasticEasingFunction class --------------------

    static PyObject* _new_ElasticEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ElasticEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ElasticEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_ElasticEasingFunction(py::wrapper::Microsoft::UI::Composition::ElasticEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElasticEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::ElasticEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ElasticEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElasticEasingFunction_get_Oscillations(py::wrapper::Microsoft::UI::Composition::ElasticEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ElasticEasingFunction", L"Oscillations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Oscillations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElasticEasingFunction_get_Springiness(py::wrapper::Microsoft::UI::Composition::ElasticEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ElasticEasingFunction", L"Springiness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Springiness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ElasticEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ElasticEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElasticEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ElasticEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElasticEasingFunction[] = {
        { "_assign_array_", _assign_array_ElasticEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElasticEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ElasticEasingFunction[] = {
        { "mode", reinterpret_cast<getter>(ElasticEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { "oscillations", reinterpret_cast<getter>(ElasticEasingFunction_get_Oscillations), nullptr, nullptr, nullptr },
        { "springiness", reinterpret_cast<getter>(ElasticEasingFunction_get_Springiness), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ElasticEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElasticEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElasticEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElasticEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElasticEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_ElasticEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.ElasticEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::ElasticEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElasticEasingFunction};

    // ----- ExponentialEasingFunction class --------------------

    static PyObject* _new_ExponentialEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ExponentialEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ExponentialEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_ExponentialEasingFunction(py::wrapper::Microsoft::UI::Composition::ExponentialEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExponentialEasingFunction_get_Exponent(py::wrapper::Microsoft::UI::Composition::ExponentialEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ExponentialEasingFunction", L"Exponent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Exponent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExponentialEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::ExponentialEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ExponentialEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExponentialEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ExponentialEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExponentialEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ExponentialEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExponentialEasingFunction[] = {
        { "_assign_array_", _assign_array_ExponentialEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExponentialEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExponentialEasingFunction[] = {
        { "exponent", reinterpret_cast<getter>(ExponentialEasingFunction_get_Exponent), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ExponentialEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExponentialEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExponentialEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExponentialEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExponentialEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExponentialEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_ExponentialEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.ExponentialEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::ExponentialEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExponentialEasingFunction};

    // ----- ExpressionAnimation class --------------------

    static PyObject* _new_ExpressionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ExpressionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ExpressionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_ExpressionAnimation(py::wrapper::Microsoft::UI::Composition::ExpressionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExpressionAnimation_get_Expression(py::wrapper::Microsoft::UI::Composition::ExpressionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ExpressionAnimation", L"Expression");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Expression());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ExpressionAnimation_put_Expression(py::wrapper::Microsoft::UI::Composition::ExpressionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ExpressionAnimation", L"Expression");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Expression(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ExpressionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ExpressionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpressionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ExpressionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpressionAnimation[] = {
        { "_assign_array_", _assign_array_ExpressionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpressionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExpressionAnimation[] = {
        { "expression", reinterpret_cast<getter>(ExpressionAnimation_get_Expression), reinterpret_cast<setter>(ExpressionAnimation_put_Expression), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExpressionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpressionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpressionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpressionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpressionAnimation) },
        { }
    };

    static PyType_Spec type_spec_ExpressionAnimation = {
        "winrt._winrt_microsoft_ui_composition.ExpressionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::ExpressionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExpressionAnimation};

    // ----- ImplicitAnimationCollection class --------------------

    static PyObject* _new_ImplicitAnimationCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ImplicitAnimationCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ImplicitAnimationCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_ImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImplicitAnimationCollection_Clear(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_First(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_GetView(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_HasKey(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"HasKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_Insert(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"Insert", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_Lookup(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"Lookup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_Remove(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImplicitAnimationCollection_get_Size(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ImplicitAnimationCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImplicitAnimationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ImplicitAnimationCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImplicitAnimationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ImplicitAnimationCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ImplicitAnimationCollection(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ImplicitAnimationCollection[] = {
        { "clear", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ImplicitAnimationCollection_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImplicitAnimationCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImplicitAnimationCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImplicitAnimationCollection[] = {
        { "size", reinterpret_cast<getter>(ImplicitAnimationCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImplicitAnimationCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImplicitAnimationCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImplicitAnimationCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImplicitAnimationCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImplicitAnimationCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ImplicitAnimationCollection) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_ImplicitAnimationCollection) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_ImplicitAnimationCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_ImplicitAnimationCollection) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_ImplicitAnimationCollection) },
        { }
    };

    static PyType_Spec type_spec_ImplicitAnimationCollection = {
        "winrt._winrt_microsoft_ui_composition.ImplicitAnimationCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::ImplicitAnimationCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImplicitAnimationCollection};

    // ----- InitialValueExpressionCollection class --------------------

    static PyObject* _new_InitialValueExpressionCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::InitialValueExpressionCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::InitialValueExpressionCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_InitialValueExpressionCollection(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InitialValueExpressionCollection_Clear(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_First(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_GetView(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_HasKey(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"HasKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_Insert(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"Insert", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_Lookup(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"Lookup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_Remove(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitialValueExpressionCollection_get_Size(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InitialValueExpressionCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InitialValueExpressionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::InitialValueExpressionCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InitialValueExpressionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::InitialValueExpressionCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_InitialValueExpressionCollection(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_InitialValueExpressionCollection(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_InitialValueExpressionCollection(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_InitialValueExpressionCollection(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_InitialValueExpressionCollection(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::hstring>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_InitialValueExpressionCollection[] = {
        { "clear", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(InitialValueExpressionCollection_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InitialValueExpressionCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InitialValueExpressionCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InitialValueExpressionCollection[] = {
        { "size", reinterpret_cast<getter>(InitialValueExpressionCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InitialValueExpressionCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InitialValueExpressionCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InitialValueExpressionCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InitialValueExpressionCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InitialValueExpressionCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_InitialValueExpressionCollection) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_InitialValueExpressionCollection) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_InitialValueExpressionCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_InitialValueExpressionCollection) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_InitialValueExpressionCollection) },
        { }
    };

    static PyType_Spec type_spec_InitialValueExpressionCollection = {
        "winrt._winrt_microsoft_ui_composition.InitialValueExpressionCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::InitialValueExpressionCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InitialValueExpressionCollection};

    // ----- InsetClip class --------------------

    static PyObject* _new_InsetClip(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::InsetClip>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::InsetClip>::type_name);
        return nullptr;
    }

    static void _dealloc_InsetClip(py::wrapper::Microsoft::UI::Composition::InsetClip* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InsetClip_get_TopInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"TopInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TopInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InsetClip_put_TopInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"TopInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.TopInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InsetClip_get_RightInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"RightInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RightInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InsetClip_put_RightInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"RightInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RightInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InsetClip_get_LeftInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"LeftInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LeftInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InsetClip_put_LeftInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"LeftInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.LeftInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InsetClip_get_BottomInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"BottomInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BottomInset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InsetClip_put_BottomInset(py::wrapper::Microsoft::UI::Composition::InsetClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.InsetClip", L"BottomInset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.BottomInset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InsetClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::InsetClip>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InsetClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::InsetClip>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InsetClip[] = {
        { "_assign_array_", _assign_array_InsetClip, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InsetClip), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InsetClip[] = {
        { "top_inset", reinterpret_cast<getter>(InsetClip_get_TopInset), reinterpret_cast<setter>(InsetClip_put_TopInset), nullptr, nullptr },
        { "right_inset", reinterpret_cast<getter>(InsetClip_get_RightInset), reinterpret_cast<setter>(InsetClip_put_RightInset), nullptr, nullptr },
        { "left_inset", reinterpret_cast<getter>(InsetClip_get_LeftInset), reinterpret_cast<setter>(InsetClip_put_LeftInset), nullptr, nullptr },
        { "bottom_inset", reinterpret_cast<getter>(InsetClip_get_BottomInset), reinterpret_cast<setter>(InsetClip_put_BottomInset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InsetClip[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InsetClip) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InsetClip) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InsetClip) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InsetClip) },
        { }
    };

    static PyType_Spec type_spec_InsetClip = {
        "winrt._winrt_microsoft_ui_composition.InsetClip",
        sizeof(py::wrapper::Microsoft::UI::Composition::InsetClip),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InsetClip};

    // ----- KeyFrameAnimation class --------------------

    static PyObject* _new_KeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::KeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::KeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyFrameAnimation_InsertExpressionKeyFrame(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"InsertExpressionKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().InsertExpressionKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyFrameAnimation_InsertExpressionKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"InsertExpressionKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().InsertExpressionKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyFrameAnimation_get_StopBehavior(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"StopBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().StopBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_StopBehavior(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"StopBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationStopBehavior>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().StopBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyFrameAnimation_get_IterationCount(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"IterationCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().IterationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_IterationCount(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"IterationCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().IterationCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyFrameAnimation_get_IterationBehavior(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"IterationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().IterationBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_IterationBehavior(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"IterationBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationIterationBehavior>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().IterationBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyFrameAnimation_get_Duration(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_Duration(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyFrameAnimation_get_DelayTime(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"DelayTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().DelayTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_DelayTime(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"DelayTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().DelayTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyFrameAnimation_get_KeyFrameCount(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"KeyFrameCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().KeyFrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyFrameAnimation_get_Direction(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_Direction(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationDirection>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyFrameAnimation_get_DelayBehavior(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"DelayBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().DelayBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyFrameAnimation_put_DelayBehavior(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.KeyFrameAnimation", L"DelayBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationDelayBehavior>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>().DelayBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::KeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::KeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyFrameAnimation[] = {
        { "insert_expression_key_frame", reinterpret_cast<PyCFunction>(KeyFrameAnimation_InsertExpressionKeyFrame), METH_VARARGS, nullptr },
        { "insert_expression_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(KeyFrameAnimation_InsertExpressionKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_KeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyFrameAnimation[] = {
        { "stop_behavior", reinterpret_cast<getter>(KeyFrameAnimation_get_StopBehavior), reinterpret_cast<setter>(KeyFrameAnimation_put_StopBehavior), nullptr, nullptr },
        { "iteration_count", reinterpret_cast<getter>(KeyFrameAnimation_get_IterationCount), reinterpret_cast<setter>(KeyFrameAnimation_put_IterationCount), nullptr, nullptr },
        { "iteration_behavior", reinterpret_cast<getter>(KeyFrameAnimation_get_IterationBehavior), reinterpret_cast<setter>(KeyFrameAnimation_put_IterationBehavior), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(KeyFrameAnimation_get_Duration), reinterpret_cast<setter>(KeyFrameAnimation_put_Duration), nullptr, nullptr },
        { "delay_time", reinterpret_cast<getter>(KeyFrameAnimation_get_DelayTime), reinterpret_cast<setter>(KeyFrameAnimation_put_DelayTime), nullptr, nullptr },
        { "key_frame_count", reinterpret_cast<getter>(KeyFrameAnimation_get_KeyFrameCount), nullptr, nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(KeyFrameAnimation_get_Direction), reinterpret_cast<setter>(KeyFrameAnimation_put_Direction), nullptr, nullptr },
        { "delay_behavior", reinterpret_cast<getter>(KeyFrameAnimation_get_DelayBehavior), reinterpret_cast<setter>(KeyFrameAnimation_put_DelayBehavior), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_KeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.KeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::KeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_KeyFrameAnimation};

    static PyGetSetDef getset_KeyFrameAnimation_Static[] = {
        { }
    };

    static PyMethodDef methods_KeyFrameAnimation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KeyFrameAnimation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyFrameAnimation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyFrameAnimation_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyFrameAnimation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.KeyFrameAnimation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_KeyFrameAnimation_Static
    };

    // ----- LayerVisual class --------------------

    static PyObject* _new_LayerVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::LayerVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::LayerVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_LayerVisual(py::wrapper::Microsoft::UI::Composition::LayerVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LayerVisual_get_Effect(py::wrapper::Microsoft::UI::Composition::LayerVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.LayerVisual", L"Effect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Effect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LayerVisual_put_Effect(py::wrapper::Microsoft::UI::Composition::LayerVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.LayerVisual", L"Effect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEffectBrush>(arg);

            self->obj.Effect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LayerVisual_get_Shadow(py::wrapper::Microsoft::UI::Composition::LayerVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.LayerVisual", L"Shadow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shadow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LayerVisual_put_Shadow(py::wrapper::Microsoft::UI::Composition::LayerVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.LayerVisual", L"Shadow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionShadow>(arg);

            self->obj.Shadow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LayerVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::LayerVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LayerVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::LayerVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LayerVisual[] = {
        { "_assign_array_", _assign_array_LayerVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LayerVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LayerVisual[] = {
        { "effect", reinterpret_cast<getter>(LayerVisual_get_Effect), reinterpret_cast<setter>(LayerVisual_put_Effect), nullptr, nullptr },
        { "shadow", reinterpret_cast<getter>(LayerVisual_get_Shadow), reinterpret_cast<setter>(LayerVisual_put_Shadow), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LayerVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LayerVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LayerVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LayerVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LayerVisual) },
        { }
    };

    static PyType_Spec type_spec_LayerVisual = {
        "winrt._winrt_microsoft_ui_composition.LayerVisual",
        sizeof(py::wrapper::Microsoft::UI::Composition::LayerVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LayerVisual};

    // ----- LinearEasingFunction class --------------------

    static PyObject* _new_LinearEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::LinearEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::LinearEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_LinearEasingFunction(py::wrapper::Microsoft::UI::Composition::LinearEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LinearEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::LinearEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LinearEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::LinearEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LinearEasingFunction[] = {
        { "_assign_array_", _assign_array_LinearEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LinearEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LinearEasingFunction[] = {
        { }
    };

    static PyType_Slot _type_slots_LinearEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LinearEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LinearEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LinearEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LinearEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_LinearEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.LinearEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::LinearEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LinearEasingFunction};

    // ----- NaturalMotionAnimation class --------------------

    static PyObject* _new_NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NaturalMotionAnimation_get_StopBehavior(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.NaturalMotionAnimation", L"StopBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>().StopBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NaturalMotionAnimation_put_StopBehavior(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.NaturalMotionAnimation", L"StopBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationStopBehavior>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>().StopBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NaturalMotionAnimation_get_DelayTime(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.NaturalMotionAnimation", L"DelayTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>().DelayTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NaturalMotionAnimation_put_DelayTime(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.NaturalMotionAnimation", L"DelayTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>().DelayTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NaturalMotionAnimation_get_DelayBehavior(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.NaturalMotionAnimation", L"DelayBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>().DelayBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NaturalMotionAnimation_put_DelayBehavior(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.NaturalMotionAnimation", L"DelayBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationDelayBehavior>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>().DelayBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NaturalMotionAnimation[] = {
        { "stop_behavior", reinterpret_cast<getter>(NaturalMotionAnimation_get_StopBehavior), reinterpret_cast<setter>(NaturalMotionAnimation_put_StopBehavior), nullptr, nullptr },
        { "delay_time", reinterpret_cast<getter>(NaturalMotionAnimation_get_DelayTime), reinterpret_cast<setter>(NaturalMotionAnimation_put_DelayTime), nullptr, nullptr },
        { "delay_behavior", reinterpret_cast<getter>(NaturalMotionAnimation_get_DelayBehavior), reinterpret_cast<setter>(NaturalMotionAnimation_put_DelayBehavior), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NaturalMotionAnimation};

    static PyGetSetDef getset_NaturalMotionAnimation_Static[] = {
        { }
    };

    static PyMethodDef methods_NaturalMotionAnimation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NaturalMotionAnimation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NaturalMotionAnimation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NaturalMotionAnimation_Static) },
        { }
    };

    static PyType_Spec type_spec_NaturalMotionAnimation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.NaturalMotionAnimation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NaturalMotionAnimation_Static
    };

    // ----- PathKeyFrameAnimation class --------------------

    static PyObject* _new_PathKeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::PathKeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::PathKeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_PathKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::PathKeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathKeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::PathKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.PathKeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionPath>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathKeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::PathKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.PathKeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionPath>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::PathKeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::PathKeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathKeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(PathKeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(PathKeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PathKeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathKeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathKeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_PathKeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathKeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathKeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathKeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathKeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_PathKeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.PathKeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::PathKeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathKeyFrameAnimation};

    // ----- PointLight class --------------------

    static PyObject* _new_PointLight(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::PointLight>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::PointLight>::type_name);
        return nullptr;
    }

    static void _dealloc_PointLight(py::wrapper::Microsoft::UI::Composition::PointLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointLight_get_QuadraticAttenuation(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"QuadraticAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuadraticAttenuation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_QuadraticAttenuation(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"QuadraticAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.QuadraticAttenuation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_Offset(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_Offset(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_LinearAttenuation(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"LinearAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinearAttenuation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_LinearAttenuation(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"LinearAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.LinearAttenuation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_CoordinateSpace(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"CoordinateSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CoordinateSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_CoordinateSpace(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"CoordinateSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.CoordinateSpace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_ConstantAttenuation(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"ConstantAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConstantAttenuation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_ConstantAttenuation(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"ConstantAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.ConstantAttenuation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_Color(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_Color(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_Intensity(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"Intensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Intensity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_Intensity(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"Intensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Intensity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_MinAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"MinAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinAttenuationCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_MinAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"MinAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MinAttenuationCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointLight_get_MaxAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::PointLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"MaxAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxAttenuationCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointLight_put_MaxAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::PointLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PointLight", L"MaxAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxAttenuationCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PointLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::PointLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::PointLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointLight[] = {
        { "_assign_array_", _assign_array_PointLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointLight[] = {
        { "quadratic_attenuation", reinterpret_cast<getter>(PointLight_get_QuadraticAttenuation), reinterpret_cast<setter>(PointLight_put_QuadraticAttenuation), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(PointLight_get_Offset), reinterpret_cast<setter>(PointLight_put_Offset), nullptr, nullptr },
        { "linear_attenuation", reinterpret_cast<getter>(PointLight_get_LinearAttenuation), reinterpret_cast<setter>(PointLight_put_LinearAttenuation), nullptr, nullptr },
        { "coordinate_space", reinterpret_cast<getter>(PointLight_get_CoordinateSpace), reinterpret_cast<setter>(PointLight_put_CoordinateSpace), nullptr, nullptr },
        { "constant_attenuation", reinterpret_cast<getter>(PointLight_get_ConstantAttenuation), reinterpret_cast<setter>(PointLight_put_ConstantAttenuation), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(PointLight_get_Color), reinterpret_cast<setter>(PointLight_put_Color), nullptr, nullptr },
        { "intensity", reinterpret_cast<getter>(PointLight_get_Intensity), reinterpret_cast<setter>(PointLight_put_Intensity), nullptr, nullptr },
        { "min_attenuation_cutoff", reinterpret_cast<getter>(PointLight_get_MinAttenuationCutoff), reinterpret_cast<setter>(PointLight_put_MinAttenuationCutoff), nullptr, nullptr },
        { "max_attenuation_cutoff", reinterpret_cast<getter>(PointLight_get_MaxAttenuationCutoff), reinterpret_cast<setter>(PointLight_put_MaxAttenuationCutoff), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointLight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointLight) },
        { }
    };

    static PyType_Spec type_spec_PointLight = {
        "winrt._winrt_microsoft_ui_composition.PointLight",
        sizeof(py::wrapper::Microsoft::UI::Composition::PointLight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointLight};

    // ----- PowerEasingFunction class --------------------

    static PyObject* _new_PowerEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::PowerEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::PowerEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_PowerEasingFunction(py::wrapper::Microsoft::UI::Composition::PowerEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PowerEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::PowerEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PowerEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PowerEasingFunction_get_Power(py::wrapper::Microsoft::UI::Composition::PowerEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.PowerEasingFunction", L"Power");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Power());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PowerEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::PowerEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PowerEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::PowerEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PowerEasingFunction[] = {
        { "_assign_array_", _assign_array_PowerEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PowerEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PowerEasingFunction[] = {
        { "mode", reinterpret_cast<getter>(PowerEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { "power", reinterpret_cast<getter>(PowerEasingFunction_get_Power), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PowerEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PowerEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PowerEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PowerEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PowerEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_PowerEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.PowerEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::PowerEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PowerEasingFunction};

    // ----- QuaternionKeyFrameAnimation class --------------------

    static PyObject* _new_QuaternionKeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::QuaternionKeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::QuaternionKeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_QuaternionKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::QuaternionKeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* QuaternionKeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::QuaternionKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.QuaternionKeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* QuaternionKeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::QuaternionKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.QuaternionKeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_QuaternionKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::QuaternionKeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_QuaternionKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::QuaternionKeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_QuaternionKeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(QuaternionKeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(QuaternionKeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_QuaternionKeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_QuaternionKeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_QuaternionKeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_QuaternionKeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_QuaternionKeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_QuaternionKeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_QuaternionKeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_QuaternionKeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_QuaternionKeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.QuaternionKeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::QuaternionKeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_QuaternionKeyFrameAnimation};

    // ----- RectangleClip class --------------------

    static PyObject* _new_RectangleClip(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::RectangleClip>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::RectangleClip>::type_name);
        return nullptr;
    }

    static void _dealloc_RectangleClip(py::wrapper::Microsoft::UI::Composition::RectangleClip* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RectangleClip_get_TopRightRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"TopRightRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TopRightRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_TopRightRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"TopRightRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.TopRightRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_TopLeftRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"TopLeftRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TopLeftRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_TopLeftRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"TopLeftRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.TopLeftRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_Top(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Top");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Top());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_Top(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Top");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Top(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_Right(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Right");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Right());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_Right(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Right");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Right(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_Left(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Left");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Left());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_Left(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Left");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Left(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_BottomRightRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"BottomRightRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BottomRightRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_BottomRightRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"BottomRightRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.BottomRightRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_BottomLeftRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"BottomLeftRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BottomLeftRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_BottomLeftRadius(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"BottomLeftRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.BottomLeftRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleClip_get_Bottom(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Bottom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bottom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleClip_put_Bottom(py::wrapper::Microsoft::UI::Composition::RectangleClip* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RectangleClip", L"Bottom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Bottom(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RectangleClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::RectangleClip>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RectangleClip(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::RectangleClip>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RectangleClip[] = {
        { "_assign_array_", _assign_array_RectangleClip, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RectangleClip), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RectangleClip[] = {
        { "top_right_radius", reinterpret_cast<getter>(RectangleClip_get_TopRightRadius), reinterpret_cast<setter>(RectangleClip_put_TopRightRadius), nullptr, nullptr },
        { "top_left_radius", reinterpret_cast<getter>(RectangleClip_get_TopLeftRadius), reinterpret_cast<setter>(RectangleClip_put_TopLeftRadius), nullptr, nullptr },
        { "top", reinterpret_cast<getter>(RectangleClip_get_Top), reinterpret_cast<setter>(RectangleClip_put_Top), nullptr, nullptr },
        { "right", reinterpret_cast<getter>(RectangleClip_get_Right), reinterpret_cast<setter>(RectangleClip_put_Right), nullptr, nullptr },
        { "left", reinterpret_cast<getter>(RectangleClip_get_Left), reinterpret_cast<setter>(RectangleClip_put_Left), nullptr, nullptr },
        { "bottom_right_radius", reinterpret_cast<getter>(RectangleClip_get_BottomRightRadius), reinterpret_cast<setter>(RectangleClip_put_BottomRightRadius), nullptr, nullptr },
        { "bottom_left_radius", reinterpret_cast<getter>(RectangleClip_get_BottomLeftRadius), reinterpret_cast<setter>(RectangleClip_put_BottomLeftRadius), nullptr, nullptr },
        { "bottom", reinterpret_cast<getter>(RectangleClip_get_Bottom), reinterpret_cast<setter>(RectangleClip_put_Bottom), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RectangleClip[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RectangleClip) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RectangleClip) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RectangleClip) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RectangleClip) },
        { }
    };

    static PyType_Spec type_spec_RectangleClip = {
        "winrt._winrt_microsoft_ui_composition.RectangleClip",
        sizeof(py::wrapper::Microsoft::UI::Composition::RectangleClip),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RectangleClip};

    // ----- RedirectVisual class --------------------

    static PyObject* _new_RedirectVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::RedirectVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::RedirectVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_RedirectVisual(py::wrapper::Microsoft::UI::Composition::RedirectVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RedirectVisual_get_Source(py::wrapper::Microsoft::UI::Composition::RedirectVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RedirectVisual", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RedirectVisual_put_Source(py::wrapper::Microsoft::UI::Composition::RedirectVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RedirectVisual", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RedirectVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::RedirectVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RedirectVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::RedirectVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RedirectVisual[] = {
        { "_assign_array_", _assign_array_RedirectVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RedirectVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RedirectVisual[] = {
        { "source", reinterpret_cast<getter>(RedirectVisual_get_Source), reinterpret_cast<setter>(RedirectVisual_put_Source), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RedirectVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RedirectVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RedirectVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RedirectVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RedirectVisual) },
        { }
    };

    static PyType_Spec type_spec_RedirectVisual = {
        "winrt._winrt_microsoft_ui_composition.RedirectVisual",
        sizeof(py::wrapper::Microsoft::UI::Composition::RedirectVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RedirectVisual};

    // ----- RenderingDeviceReplacedEventArgs class --------------------

    static PyObject* _new_RenderingDeviceReplacedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RenderingDeviceReplacedEventArgs(py::wrapper::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderingDeviceReplacedEventArgs_get_GraphicsDevice(py::wrapper::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.RenderingDeviceReplacedEventArgs", L"GraphicsDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GraphicsDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderingDeviceReplacedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderingDeviceReplacedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderingDeviceReplacedEventArgs[] = {
        { "_assign_array_", _assign_array_RenderingDeviceReplacedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderingDeviceReplacedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RenderingDeviceReplacedEventArgs[] = {
        { "graphics_device", reinterpret_cast<getter>(RenderingDeviceReplacedEventArgs_get_GraphicsDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RenderingDeviceReplacedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderingDeviceReplacedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderingDeviceReplacedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderingDeviceReplacedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderingDeviceReplacedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RenderingDeviceReplacedEventArgs = {
        "winrt._winrt_microsoft_ui_composition.RenderingDeviceReplacedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::RenderingDeviceReplacedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderingDeviceReplacedEventArgs};

    // ----- ScalarKeyFrameAnimation class --------------------

    static PyObject* _new_ScalarKeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ScalarKeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ScalarKeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_ScalarKeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::ScalarKeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScalarKeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::ScalarKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ScalarKeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScalarKeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::ScalarKeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ScalarKeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScalarKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ScalarKeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScalarKeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ScalarKeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScalarKeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(ScalarKeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(ScalarKeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScalarKeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScalarKeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScalarKeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_ScalarKeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScalarKeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScalarKeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScalarKeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScalarKeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_ScalarKeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.ScalarKeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::ScalarKeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScalarKeyFrameAnimation};

    // ----- ScalarNaturalMotionAnimation class --------------------

    static PyObject* _new_ScalarNaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_ScalarNaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScalarNaturalMotionAnimation_get_InitialVelocity(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ScalarNaturalMotionAnimation", L"InitialVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>().InitialVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScalarNaturalMotionAnimation_put_InitialVelocity(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ScalarNaturalMotionAnimation", L"InitialVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>().InitialVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScalarNaturalMotionAnimation_get_InitialValue(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ScalarNaturalMotionAnimation", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>().InitialValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScalarNaturalMotionAnimation_put_InitialValue(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ScalarNaturalMotionAnimation", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>().InitialValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScalarNaturalMotionAnimation_get_FinalValue(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ScalarNaturalMotionAnimation", L"FinalValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>().FinalValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScalarNaturalMotionAnimation_put_FinalValue(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ScalarNaturalMotionAnimation", L"FinalValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>().FinalValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ScalarNaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScalarNaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScalarNaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_ScalarNaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScalarNaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScalarNaturalMotionAnimation[] = {
        { "initial_velocity", reinterpret_cast<getter>(ScalarNaturalMotionAnimation_get_InitialVelocity), reinterpret_cast<setter>(ScalarNaturalMotionAnimation_put_InitialVelocity), nullptr, nullptr },
        { "initial_value", reinterpret_cast<getter>(ScalarNaturalMotionAnimation_get_InitialValue), reinterpret_cast<setter>(ScalarNaturalMotionAnimation_put_InitialValue), nullptr, nullptr },
        { "final_value", reinterpret_cast<getter>(ScalarNaturalMotionAnimation_get_FinalValue), reinterpret_cast<setter>(ScalarNaturalMotionAnimation_put_FinalValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScalarNaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScalarNaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScalarNaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScalarNaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScalarNaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_ScalarNaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.ScalarNaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::ScalarNaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScalarNaturalMotionAnimation};

    static PyGetSetDef getset_ScalarNaturalMotionAnimation_Static[] = {
        { }
    };

    static PyMethodDef methods_ScalarNaturalMotionAnimation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScalarNaturalMotionAnimation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScalarNaturalMotionAnimation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScalarNaturalMotionAnimation_Static) },
        { }
    };

    static PyType_Spec type_spec_ScalarNaturalMotionAnimation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.ScalarNaturalMotionAnimation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScalarNaturalMotionAnimation_Static
    };

    // ----- ShapeVisual class --------------------

    static PyObject* _new_ShapeVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ShapeVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ShapeVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_ShapeVisual(py::wrapper::Microsoft::UI::Composition::ShapeVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShapeVisual_get_ViewBox(py::wrapper::Microsoft::UI::Composition::ShapeVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ShapeVisual", L"ViewBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewBox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShapeVisual_put_ViewBox(py::wrapper::Microsoft::UI::Composition::ShapeVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ShapeVisual", L"ViewBox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionViewBox>(arg);

            self->obj.ViewBox(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShapeVisual_get_Shapes(py::wrapper::Microsoft::UI::Composition::ShapeVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ShapeVisual", L"Shapes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shapes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShapeVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ShapeVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShapeVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ShapeVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShapeVisual[] = {
        { "_assign_array_", _assign_array_ShapeVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShapeVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShapeVisual[] = {
        { "view_box", reinterpret_cast<getter>(ShapeVisual_get_ViewBox), reinterpret_cast<setter>(ShapeVisual_put_ViewBox), nullptr, nullptr },
        { "shapes", reinterpret_cast<getter>(ShapeVisual_get_Shapes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShapeVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShapeVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShapeVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShapeVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShapeVisual) },
        { }
    };

    static PyType_Spec type_spec_ShapeVisual = {
        "winrt._winrt_microsoft_ui_composition.ShapeVisual",
        sizeof(py::wrapper::Microsoft::UI::Composition::ShapeVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShapeVisual};

    // ----- SineEasingFunction class --------------------

    static PyObject* _new_SineEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::SineEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::SineEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_SineEasingFunction(py::wrapper::Microsoft::UI::Composition::SineEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SineEasingFunction_get_Mode(py::wrapper::Microsoft::UI::Composition::SineEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SineEasingFunction", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SineEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::SineEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SineEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::SineEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SineEasingFunction[] = {
        { "_assign_array_", _assign_array_SineEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SineEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SineEasingFunction[] = {
        { "mode", reinterpret_cast<getter>(SineEasingFunction_get_Mode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SineEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SineEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SineEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SineEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SineEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_SineEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.SineEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::SineEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SineEasingFunction};

    // ----- SpotLight class --------------------

    static PyObject* _new_SpotLight(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::SpotLight>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::SpotLight>::type_name);
        return nullptr;
    }

    static void _dealloc_SpotLight(py::wrapper::Microsoft::UI::Composition::SpotLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpotLight_get_QuadraticAttenuation(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"QuadraticAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuadraticAttenuation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_QuadraticAttenuation(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"QuadraticAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.QuadraticAttenuation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_OuterConeColor(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OuterConeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_OuterConeColor(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OuterConeColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_OuterConeAngleInDegrees(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OuterConeAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_OuterConeAngleInDegrees(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.OuterConeAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_OuterConeAngle(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OuterConeAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_OuterConeAngle(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.OuterConeAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_Offset(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_Offset(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_LinearAttenuation(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"LinearAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinearAttenuation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_LinearAttenuation(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"LinearAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.LinearAttenuation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_InnerConeColor(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InnerConeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_InnerConeColor(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.InnerConeColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_InnerConeAngleInDegrees(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InnerConeAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_InnerConeAngleInDegrees(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.InnerConeAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_InnerConeAngle(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InnerConeAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_InnerConeAngle(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.InnerConeAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_Direction(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_Direction(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_CoordinateSpace(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"CoordinateSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CoordinateSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_CoordinateSpace(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"CoordinateSpace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.CoordinateSpace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_ConstantAttenuation(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"ConstantAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConstantAttenuation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_ConstantAttenuation(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"ConstantAttenuation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.ConstantAttenuation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_OuterConeIntensity(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeIntensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OuterConeIntensity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_OuterConeIntensity(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"OuterConeIntensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.OuterConeIntensity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_InnerConeIntensity(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeIntensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InnerConeIntensity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_InnerConeIntensity(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"InnerConeIntensity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.InnerConeIntensity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_MinAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"MinAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinAttenuationCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_MinAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"MinAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MinAttenuationCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpotLight_get_MaxAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::SpotLight* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"MaxAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxAttenuationCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpotLight_put_MaxAttenuationCutoff(py::wrapper::Microsoft::UI::Composition::SpotLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpotLight", L"MaxAttenuationCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxAttenuationCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpotLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::SpotLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpotLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::SpotLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpotLight[] = {
        { "_assign_array_", _assign_array_SpotLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpotLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpotLight[] = {
        { "quadratic_attenuation", reinterpret_cast<getter>(SpotLight_get_QuadraticAttenuation), reinterpret_cast<setter>(SpotLight_put_QuadraticAttenuation), nullptr, nullptr },
        { "outer_cone_color", reinterpret_cast<getter>(SpotLight_get_OuterConeColor), reinterpret_cast<setter>(SpotLight_put_OuterConeColor), nullptr, nullptr },
        { "outer_cone_angle_in_degrees", reinterpret_cast<getter>(SpotLight_get_OuterConeAngleInDegrees), reinterpret_cast<setter>(SpotLight_put_OuterConeAngleInDegrees), nullptr, nullptr },
        { "outer_cone_angle", reinterpret_cast<getter>(SpotLight_get_OuterConeAngle), reinterpret_cast<setter>(SpotLight_put_OuterConeAngle), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(SpotLight_get_Offset), reinterpret_cast<setter>(SpotLight_put_Offset), nullptr, nullptr },
        { "linear_attenuation", reinterpret_cast<getter>(SpotLight_get_LinearAttenuation), reinterpret_cast<setter>(SpotLight_put_LinearAttenuation), nullptr, nullptr },
        { "inner_cone_color", reinterpret_cast<getter>(SpotLight_get_InnerConeColor), reinterpret_cast<setter>(SpotLight_put_InnerConeColor), nullptr, nullptr },
        { "inner_cone_angle_in_degrees", reinterpret_cast<getter>(SpotLight_get_InnerConeAngleInDegrees), reinterpret_cast<setter>(SpotLight_put_InnerConeAngleInDegrees), nullptr, nullptr },
        { "inner_cone_angle", reinterpret_cast<getter>(SpotLight_get_InnerConeAngle), reinterpret_cast<setter>(SpotLight_put_InnerConeAngle), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(SpotLight_get_Direction), reinterpret_cast<setter>(SpotLight_put_Direction), nullptr, nullptr },
        { "coordinate_space", reinterpret_cast<getter>(SpotLight_get_CoordinateSpace), reinterpret_cast<setter>(SpotLight_put_CoordinateSpace), nullptr, nullptr },
        { "constant_attenuation", reinterpret_cast<getter>(SpotLight_get_ConstantAttenuation), reinterpret_cast<setter>(SpotLight_put_ConstantAttenuation), nullptr, nullptr },
        { "outer_cone_intensity", reinterpret_cast<getter>(SpotLight_get_OuterConeIntensity), reinterpret_cast<setter>(SpotLight_put_OuterConeIntensity), nullptr, nullptr },
        { "inner_cone_intensity", reinterpret_cast<getter>(SpotLight_get_InnerConeIntensity), reinterpret_cast<setter>(SpotLight_put_InnerConeIntensity), nullptr, nullptr },
        { "min_attenuation_cutoff", reinterpret_cast<getter>(SpotLight_get_MinAttenuationCutoff), reinterpret_cast<setter>(SpotLight_put_MinAttenuationCutoff), nullptr, nullptr },
        { "max_attenuation_cutoff", reinterpret_cast<getter>(SpotLight_get_MaxAttenuationCutoff), reinterpret_cast<setter>(SpotLight_put_MaxAttenuationCutoff), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpotLight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpotLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpotLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpotLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpotLight) },
        { }
    };

    static PyType_Spec type_spec_SpotLight = {
        "winrt._winrt_microsoft_ui_composition.SpotLight",
        sizeof(py::wrapper::Microsoft::UI::Composition::SpotLight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpotLight};

    // ----- SpringScalarNaturalMotionAnimation class --------------------

    static PyObject* _new_SpringScalarNaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_SpringScalarNaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpringScalarNaturalMotionAnimation_get_Period(py::wrapper::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringScalarNaturalMotionAnimation", L"Period");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Period());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpringScalarNaturalMotionAnimation_put_Period(py::wrapper::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringScalarNaturalMotionAnimation", L"Period");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Period(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpringScalarNaturalMotionAnimation_get_DampingRatio(py::wrapper::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringScalarNaturalMotionAnimation", L"DampingRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DampingRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpringScalarNaturalMotionAnimation_put_DampingRatio(py::wrapper::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringScalarNaturalMotionAnimation", L"DampingRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.DampingRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpringScalarNaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpringScalarNaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpringScalarNaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_SpringScalarNaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpringScalarNaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpringScalarNaturalMotionAnimation[] = {
        { "period", reinterpret_cast<getter>(SpringScalarNaturalMotionAnimation_get_Period), reinterpret_cast<setter>(SpringScalarNaturalMotionAnimation_put_Period), nullptr, nullptr },
        { "damping_ratio", reinterpret_cast<getter>(SpringScalarNaturalMotionAnimation_get_DampingRatio), reinterpret_cast<setter>(SpringScalarNaturalMotionAnimation_put_DampingRatio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpringScalarNaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpringScalarNaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpringScalarNaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpringScalarNaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpringScalarNaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_SpringScalarNaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.SpringScalarNaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::SpringScalarNaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpringScalarNaturalMotionAnimation};

    // ----- SpringVector2NaturalMotionAnimation class --------------------

    static PyObject* _new_SpringVector2NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_SpringVector2NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpringVector2NaturalMotionAnimation_get_Period(py::wrapper::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector2NaturalMotionAnimation", L"Period");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Period());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpringVector2NaturalMotionAnimation_put_Period(py::wrapper::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector2NaturalMotionAnimation", L"Period");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Period(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpringVector2NaturalMotionAnimation_get_DampingRatio(py::wrapper::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector2NaturalMotionAnimation", L"DampingRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DampingRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpringVector2NaturalMotionAnimation_put_DampingRatio(py::wrapper::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector2NaturalMotionAnimation", L"DampingRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.DampingRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpringVector2NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpringVector2NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpringVector2NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_SpringVector2NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpringVector2NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpringVector2NaturalMotionAnimation[] = {
        { "period", reinterpret_cast<getter>(SpringVector2NaturalMotionAnimation_get_Period), reinterpret_cast<setter>(SpringVector2NaturalMotionAnimation_put_Period), nullptr, nullptr },
        { "damping_ratio", reinterpret_cast<getter>(SpringVector2NaturalMotionAnimation_get_DampingRatio), reinterpret_cast<setter>(SpringVector2NaturalMotionAnimation_put_DampingRatio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpringVector2NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpringVector2NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpringVector2NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpringVector2NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpringVector2NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_SpringVector2NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.SpringVector2NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::SpringVector2NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpringVector2NaturalMotionAnimation};

    // ----- SpringVector3NaturalMotionAnimation class --------------------

    static PyObject* _new_SpringVector3NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_SpringVector3NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpringVector3NaturalMotionAnimation_get_Period(py::wrapper::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector3NaturalMotionAnimation", L"Period");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Period());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpringVector3NaturalMotionAnimation_put_Period(py::wrapper::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector3NaturalMotionAnimation", L"Period");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Period(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpringVector3NaturalMotionAnimation_get_DampingRatio(py::wrapper::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector3NaturalMotionAnimation", L"DampingRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DampingRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpringVector3NaturalMotionAnimation_put_DampingRatio(py::wrapper::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpringVector3NaturalMotionAnimation", L"DampingRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.DampingRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpringVector3NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpringVector3NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpringVector3NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_SpringVector3NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpringVector3NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpringVector3NaturalMotionAnimation[] = {
        { "period", reinterpret_cast<getter>(SpringVector3NaturalMotionAnimation_get_Period), reinterpret_cast<setter>(SpringVector3NaturalMotionAnimation_put_Period), nullptr, nullptr },
        { "damping_ratio", reinterpret_cast<getter>(SpringVector3NaturalMotionAnimation_get_DampingRatio), reinterpret_cast<setter>(SpringVector3NaturalMotionAnimation_put_DampingRatio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpringVector3NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpringVector3NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpringVector3NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpringVector3NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpringVector3NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_SpringVector3NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.SpringVector3NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::SpringVector3NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpringVector3NaturalMotionAnimation};

    // ----- SpriteVisual class --------------------

    static PyObject* _new_SpriteVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::SpriteVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::SpriteVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_SpriteVisual(py::wrapper::Microsoft::UI::Composition::SpriteVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpriteVisual_get_Brush(py::wrapper::Microsoft::UI::Composition::SpriteVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpriteVisual", L"Brush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Brush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpriteVisual_put_Brush(py::wrapper::Microsoft::UI::Composition::SpriteVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpriteVisual", L"Brush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.Brush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpriteVisual_get_Shadow(py::wrapper::Microsoft::UI::Composition::SpriteVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpriteVisual", L"Shadow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shadow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpriteVisual_put_Shadow(py::wrapper::Microsoft::UI::Composition::SpriteVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.SpriteVisual", L"Shadow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionShadow>(arg);

            self->obj.Shadow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpriteVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::SpriteVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpriteVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::SpriteVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpriteVisual[] = {
        { "_assign_array_", _assign_array_SpriteVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpriteVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpriteVisual[] = {
        { "brush", reinterpret_cast<getter>(SpriteVisual_get_Brush), reinterpret_cast<setter>(SpriteVisual_put_Brush), nullptr, nullptr },
        { "shadow", reinterpret_cast<getter>(SpriteVisual_get_Shadow), reinterpret_cast<setter>(SpriteVisual_put_Shadow), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpriteVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpriteVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpriteVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpriteVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpriteVisual) },
        { }
    };

    static PyType_Spec type_spec_SpriteVisual = {
        "winrt._winrt_microsoft_ui_composition.SpriteVisual",
        sizeof(py::wrapper::Microsoft::UI::Composition::SpriteVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpriteVisual};

    // ----- StepEasingFunction class --------------------

    static PyObject* _new_StepEasingFunction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::StepEasingFunction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::StepEasingFunction>::type_name);
        return nullptr;
    }

    static void _dealloc_StepEasingFunction(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StepEasingFunction_get_StepCount(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"StepCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StepCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StepEasingFunction_put_StepCount(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"StepCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StepCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StepEasingFunction_get_IsInitialStepSingleFrame(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"IsInitialStepSingleFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInitialStepSingleFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StepEasingFunction_put_IsInitialStepSingleFrame(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"IsInitialStepSingleFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInitialStepSingleFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StepEasingFunction_get_IsFinalStepSingleFrame(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"IsFinalStepSingleFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFinalStepSingleFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StepEasingFunction_put_IsFinalStepSingleFrame(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"IsFinalStepSingleFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFinalStepSingleFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StepEasingFunction_get_InitialStep(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"InitialStep");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InitialStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StepEasingFunction_put_InitialStep(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"InitialStep");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.InitialStep(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StepEasingFunction_get_FinalStep(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"FinalStep");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FinalStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StepEasingFunction_put_FinalStep(py::wrapper::Microsoft::UI::Composition::StepEasingFunction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.StepEasingFunction", L"FinalStep");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FinalStep(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StepEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::StepEasingFunction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StepEasingFunction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::StepEasingFunction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StepEasingFunction[] = {
        { "_assign_array_", _assign_array_StepEasingFunction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StepEasingFunction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StepEasingFunction[] = {
        { "step_count", reinterpret_cast<getter>(StepEasingFunction_get_StepCount), reinterpret_cast<setter>(StepEasingFunction_put_StepCount), nullptr, nullptr },
        { "is_initial_step_single_frame", reinterpret_cast<getter>(StepEasingFunction_get_IsInitialStepSingleFrame), reinterpret_cast<setter>(StepEasingFunction_put_IsInitialStepSingleFrame), nullptr, nullptr },
        { "is_final_step_single_frame", reinterpret_cast<getter>(StepEasingFunction_get_IsFinalStepSingleFrame), reinterpret_cast<setter>(StepEasingFunction_put_IsFinalStepSingleFrame), nullptr, nullptr },
        { "initial_step", reinterpret_cast<getter>(StepEasingFunction_get_InitialStep), reinterpret_cast<setter>(StepEasingFunction_put_InitialStep), nullptr, nullptr },
        { "final_step", reinterpret_cast<getter>(StepEasingFunction_get_FinalStep), reinterpret_cast<setter>(StepEasingFunction_put_FinalStep), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StepEasingFunction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StepEasingFunction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StepEasingFunction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StepEasingFunction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StepEasingFunction) },
        { }
    };

    static PyType_Spec type_spec_StepEasingFunction = {
        "winrt._winrt_microsoft_ui_composition.StepEasingFunction",
        sizeof(py::wrapper::Microsoft::UI::Composition::StepEasingFunction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StepEasingFunction};

    // ----- Vector2KeyFrameAnimation class --------------------

    static PyObject* _new_Vector2KeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Vector2KeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Vector2KeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_Vector2KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Vector2KeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Vector2KeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::Vector2KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Vector2KeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Vector2KeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::Vector2KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Vector2KeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Vector2KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Vector2KeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Vector2KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Vector2KeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vector2KeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(Vector2KeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(Vector2KeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Vector2KeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Vector2KeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Vector2KeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_Vector2KeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector2KeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector2KeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector2KeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector2KeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_Vector2KeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.Vector2KeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::Vector2KeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector2KeyFrameAnimation};

    // ----- Vector2NaturalMotionAnimation class --------------------

    static PyObject* _new_Vector2NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_Vector2NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Vector2NaturalMotionAnimation_get_InitialVelocity(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector2NaturalMotionAnimation", L"InitialVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>().InitialVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2NaturalMotionAnimation_put_InitialVelocity(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector2NaturalMotionAnimation", L"InitialVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>().InitialVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector2NaturalMotionAnimation_get_InitialValue(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector2NaturalMotionAnimation", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>().InitialValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2NaturalMotionAnimation_put_InitialValue(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector2NaturalMotionAnimation", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>().InitialValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector2NaturalMotionAnimation_get_FinalValue(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector2NaturalMotionAnimation", L"FinalValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>().FinalValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2NaturalMotionAnimation_put_FinalValue(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector2NaturalMotionAnimation", L"FinalValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>().FinalValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Vector2NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Vector2NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vector2NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_Vector2NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Vector2NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Vector2NaturalMotionAnimation[] = {
        { "initial_velocity", reinterpret_cast<getter>(Vector2NaturalMotionAnimation_get_InitialVelocity), reinterpret_cast<setter>(Vector2NaturalMotionAnimation_put_InitialVelocity), nullptr, nullptr },
        { "initial_value", reinterpret_cast<getter>(Vector2NaturalMotionAnimation_get_InitialValue), reinterpret_cast<setter>(Vector2NaturalMotionAnimation_put_InitialValue), nullptr, nullptr },
        { "final_value", reinterpret_cast<getter>(Vector2NaturalMotionAnimation_get_FinalValue), reinterpret_cast<setter>(Vector2NaturalMotionAnimation_put_FinalValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Vector2NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector2NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector2NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector2NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector2NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_Vector2NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.Vector2NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::Vector2NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Vector2NaturalMotionAnimation};

    static PyGetSetDef getset_Vector2NaturalMotionAnimation_Static[] = {
        { }
    };

    static PyMethodDef methods_Vector2NaturalMotionAnimation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Vector2NaturalMotionAnimation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Vector2NaturalMotionAnimation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Vector2NaturalMotionAnimation_Static) },
        { }
    };

    static PyType_Spec type_spec_Vector2NaturalMotionAnimation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.Vector2NaturalMotionAnimation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Vector2NaturalMotionAnimation_Static
    };

    // ----- Vector3KeyFrameAnimation class --------------------

    static PyObject* _new_Vector3KeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Vector3KeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Vector3KeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_Vector3KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Vector3KeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Vector3KeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::Vector3KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Vector3KeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Vector3KeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::Vector3KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Vector3KeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Vector3KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Vector3KeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Vector3KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Vector3KeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vector3KeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(Vector3KeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(Vector3KeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Vector3KeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Vector3KeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Vector3KeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_Vector3KeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector3KeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector3KeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector3KeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector3KeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_Vector3KeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.Vector3KeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::Vector3KeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector3KeyFrameAnimation};

    // ----- Vector3NaturalMotionAnimation class --------------------

    static PyObject* _new_Vector3NaturalMotionAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_Vector3NaturalMotionAnimation(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Vector3NaturalMotionAnimation_get_InitialVelocity(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector3NaturalMotionAnimation", L"InitialVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>().InitialVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3NaturalMotionAnimation_put_InitialVelocity(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector3NaturalMotionAnimation", L"InitialVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>().InitialVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3NaturalMotionAnimation_get_InitialValue(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector3NaturalMotionAnimation", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>().InitialValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3NaturalMotionAnimation_put_InitialValue(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector3NaturalMotionAnimation", L"InitialValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float3>>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>().InitialValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3NaturalMotionAnimation_get_FinalValue(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector3NaturalMotionAnimation", L"FinalValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>().FinalValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3NaturalMotionAnimation_put_FinalValue(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Vector3NaturalMotionAnimation", L"FinalValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float3>>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>().FinalValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Vector3NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Vector3NaturalMotionAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Vector3NaturalMotionAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vector3NaturalMotionAnimation[] = {
        { "_assign_array_", _assign_array_Vector3NaturalMotionAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Vector3NaturalMotionAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Vector3NaturalMotionAnimation[] = {
        { "initial_velocity", reinterpret_cast<getter>(Vector3NaturalMotionAnimation_get_InitialVelocity), reinterpret_cast<setter>(Vector3NaturalMotionAnimation_put_InitialVelocity), nullptr, nullptr },
        { "initial_value", reinterpret_cast<getter>(Vector3NaturalMotionAnimation_get_InitialValue), reinterpret_cast<setter>(Vector3NaturalMotionAnimation_put_InitialValue), nullptr, nullptr },
        { "final_value", reinterpret_cast<getter>(Vector3NaturalMotionAnimation_get_FinalValue), reinterpret_cast<setter>(Vector3NaturalMotionAnimation_put_FinalValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Vector3NaturalMotionAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector3NaturalMotionAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector3NaturalMotionAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector3NaturalMotionAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector3NaturalMotionAnimation) },
        { }
    };

    static PyType_Spec type_spec_Vector3NaturalMotionAnimation = {
        "winrt._winrt_microsoft_ui_composition.Vector3NaturalMotionAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::Vector3NaturalMotionAnimation),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Vector3NaturalMotionAnimation};

    static PyGetSetDef getset_Vector3NaturalMotionAnimation_Static[] = {
        { }
    };

    static PyMethodDef methods_Vector3NaturalMotionAnimation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Vector3NaturalMotionAnimation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Vector3NaturalMotionAnimation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Vector3NaturalMotionAnimation_Static) },
        { }
    };

    static PyType_Spec type_spec_Vector3NaturalMotionAnimation_Static =
    {
        "winrt._winrt_microsoft_ui_composition.Vector3NaturalMotionAnimation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Vector3NaturalMotionAnimation_Static
    };

    // ----- Vector4KeyFrameAnimation class --------------------

    static PyObject* _new_Vector4KeyFrameAnimation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Vector4KeyFrameAnimation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Vector4KeyFrameAnimation>::type_name);
        return nullptr;
    }

    static void _dealloc_Vector4KeyFrameAnimation(py::wrapper::Microsoft::UI::Composition::Vector4KeyFrameAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Vector4KeyFrameAnimation_InsertKeyFrame(py::wrapper::Microsoft::UI::Composition::Vector4KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Vector4KeyFrameAnimation", L"InsertKeyFrame", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 1);

                self->obj.InsertKeyFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Vector4KeyFrameAnimation_InsertKeyFrameWithEasingFunction(py::wrapper::Microsoft::UI::Composition::Vector4KeyFrameAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Vector4KeyFrameAnimation", L"InsertKeyFrame", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionEasingFunction>(args, 2);

                self->obj.InsertKeyFrame(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Vector4KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Vector4KeyFrameAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Vector4KeyFrameAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Vector4KeyFrameAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vector4KeyFrameAnimation[] = {
        { "insert_key_frame", reinterpret_cast<PyCFunction>(Vector4KeyFrameAnimation_InsertKeyFrame), METH_VARARGS, nullptr },
        { "insert_key_frame_with_easing_function", reinterpret_cast<PyCFunction>(Vector4KeyFrameAnimation_InsertKeyFrameWithEasingFunction), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Vector4KeyFrameAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Vector4KeyFrameAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Vector4KeyFrameAnimation[] = {
        { }
    };

    static PyType_Slot _type_slots_Vector4KeyFrameAnimation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector4KeyFrameAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector4KeyFrameAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector4KeyFrameAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector4KeyFrameAnimation) },
        { }
    };

    static PyType_Spec type_spec_Vector4KeyFrameAnimation = {
        "winrt._winrt_microsoft_ui_composition.Vector4KeyFrameAnimation",
        sizeof(py::wrapper::Microsoft::UI::Composition::Vector4KeyFrameAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector4KeyFrameAnimation};

    // ----- Visual class --------------------

    static PyObject* _new_Visual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Visual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Visual>::type_name);
        return nullptr;
    }

    static void _dealloc_Visual(py::wrapper::Microsoft::UI::Composition::Visual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Visual_get_TransformMatrix(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_TransformMatrix(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"TransformMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Size(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_Size(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Scale(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_Scale(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_RotationAxis(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RotationAxis");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RotationAxis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_RotationAxis(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RotationAxis");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RotationAxis(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RotationAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_RotationAngleInDegrees(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RotationAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_RotationAngle(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_RotationAngle(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Orientation(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_Orientation(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Opacity(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_Opacity(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Offset(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_Offset(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_IsVisible(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_IsVisible(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_CompositeMode(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"CompositeMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().CompositeMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_CompositeMode(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"CompositeMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionCompositeMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().CompositeMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Clip(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Clip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Clip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_Clip(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Clip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionClip>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Clip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_CenterPoint(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_CenterPoint(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"CenterPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_BorderMode(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"BorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().BorderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_BorderMode(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"BorderMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBorderMode>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().BorderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_BackfaceVisibility(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"BackfaceVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().BackfaceVisibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_BackfaceVisibility(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"BackfaceVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBackfaceVisibility>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().BackfaceVisibility(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_AnchorPoint(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().AnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_AnchorPoint(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"AnchorPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().AnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_Parent(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Visual_get_RelativeSizeAdjustment(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RelativeSizeAdjustment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RelativeSizeAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_RelativeSizeAdjustment(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RelativeSizeAdjustment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RelativeSizeAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_RelativeOffsetAdjustment(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RelativeOffsetAdjustment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RelativeOffsetAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_RelativeOffsetAdjustment(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"RelativeOffsetAdjustment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().RelativeOffsetAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_ParentForTransform(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"ParentForTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().ParentForTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_ParentForTransform(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"ParentForTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().ParentForTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_IsHitTestVisible(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"IsHitTestVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().IsHitTestVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_IsHitTestVisible(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"IsHitTestVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().IsHitTestVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Visual_get_IsPixelSnappingEnabled(py::wrapper::Microsoft::UI::Composition::Visual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"IsPixelSnappingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().IsPixelSnappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Visual_put_IsPixelSnappingEnabled(py::wrapper::Microsoft::UI::Composition::Visual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Visual", L"IsPixelSnappingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Microsoft::UI::Composition::Visual>().IsPixelSnappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Visual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Visual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Visual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Visual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Visual[] = {
        { "_assign_array_", _assign_array_Visual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Visual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Visual[] = {
        { "transform_matrix", reinterpret_cast<getter>(Visual_get_TransformMatrix), reinterpret_cast<setter>(Visual_put_TransformMatrix), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(Visual_get_Size), reinterpret_cast<setter>(Visual_put_Size), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(Visual_get_Scale), reinterpret_cast<setter>(Visual_put_Scale), nullptr, nullptr },
        { "rotation_axis", reinterpret_cast<getter>(Visual_get_RotationAxis), reinterpret_cast<setter>(Visual_put_RotationAxis), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(Visual_get_RotationAngleInDegrees), reinterpret_cast<setter>(Visual_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(Visual_get_RotationAngle), reinterpret_cast<setter>(Visual_put_RotationAngle), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(Visual_get_Orientation), reinterpret_cast<setter>(Visual_put_Orientation), nullptr, nullptr },
        { "opacity", reinterpret_cast<getter>(Visual_get_Opacity), reinterpret_cast<setter>(Visual_put_Opacity), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(Visual_get_Offset), reinterpret_cast<setter>(Visual_put_Offset), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(Visual_get_IsVisible), reinterpret_cast<setter>(Visual_put_IsVisible), nullptr, nullptr },
        { "composite_mode", reinterpret_cast<getter>(Visual_get_CompositeMode), reinterpret_cast<setter>(Visual_put_CompositeMode), nullptr, nullptr },
        { "clip", reinterpret_cast<getter>(Visual_get_Clip), reinterpret_cast<setter>(Visual_put_Clip), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(Visual_get_CenterPoint), reinterpret_cast<setter>(Visual_put_CenterPoint), nullptr, nullptr },
        { "border_mode", reinterpret_cast<getter>(Visual_get_BorderMode), reinterpret_cast<setter>(Visual_put_BorderMode), nullptr, nullptr },
        { "backface_visibility", reinterpret_cast<getter>(Visual_get_BackfaceVisibility), reinterpret_cast<setter>(Visual_put_BackfaceVisibility), nullptr, nullptr },
        { "anchor_point", reinterpret_cast<getter>(Visual_get_AnchorPoint), reinterpret_cast<setter>(Visual_put_AnchorPoint), nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(Visual_get_Parent), nullptr, nullptr, nullptr },
        { "relative_size_adjustment", reinterpret_cast<getter>(Visual_get_RelativeSizeAdjustment), reinterpret_cast<setter>(Visual_put_RelativeSizeAdjustment), nullptr, nullptr },
        { "relative_offset_adjustment", reinterpret_cast<getter>(Visual_get_RelativeOffsetAdjustment), reinterpret_cast<setter>(Visual_put_RelativeOffsetAdjustment), nullptr, nullptr },
        { "parent_for_transform", reinterpret_cast<getter>(Visual_get_ParentForTransform), reinterpret_cast<setter>(Visual_put_ParentForTransform), nullptr, nullptr },
        { "is_hit_test_visible", reinterpret_cast<getter>(Visual_get_IsHitTestVisible), reinterpret_cast<setter>(Visual_put_IsHitTestVisible), nullptr, nullptr },
        { "is_pixel_snapping_enabled", reinterpret_cast<getter>(Visual_get_IsPixelSnappingEnabled), reinterpret_cast<setter>(Visual_put_IsPixelSnappingEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Visual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Visual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Visual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Visual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Visual) },
        { }
    };

    static PyType_Spec type_spec_Visual = {
        "winrt._winrt_microsoft_ui_composition.Visual",
        sizeof(py::wrapper::Microsoft::UI::Composition::Visual),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Visual};

    static PyGetSetDef getset_Visual_Static[] = {
        { }
    };

    static PyMethodDef methods_Visual_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Visual_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Visual_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Visual_Static) },
        { }
    };

    static PyType_Spec type_spec_Visual_Static =
    {
        "winrt._winrt_microsoft_ui_composition.Visual_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Visual_Static
    };

    // ----- VisualCollection class --------------------

    static PyObject* _new_VisualCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::VisualCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::VisualCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualCollection(py::wrapper::Microsoft::UI::Composition::VisualCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualCollection_First(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_InsertAbove(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"InsertAbove", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 1);

                self->obj.InsertAbove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_InsertAtBottom(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"InsertAtBottom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                self->obj.InsertAtBottom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_InsertAtTop(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"InsertAtTop", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                self->obj.InsertAtTop(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_InsertBelow(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"InsertBelow", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 1);

                self->obj.InsertBelow(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_Remove(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_RemoveAll(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualCollection", L"RemoveAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualCollection_get_Count(py::wrapper::Microsoft::UI::Composition::VisualCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.VisualCollection", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Count());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::VisualCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::VisualCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_VisualCollection(py::wrapper::Microsoft::UI::Composition::VisualCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualCollection[] = {
        { "first", reinterpret_cast<PyCFunction>(VisualCollection_First), METH_VARARGS, nullptr },
        { "insert_above", reinterpret_cast<PyCFunction>(VisualCollection_InsertAbove), METH_VARARGS, nullptr },
        { "insert_at_bottom", reinterpret_cast<PyCFunction>(VisualCollection_InsertAtBottom), METH_VARARGS, nullptr },
        { "insert_at_top", reinterpret_cast<PyCFunction>(VisualCollection_InsertAtTop), METH_VARARGS, nullptr },
        { "insert_below", reinterpret_cast<PyCFunction>(VisualCollection_InsertBelow), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(VisualCollection_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(VisualCollection_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualCollection[] = {
        { "count", reinterpret_cast<getter>(VisualCollection_get_Count), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_VisualCollection) },
        { }
    };

    static PyType_Spec type_spec_VisualCollection = {
        "winrt._winrt_microsoft_ui_composition.VisualCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::VisualCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualCollection};

    // ----- VisualUnorderedCollection class --------------------

    static PyObject* _new_VisualUnorderedCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::VisualUnorderedCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::VisualUnorderedCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualUnorderedCollection(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualUnorderedCollection_Add(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualUnorderedCollection", L"Add", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualUnorderedCollection_First(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualUnorderedCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualUnorderedCollection_Remove(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualUnorderedCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualUnorderedCollection_RemoveAll(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.VisualUnorderedCollection", L"RemoveAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualUnorderedCollection_get_Count(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.VisualUnorderedCollection", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Count());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualUnorderedCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::VisualUnorderedCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualUnorderedCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::VisualUnorderedCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_VisualUnorderedCollection(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualUnorderedCollection[] = {
        { "add", reinterpret_cast<PyCFunction>(VisualUnorderedCollection_Add), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(VisualUnorderedCollection_First), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(VisualUnorderedCollection_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(VisualUnorderedCollection_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualUnorderedCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualUnorderedCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualUnorderedCollection[] = {
        { "count", reinterpret_cast<getter>(VisualUnorderedCollection_get_Count), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualUnorderedCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualUnorderedCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualUnorderedCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualUnorderedCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualUnorderedCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_VisualUnorderedCollection) },
        { }
    };

    static PyType_Spec type_spec_VisualUnorderedCollection = {
        "winrt._winrt_microsoft_ui_composition.VisualUnorderedCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::VisualUnorderedCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualUnorderedCollection};

    // ----- IAnimationObject interface --------------------

    static PyObject* _new_IAnimationObject(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::IAnimationObject>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::IAnimationObject>::type_name);
        return nullptr;
    }

    static void _dealloc_IAnimationObject(py::wrapper::Microsoft::UI::Composition::IAnimationObject* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnimationObject_PopulatePropertyInfo(py::wrapper::Microsoft::UI::Composition::IAnimationObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.IAnimationObject", L"PopulatePropertyInfo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.PopulatePropertyInfo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAnimationObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::IAnimationObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnimationObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::IAnimationObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnimationObject[] = {
        { "populate_property_info", reinterpret_cast<PyCFunction>(IAnimationObject_PopulatePropertyInfo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAnimationObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnimationObject), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAnimationObject[] = {
        { }
    };

    static PyType_Slot _type_slots_IAnimationObject[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnimationObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnimationObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnimationObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnimationObject) },
        { }
    };

    static PyType_Spec type_spec_IAnimationObject = {
        "winrt._winrt_microsoft_ui_composition.IAnimationObject",
        sizeof(py::wrapper::Microsoft::UI::Composition::IAnimationObject),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAnimationObject};

    // ----- ICompositionAnimationBase interface --------------------

    static PyObject* _new_ICompositionAnimationBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ICompositionAnimationBase(py::wrapper::Microsoft::UI::Composition::ICompositionAnimationBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ICompositionAnimationBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICompositionAnimationBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ICompositionAnimationBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICompositionAnimationBase[] = {
        { "_assign_array_", _assign_array_ICompositionAnimationBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICompositionAnimationBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICompositionAnimationBase[] = {
        { }
    };

    static PyType_Slot _type_slots_ICompositionAnimationBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICompositionAnimationBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICompositionAnimationBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICompositionAnimationBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICompositionAnimationBase) },
        { }
    };

    static PyType_Spec type_spec_ICompositionAnimationBase = {
        "winrt._winrt_microsoft_ui_composition.ICompositionAnimationBase",
        sizeof(py::wrapper::Microsoft::UI::Composition::ICompositionAnimationBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICompositionAnimationBase};

    // ----- ICompositionSupportsSystemBackdrop interface --------------------

    static PyObject* _new_ICompositionSupportsSystemBackdrop(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>::type_name);
        return nullptr;
    }

    static void _dealloc_ICompositionSupportsSystemBackdrop(py::wrapper::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICompositionSupportsSystemBackdrop_get_SystemBackdrop(py::wrapper::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ICompositionSupportsSystemBackdrop", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SystemBackdrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICompositionSupportsSystemBackdrop_put_SystemBackdrop(py::wrapper::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.ICompositionSupportsSystemBackdrop", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::CompositionBrush>(arg);

            self->obj.SystemBackdrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ICompositionSupportsSystemBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICompositionSupportsSystemBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICompositionSupportsSystemBackdrop[] = {
        { "_assign_array_", _assign_array_ICompositionSupportsSystemBackdrop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICompositionSupportsSystemBackdrop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICompositionSupportsSystemBackdrop[] = {
        { "system_backdrop", reinterpret_cast<getter>(ICompositionSupportsSystemBackdrop_get_SystemBackdrop), reinterpret_cast<setter>(ICompositionSupportsSystemBackdrop_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICompositionSupportsSystemBackdrop[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICompositionSupportsSystemBackdrop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICompositionSupportsSystemBackdrop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICompositionSupportsSystemBackdrop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICompositionSupportsSystemBackdrop) },
        { }
    };

    static PyType_Spec type_spec_ICompositionSupportsSystemBackdrop = {
        "winrt._winrt_microsoft_ui_composition.ICompositionSupportsSystemBackdrop",
        sizeof(py::wrapper::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICompositionSupportsSystemBackdrop};

    // ----- ICompositionSurface interface --------------------

    static PyObject* _new_ICompositionSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ICompositionSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ICompositionSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_ICompositionSurface(py::wrapper::Microsoft::UI::Composition::ICompositionSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ICompositionSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ICompositionSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICompositionSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ICompositionSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICompositionSurface[] = {
        { "_assign_array_", _assign_array_ICompositionSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICompositionSurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICompositionSurface[] = {
        { }
    };

    static PyType_Slot _type_slots_ICompositionSurface[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICompositionSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICompositionSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICompositionSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICompositionSurface) },
        { }
    };

    static PyType_Spec type_spec_ICompositionSurface = {
        "winrt._winrt_microsoft_ui_composition.ICompositionSurface",
        sizeof(py::wrapper::Microsoft::UI::Composition::ICompositionSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICompositionSurface};

    // ----- ICompositionSurfaceFacade interface --------------------

    static PyObject* _new_ICompositionSurfaceFacade(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::ICompositionSurfaceFacade>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::ICompositionSurfaceFacade>::type_name);
        return nullptr;
    }

    static void _dealloc_ICompositionSurfaceFacade(py::wrapper::Microsoft::UI::Composition::ICompositionSurfaceFacade* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICompositionSurfaceFacade_GetRealSurface(py::wrapper::Microsoft::UI::Composition::ICompositionSurfaceFacade* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.ICompositionSurfaceFacade", L"GetRealSurface", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRealSurface());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICompositionSurfaceFacade(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::ICompositionSurfaceFacade>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICompositionSurfaceFacade(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::ICompositionSurfaceFacade>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICompositionSurfaceFacade[] = {
        { "get_real_surface", reinterpret_cast<PyCFunction>(ICompositionSurfaceFacade_GetRealSurface), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICompositionSurfaceFacade, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICompositionSurfaceFacade), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICompositionSurfaceFacade[] = {
        { }
    };

    static PyType_Slot _type_slots_ICompositionSurfaceFacade[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICompositionSurfaceFacade) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICompositionSurfaceFacade) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICompositionSurfaceFacade) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICompositionSurfaceFacade) },
        { }
    };

    static PyType_Spec type_spec_ICompositionSurfaceFacade = {
        "winrt._winrt_microsoft_ui_composition.ICompositionSurfaceFacade",
        sizeof(py::wrapper::Microsoft::UI::Composition::ICompositionSurfaceFacade),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICompositionSurfaceFacade};

    // ----- IVisualElement interface --------------------

    static PyObject* _new_IVisualElement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::IVisualElement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::IVisualElement>::type_name);
        return nullptr;
    }

    static void _dealloc_IVisualElement(py::wrapper::Microsoft::UI::Composition::IVisualElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IVisualElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::IVisualElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVisualElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::IVisualElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVisualElement[] = {
        { "_assign_array_", _assign_array_IVisualElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVisualElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVisualElement[] = {
        { }
    };

    static PyType_Slot _type_slots_IVisualElement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVisualElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVisualElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVisualElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVisualElement) },
        { }
    };

    static PyType_Spec type_spec_IVisualElement = {
        "winrt._winrt_microsoft_ui_composition.IVisualElement",
        sizeof(py::wrapper::Microsoft::UI::Composition::IVisualElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVisualElement};

    // ----- IVisualElement2 interface --------------------

    static PyObject* _new_IVisualElement2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::IVisualElement2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::IVisualElement2>::type_name);
        return nullptr;
    }

    static void _dealloc_IVisualElement2(py::wrapper::Microsoft::UI::Composition::IVisualElement2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVisualElement2_GetVisualInternal(py::wrapper::Microsoft::UI::Composition::IVisualElement2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.IVisualElement2", L"GetVisualInternal", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVisualInternal());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVisualElement2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::IVisualElement2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVisualElement2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::IVisualElement2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVisualElement2[] = {
        { "get_visual_internal", reinterpret_cast<PyCFunction>(IVisualElement2_GetVisualInternal), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVisualElement2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVisualElement2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVisualElement2[] = {
        { }
    };

    static PyType_Slot _type_slots_IVisualElement2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVisualElement2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVisualElement2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVisualElement2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVisualElement2) },
        { }
    };

    static PyType_Spec type_spec_IVisualElement2 = {
        "winrt._winrt_microsoft_ui_composition.IVisualElement2",
        sizeof(py::wrapper::Microsoft::UI::Composition::IVisualElement2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVisualElement2};

    // ----- Microsoft.UI.Composition Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Composition");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_composition",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Composition

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_composition(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Composition;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionObject_Static{PyType_FromSpec(&type_spec_CompositionObject_Static)};
    if (!type_CompositionObject_Static)
    {
        return nullptr;
    }

    py::pytype_handle CompositionObject_type{py::register_python_type(module.get(), &type_spec_CompositionObject, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionObject_Static.get()))};
    if (!CompositionObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionLight_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionLight_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionLight_Static{PyType_FromSpecWithBases(&type_spec_CompositionLight_Static, CompositionLight_Static_bases.get())};
    if (!type_CompositionLight_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionLight_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionLight_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionLight_type{py::register_python_type(module.get(), &type_spec_CompositionLight, CompositionLight_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionLight_Static.get()))};
    if (!CompositionLight_type)
    {
        return nullptr;
    }

    py::pyobj_handle AmbientLight_bases{PyTuple_Pack(1, CompositionLight_type.get())};
    if (!AmbientLight_bases)
    {
        return nullptr;
    }

    py::pytype_handle AmbientLight_type{py::register_python_type(module.get(), &type_spec_AmbientLight, AmbientLight_bases.get(), nullptr)};
    if (!AmbientLight_type)
    {
        return nullptr;
    }

    py::pyobj_handle AnimationController_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!AnimationController_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnimationController_Static{PyType_FromSpecWithBases(&type_spec_AnimationController_Static, AnimationController_Static_bases.get())};
    if (!type_AnimationController_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AnimationController_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!AnimationController_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimationController_type{py::register_python_type(module.get(), &type_spec_AnimationController, AnimationController_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnimationController_Static.get()))};
    if (!AnimationController_type)
    {
        return nullptr;
    }

    py::pyobj_handle AnimationPropertyInfo_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!AnimationPropertyInfo_bases)
    {
        return nullptr;
    }

    py::pytype_handle AnimationPropertyInfo_type{py::register_python_type(module.get(), &type_spec_AnimationPropertyInfo, AnimationPropertyInfo_bases.get(), nullptr)};
    if (!AnimationPropertyInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionEasingFunction_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionEasingFunction_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionEasingFunction_Static{PyType_FromSpecWithBases(&type_spec_CompositionEasingFunction_Static, CompositionEasingFunction_Static_bases.get())};
    if (!type_CompositionEasingFunction_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionEasingFunction_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionEasingFunction_type{py::register_python_type(module.get(), &type_spec_CompositionEasingFunction, CompositionEasingFunction_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionEasingFunction_Static.get()))};
    if (!CompositionEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle BackEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!BackEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle BackEasingFunction_type{py::register_python_type(module.get(), &type_spec_BackEasingFunction, BackEasingFunction_bases.get(), nullptr)};
    if (!BackEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionAnimation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionAnimation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionAnimation_Static{PyType_FromSpecWithBases(&type_spec_CompositionAnimation_Static, CompositionAnimation_Static_bases.get())};
    if (!type_CompositionAnimation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionAnimation_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionAnimation_type{py::register_python_type(module.get(), &type_spec_CompositionAnimation, CompositionAnimation_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionAnimation_Static.get()))};
    if (!CompositionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle KeyFrameAnimation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionAnimation_type.get())))};
    if (!KeyFrameAnimation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyFrameAnimation_Static{PyType_FromSpecWithBases(&type_spec_KeyFrameAnimation_Static, KeyFrameAnimation_Static_bases.get())};
    if (!type_KeyFrameAnimation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle KeyFrameAnimation_bases{PyTuple_Pack(1, CompositionAnimation_type.get())};
    if (!KeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle KeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_KeyFrameAnimation, KeyFrameAnimation_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyFrameAnimation_Static.get()))};
    if (!KeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle BooleanKeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!BooleanKeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle BooleanKeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_BooleanKeyFrameAnimation, BooleanKeyFrameAnimation_bases.get(), nullptr)};
    if (!BooleanKeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle BounceEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!BounceEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle BounceEasingFunction_type{py::register_python_type(module.get(), &type_spec_BounceEasingFunction, BounceEasingFunction_bases.get(), nullptr)};
    if (!BounceEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle NaturalMotionAnimation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionAnimation_type.get())))};
    if (!NaturalMotionAnimation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NaturalMotionAnimation_Static{PyType_FromSpecWithBases(&type_spec_NaturalMotionAnimation_Static, NaturalMotionAnimation_Static_bases.get())};
    if (!type_NaturalMotionAnimation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NaturalMotionAnimation_bases{PyTuple_Pack(1, CompositionAnimation_type.get())};
    if (!NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_NaturalMotionAnimation, NaturalMotionAnimation_bases.get(), reinterpret_cast<PyTypeObject*>(type_NaturalMotionAnimation_Static.get()))};
    if (!NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScalarNaturalMotionAnimation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NaturalMotionAnimation_type.get())))};
    if (!ScalarNaturalMotionAnimation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScalarNaturalMotionAnimation_Static{PyType_FromSpecWithBases(&type_spec_ScalarNaturalMotionAnimation_Static, ScalarNaturalMotionAnimation_Static_bases.get())};
    if (!type_ScalarNaturalMotionAnimation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScalarNaturalMotionAnimation_bases{PyTuple_Pack(1, NaturalMotionAnimation_type.get())};
    if (!ScalarNaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScalarNaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_ScalarNaturalMotionAnimation, ScalarNaturalMotionAnimation_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScalarNaturalMotionAnimation_Static.get()))};
    if (!ScalarNaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle BounceScalarNaturalMotionAnimation_bases{PyTuple_Pack(1, ScalarNaturalMotionAnimation_type.get())};
    if (!BounceScalarNaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle BounceScalarNaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_BounceScalarNaturalMotionAnimation, BounceScalarNaturalMotionAnimation_bases.get(), nullptr)};
    if (!BounceScalarNaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector2NaturalMotionAnimation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NaturalMotionAnimation_type.get())))};
    if (!Vector2NaturalMotionAnimation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Vector2NaturalMotionAnimation_Static{PyType_FromSpecWithBases(&type_spec_Vector2NaturalMotionAnimation_Static, Vector2NaturalMotionAnimation_Static_bases.get())};
    if (!type_Vector2NaturalMotionAnimation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Vector2NaturalMotionAnimation_bases{PyTuple_Pack(1, NaturalMotionAnimation_type.get())};
    if (!Vector2NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle Vector2NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_Vector2NaturalMotionAnimation, Vector2NaturalMotionAnimation_bases.get(), reinterpret_cast<PyTypeObject*>(type_Vector2NaturalMotionAnimation_Static.get()))};
    if (!Vector2NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle BounceVector2NaturalMotionAnimation_bases{PyTuple_Pack(1, Vector2NaturalMotionAnimation_type.get())};
    if (!BounceVector2NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle BounceVector2NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_BounceVector2NaturalMotionAnimation, BounceVector2NaturalMotionAnimation_bases.get(), nullptr)};
    if (!BounceVector2NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector3NaturalMotionAnimation_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(NaturalMotionAnimation_type.get())))};
    if (!Vector3NaturalMotionAnimation_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Vector3NaturalMotionAnimation_Static{PyType_FromSpecWithBases(&type_spec_Vector3NaturalMotionAnimation_Static, Vector3NaturalMotionAnimation_Static_bases.get())};
    if (!type_Vector3NaturalMotionAnimation_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Vector3NaturalMotionAnimation_bases{PyTuple_Pack(1, NaturalMotionAnimation_type.get())};
    if (!Vector3NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle Vector3NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_Vector3NaturalMotionAnimation, Vector3NaturalMotionAnimation_bases.get(), reinterpret_cast<PyTypeObject*>(type_Vector3NaturalMotionAnimation_Static.get()))};
    if (!Vector3NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle BounceVector3NaturalMotionAnimation_bases{PyTuple_Pack(1, Vector3NaturalMotionAnimation_type.get())};
    if (!BounceVector3NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle BounceVector3NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_BounceVector3NaturalMotionAnimation, BounceVector3NaturalMotionAnimation_bases.get(), nullptr)};
    if (!BounceVector3NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle CircleEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!CircleEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle CircleEasingFunction_type{py::register_python_type(module.get(), &type_spec_CircleEasingFunction, CircleEasingFunction_bases.get(), nullptr)};
    if (!CircleEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorKeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!ColorKeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorKeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_ColorKeyFrameAnimation, ColorKeyFrameAnimation_bases.get(), nullptr)};
    if (!ColorKeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionAnimationGroup_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionAnimationGroup_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionAnimationGroup_type{py::register_python_type(module.get(), &type_spec_CompositionAnimationGroup, CompositionAnimationGroup_bases.get(), nullptr)};
    if (!CompositionAnimationGroup_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionApiInformation_Static{PyType_FromSpec(&type_spec_CompositionApiInformation_Static)};
    if (!type_CompositionApiInformation_Static)
    {
        return nullptr;
    }

    py::pytype_handle CompositionApiInformation_type{py::register_python_type(module.get(), &type_spec_CompositionApiInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionApiInformation_Static.get()))};
    if (!CompositionApiInformation_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionBrush_Static{PyType_FromSpecWithBases(&type_spec_CompositionBrush_Static, CompositionBrush_Static_bases.get())};
    if (!type_CompositionBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionBrush_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionBrush_type{py::register_python_type(module.get(), &type_spec_CompositionBrush, CompositionBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionBrush_Static.get()))};
    if (!CompositionBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionBackdropBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionBackdropBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionBackdropBrush_type{py::register_python_type(module.get(), &type_spec_CompositionBackdropBrush, CompositionBackdropBrush_bases.get(), nullptr)};
    if (!CompositionBackdropBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionBatchCompletedEventArgs_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionBatchCompletedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionBatchCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_CompositionBatchCompletedEventArgs, CompositionBatchCompletedEventArgs_bases.get(), nullptr)};
    if (!CompositionBatchCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CompositionCapabilities_type{py::register_python_type(module.get(), &type_spec_CompositionCapabilities, object_bases.get(), nullptr)};
    if (!CompositionCapabilities_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionClip_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionClip_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionClip_Static{PyType_FromSpecWithBases(&type_spec_CompositionClip_Static, CompositionClip_Static_bases.get())};
    if (!type_CompositionClip_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionClip_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionClip_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionClip_type{py::register_python_type(module.get(), &type_spec_CompositionClip, CompositionClip_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionClip_Static.get()))};
    if (!CompositionClip_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionColorBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionColorBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionColorBrush_type{py::register_python_type(module.get(), &type_spec_CompositionColorBrush, CompositionColorBrush_bases.get(), nullptr)};
    if (!CompositionColorBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionColorGradientStop_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionColorGradientStop_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionColorGradientStop_type{py::register_python_type(module.get(), &type_spec_CompositionColorGradientStop, CompositionColorGradientStop_bases.get(), nullptr)};
    if (!CompositionColorGradientStop_type)
    {
        return nullptr;
    }

    py::pytype_handle CompositionColorGradientStopCollection_type{py::register_python_type(module.get(), &type_spec_CompositionColorGradientStopCollection, object_bases.get(), nullptr)};
    if (!CompositionColorGradientStopCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionCommitBatch_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionCommitBatch_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionCommitBatch_type{py::register_python_type(module.get(), &type_spec_CompositionCommitBatch, CompositionCommitBatch_bases.get(), nullptr)};
    if (!CompositionCommitBatch_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionShape_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionShape_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionShape_Static{PyType_FromSpecWithBases(&type_spec_CompositionShape_Static, CompositionShape_Static_bases.get())};
    if (!type_CompositionShape_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionShape_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionShape_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionShape_type{py::register_python_type(module.get(), &type_spec_CompositionShape, CompositionShape_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionShape_Static.get()))};
    if (!CompositionShape_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionContainerShape_bases{PyTuple_Pack(1, CompositionShape_type.get())};
    if (!CompositionContainerShape_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionContainerShape_type{py::register_python_type(module.get(), &type_spec_CompositionContainerShape, CompositionContainerShape_bases.get(), nullptr)};
    if (!CompositionContainerShape_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionDrawingSurface_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionDrawingSurface_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionDrawingSurface_Static{PyType_FromSpecWithBases(&type_spec_CompositionDrawingSurface_Static, CompositionDrawingSurface_Static_bases.get())};
    if (!type_CompositionDrawingSurface_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionDrawingSurface_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionDrawingSurface_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionDrawingSurface_type{py::register_python_type(module.get(), &type_spec_CompositionDrawingSurface, CompositionDrawingSurface_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionDrawingSurface_Static.get()))};
    if (!CompositionDrawingSurface_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionEffectBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionEffectBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionEffectBrush_type{py::register_python_type(module.get(), &type_spec_CompositionEffectBrush, CompositionEffectBrush_bases.get(), nullptr)};
    if (!CompositionEffectBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionEffectFactory_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionEffectFactory_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionEffectFactory_type{py::register_python_type(module.get(), &type_spec_CompositionEffectFactory, CompositionEffectFactory_bases.get(), nullptr)};
    if (!CompositionEffectFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle CompositionEffectSourceParameter_type{py::register_python_type(module.get(), &type_spec_CompositionEffectSourceParameter, object_bases.get(), nullptr)};
    if (!CompositionEffectSourceParameter_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionGeometry_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionGeometry_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionGeometry_Static{PyType_FromSpecWithBases(&type_spec_CompositionGeometry_Static, CompositionGeometry_Static_bases.get())};
    if (!type_CompositionGeometry_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionGeometry_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionGeometry_type{py::register_python_type(module.get(), &type_spec_CompositionGeometry, CompositionGeometry_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionGeometry_Static.get()))};
    if (!CompositionGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionEllipseGeometry_bases{PyTuple_Pack(1, CompositionGeometry_type.get())};
    if (!CompositionEllipseGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionEllipseGeometry_type{py::register_python_type(module.get(), &type_spec_CompositionEllipseGeometry, CompositionEllipseGeometry_bases.get(), nullptr)};
    if (!CompositionEllipseGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionGeometricClip_bases{PyTuple_Pack(1, CompositionClip_type.get())};
    if (!CompositionGeometricClip_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionGeometricClip_type{py::register_python_type(module.get(), &type_spec_CompositionGeometricClip, CompositionGeometricClip_bases.get(), nullptr)};
    if (!CompositionGeometricClip_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionGradientBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionBrush_type.get())))};
    if (!CompositionGradientBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionGradientBrush_Static{PyType_FromSpecWithBases(&type_spec_CompositionGradientBrush_Static, CompositionGradientBrush_Static_bases.get())};
    if (!type_CompositionGradientBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionGradientBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionGradientBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionGradientBrush_type{py::register_python_type(module.get(), &type_spec_CompositionGradientBrush, CompositionGradientBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionGradientBrush_Static.get()))};
    if (!CompositionGradientBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionGraphicsDevice_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionGraphicsDevice_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionGraphicsDevice_type{py::register_python_type(module.get(), &type_spec_CompositionGraphicsDevice, CompositionGraphicsDevice_bases.get(), nullptr)};
    if (!CompositionGraphicsDevice_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionLineGeometry_bases{PyTuple_Pack(1, CompositionGeometry_type.get())};
    if (!CompositionLineGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionLineGeometry_type{py::register_python_type(module.get(), &type_spec_CompositionLineGeometry, CompositionLineGeometry_bases.get(), nullptr)};
    if (!CompositionLineGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionLinearGradientBrush_bases{PyTuple_Pack(1, CompositionGradientBrush_type.get())};
    if (!CompositionLinearGradientBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionLinearGradientBrush_type{py::register_python_type(module.get(), &type_spec_CompositionLinearGradientBrush, CompositionLinearGradientBrush_bases.get(), nullptr)};
    if (!CompositionLinearGradientBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionMaskBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionMaskBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionMaskBrush_type{py::register_python_type(module.get(), &type_spec_CompositionMaskBrush, CompositionMaskBrush_bases.get(), nullptr)};
    if (!CompositionMaskBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionMipmapSurface_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionMipmapSurface_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionMipmapSurface_type{py::register_python_type(module.get(), &type_spec_CompositionMipmapSurface, CompositionMipmapSurface_bases.get(), nullptr)};
    if (!CompositionMipmapSurface_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionNineGridBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionNineGridBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionNineGridBrush_type{py::register_python_type(module.get(), &type_spec_CompositionNineGridBrush, CompositionNineGridBrush_bases.get(), nullptr)};
    if (!CompositionNineGridBrush_type)
    {
        return nullptr;
    }

    py::pytype_handle CompositionPath_type{py::register_python_type(module.get(), &type_spec_CompositionPath, object_bases.get(), nullptr)};
    if (!CompositionPath_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionPathGeometry_bases{PyTuple_Pack(1, CompositionGeometry_type.get())};
    if (!CompositionPathGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionPathGeometry_type{py::register_python_type(module.get(), &type_spec_CompositionPathGeometry, CompositionPathGeometry_bases.get(), nullptr)};
    if (!CompositionPathGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionProjectedShadow_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionProjectedShadow_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionProjectedShadow_type{py::register_python_type(module.get(), &type_spec_CompositionProjectedShadow, CompositionProjectedShadow_bases.get(), nullptr)};
    if (!CompositionProjectedShadow_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionProjectedShadowCaster_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionProjectedShadowCaster_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionProjectedShadowCaster_type{py::register_python_type(module.get(), &type_spec_CompositionProjectedShadowCaster, CompositionProjectedShadowCaster_bases.get(), nullptr)};
    if (!CompositionProjectedShadowCaster_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionProjectedShadowCasterCollection_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionProjectedShadowCasterCollection_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionProjectedShadowCasterCollection_Static{PyType_FromSpecWithBases(&type_spec_CompositionProjectedShadowCasterCollection_Static, CompositionProjectedShadowCasterCollection_Static_bases.get())};
    if (!type_CompositionProjectedShadowCasterCollection_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionProjectedShadowCasterCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionProjectedShadowCasterCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionProjectedShadowCasterCollection_type{py::register_python_type(module.get(), &type_spec_CompositionProjectedShadowCasterCollection, CompositionProjectedShadowCasterCollection_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionProjectedShadowCasterCollection_Static.get()))};
    if (!CompositionProjectedShadowCasterCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionProjectedShadowReceiver_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionProjectedShadowReceiver_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionProjectedShadowReceiver_type{py::register_python_type(module.get(), &type_spec_CompositionProjectedShadowReceiver, CompositionProjectedShadowReceiver_bases.get(), nullptr)};
    if (!CompositionProjectedShadowReceiver_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionProjectedShadowReceiverUnorderedCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionProjectedShadowReceiverUnorderedCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionProjectedShadowReceiverUnorderedCollection_type{py::register_python_type(module.get(), &type_spec_CompositionProjectedShadowReceiverUnorderedCollection, CompositionProjectedShadowReceiverUnorderedCollection_bases.get(), nullptr)};
    if (!CompositionProjectedShadowReceiverUnorderedCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionPropertySet_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionPropertySet_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionPropertySet_type{py::register_python_type(module.get(), &type_spec_CompositionPropertySet, CompositionPropertySet_bases.get(), nullptr)};
    if (!CompositionPropertySet_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionRadialGradientBrush_bases{PyTuple_Pack(1, CompositionGradientBrush_type.get())};
    if (!CompositionRadialGradientBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionRadialGradientBrush_type{py::register_python_type(module.get(), &type_spec_CompositionRadialGradientBrush, CompositionRadialGradientBrush_bases.get(), nullptr)};
    if (!CompositionRadialGradientBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionRectangleGeometry_bases{PyTuple_Pack(1, CompositionGeometry_type.get())};
    if (!CompositionRectangleGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionRectangleGeometry_type{py::register_python_type(module.get(), &type_spec_CompositionRectangleGeometry, CompositionRectangleGeometry_bases.get(), nullptr)};
    if (!CompositionRectangleGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionRoundedRectangleGeometry_bases{PyTuple_Pack(1, CompositionGeometry_type.get())};
    if (!CompositionRoundedRectangleGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionRoundedRectangleGeometry_type{py::register_python_type(module.get(), &type_spec_CompositionRoundedRectangleGeometry, CompositionRoundedRectangleGeometry_bases.get(), nullptr)};
    if (!CompositionRoundedRectangleGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionScopedBatch_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionScopedBatch_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionScopedBatch_type{py::register_python_type(module.get(), &type_spec_CompositionScopedBatch, CompositionScopedBatch_bases.get(), nullptr)};
    if (!CompositionScopedBatch_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionShadow_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionShadow_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionShadow_Static{PyType_FromSpecWithBases(&type_spec_CompositionShadow_Static, CompositionShadow_Static_bases.get())};
    if (!type_CompositionShadow_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionShadow_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionShadow_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionShadow_type{py::register_python_type(module.get(), &type_spec_CompositionShadow, CompositionShadow_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionShadow_Static.get()))};
    if (!CompositionShadow_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionShapeCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionShapeCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionShapeCollection_type{py::register_python_type(module.get(), &type_spec_CompositionShapeCollection, CompositionShapeCollection_bases.get(), nullptr)};
    if (!CompositionShapeCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionSpriteShape_bases{PyTuple_Pack(1, CompositionShape_type.get())};
    if (!CompositionSpriteShape_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionSpriteShape_type{py::register_python_type(module.get(), &type_spec_CompositionSpriteShape, CompositionSpriteShape_bases.get(), nullptr)};
    if (!CompositionSpriteShape_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionStrokeDashArray_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionStrokeDashArray_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionStrokeDashArray_type{py::register_python_type(module.get(), &type_spec_CompositionStrokeDashArray, CompositionStrokeDashArray_bases.get(), nullptr)};
    if (!CompositionStrokeDashArray_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionSurfaceBrush_bases{PyTuple_Pack(1, CompositionBrush_type.get())};
    if (!CompositionSurfaceBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionSurfaceBrush_type{py::register_python_type(module.get(), &type_spec_CompositionSurfaceBrush, CompositionSurfaceBrush_bases.get(), nullptr)};
    if (!CompositionSurfaceBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!CompositionTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionTransform_Static{PyType_FromSpecWithBases(&type_spec_CompositionTransform_Static, CompositionTransform_Static_bases.get())};
    if (!type_CompositionTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionTransform_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionTransform_type{py::register_python_type(module.get(), &type_spec_CompositionTransform, CompositionTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionTransform_Static.get()))};
    if (!CompositionTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionViewBox_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionViewBox_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionViewBox_type{py::register_python_type(module.get(), &type_spec_CompositionViewBox, CompositionViewBox_bases.get(), nullptr)};
    if (!CompositionViewBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionVirtualDrawingSurface_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionDrawingSurface_type.get())))};
    if (!CompositionVirtualDrawingSurface_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionVirtualDrawingSurface_Static{PyType_FromSpecWithBases(&type_spec_CompositionVirtualDrawingSurface_Static, CompositionVirtualDrawingSurface_Static_bases.get())};
    if (!type_CompositionVirtualDrawingSurface_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionVirtualDrawingSurface_bases{PyTuple_Pack(1, CompositionDrawingSurface_type.get())};
    if (!CompositionVirtualDrawingSurface_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionVirtualDrawingSurface_type{py::register_python_type(module.get(), &type_spec_CompositionVirtualDrawingSurface, CompositionVirtualDrawingSurface_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionVirtualDrawingSurface_Static.get()))};
    if (!CompositionVirtualDrawingSurface_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionVisualSurface_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!CompositionVisualSurface_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionVisualSurface_type{py::register_python_type(module.get(), &type_spec_CompositionVisualSurface, CompositionVisualSurface_bases.get(), nullptr)};
    if (!CompositionVisualSurface_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Compositor_Static{PyType_FromSpec(&type_spec_Compositor_Static)};
    if (!type_Compositor_Static)
    {
        return nullptr;
    }

    py::pytype_handle Compositor_type{py::register_python_type(module.get(), &type_spec_Compositor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Compositor_Static.get()))};
    if (!Compositor_type)
    {
        return nullptr;
    }

    py::pyobj_handle Visual_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(CompositionObject_type.get())))};
    if (!Visual_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Visual_Static{PyType_FromSpecWithBases(&type_spec_Visual_Static, Visual_Static_bases.get())};
    if (!type_Visual_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Visual_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!Visual_bases)
    {
        return nullptr;
    }

    py::pytype_handle Visual_type{py::register_python_type(module.get(), &type_spec_Visual, Visual_bases.get(), reinterpret_cast<PyTypeObject*>(type_Visual_Static.get()))};
    if (!Visual_type)
    {
        return nullptr;
    }

    py::pyobj_handle ContainerVisual_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Visual_type.get())))};
    if (!ContainerVisual_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContainerVisual_Static{PyType_FromSpecWithBases(&type_spec_ContainerVisual_Static, ContainerVisual_Static_bases.get())};
    if (!type_ContainerVisual_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ContainerVisual_bases{PyTuple_Pack(1, Visual_type.get())};
    if (!ContainerVisual_bases)
    {
        return nullptr;
    }

    py::pytype_handle ContainerVisual_type{py::register_python_type(module.get(), &type_spec_ContainerVisual, ContainerVisual_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContainerVisual_Static.get()))};
    if (!ContainerVisual_type)
    {
        return nullptr;
    }

    py::pyobj_handle CubicBezierEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!CubicBezierEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle CubicBezierEasingFunction_type{py::register_python_type(module.get(), &type_spec_CubicBezierEasingFunction, CubicBezierEasingFunction_bases.get(), nullptr)};
    if (!CubicBezierEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle DistantLight_bases{PyTuple_Pack(1, CompositionLight_type.get())};
    if (!DistantLight_bases)
    {
        return nullptr;
    }

    py::pytype_handle DistantLight_type{py::register_python_type(module.get(), &type_spec_DistantLight, DistantLight_bases.get(), nullptr)};
    if (!DistantLight_type)
    {
        return nullptr;
    }

    py::pyobj_handle DropShadow_bases{PyTuple_Pack(1, CompositionShadow_type.get())};
    if (!DropShadow_bases)
    {
        return nullptr;
    }

    py::pytype_handle DropShadow_type{py::register_python_type(module.get(), &type_spec_DropShadow, DropShadow_bases.get(), nullptr)};
    if (!DropShadow_type)
    {
        return nullptr;
    }

    py::pyobj_handle ElasticEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!ElasticEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle ElasticEasingFunction_type{py::register_python_type(module.get(), &type_spec_ElasticEasingFunction, ElasticEasingFunction_bases.get(), nullptr)};
    if (!ElasticEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle ExponentialEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!ExponentialEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle ExponentialEasingFunction_type{py::register_python_type(module.get(), &type_spec_ExponentialEasingFunction, ExponentialEasingFunction_bases.get(), nullptr)};
    if (!ExponentialEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle ExpressionAnimation_bases{PyTuple_Pack(1, CompositionAnimation_type.get())};
    if (!ExpressionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle ExpressionAnimation_type{py::register_python_type(module.get(), &type_spec_ExpressionAnimation, ExpressionAnimation_bases.get(), nullptr)};
    if (!ExpressionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImplicitAnimationCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!ImplicitAnimationCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle ImplicitAnimationCollection_type{py::register_python_type(module.get(), &type_spec_ImplicitAnimationCollection, ImplicitAnimationCollection_bases.get(), nullptr)};
    if (!ImplicitAnimationCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle InitialValueExpressionCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!InitialValueExpressionCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle InitialValueExpressionCollection_type{py::register_python_type(module.get(), &type_spec_InitialValueExpressionCollection, InitialValueExpressionCollection_bases.get(), nullptr)};
    if (!InitialValueExpressionCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle InsetClip_bases{PyTuple_Pack(1, CompositionClip_type.get())};
    if (!InsetClip_bases)
    {
        return nullptr;
    }

    py::pytype_handle InsetClip_type{py::register_python_type(module.get(), &type_spec_InsetClip, InsetClip_bases.get(), nullptr)};
    if (!InsetClip_type)
    {
        return nullptr;
    }

    py::pyobj_handle LayerVisual_bases{PyTuple_Pack(1, ContainerVisual_type.get())};
    if (!LayerVisual_bases)
    {
        return nullptr;
    }

    py::pytype_handle LayerVisual_type{py::register_python_type(module.get(), &type_spec_LayerVisual, LayerVisual_bases.get(), nullptr)};
    if (!LayerVisual_type)
    {
        return nullptr;
    }

    py::pyobj_handle LinearEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!LinearEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle LinearEasingFunction_type{py::register_python_type(module.get(), &type_spec_LinearEasingFunction, LinearEasingFunction_bases.get(), nullptr)};
    if (!LinearEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle PathKeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!PathKeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle PathKeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_PathKeyFrameAnimation, PathKeyFrameAnimation_bases.get(), nullptr)};
    if (!PathKeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointLight_bases{PyTuple_Pack(1, CompositionLight_type.get())};
    if (!PointLight_bases)
    {
        return nullptr;
    }

    py::pytype_handle PointLight_type{py::register_python_type(module.get(), &type_spec_PointLight, PointLight_bases.get(), nullptr)};
    if (!PointLight_type)
    {
        return nullptr;
    }

    py::pyobj_handle PowerEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!PowerEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle PowerEasingFunction_type{py::register_python_type(module.get(), &type_spec_PowerEasingFunction, PowerEasingFunction_bases.get(), nullptr)};
    if (!PowerEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle QuaternionKeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!QuaternionKeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle QuaternionKeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_QuaternionKeyFrameAnimation, QuaternionKeyFrameAnimation_bases.get(), nullptr)};
    if (!QuaternionKeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle RectangleClip_bases{PyTuple_Pack(1, CompositionClip_type.get())};
    if (!RectangleClip_bases)
    {
        return nullptr;
    }

    py::pytype_handle RectangleClip_type{py::register_python_type(module.get(), &type_spec_RectangleClip, RectangleClip_bases.get(), nullptr)};
    if (!RectangleClip_type)
    {
        return nullptr;
    }

    py::pyobj_handle RedirectVisual_bases{PyTuple_Pack(1, ContainerVisual_type.get())};
    if (!RedirectVisual_bases)
    {
        return nullptr;
    }

    py::pytype_handle RedirectVisual_type{py::register_python_type(module.get(), &type_spec_RedirectVisual, RedirectVisual_bases.get(), nullptr)};
    if (!RedirectVisual_type)
    {
        return nullptr;
    }

    py::pyobj_handle RenderingDeviceReplacedEventArgs_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!RenderingDeviceReplacedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle RenderingDeviceReplacedEventArgs_type{py::register_python_type(module.get(), &type_spec_RenderingDeviceReplacedEventArgs, RenderingDeviceReplacedEventArgs_bases.get(), nullptr)};
    if (!RenderingDeviceReplacedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScalarKeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!ScalarKeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScalarKeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_ScalarKeyFrameAnimation, ScalarKeyFrameAnimation_bases.get(), nullptr)};
    if (!ScalarKeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle ShapeVisual_bases{PyTuple_Pack(1, ContainerVisual_type.get())};
    if (!ShapeVisual_bases)
    {
        return nullptr;
    }

    py::pytype_handle ShapeVisual_type{py::register_python_type(module.get(), &type_spec_ShapeVisual, ShapeVisual_bases.get(), nullptr)};
    if (!ShapeVisual_type)
    {
        return nullptr;
    }

    py::pyobj_handle SineEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!SineEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle SineEasingFunction_type{py::register_python_type(module.get(), &type_spec_SineEasingFunction, SineEasingFunction_bases.get(), nullptr)};
    if (!SineEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpotLight_bases{PyTuple_Pack(1, CompositionLight_type.get())};
    if (!SpotLight_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpotLight_type{py::register_python_type(module.get(), &type_spec_SpotLight, SpotLight_bases.get(), nullptr)};
    if (!SpotLight_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpringScalarNaturalMotionAnimation_bases{PyTuple_Pack(1, ScalarNaturalMotionAnimation_type.get())};
    if (!SpringScalarNaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpringScalarNaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_SpringScalarNaturalMotionAnimation, SpringScalarNaturalMotionAnimation_bases.get(), nullptr)};
    if (!SpringScalarNaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpringVector2NaturalMotionAnimation_bases{PyTuple_Pack(1, Vector2NaturalMotionAnimation_type.get())};
    if (!SpringVector2NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpringVector2NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_SpringVector2NaturalMotionAnimation, SpringVector2NaturalMotionAnimation_bases.get(), nullptr)};
    if (!SpringVector2NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpringVector3NaturalMotionAnimation_bases{PyTuple_Pack(1, Vector3NaturalMotionAnimation_type.get())};
    if (!SpringVector3NaturalMotionAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpringVector3NaturalMotionAnimation_type{py::register_python_type(module.get(), &type_spec_SpringVector3NaturalMotionAnimation, SpringVector3NaturalMotionAnimation_bases.get(), nullptr)};
    if (!SpringVector3NaturalMotionAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle SpriteVisual_bases{PyTuple_Pack(1, ContainerVisual_type.get())};
    if (!SpriteVisual_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpriteVisual_type{py::register_python_type(module.get(), &type_spec_SpriteVisual, SpriteVisual_bases.get(), nullptr)};
    if (!SpriteVisual_type)
    {
        return nullptr;
    }

    py::pyobj_handle StepEasingFunction_bases{PyTuple_Pack(1, CompositionEasingFunction_type.get())};
    if (!StepEasingFunction_bases)
    {
        return nullptr;
    }

    py::pytype_handle StepEasingFunction_type{py::register_python_type(module.get(), &type_spec_StepEasingFunction, StepEasingFunction_bases.get(), nullptr)};
    if (!StepEasingFunction_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector2KeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!Vector2KeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle Vector2KeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_Vector2KeyFrameAnimation, Vector2KeyFrameAnimation_bases.get(), nullptr)};
    if (!Vector2KeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector3KeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!Vector3KeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle Vector3KeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_Vector3KeyFrameAnimation, Vector3KeyFrameAnimation_bases.get(), nullptr)};
    if (!Vector3KeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle Vector4KeyFrameAnimation_bases{PyTuple_Pack(1, KeyFrameAnimation_type.get())};
    if (!Vector4KeyFrameAnimation_bases)
    {
        return nullptr;
    }

    py::pytype_handle Vector4KeyFrameAnimation_type{py::register_python_type(module.get(), &type_spec_Vector4KeyFrameAnimation, Vector4KeyFrameAnimation_bases.get(), nullptr)};
    if (!Vector4KeyFrameAnimation_type)
    {
        return nullptr;
    }

    py::pyobj_handle VisualCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!VisualCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle VisualCollection_type{py::register_python_type(module.get(), &type_spec_VisualCollection, VisualCollection_bases.get(), nullptr)};
    if (!VisualCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle VisualUnorderedCollection_bases{PyTuple_Pack(1, CompositionObject_type.get())};
    if (!VisualUnorderedCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle VisualUnorderedCollection_type{py::register_python_type(module.get(), &type_spec_VisualUnorderedCollection, VisualUnorderedCollection_bases.get(), nullptr)};
    if (!VisualUnorderedCollection_type)
    {
        return nullptr;
    }

    py::pytype_handle IAnimationObject_type{py::register_python_type(module.get(), &type_spec_IAnimationObject, object_bases.get(), nullptr)};
    if (!IAnimationObject_type)
    {
        return nullptr;
    }

    py::pytype_handle ICompositionAnimationBase_type{py::register_python_type(module.get(), &type_spec_ICompositionAnimationBase, object_bases.get(), nullptr)};
    if (!ICompositionAnimationBase_type)
    {
        return nullptr;
    }

    py::pytype_handle ICompositionSupportsSystemBackdrop_type{py::register_python_type(module.get(), &type_spec_ICompositionSupportsSystemBackdrop, object_bases.get(), nullptr)};
    if (!ICompositionSupportsSystemBackdrop_type)
    {
        return nullptr;
    }

    py::pytype_handle ICompositionSurface_type{py::register_python_type(module.get(), &type_spec_ICompositionSurface, object_bases.get(), nullptr)};
    if (!ICompositionSurface_type)
    {
        return nullptr;
    }

    py::pytype_handle ICompositionSurfaceFacade_type{py::register_python_type(module.get(), &type_spec_ICompositionSurfaceFacade, object_bases.get(), nullptr)};
    if (!ICompositionSurfaceFacade_type)
    {
        return nullptr;
    }

    py::pytype_handle IVisualElement_type{py::register_python_type(module.get(), &type_spec_IVisualElement, object_bases.get(), nullptr)};
    if (!IVisualElement_type)
    {
        return nullptr;
    }

    py::pytype_handle IVisualElement2_type{py::register_python_type(module.get(), &type_spec_IVisualElement2, object_bases.get(), nullptr)};
    if (!IVisualElement2_type)
    {
        return nullptr;
    }


    return module.detach();
}
