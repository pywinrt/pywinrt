// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.Devices.Scanners.h"


namespace py::cpp::Windows::Devices::Scanners
{
    // ----- ImageScanner class --------------------

    static PyObject* _new_ImageScanner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::ImageScanner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::ImageScanner>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageScanner(py::wrapper::Windows::Devices::Scanners::ImageScanner* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScanner_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Scanners::ImageScanner::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Scanners::ImageScanner::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_IsPreviewSupported(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"IsPreviewSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);

                return py::convert(self->obj.IsPreviewSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_IsScanSourceSupported(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"IsScanSourceSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);

                return py::convert(self->obj.IsScanSourceSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_ScanFilesToFolderAsync(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"ScanFilesToFolderAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 1);

                return py::convert(self->obj.ScanFilesToFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_ScanPreviewToStreamAsync(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"ScanPreviewToStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.ScanPreviewToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_AutoConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"AutoConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_DefaultScanSource(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"DefaultScanSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultScanSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_DeviceId(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_FeederConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"FeederConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FeederConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_FlatbedConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"FlatbedConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlatbedConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScanner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScanner[] = {
        { "is_preview_supported", reinterpret_cast<PyCFunction>(ImageScanner_IsPreviewSupported), METH_VARARGS, nullptr },
        { "is_scan_source_supported", reinterpret_cast<PyCFunction>(ImageScanner_IsScanSourceSupported), METH_VARARGS, nullptr },
        { "scan_files_to_folder_async", reinterpret_cast<PyCFunction>(ImageScanner_ScanFilesToFolderAsync), METH_VARARGS, nullptr },
        { "scan_preview_to_stream_async", reinterpret_cast<PyCFunction>(ImageScanner_ScanPreviewToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScanner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScanner), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScanner[] = {
        { "auto_configuration", reinterpret_cast<getter>(ImageScanner_get_AutoConfiguration), nullptr, nullptr, nullptr },
        { "default_scan_source", reinterpret_cast<getter>(ImageScanner_get_DefaultScanSource), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ImageScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "feeder_configuration", reinterpret_cast<getter>(ImageScanner_get_FeederConfiguration), nullptr, nullptr, nullptr },
        { "flatbed_configuration", reinterpret_cast<getter>(ImageScanner_get_FlatbedConfiguration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScanner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScanner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScanner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScanner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScanner) },
        { },
    };

    static PyType_Spec type_spec_ImageScanner =
    {
        "winrt._winrt_windows_devices_scanners.ImageScanner",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScanner
    };

    static PyGetSetDef getset_ImageScanner_Static[] = {
        { }
    };

    static PyMethodDef methods_ImageScanner_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(ImageScanner_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ImageScanner_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImageScanner_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageScanner_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageScanner_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageScanner_Static =
    {
        "winrt._winrt_windows_devices_scanners.ImageScanner_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ImageScanner_Static
    };

    // ----- ImageScannerAutoConfiguration class --------------------

    static PyObject* _new_ImageScannerAutoConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageScannerAutoConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerAutoConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerAutoConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerAutoConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerAutoConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerAutoConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerAutoConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerAutoConfiguration[] = {
        { "is_format_supported", reinterpret_cast<PyCFunction>(ImageScannerAutoConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScannerAutoConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerAutoConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerAutoConfiguration[] = {
        { "format", reinterpret_cast<getter>(ImageScannerAutoConfiguration_get_Format), reinterpret_cast<setter>(ImageScannerAutoConfiguration_put_Format), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(ImageScannerAutoConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerAutoConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerAutoConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerAutoConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerAutoConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerAutoConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerAutoConfiguration =
    {
        "winrt._winrt_windows_devices_scanners.ImageScannerAutoConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerAutoConfiguration
    };

    // ----- ImageScannerFeederConfiguration class --------------------

    static PyObject* _new_ImageScannerFeederConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageScannerFeederConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerFeederConfiguration_IsAutoCroppingModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsAutoCroppingModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(args, 0);

                return py::convert(self->obj.IsAutoCroppingModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_IsColorModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsColorModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(args, 0);

                return py::convert(self->obj.IsColorModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_IsPageSizeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsPageSizeSupported", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintMediaSize>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Printing::PrintOrientation>(args, 1);

                return py::convert(self->obj.IsPageSizeSupported(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ScanAhead(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ScanAhead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanAhead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_ScanAhead(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ScanAhead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ScanAhead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_AutoDetectPageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoDetectPageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoDetectPageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_AutoDetectPageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoDetectPageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoDetectPageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Duplex(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Duplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duplex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Duplex(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Duplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Duplex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxNumberOfPages(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxNumberOfPages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxNumberOfPages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_MaxNumberOfPages(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxNumberOfPages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxNumberOfPages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_PageOrientation(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_PageOrientation(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintOrientation>(arg);

            self->obj.PageOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_PageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_PageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintMediaSize>(arg);

            self->obj.PageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_PageSizeDimensions(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageSizeDimensions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageSizeDimensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_CanScanDuplex(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"CanScanDuplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanScanDuplex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_CanScanAhead(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"CanScanAhead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanScanAhead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_CanAutoDetectPageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"CanAutoDetectPageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanAutoDetectPageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerResolution>(arg);

            self->obj.DesiredResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Contrast(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoCroppingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(arg);

            self->obj.AutoCroppingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedScanRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.SelectedScanRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_OpticalResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"OpticalResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ContrastStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ContrastStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContrastStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_BrightnessStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"BrightnessStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrightnessStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ActualResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ActualResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerFeederConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerFeederConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerFeederConfiguration[] = {
        { "is_auto_cropping_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsAutoCroppingModeSupported), METH_VARARGS, nullptr },
        { "is_color_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsColorModeSupported), METH_VARARGS, nullptr },
        { "is_format_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "is_page_size_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsPageSizeSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScannerFeederConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerFeederConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerFeederConfiguration[] = {
        { "scan_ahead", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ScanAhead), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_ScanAhead), nullptr, nullptr },
        { "auto_detect_page_size", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_AutoDetectPageSize), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_AutoDetectPageSize), nullptr, nullptr },
        { "duplex", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Duplex), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Duplex), nullptr, nullptr },
        { "max_number_of_pages", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxNumberOfPages), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_MaxNumberOfPages), nullptr, nullptr },
        { "page_orientation", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_PageOrientation), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_PageOrientation), nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_PageSize), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_PageSize), nullptr, nullptr },
        { "page_size_dimensions", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_PageSizeDimensions), nullptr, nullptr, nullptr },
        { "can_scan_duplex", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_CanScanDuplex), nullptr, nullptr, nullptr },
        { "can_scan_ahead", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_CanScanAhead), nullptr, nullptr, nullptr },
        { "can_auto_detect_page_size", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_CanAutoDetectPageSize), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Format), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Format), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "desired_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DesiredResolution), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_DesiredResolution), nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Contrast), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Contrast), nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ColorMode), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_ColorMode), nullptr, nullptr },
        { "auto_cropping_mode", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_AutoCroppingMode), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_AutoCroppingMode), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Brightness), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Brightness), nullptr, nullptr },
        { "selected_scan_region", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_SelectedScanRegion), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_SelectedScanRegion), nullptr, nullptr },
        { "min_brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinBrightness), nullptr, nullptr, nullptr },
        { "min_contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinContrast), nullptr, nullptr, nullptr },
        { "min_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinResolution), nullptr, nullptr, nullptr },
        { "min_scan_area", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinScanArea), nullptr, nullptr, nullptr },
        { "optical_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_OpticalResolution), nullptr, nullptr, nullptr },
        { "max_scan_area", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxScanArea), nullptr, nullptr, nullptr },
        { "max_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxResolution), nullptr, nullptr, nullptr },
        { "max_contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxContrast), nullptr, nullptr, nullptr },
        { "max_brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxBrightness), nullptr, nullptr, nullptr },
        { "default_contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultContrast), nullptr, nullptr, nullptr },
        { "default_color_mode", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultColorMode), nullptr, nullptr, nullptr },
        { "default_brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultBrightness), nullptr, nullptr, nullptr },
        { "contrast_step", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ContrastStep), nullptr, nullptr, nullptr },
        { "brightness_step", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_BrightnessStep), nullptr, nullptr, nullptr },
        { "actual_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ActualResolution), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerFeederConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerFeederConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerFeederConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerFeederConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerFeederConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerFeederConfiguration =
    {
        "winrt._winrt_windows_devices_scanners.ImageScannerFeederConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerFeederConfiguration
    };

    // ----- ImageScannerFlatbedConfiguration class --------------------

    static PyObject* _new_ImageScannerFlatbedConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageScannerFlatbedConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerFlatbedConfiguration_IsAutoCroppingModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"IsAutoCroppingModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(args, 0);

                return py::convert(self->obj.IsAutoCroppingModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_IsColorModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"IsColorModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(args, 0);

                return py::convert(self->obj.IsColorModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedScanRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.SelectedScanRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerResolution>(arg);

            self->obj.DesiredResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Contrast(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoCroppingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(arg);

            self->obj.AutoCroppingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_ContrastStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ContrastStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContrastStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_ActualResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ActualResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_BrightnessStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"BrightnessStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrightnessStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_OpticalResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"OpticalResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerFlatbedConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerFlatbedConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerFlatbedConfiguration[] = {
        { "is_auto_cropping_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFlatbedConfiguration_IsAutoCroppingModeSupported), METH_VARARGS, nullptr },
        { "is_color_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFlatbedConfiguration_IsColorModeSupported), METH_VARARGS, nullptr },
        { "is_format_supported", reinterpret_cast<PyCFunction>(ImageScannerFlatbedConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScannerFlatbedConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerFlatbedConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerFlatbedConfiguration[] = {
        { "format", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_Format), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_Format), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "selected_scan_region", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_SelectedScanRegion), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_SelectedScanRegion), nullptr, nullptr },
        { "desired_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DesiredResolution), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_DesiredResolution), nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_Contrast), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_Contrast), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_Brightness), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_Brightness), nullptr, nullptr },
        { "auto_cropping_mode", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_AutoCroppingMode), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_AutoCroppingMode), nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_ColorMode), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_ColorMode), nullptr, nullptr },
        { "contrast_step", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_ContrastStep), nullptr, nullptr, nullptr },
        { "default_brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultBrightness), nullptr, nullptr, nullptr },
        { "default_color_mode", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultColorMode), nullptr, nullptr, nullptr },
        { "default_contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultContrast), nullptr, nullptr, nullptr },
        { "actual_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_ActualResolution), nullptr, nullptr, nullptr },
        { "max_brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxBrightness), nullptr, nullptr, nullptr },
        { "max_contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxContrast), nullptr, nullptr, nullptr },
        { "max_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxResolution), nullptr, nullptr, nullptr },
        { "max_scan_area", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxScanArea), nullptr, nullptr, nullptr },
        { "min_brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinBrightness), nullptr, nullptr, nullptr },
        { "brightness_step", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_BrightnessStep), nullptr, nullptr, nullptr },
        { "min_contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinContrast), nullptr, nullptr, nullptr },
        { "min_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinResolution), nullptr, nullptr, nullptr },
        { "optical_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_OpticalResolution), nullptr, nullptr, nullptr },
        { "min_scan_area", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinScanArea), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerFlatbedConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerFlatbedConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerFlatbedConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerFlatbedConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerFlatbedConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerFlatbedConfiguration =
    {
        "winrt._winrt_windows_devices_scanners.ImageScannerFlatbedConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerFlatbedConfiguration
    };

    // ----- ImageScannerPreviewResult class --------------------

    static PyObject* _new_ImageScannerPreviewResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageScannerPreviewResult(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerPreviewResult_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerPreviewResult", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerPreviewResult_get_Succeeded(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerPreviewResult", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerPreviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerPreviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerPreviewResult[] = {
        { "_assign_array_", _assign_array_ImageScannerPreviewResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerPreviewResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerPreviewResult[] = {
        { "format", reinterpret_cast<getter>(ImageScannerPreviewResult_get_Format), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(ImageScannerPreviewResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerPreviewResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerPreviewResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerPreviewResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerPreviewResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerPreviewResult) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerPreviewResult =
    {
        "winrt._winrt_windows_devices_scanners.ImageScannerPreviewResult",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerPreviewResult
    };

    // ----- ImageScannerScanResult class --------------------

    static PyObject* _new_ImageScannerScanResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerScanResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::ImageScannerScanResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageScannerScanResult(py::wrapper::Windows::Devices::Scanners::ImageScannerScanResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerScanResult_get_ScannedFiles(py::wrapper::Windows::Devices::Scanners::ImageScannerScanResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerScanResult", L"ScannedFiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScannedFiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerScanResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerScanResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerScanResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerScanResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerScanResult[] = {
        { "_assign_array_", _assign_array_ImageScannerScanResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerScanResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerScanResult[] = {
        { "scanned_files", reinterpret_cast<getter>(ImageScannerScanResult_get_ScannedFiles), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerScanResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerScanResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerScanResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerScanResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerScanResult) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerScanResult =
    {
        "winrt._winrt_windows_devices_scanners.ImageScannerScanResult",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerScanResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerScanResult
    };

    // ----- IImageScannerFormatConfiguration interface --------------------

    static PyObject* _new_IImageScannerFormatConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_IImageScannerFormatConfiguration(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IImageScannerFormatConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerFormatConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerFormatConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerFormatConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IImageScannerFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IImageScannerFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IImageScannerFormatConfiguration[] = {
        { "is_format_supported", reinterpret_cast<PyCFunction>(IImageScannerFormatConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IImageScannerFormatConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IImageScannerFormatConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IImageScannerFormatConfiguration[] = {
        { "default_format", reinterpret_cast<getter>(IImageScannerFormatConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(IImageScannerFormatConfiguration_get_Format), reinterpret_cast<setter>(IImageScannerFormatConfiguration_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IImageScannerFormatConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IImageScannerFormatConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IImageScannerFormatConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IImageScannerFormatConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IImageScannerFormatConfiguration) },
        { },
    };

    static PyType_Spec type_spec_IImageScannerFormatConfiguration =
    {
        "winrt._winrt_windows_devices_scanners.IImageScannerFormatConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IImageScannerFormatConfiguration
    };

    // ----- IImageScannerSourceConfiguration interface --------------------

    static PyObject* _new_IImageScannerSourceConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_IImageScannerSourceConfiguration(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IImageScannerSourceConfiguration_IsAutoCroppingModeSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"IsAutoCroppingModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(args, 0);

                return py::convert(self->obj.IsAutoCroppingModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_IsColorModeSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"IsColorModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(args, 0);

                return py::convert(self->obj.IsColorModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_ActualResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ActualResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoCroppingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(arg);

            self->obj.AutoCroppingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_Brightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_Brightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_BrightnessStep(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"BrightnessStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrightnessStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_ColorMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_ColorMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_Contrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_Contrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Contrast(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_ContrastStep(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ContrastStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContrastStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultBrightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DefaultBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultColorMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DefaultColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultContrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DefaultContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DesiredResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_DesiredResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerResolution>(arg);

            self->obj.DesiredResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxBrightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxContrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxScanArea(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinBrightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinContrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinScanArea(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_OpticalResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"OpticalResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedScanRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.SelectedScanRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IImageScannerSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IImageScannerSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IImageScannerSourceConfiguration[] = {
        { "is_auto_cropping_mode_supported", reinterpret_cast<PyCFunction>(IImageScannerSourceConfiguration_IsAutoCroppingModeSupported), METH_VARARGS, nullptr },
        { "is_color_mode_supported", reinterpret_cast<PyCFunction>(IImageScannerSourceConfiguration_IsColorModeSupported), METH_VARARGS, nullptr },
        { "is_format_supported", reinterpret_cast<PyCFunction>(IImageScannerSourceConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IImageScannerSourceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IImageScannerSourceConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IImageScannerSourceConfiguration[] = {
        { "actual_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_ActualResolution), nullptr, nullptr, nullptr },
        { "auto_cropping_mode", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_AutoCroppingMode), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_AutoCroppingMode), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_Brightness), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_Brightness), nullptr, nullptr },
        { "brightness_step", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_BrightnessStep), nullptr, nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_ColorMode), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_ColorMode), nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_Contrast), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_Contrast), nullptr, nullptr },
        { "contrast_step", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_ContrastStep), nullptr, nullptr, nullptr },
        { "default_brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultBrightness), nullptr, nullptr, nullptr },
        { "default_color_mode", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultColorMode), nullptr, nullptr, nullptr },
        { "default_contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultContrast), nullptr, nullptr, nullptr },
        { "desired_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DesiredResolution), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_DesiredResolution), nullptr, nullptr },
        { "max_brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxBrightness), nullptr, nullptr, nullptr },
        { "max_contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxContrast), nullptr, nullptr, nullptr },
        { "max_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxResolution), nullptr, nullptr, nullptr },
        { "max_scan_area", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxScanArea), nullptr, nullptr, nullptr },
        { "min_brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinBrightness), nullptr, nullptr, nullptr },
        { "min_contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinContrast), nullptr, nullptr, nullptr },
        { "min_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinResolution), nullptr, nullptr, nullptr },
        { "min_scan_area", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinScanArea), nullptr, nullptr, nullptr },
        { "optical_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_OpticalResolution), nullptr, nullptr, nullptr },
        { "selected_scan_region", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_SelectedScanRegion), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_SelectedScanRegion), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_Format), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IImageScannerSourceConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IImageScannerSourceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IImageScannerSourceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IImageScannerSourceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IImageScannerSourceConfiguration) },
        { },
    };

    static PyType_Spec type_spec_IImageScannerSourceConfiguration =
    {
        "winrt._winrt_windows_devices_scanners.IImageScannerSourceConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IImageScannerSourceConfiguration
    };

    // ----- ImageScannerResolution struct --------------------

    winrt_struct_wrapper<winrt::Windows::Devices::Scanners::ImageScannerResolution>* _new_ImageScannerResolution(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Scanners::ImageScannerResolution>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_ImageScannerResolution(winrt_struct_wrapper<winrt::Windows::Devices::Scanners::ImageScannerResolution>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        float _DpiX{};
        float _DpiY{};

        static const char* kwlist[] = {"dpi_x", "dpi_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_DpiX, &_DpiY))
        {
            return -1;
        }

        try
        {
            self->obj = {_DpiX, _DpiY};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_ImageScannerResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageScannerResolution(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerResolution>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ImageScannerResolution[] = {
        { "_assign_array_", _assign_array_ImageScannerResolution, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* ImageScannerResolution_get_DpiX(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerResolution_set_DpiX(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.DpiX = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerResolution_get_DpiY(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerResolution_set_DpiY(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.DpiY = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ImageScannerResolution[] = {
        { "dpi_x", reinterpret_cast<getter>(ImageScannerResolution_get_DpiX), reinterpret_cast<setter>(ImageScannerResolution_set_DpiX), nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(ImageScannerResolution_get_DpiY), reinterpret_cast<setter>(ImageScannerResolution_set_DpiY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerResolution[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerResolution) },
        { Py_tp_init, reinterpret_cast<void*>(_init_ImageScannerResolution) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerResolution) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerResolution) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerResolution) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerResolution =
    {
        "winrt._winrt_windows_devices_scanners.ImageScannerResolution",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerResolution
    };

    // ----- Windows.Devices.Scanners Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Scanners");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_scanners",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Scanners

PyMODINIT_FUNC PyInit__winrt_windows_devices_scanners(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Scanners;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageScanner_Static{PyType_FromSpec(&type_spec_ImageScanner_Static)};
    if (!type_ImageScanner_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScanner, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageScanner_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScannerAutoConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScannerFeederConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScannerFlatbedConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScannerPreviewResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScannerScanResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IImageScannerFormatConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IImageScannerSourceConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageScannerResolution, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
