# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections

from winrt.windows.management.deployment import AddPackageByAppInstallerOptions, DeploymentOptions, DeploymentProgressState, PackageInstallState, PackageState, PackageStatus, PackageStubPreference, PackageTypes, RemovalOptions, SharedPackageContainerCreationCollisionOptions, SharedPackageContainerOperationStatus, StubPackageOption

Self = typing.TypeVar('Self')

@typing.final
class DeploymentProgress:
    state: DeploymentProgressState
    percentage: winrt.system.UInt32
    def __init__(self, state: DeploymentProgressState, percentage: winrt.system.UInt32) -> None: ...

@typing.final
class AddPackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AddPackageOptions: ...
    def __new__(cls: typing.Type[AddPackageOptions]) -> AddPackageOptions:...
    @_property
    def target_volume(self) -> typing.Optional[PackageVolume]: ...
    @target_volume.setter
    def target_volume(self, value: typing.Optional[PackageVolume]) -> None: ...
    @_property
    def stub_package_option(self) -> StubPackageOption: ...
    @stub_package_option.setter
    def stub_package_option(self, value: StubPackageOption) -> None: ...
    @_property
    def stage_in_place(self) -> bool: ...
    @stage_in_place.setter
    def stage_in_place(self, value: bool) -> None: ...
    @_property
    def retain_files_on_failure(self) -> bool: ...
    @retain_files_on_failure.setter
    def retain_files_on_failure(self, value: bool) -> None: ...
    @_property
    def required_content_group_only(self) -> bool: ...
    @required_content_group_only.setter
    def required_content_group_only(self, value: bool) -> None: ...
    @_property
    def install_all_resources(self) -> bool: ...
    @install_all_resources.setter
    def install_all_resources(self, value: bool) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def force_target_app_shutdown(self) -> bool: ...
    @force_target_app_shutdown.setter
    def force_target_app_shutdown(self, value: bool) -> None: ...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...
    @_property
    def external_location_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @external_location_uri.setter
    def external_location_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def developer_mode(self) -> bool: ...
    @developer_mode.setter
    def developer_mode(self, value: bool) -> None: ...
    @_property
    def defer_registration_when_packages_are_in_use(self) -> bool: ...
    @defer_registration_when_packages_are_in_use.setter
    def defer_registration_when_packages_are_in_use(self, value: bool) -> None: ...
    @_property
    def allow_unsigned(self) -> bool: ...
    @allow_unsigned.setter
    def allow_unsigned(self, value: bool) -> None: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def optional_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def related_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def limit_to_existing_packages(self) -> bool: ...
    @limit_to_existing_packages.setter
    def limit_to_existing_packages(self, value: bool) -> None: ...
    @_property
    def expected_digests(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]: ...

@typing.final
class AppInstallerManager_Static(type):
    def get_default(cls) -> typing.Optional[AppInstallerManager]: ...
    def get_for_system(cls) -> typing.Optional[AppInstallerManager]: ...

@typing.final
class AppInstallerManager(winrt.system.Object, metaclass=AppInstallerManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallerManager: ...
    def clear_auto_update_settings(self, package_family_name: str, /) -> None: ...
    def pause_auto_updates_until(self, package_family_name: str, date_time: datetime.datetime, /) -> None: ...
    def set_auto_update_settings(self, package_family_name: str, app_installer_info: typing.Optional[AutoUpdateSettingsOptions], /) -> None: ...

@typing.final
class AutoUpdateSettingsOptions_Static(type):
    def create_from_app_installer_info(cls, app_installer_info: typing.Optional[winrt.windows.applicationmodel.AppInstallerInfo], /) -> typing.Optional[AutoUpdateSettingsOptions]: ...

@typing.final
class AutoUpdateSettingsOptions(winrt.system.Object, metaclass=AutoUpdateSettingsOptions_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoUpdateSettingsOptions: ...
    def __new__(cls: typing.Type[AutoUpdateSettingsOptions]) -> AutoUpdateSettingsOptions:...
    @_property
    def version(self) -> winrt.windows.applicationmodel.PackageVersion: ...
    @version.setter
    def version(self, value: winrt.windows.applicationmodel.PackageVersion) -> None: ...
    @_property
    def update_blocks_activation(self) -> bool: ...
    @update_blocks_activation.setter
    def update_blocks_activation(self, value: bool) -> None: ...
    @_property
    def show_prompt(self) -> bool: ...
    @show_prompt.setter
    def show_prompt(self, value: bool) -> None: ...
    @_property
    def on_launch(self) -> bool: ...
    @on_launch.setter
    def on_launch(self, value: bool) -> None: ...
    @_property
    def is_auto_repair_enabled(self) -> bool: ...
    @is_auto_repair_enabled.setter
    def is_auto_repair_enabled(self, value: bool) -> None: ...
    @_property
    def hours_between_update_checks(self) -> winrt.system.UInt32: ...
    @hours_between_update_checks.setter
    def hours_between_update_checks(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def automatic_background_task(self) -> bool: ...
    @automatic_background_task.setter
    def automatic_background_task(self, value: bool) -> None: ...
    @_property
    def app_installer_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @app_installer_uri.setter
    def app_installer_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def optional_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def repair_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def update_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...

@typing.final
class CreateSharedPackageContainerOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[CreateSharedPackageContainerOptions]) -> CreateSharedPackageContainerOptions:...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...
    @_property
    def create_collision_option(self) -> SharedPackageContainerCreationCollisionOptions: ...
    @create_collision_option.setter
    def create_collision_option(self, value: SharedPackageContainerCreationCollisionOptions) -> None: ...
    @_property
    def members(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainerMember]]: ...

@typing.final
class CreateSharedPackageContainerResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateSharedPackageContainerResult: ...
    @_property
    def container(self) -> typing.Optional[SharedPackageContainer]: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def status(self) -> SharedPackageContainerOperationStatus: ...

@typing.final
class DeleteSharedPackageContainerOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeleteSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[DeleteSharedPackageContainerOptions]) -> DeleteSharedPackageContainerOptions:...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...
    @_property
    def all_users(self) -> bool: ...
    @all_users.setter
    def all_users(self, value: bool) -> None: ...

@typing.final
class DeleteSharedPackageContainerResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeleteSharedPackageContainerResult: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def status(self) -> SharedPackageContainerOperationStatus: ...

@typing.final
class DeploymentResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeploymentResult: ...
    @_property
    def activity_id(self) -> _uuid.UUID: ...
    @_property
    def error_text(self) -> str: ...
    @_property
    def extended_error_code(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def is_registered(self) -> bool: ...

@typing.final
class FindSharedPackageContainerOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[FindSharedPackageContainerOptions]) -> FindSharedPackageContainerOptions:...
    @_property
    def package_family_name(self) -> str: ...
    @package_family_name.setter
    def package_family_name(self, value: str) -> None: ...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...

@typing.final
class PackageAllUserProvisioningOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageAllUserProvisioningOptions: ...
    def __new__(cls: typing.Type[PackageAllUserProvisioningOptions]) -> PackageAllUserProvisioningOptions:...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def projection_order_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class PackageManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageManager: ...
    def __new__(cls: typing.Type[PackageManager]) -> PackageManager:...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], external_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], package_uris_to_install: typing.Iterable[winrt.windows.foundation.Uri], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_by_app_installer_file_async(self, app_installer_file_uri: typing.Optional[winrt.windows.foundation.Uri], options: AddPackageByAppInstallerOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[AddPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_volume_async(self, package_store_path: str, /) -> winrt.windows.foundation.IAsyncOperation[PackageVolume]: ...
    def cleanup_package_for_user_async(self, package_name: str, user_security_id: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def clear_package_status(self, package_full_name: str, status: PackageStatus, /) -> None: ...
    def deprovision_package_for_all_users_async(self, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def find_package(self, package_full_name: str, /) -> typing.Optional[winrt.windows.applicationmodel.Package]: ...
    def find_package_for_user(self, user_security_id: str, package_full_name: str, /) -> typing.Optional[winrt.windows.applicationmodel.Package]: ...
    def find_package_volume(self, volume_name: str, /) -> typing.Optional[PackageVolume]: ...
    def find_package_volumes(self) -> typing.Optional[winrt.windows.foundation.collections.IIterable[PackageVolume]]: ...
    @typing.overload
    def find_packages(self) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_family_name: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_name: str, package_publisher: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_family_name: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_name: str, package_publisher: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    def find_provisioned_packages(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    def find_users(self, package_full_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[PackageUserInformation]]: ...
    def get_default_package_volume(self) -> typing.Optional[PackageVolume]: ...
    def get_package_stub_preference(self, package_family_name: str, /) -> PackageStubPreference: ...
    def get_package_volumes_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PackageVolume]]: ...
    def move_package_to_volume_async(self, package_full_name: str, deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def provision_package_for_all_users_async(self, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def provision_package_for_all_users_async(self, main_package_family_name: str, options: typing.Optional[PackageAllUserProvisioningOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def register_package_async(self, manifest_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def register_package_async(self, manifest_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, app_data_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_family_name_async(self, main_package_family_name: str, dependency_package_family_names: typing.Iterable[str], deployment_options: DeploymentOptions, app_data_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_full_name_async(self, main_package_full_name: str, dependency_package_full_names: typing.Iterable[str], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_uri_async(self, manifest_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_packages_by_full_name_async(self, package_full_names: typing.Iterable[str], options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def remove_package_async(self, package_full_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def remove_package_async(self, package_full_name: str, removal_options: RemovalOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def remove_package_volume_async(self, volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def request_add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def request_add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], package_uris_to_install: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def request_add_package_by_app_installer_file_async(self, app_installer_file_uri: typing.Optional[winrt.windows.foundation.Uri], options: AddPackageByAppInstallerOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def set_default_package_volume(self, volume: typing.Optional[PackageVolume], /) -> None: ...
    def set_package_state(self, package_full_name: str, package_state: PackageState, /) -> None: ...
    def set_package_status(self, package_full_name: str, status: PackageStatus, /) -> None: ...
    def set_package_stub_preference(self, package_family_name: str, use_stub: PackageStubPreference, /) -> None: ...
    def set_package_volume_offline_async(self, package_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def set_package_volume_online_async(self, package_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], external_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], package_uris_to_install: typing.Iterable[winrt.windows.foundation.Uri], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def stage_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[StagePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_user_data_async(self, package_full_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_user_data_async(self, package_full_name: str, deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def update_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @_property
    def debug_settings(self) -> typing.Optional[PackageManagerDebugSettings]: ...

@typing.final
class PackageManagerDebugSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageManagerDebugSettings: ...
    @typing.overload
    def set_content_group_state_async(self, package: typing.Optional[winrt.windows.applicationmodel.Package], content_group_name: str, state: winrt.windows.applicationmodel.PackageContentGroupState, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_content_group_state_async(self, package: typing.Optional[winrt.windows.applicationmodel.Package], content_group_name: str, state: winrt.windows.applicationmodel.PackageContentGroupState, completion_percentage: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class PackageUserInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageUserInformation: ...
    @_property
    def install_state(self) -> PackageInstallState: ...
    @_property
    def user_security_id(self) -> str: ...

@typing.final
class PackageVolume(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageVolume: ...
    def find_package(self, package_full_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    def find_package_for_user(self, user_security_id: str, package_full_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    def get_available_space_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt64]: ...
    @_property
    def is_offline(self) -> bool: ...
    @_property
    def is_system_volume(self) -> bool: ...
    @_property
    def mount_point(self) -> str: ...
    @_property
    def name(self) -> str: ...
    @_property
    def package_store_path(self) -> str: ...
    @_property
    def supports_hard_links(self) -> bool: ...
    @_property
    def is_appx_install_supported(self) -> bool: ...
    @_property
    def is_full_trust_package_supported(self) -> bool: ...

@typing.final
class RegisterPackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegisterPackageOptions: ...
    def __new__(cls: typing.Type[RegisterPackageOptions]) -> RegisterPackageOptions:...
    @_property
    def stage_in_place(self) -> bool: ...
    @stage_in_place.setter
    def stage_in_place(self, value: bool) -> None: ...
    @_property
    def install_all_resources(self) -> bool: ...
    @install_all_resources.setter
    def install_all_resources(self, value: bool) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def force_target_app_shutdown(self) -> bool: ...
    @force_target_app_shutdown.setter
    def force_target_app_shutdown(self, value: bool) -> None: ...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...
    @_property
    def external_location_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @external_location_uri.setter
    def external_location_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def developer_mode(self) -> bool: ...
    @developer_mode.setter
    def developer_mode(self, value: bool) -> None: ...
    @_property
    def defer_registration_when_packages_are_in_use(self) -> bool: ...
    @defer_registration_when_packages_are_in_use.setter
    def defer_registration_when_packages_are_in_use(self, value: bool) -> None: ...
    @_property
    def app_data_volume(self) -> typing.Optional[PackageVolume]: ...
    @app_data_volume.setter
    def app_data_volume(self, value: typing.Optional[PackageVolume]) -> None: ...
    @_property
    def allow_unsigned(self) -> bool: ...
    @allow_unsigned.setter
    def allow_unsigned(self, value: bool) -> None: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def expected_digests(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]: ...

@typing.final
class SharedPackageContainer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SharedPackageContainer: ...
    def get_members(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainerMember]]: ...
    def remove_package_family(self, package_family_name: str, options: typing.Optional[UpdateSharedPackageContainerOptions], /) -> typing.Optional[UpdateSharedPackageContainerResult]: ...
    def reset_data(self) -> typing.Optional[UpdateSharedPackageContainerResult]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def name(self) -> str: ...

@typing.final
class SharedPackageContainerManager_Static(type):
    def get_default(cls) -> typing.Optional[SharedPackageContainerManager]: ...
    def get_for_provisioning(cls) -> typing.Optional[SharedPackageContainerManager]: ...
    def get_for_user(cls, user_sid: str, /) -> typing.Optional[SharedPackageContainerManager]: ...

@typing.final
class SharedPackageContainerManager(winrt.system.Object, metaclass=SharedPackageContainerManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SharedPackageContainerManager: ...
    def create_container(self, name: str, options: typing.Optional[CreateSharedPackageContainerOptions], /) -> typing.Optional[CreateSharedPackageContainerResult]: ...
    def delete_container(self, id: str, options: typing.Optional[DeleteSharedPackageContainerOptions], /) -> typing.Optional[DeleteSharedPackageContainerResult]: ...
    @typing.overload
    def find_containers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainer]]: ...
    @typing.overload
    def find_containers(self, options: typing.Optional[FindSharedPackageContainerOptions], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainer]]: ...
    def get_container(self, id: str, /) -> typing.Optional[SharedPackageContainer]: ...

@typing.final
class SharedPackageContainerMember(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SharedPackageContainerMember: ...
    def __new__(cls: typing.Type[SharedPackageContainerMember], package_family_name: str) -> SharedPackageContainerMember:...
    @_property
    def package_family_name(self) -> str: ...

@typing.final
class StagePackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StagePackageOptions: ...
    def __new__(cls: typing.Type[StagePackageOptions]) -> StagePackageOptions:...
    @_property
    def target_volume(self) -> typing.Optional[PackageVolume]: ...
    @target_volume.setter
    def target_volume(self, value: typing.Optional[PackageVolume]) -> None: ...
    @_property
    def stub_package_option(self) -> StubPackageOption: ...
    @stub_package_option.setter
    def stub_package_option(self, value: StubPackageOption) -> None: ...
    @_property
    def stage_in_place(self) -> bool: ...
    @stage_in_place.setter
    def stage_in_place(self, value: bool) -> None: ...
    @_property
    def required_content_group_only(self) -> bool: ...
    @required_content_group_only.setter
    def required_content_group_only(self, value: bool) -> None: ...
    @_property
    def install_all_resources(self) -> bool: ...
    @install_all_resources.setter
    def install_all_resources(self, value: bool) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def external_location_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @external_location_uri.setter
    def external_location_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def developer_mode(self) -> bool: ...
    @developer_mode.setter
    def developer_mode(self, value: bool) -> None: ...
    @_property
    def allow_unsigned(self) -> bool: ...
    @allow_unsigned.setter
    def allow_unsigned(self, value: bool) -> None: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def optional_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def related_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def expected_digests(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]: ...

@typing.final
class UpdateSharedPackageContainerOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UpdateSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[UpdateSharedPackageContainerOptions]) -> UpdateSharedPackageContainerOptions:...
    @_property
    def require_packages_present(self) -> bool: ...
    @require_packages_present.setter
    def require_packages_present(self, value: bool) -> None: ...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...

@typing.final
class UpdateSharedPackageContainerResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UpdateSharedPackageContainerResult: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def status(self) -> SharedPackageContainerOperationStatus: ...

