// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Management.Deployment.h"


namespace py::cpp::Windows::Management::Deployment
{
    // ----- AddPackageOptions class --------------------

    static PyObject* _new_AddPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::AddPackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddPackageOptions(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AddPackageOptions_get_TargetVolume(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"TargetVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_TargetVolume(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"TargetVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StubPackageOption(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"StubPackageOption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StubPackageOption(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"StubPackageOption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"StageInPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"StageInPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RetainFilesOnFailure(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"RetainFilesOnFailure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RetainFilesOnFailure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RetainFilesOnFailure(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"RetainFilesOnFailure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RetainFilesOnFailure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"RequiredContentGroupOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"RequiredContentGroupOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"InstallAllResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"InstallAllResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ForceTargetAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ForceTargetAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ExternalLocationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ExternalLocationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"DeveloperMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"DeveloperMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"DeferRegistrationWhenPackagesAreInUse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"DeferRegistrationWhenPackagesAreInUse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"AllowUnsigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"AllowUnsigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"DependencyPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"OptionalPackageFamilyNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"OptionalPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_RelatedPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"RelatedPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_LimitToExistingPackages(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"LimitToExistingPackages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LimitToExistingPackages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_LimitToExistingPackages(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"LimitToExistingPackages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.LimitToExistingPackages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ExpectedDigests(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AddPackageOptions", L"ExpectedDigests"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedDigests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AddPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::AddPackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AddPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AddPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddPackageOptions[] = {
        { "_assign_array_", _assign_array_AddPackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AddPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AddPackageOptions[] = {
        { "target_volume", reinterpret_cast<getter>(AddPackageOptions_get_TargetVolume), reinterpret_cast<setter>(AddPackageOptions_put_TargetVolume), nullptr, nullptr },
        { "stub_package_option", reinterpret_cast<getter>(AddPackageOptions_get_StubPackageOption), reinterpret_cast<setter>(AddPackageOptions_put_StubPackageOption), nullptr, nullptr },
        { "stage_in_place", reinterpret_cast<getter>(AddPackageOptions_get_StageInPlace), reinterpret_cast<setter>(AddPackageOptions_put_StageInPlace), nullptr, nullptr },
        { "retain_files_on_failure", reinterpret_cast<getter>(AddPackageOptions_get_RetainFilesOnFailure), reinterpret_cast<setter>(AddPackageOptions_put_RetainFilesOnFailure), nullptr, nullptr },
        { "required_content_group_only", reinterpret_cast<getter>(AddPackageOptions_get_RequiredContentGroupOnly), reinterpret_cast<setter>(AddPackageOptions_put_RequiredContentGroupOnly), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(AddPackageOptions_get_InstallAllResources), reinterpret_cast<setter>(AddPackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AddPackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(AddPackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "force_target_app_shutdown", reinterpret_cast<getter>(AddPackageOptions_get_ForceTargetAppShutdown), reinterpret_cast<setter>(AddPackageOptions_put_ForceTargetAppShutdown), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(AddPackageOptions_get_ForceAppShutdown), reinterpret_cast<setter>(AddPackageOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(AddPackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(AddPackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(AddPackageOptions_get_DeveloperMode), reinterpret_cast<setter>(AddPackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "defer_registration_when_packages_are_in_use", reinterpret_cast<getter>(AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse), reinterpret_cast<setter>(AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(AddPackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(AddPackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(AddPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "related_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_RelatedPackageUris), nullptr, nullptr, nullptr },
        { "limit_to_existing_packages", reinterpret_cast<getter>(AddPackageOptions_get_LimitToExistingPackages), reinterpret_cast<setter>(AddPackageOptions_put_LimitToExistingPackages), nullptr, nullptr },
        { "expected_digests", reinterpret_cast<getter>(AddPackageOptions_get_ExpectedDigests), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AddPackageOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AddPackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AddPackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AddPackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AddPackageOptions) },
        { },
    };

    static PyType_Spec type_spec_AddPackageOptions = {
        "winrt._winrt_windows_management_deployment.AddPackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::AddPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddPackageOptions};

    // ----- AppInstallerManager class --------------------

    static PyObject* _new_AppInstallerManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::AppInstallerManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::AppInstallerManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AppInstallerManager(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppInstallerManager_ClearAutoUpdateSettings(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.AppInstallerManager", L"ClearAutoUpdateSettings", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ClearAutoUpdateSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.AppInstallerManager", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Management::Deployment::AppInstallerManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_GetForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.AppInstallerManager", L"GetForSystem", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Management::Deployment::AppInstallerManager::GetForSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_PauseAutoUpdatesUntil(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.AppInstallerManager", L"PauseAutoUpdatesUntil", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                self->obj.PauseAutoUpdatesUntil(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_SetAutoUpdateSettings(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.AppInstallerManager", L"SetAutoUpdateSettings", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>(args, 1);

                self->obj.SetAutoUpdateSettings(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppInstallerManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::AppInstallerManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppInstallerManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AppInstallerManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerManager[] = {
        { "clear_auto_update_settings", reinterpret_cast<PyCFunction>(AppInstallerManager_ClearAutoUpdateSettings), METH_VARARGS, nullptr },
        { "pause_auto_updates_until", reinterpret_cast<PyCFunction>(AppInstallerManager_PauseAutoUpdatesUntil), METH_VARARGS, nullptr },
        { "set_auto_update_settings", reinterpret_cast<PyCFunction>(AppInstallerManager_SetAutoUpdateSettings), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppInstallerManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstallerManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstallerManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppInstallerManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppInstallerManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppInstallerManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppInstallerManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppInstallerManager) },
        { },
    };

    static PyType_Spec type_spec_AppInstallerManager = {
        "winrt._winrt_windows_management_deployment.AppInstallerManager",
        sizeof(py::wrapper::Windows::Management::Deployment::AppInstallerManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerManager};

    static PyGetSetDef getset_AppInstallerManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AppInstallerManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppInstallerManager_GetDefault), METH_VARARGS, nullptr },
        { "get_for_system", reinterpret_cast<PyCFunction>(AppInstallerManager_GetForSystem), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppInstallerManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppInstallerManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppInstallerManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AppInstallerManager_Static =
    {
        "winrt._winrt_windows_management_deployment.AppInstallerManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppInstallerManager_Static
    };

    // ----- AutoUpdateSettingsOptions class --------------------

    static PyObject* _new_AutoUpdateSettingsOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoUpdateSettingsOptions(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoUpdateSettingsOptions_CreateFromAppInstallerInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"CreateFromAppInstallerInfo", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppInstallerInfo>(args, 0);

                return py::convert(winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions::CreateFromAppInstallerInfo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_Version(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_Version(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_UpdateBlocksActivation(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"UpdateBlocksActivation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_UpdateBlocksActivation(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"UpdateBlocksActivation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UpdateBlocksActivation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_ShowPrompt(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"ShowPrompt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_ShowPrompt(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"ShowPrompt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowPrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_OnLaunch(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"OnLaunch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_OnLaunch(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"OnLaunch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.OnLaunch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_IsAutoRepairEnabled(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"IsAutoRepairEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_IsAutoRepairEnabled(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"IsAutoRepairEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoRepairEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_HoursBetweenUpdateChecks(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"HoursBetweenUpdateChecks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_HoursBetweenUpdateChecks(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"HoursBetweenUpdateChecks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HoursBetweenUpdateChecks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_AutomaticBackgroundTask(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"AutomaticBackgroundTask"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_AutomaticBackgroundTask(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"AutomaticBackgroundTask"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutomaticBackgroundTask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_AppInstallerUri(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"AppInstallerUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppInstallerUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_AppInstallerUri(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"AppInstallerUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.AppInstallerUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"DependencyPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"OptionalPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_RepairUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"RepairUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_UpdateUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.AutoUpdateSettingsOptions", L"UpdateUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoUpdateSettingsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoUpdateSettingsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoUpdateSettingsOptions[] = {
        { "_assign_array_", _assign_array_AutoUpdateSettingsOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoUpdateSettingsOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoUpdateSettingsOptions[] = {
        { "version", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_Version), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_Version), nullptr, nullptr },
        { "update_blocks_activation", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_UpdateBlocksActivation), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_UpdateBlocksActivation), nullptr, nullptr },
        { "show_prompt", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_ShowPrompt), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_ShowPrompt), nullptr, nullptr },
        { "on_launch", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_OnLaunch), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_OnLaunch), nullptr, nullptr },
        { "is_auto_repair_enabled", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_IsAutoRepairEnabled), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_IsAutoRepairEnabled), nullptr, nullptr },
        { "hours_between_update_checks", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_HoursBetweenUpdateChecks), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_HoursBetweenUpdateChecks), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "automatic_background_task", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_AutomaticBackgroundTask), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_AutomaticBackgroundTask), nullptr, nullptr },
        { "app_installer_uri", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_AppInstallerUri), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_AppInstallerUri), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "repair_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_RepairUris), nullptr, nullptr, nullptr },
        { "update_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_UpdateUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutoUpdateSettingsOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoUpdateSettingsOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoUpdateSettingsOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoUpdateSettingsOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoUpdateSettingsOptions) },
        { },
    };

    static PyType_Spec type_spec_AutoUpdateSettingsOptions = {
        "winrt._winrt_windows_management_deployment.AutoUpdateSettingsOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoUpdateSettingsOptions};

    static PyGetSetDef getset_AutoUpdateSettingsOptions_Static[] = {
        { }
    };

    static PyMethodDef methods_AutoUpdateSettingsOptions_Static[] = {
        { "create_from_app_installer_info", reinterpret_cast<PyCFunction>(AutoUpdateSettingsOptions_CreateFromAppInstallerInfo), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutoUpdateSettingsOptions_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutoUpdateSettingsOptions_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutoUpdateSettingsOptions_Static) },
        { }
    };

    static PyType_Spec type_spec_AutoUpdateSettingsOptions_Static =
    {
        "winrt._winrt_windows_management_deployment.AutoUpdateSettingsOptions_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutoUpdateSettingsOptions_Static
    };

    // ----- CreateSharedPackageContainerOptions class --------------------

    static PyObject* _new_CreateSharedPackageContainerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::CreateSharedPackageContainerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CreateSharedPackageContainerOptions(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateSharedPackageContainerOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreateSharedPackageContainerOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreateSharedPackageContainerOptions_get_CreateCollisionOption(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerOptions", L"CreateCollisionOption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CreateCollisionOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreateSharedPackageContainerOptions_put_CreateCollisionOption(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerOptions", L"CreateCollisionOption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::SharedPackageContainerCreationCollisionOptions>(arg);

            self->obj.CreateCollisionOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreateSharedPackageContainerOptions_get_Members(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerOptions", L"Members"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Members());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::CreateSharedPackageContainerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::CreateSharedPackageContainerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateSharedPackageContainerOptions[] = {
        { "_assign_array_", _assign_array_CreateSharedPackageContainerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateSharedPackageContainerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateSharedPackageContainerOptions[] = {
        { "force_app_shutdown", reinterpret_cast<getter>(CreateSharedPackageContainerOptions_get_ForceAppShutdown), reinterpret_cast<setter>(CreateSharedPackageContainerOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "create_collision_option", reinterpret_cast<getter>(CreateSharedPackageContainerOptions_get_CreateCollisionOption), reinterpret_cast<setter>(CreateSharedPackageContainerOptions_put_CreateCollisionOption), nullptr, nullptr },
        { "members", reinterpret_cast<getter>(CreateSharedPackageContainerOptions_get_Members), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateSharedPackageContainerOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateSharedPackageContainerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateSharedPackageContainerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateSharedPackageContainerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateSharedPackageContainerOptions) },
        { },
    };

    static PyType_Spec type_spec_CreateSharedPackageContainerOptions = {
        "winrt._winrt_windows_management_deployment.CreateSharedPackageContainerOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateSharedPackageContainerOptions};

    // ----- CreateSharedPackageContainerResult class --------------------

    static PyObject* _new_CreateSharedPackageContainerResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::CreateSharedPackageContainerResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::CreateSharedPackageContainerResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateSharedPackageContainerResult(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateSharedPackageContainerResult_get_Container(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerResult", L"Container"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateSharedPackageContainerResult_get_ExtendedError(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateSharedPackageContainerResult_get_Status(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.CreateSharedPackageContainerResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateSharedPackageContainerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::CreateSharedPackageContainerResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateSharedPackageContainerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::CreateSharedPackageContainerResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateSharedPackageContainerResult[] = {
        { "_assign_array_", _assign_array_CreateSharedPackageContainerResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateSharedPackageContainerResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateSharedPackageContainerResult[] = {
        { "container", reinterpret_cast<getter>(CreateSharedPackageContainerResult_get_Container), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateSharedPackageContainerResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateSharedPackageContainerResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateSharedPackageContainerResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateSharedPackageContainerResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateSharedPackageContainerResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateSharedPackageContainerResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateSharedPackageContainerResult) },
        { },
    };

    static PyType_Spec type_spec_CreateSharedPackageContainerResult = {
        "winrt._winrt_windows_management_deployment.CreateSharedPackageContainerResult",
        sizeof(py::wrapper::Windows::Management::Deployment::CreateSharedPackageContainerResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateSharedPackageContainerResult};

    // ----- DeleteSharedPackageContainerOptions class --------------------

    static PyObject* _new_DeleteSharedPackageContainerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::DeleteSharedPackageContainerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeleteSharedPackageContainerOptions(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeleteSharedPackageContainerOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeleteSharedPackageContainerOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeleteSharedPackageContainerOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeleteSharedPackageContainerOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeleteSharedPackageContainerOptions_get_AllUsers(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeleteSharedPackageContainerOptions", L"AllUsers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllUsers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeleteSharedPackageContainerOptions_put_AllUsers(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeleteSharedPackageContainerOptions", L"AllUsers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllUsers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DeleteSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeleteSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeleteSharedPackageContainerOptions[] = {
        { "_assign_array_", _assign_array_DeleteSharedPackageContainerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeleteSharedPackageContainerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeleteSharedPackageContainerOptions[] = {
        { "force_app_shutdown", reinterpret_cast<getter>(DeleteSharedPackageContainerOptions_get_ForceAppShutdown), reinterpret_cast<setter>(DeleteSharedPackageContainerOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "all_users", reinterpret_cast<getter>(DeleteSharedPackageContainerOptions_get_AllUsers), reinterpret_cast<setter>(DeleteSharedPackageContainerOptions_put_AllUsers), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeleteSharedPackageContainerOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeleteSharedPackageContainerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeleteSharedPackageContainerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeleteSharedPackageContainerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeleteSharedPackageContainerOptions) },
        { },
    };

    static PyType_Spec type_spec_DeleteSharedPackageContainerOptions = {
        "winrt._winrt_windows_management_deployment.DeleteSharedPackageContainerOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeleteSharedPackageContainerOptions};

    // ----- DeleteSharedPackageContainerResult class --------------------

    static PyObject* _new_DeleteSharedPackageContainerResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DeleteSharedPackageContainerResult(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeleteSharedPackageContainerResult_get_ExtendedError(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeleteSharedPackageContainerResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSharedPackageContainerResult_get_Status(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeleteSharedPackageContainerResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeleteSharedPackageContainerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeleteSharedPackageContainerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeleteSharedPackageContainerResult[] = {
        { "_assign_array_", _assign_array_DeleteSharedPackageContainerResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeleteSharedPackageContainerResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeleteSharedPackageContainerResult[] = {
        { "extended_error", reinterpret_cast<getter>(DeleteSharedPackageContainerResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DeleteSharedPackageContainerResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeleteSharedPackageContainerResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeleteSharedPackageContainerResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeleteSharedPackageContainerResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeleteSharedPackageContainerResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeleteSharedPackageContainerResult) },
        { },
    };

    static PyType_Spec type_spec_DeleteSharedPackageContainerResult = {
        "winrt._winrt_windows_management_deployment.DeleteSharedPackageContainerResult",
        sizeof(py::wrapper::Windows::Management::Deployment::DeleteSharedPackageContainerResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeleteSharedPackageContainerResult};

    // ----- DeploymentResult class --------------------

    static PyObject* _new_DeploymentResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::DeploymentResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::DeploymentResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DeploymentResult(py::wrapper::Windows::Management::Deployment::DeploymentResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeploymentResult_get_ActivityId(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeploymentResult", L"ActivityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_ErrorText(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeploymentResult", L"ErrorText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_ExtendedErrorCode(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeploymentResult", L"ExtendedErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_IsRegistered(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.DeploymentResult", L"IsRegistered"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRegistered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeploymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::DeploymentResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeploymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::DeploymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentResult[] = {
        { "_assign_array_", _assign_array_DeploymentResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentResult[] = {
        { "activity_id", reinterpret_cast<getter>(DeploymentResult_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(DeploymentResult_get_ErrorText), nullptr, nullptr, nullptr },
        { "extended_error_code", reinterpret_cast<getter>(DeploymentResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "is_registered", reinterpret_cast<getter>(DeploymentResult_get_IsRegistered), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentResult) },
        { },
    };

    static PyType_Spec type_spec_DeploymentResult = {
        "winrt._winrt_windows_management_deployment.DeploymentResult",
        sizeof(py::wrapper::Windows::Management::Deployment::DeploymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentResult};

    // ----- FindSharedPackageContainerOptions class --------------------

    static PyObject* _new_FindSharedPackageContainerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::FindSharedPackageContainerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindSharedPackageContainerOptions(py::wrapper::Windows::Management::Deployment::FindSharedPackageContainerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FindSharedPackageContainerOptions_get_PackageFamilyName(py::wrapper::Windows::Management::Deployment::FindSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.FindSharedPackageContainerOptions", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindSharedPackageContainerOptions_put_PackageFamilyName(py::wrapper::Windows::Management::Deployment::FindSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.FindSharedPackageContainerOptions", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindSharedPackageContainerOptions_get_Name(py::wrapper::Windows::Management::Deployment::FindSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.FindSharedPackageContainerOptions", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindSharedPackageContainerOptions_put_Name(py::wrapper::Windows::Management::Deployment::FindSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.FindSharedPackageContainerOptions", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FindSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::FindSharedPackageContainerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FindSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::FindSharedPackageContainerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindSharedPackageContainerOptions[] = {
        { "_assign_array_", _assign_array_FindSharedPackageContainerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FindSharedPackageContainerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FindSharedPackageContainerOptions[] = {
        { "package_family_name", reinterpret_cast<getter>(FindSharedPackageContainerOptions_get_PackageFamilyName), reinterpret_cast<setter>(FindSharedPackageContainerOptions_put_PackageFamilyName), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(FindSharedPackageContainerOptions_get_Name), reinterpret_cast<setter>(FindSharedPackageContainerOptions_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FindSharedPackageContainerOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FindSharedPackageContainerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FindSharedPackageContainerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FindSharedPackageContainerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FindSharedPackageContainerOptions) },
        { },
    };

    static PyType_Spec type_spec_FindSharedPackageContainerOptions = {
        "winrt._winrt_windows_management_deployment.FindSharedPackageContainerOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::FindSharedPackageContainerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindSharedPackageContainerOptions};

    // ----- PackageAllUserProvisioningOptions class --------------------

    static PyObject* _new_PackageAllUserProvisioningOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageAllUserProvisioningOptions(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageAllUserProvisioningOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageAllUserProvisioningOptions", L"OptionalPackageFamilyNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageAllUserProvisioningOptions_get_ProjectionOrderPackageFamilyNames(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageAllUserProvisioningOptions", L"ProjectionOrderPackageFamilyNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProjectionOrderPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageAllUserProvisioningOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageAllUserProvisioningOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageAllUserProvisioningOptions[] = {
        { "_assign_array_", _assign_array_PackageAllUserProvisioningOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageAllUserProvisioningOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageAllUserProvisioningOptions[] = {
        { "optional_package_family_names", reinterpret_cast<getter>(PackageAllUserProvisioningOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "projection_order_package_family_names", reinterpret_cast<getter>(PackageAllUserProvisioningOptions_get_ProjectionOrderPackageFamilyNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageAllUserProvisioningOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageAllUserProvisioningOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageAllUserProvisioningOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageAllUserProvisioningOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageAllUserProvisioningOptions) },
        { },
    };

    static PyType_Spec type_spec_PackageAllUserProvisioningOptions = {
        "winrt._winrt_windows_management_deployment.PackageAllUserProvisioningOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageAllUserProvisioningOptions};

    // ----- PackageManager class --------------------

    static PyObject* _new_PackageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::PackageManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageManager(py::wrapper::Windows::Management::Deployment::PackageManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageManager_AddPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageAsync", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageAsync", 7))
                {
                    py::set_arg_count_version_error(7);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageByAppInstallerFileAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageByAppInstallerFileAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageByAppInstallerOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.AddPackageByAppInstallerFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageByUriAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageOptions>(args, 1);

                return py::convert(self->obj.AddPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"AddPackageVolumeAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddPackageVolumeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_CleanupPackageForUserAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"CleanupPackageForUserAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CleanupPackageForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_ClearPackageStatus(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"ClearPackageStatus", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStatus>(args, 1);

                self->obj.ClearPackageStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_DeprovisionPackageForAllUsersAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"DeprovisionPackageForAllUsersAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeprovisionPackageForAllUsersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackage(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageForUser(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackageForUser", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackageVolume", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackageVolume(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageVolumes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackageVolumes", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindPackageVolumes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackages(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackages", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackages", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackages", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackages(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesForUser(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesForUser", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesForUser", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUser(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesForUserWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesForUserWithPackageTypes", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesForUserWithPackageTypes", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 2);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesForUserWithPackageTypes", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 3);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesWithPackageTypes", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesWithPackageTypes", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindPackagesWithPackageTypes", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 2);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindProvisionedPackages(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindProvisionedPackages", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindProvisionedPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindUsers(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"FindUsers", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindUsers(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetDefaultPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"GetDefaultPackageVolume", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDefaultPackageVolume());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetPackageStubPreference(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"GetPackageStubPreference", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPackageStubPreference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetPackageVolumesAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"GetPackageVolumesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPackageVolumesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_MovePackageToVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"MovePackageToVolumeAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.MovePackageToVolumeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_ProvisionPackageForAllUsersAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"ProvisionPackageForAllUsersAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ProvisionPackageForAllUsersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"ProvisionPackageForAllUsersAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>(args, 1);

                return py::convert(self->obj.ProvisionPackageForAllUsersAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RegisterPackageAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RegisterPackageAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByFamilyNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RegisterPackageByFamilyNameAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);

                return py::convert(self->obj.RegisterPackageByFamilyNameAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByFullNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RegisterPackageByFullNameAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.RegisterPackageByFullNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RegisterPackageByUriAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackagesByFullNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RegisterPackagesByFullNameAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackagesByFullNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RemovePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RemovePackageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemovePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RemovePackageAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RemovalOptions>(args, 1);

                return py::convert(self->obj.RemovePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RemovePackageVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RemovePackageVolumeAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.RemovePackageVolumeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RequestAddPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RequestAddPackageAsync", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.RequestAddPackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RequestAddPackageAsync", 7))
                {
                    py::set_arg_count_version_error(7);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.RequestAddPackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RequestAddPackageByAppInstallerFileAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"RequestAddPackageByAppInstallerFileAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageByAppInstallerOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.RequestAddPackageByAppInstallerFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetDefaultPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"SetDefaultPackageVolume", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                self->obj.SetDefaultPackageVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageState(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"SetPackageState", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageState>(args, 1);

                self->obj.SetPackageState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageStatus(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"SetPackageStatus", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStatus>(args, 1);

                self->obj.SetPackageStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageStubPreference(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"SetPackageStubPreference", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStubPreference>(args, 1);

                self->obj.SetPackageStubPreference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageVolumeOfflineAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"SetPackageVolumeOfflineAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.SetPackageVolumeOfflineAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageVolumeOnlineAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"SetPackageVolumeOnlineAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.SetPackageVolumeOnlineAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StagePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StagePackageAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);

                return py::convert(self->obj.StagePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StagePackageAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StagePackageAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StagePackageAsync", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StagePackageAsync", 7))
                {
                    py::set_arg_count_version_error(7);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StagePackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StagePackageByUriAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::StagePackageOptions>(args, 1);

                return py::convert(self->obj.StagePackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StageUserDataAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StageUserDataAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StageUserDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"StageUserDataAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 1);

                return py::convert(self->obj.StageUserDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_UpdatePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManager", L"UpdatePackageAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.UpdatePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_get_DebugSettings(py::wrapper::Windows::Management::Deployment::PackageManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageManager", L"DebugSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DebugSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::PackageManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageManager[] = {
        { "add_package_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageAsync), METH_VARARGS, nullptr },
        { "add_package_by_app_installer_file_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageByAppInstallerFileAsync), METH_VARARGS, nullptr },
        { "add_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageByUriAsync), METH_VARARGS, nullptr },
        { "add_package_volume_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageVolumeAsync), METH_VARARGS, nullptr },
        { "cleanup_package_for_user_async", reinterpret_cast<PyCFunction>(PackageManager_CleanupPackageForUserAsync), METH_VARARGS, nullptr },
        { "clear_package_status", reinterpret_cast<PyCFunction>(PackageManager_ClearPackageStatus), METH_VARARGS, nullptr },
        { "deprovision_package_for_all_users_async", reinterpret_cast<PyCFunction>(PackageManager_DeprovisionPackageForAllUsersAsync), METH_VARARGS, nullptr },
        { "find_package", reinterpret_cast<PyCFunction>(PackageManager_FindPackage), METH_VARARGS, nullptr },
        { "find_package_for_user", reinterpret_cast<PyCFunction>(PackageManager_FindPackageForUser), METH_VARARGS, nullptr },
        { "find_package_volume", reinterpret_cast<PyCFunction>(PackageManager_FindPackageVolume), METH_VARARGS, nullptr },
        { "find_package_volumes", reinterpret_cast<PyCFunction>(PackageManager_FindPackageVolumes), METH_VARARGS, nullptr },
        { "find_packages", reinterpret_cast<PyCFunction>(PackageManager_FindPackages), METH_VARARGS, nullptr },
        { "find_packages_for_user", reinterpret_cast<PyCFunction>(PackageManager_FindPackagesForUser), METH_VARARGS, nullptr },
        { "find_packages_for_user_with_package_types", reinterpret_cast<PyCFunction>(PackageManager_FindPackagesForUserWithPackageTypes), METH_VARARGS, nullptr },
        { "find_packages_with_package_types", reinterpret_cast<PyCFunction>(PackageManager_FindPackagesWithPackageTypes), METH_VARARGS, nullptr },
        { "find_provisioned_packages", reinterpret_cast<PyCFunction>(PackageManager_FindProvisionedPackages), METH_VARARGS, nullptr },
        { "find_users", reinterpret_cast<PyCFunction>(PackageManager_FindUsers), METH_VARARGS, nullptr },
        { "get_default_package_volume", reinterpret_cast<PyCFunction>(PackageManager_GetDefaultPackageVolume), METH_VARARGS, nullptr },
        { "get_package_stub_preference", reinterpret_cast<PyCFunction>(PackageManager_GetPackageStubPreference), METH_VARARGS, nullptr },
        { "get_package_volumes_async", reinterpret_cast<PyCFunction>(PackageManager_GetPackageVolumesAsync), METH_VARARGS, nullptr },
        { "move_package_to_volume_async", reinterpret_cast<PyCFunction>(PackageManager_MovePackageToVolumeAsync), METH_VARARGS, nullptr },
        { "provision_package_for_all_users_async", reinterpret_cast<PyCFunction>(PackageManager_ProvisionPackageForAllUsersAsync), METH_VARARGS, nullptr },
        { "register_package_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageAsync), METH_VARARGS, nullptr },
        { "register_package_by_family_name_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageByFamilyNameAsync), METH_VARARGS, nullptr },
        { "register_package_by_full_name_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageByFullNameAsync), METH_VARARGS, nullptr },
        { "register_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageByUriAsync), METH_VARARGS, nullptr },
        { "register_packages_by_full_name_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackagesByFullNameAsync), METH_VARARGS, nullptr },
        { "remove_package_async", reinterpret_cast<PyCFunction>(PackageManager_RemovePackageAsync), METH_VARARGS, nullptr },
        { "remove_package_volume_async", reinterpret_cast<PyCFunction>(PackageManager_RemovePackageVolumeAsync), METH_VARARGS, nullptr },
        { "request_add_package_async", reinterpret_cast<PyCFunction>(PackageManager_RequestAddPackageAsync), METH_VARARGS, nullptr },
        { "request_add_package_by_app_installer_file_async", reinterpret_cast<PyCFunction>(PackageManager_RequestAddPackageByAppInstallerFileAsync), METH_VARARGS, nullptr },
        { "set_default_package_volume", reinterpret_cast<PyCFunction>(PackageManager_SetDefaultPackageVolume), METH_VARARGS, nullptr },
        { "set_package_state", reinterpret_cast<PyCFunction>(PackageManager_SetPackageState), METH_VARARGS, nullptr },
        { "set_package_status", reinterpret_cast<PyCFunction>(PackageManager_SetPackageStatus), METH_VARARGS, nullptr },
        { "set_package_stub_preference", reinterpret_cast<PyCFunction>(PackageManager_SetPackageStubPreference), METH_VARARGS, nullptr },
        { "set_package_volume_offline_async", reinterpret_cast<PyCFunction>(PackageManager_SetPackageVolumeOfflineAsync), METH_VARARGS, nullptr },
        { "set_package_volume_online_async", reinterpret_cast<PyCFunction>(PackageManager_SetPackageVolumeOnlineAsync), METH_VARARGS, nullptr },
        { "stage_package_async", reinterpret_cast<PyCFunction>(PackageManager_StagePackageAsync), METH_VARARGS, nullptr },
        { "stage_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageManager_StagePackageByUriAsync), METH_VARARGS, nullptr },
        { "stage_user_data_async", reinterpret_cast<PyCFunction>(PackageManager_StageUserDataAsync), METH_VARARGS, nullptr },
        { "update_package_async", reinterpret_cast<PyCFunction>(PackageManager_UpdatePackageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageManager[] = {
        { "debug_settings", reinterpret_cast<getter>(PackageManager_get_DebugSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageManager) },
        { },
    };

    static PyType_Spec type_spec_PackageManager = {
        "winrt._winrt_windows_management_deployment.PackageManager",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageManager};

    // ----- PackageManagerDebugSettings class --------------------

    static PyObject* _new_PackageManagerDebugSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageManagerDebugSettings(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageManagerDebugSettings_SetContentGroupStateAsync(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManagerDebugSettings", L"SetContentGroupStateAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::PackageContentGroupState>(args, 2);

                return py::convert(self->obj.SetContentGroupStateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageManagerDebugSettings", L"SetContentGroupStateAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::PackageContentGroupState>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(self->obj.SetContentGroupStateAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageManagerDebugSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageManagerDebugSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageManagerDebugSettings[] = {
        { "set_content_group_state_async", reinterpret_cast<PyCFunction>(PackageManagerDebugSettings_SetContentGroupStateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageManagerDebugSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageManagerDebugSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageManagerDebugSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageManagerDebugSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageManagerDebugSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageManagerDebugSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageManagerDebugSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageManagerDebugSettings) },
        { },
    };

    static PyType_Spec type_spec_PackageManagerDebugSettings = {
        "winrt._winrt_windows_management_deployment.PackageManagerDebugSettings",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageManagerDebugSettings};

    // ----- PackageUserInformation class --------------------

    static PyObject* _new_PackageUserInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::PackageUserInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::PackageUserInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageUserInformation(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageUserInformation_get_InstallState(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageUserInformation", L"InstallState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUserInformation_get_UserSecurityId(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageUserInformation", L"UserSecurityId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserSecurityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageUserInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::PackageUserInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageUserInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageUserInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUserInformation[] = {
        { "_assign_array_", _assign_array_PackageUserInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUserInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUserInformation[] = {
        { "install_state", reinterpret_cast<getter>(PackageUserInformation_get_InstallState), nullptr, nullptr, nullptr },
        { "user_security_id", reinterpret_cast<getter>(PackageUserInformation_get_UserSecurityId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUserInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageUserInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageUserInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageUserInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageUserInformation) },
        { },
    };

    static PyType_Spec type_spec_PackageUserInformation = {
        "winrt._winrt_windows_management_deployment.PackageUserInformation",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageUserInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUserInformation};

    // ----- PackageVolume class --------------------

    static PyObject* _new_PackageVolume(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::PackageVolume>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::PackageVolume>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageVolume(py::wrapper::Windows::Management::Deployment::PackageVolume* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageVolume_FindPackage(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackageForUser(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackageForUser", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackages(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackages", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackages", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackages", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackages(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesForUser(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesForUser", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesForUser", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUser(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesForUserWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesForUserWithPackageTypes", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesForUserWithPackageTypes", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesForUserWithPackageTypes", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesWithPackageTypes", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesWithPackageTypes", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"FindPackagesWithPackageTypes", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_GetAvailableSpaceAsync(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.PackageVolume", L"GetAvailableSpaceAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAvailableSpaceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsOffline(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"IsOffline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsSystemVolume(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"IsSystemVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSystemVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_MountPoint(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"MountPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MountPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_Name(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_PackageStorePath(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"PackageStorePath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageStorePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_SupportsHardLinks(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"SupportsHardLinks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportsHardLinks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsAppxInstallSupported(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"IsAppxInstallSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAppxInstallSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsFullTrustPackageSupported(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.PackageVolume", L"IsFullTrustPackageSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFullTrustPackageSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageVolume(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::PackageVolume>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageVolume(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageVolume>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageVolume[] = {
        { "find_package", reinterpret_cast<PyCFunction>(PackageVolume_FindPackage), METH_VARARGS, nullptr },
        { "find_package_for_user", reinterpret_cast<PyCFunction>(PackageVolume_FindPackageForUser), METH_VARARGS, nullptr },
        { "find_packages", reinterpret_cast<PyCFunction>(PackageVolume_FindPackages), METH_VARARGS, nullptr },
        { "find_packages_for_user", reinterpret_cast<PyCFunction>(PackageVolume_FindPackagesForUser), METH_VARARGS, nullptr },
        { "find_packages_for_user_with_package_types", reinterpret_cast<PyCFunction>(PackageVolume_FindPackagesForUserWithPackageTypes), METH_VARARGS, nullptr },
        { "find_packages_with_package_types", reinterpret_cast<PyCFunction>(PackageVolume_FindPackagesWithPackageTypes), METH_VARARGS, nullptr },
        { "get_available_space_async", reinterpret_cast<PyCFunction>(PackageVolume_GetAvailableSpaceAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageVolume, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageVolume), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageVolume[] = {
        { "is_offline", reinterpret_cast<getter>(PackageVolume_get_IsOffline), nullptr, nullptr, nullptr },
        { "is_system_volume", reinterpret_cast<getter>(PackageVolume_get_IsSystemVolume), nullptr, nullptr, nullptr },
        { "mount_point", reinterpret_cast<getter>(PackageVolume_get_MountPoint), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageVolume_get_Name), nullptr, nullptr, nullptr },
        { "package_store_path", reinterpret_cast<getter>(PackageVolume_get_PackageStorePath), nullptr, nullptr, nullptr },
        { "supports_hard_links", reinterpret_cast<getter>(PackageVolume_get_SupportsHardLinks), nullptr, nullptr, nullptr },
        { "is_appx_install_supported", reinterpret_cast<getter>(PackageVolume_get_IsAppxInstallSupported), nullptr, nullptr, nullptr },
        { "is_full_trust_package_supported", reinterpret_cast<getter>(PackageVolume_get_IsFullTrustPackageSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageVolume[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageVolume) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageVolume) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageVolume) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageVolume) },
        { },
    };

    static PyType_Spec type_spec_PackageVolume = {
        "winrt._winrt_windows_management_deployment.PackageVolume",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageVolume),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVolume};

    // ----- RegisterPackageOptions class --------------------

    static PyObject* _new_RegisterPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::RegisterPackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegisterPackageOptions(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RegisterPackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"StageInPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"StageInPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"InstallAllResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"InstallAllResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ForceTargetAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ForceTargetAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ExternalLocationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ExternalLocationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"DeveloperMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"DeveloperMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"DeferRegistrationWhenPackagesAreInUse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"DeferRegistrationWhenPackagesAreInUse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AppDataVolume(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"AppDataVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppDataVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AppDataVolume(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"AppDataVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.AppDataVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"AllowUnsigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"AllowUnsigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"DependencyPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"OptionalPackageFamilyNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_ExpectedDigests(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.RegisterPackageOptions", L"ExpectedDigests"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedDigests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RegisterPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::RegisterPackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RegisterPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::RegisterPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegisterPackageOptions[] = {
        { "_assign_array_", _assign_array_RegisterPackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RegisterPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegisterPackageOptions[] = {
        { "stage_in_place", reinterpret_cast<getter>(RegisterPackageOptions_get_StageInPlace), reinterpret_cast<setter>(RegisterPackageOptions_put_StageInPlace), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(RegisterPackageOptions_get_InstallAllResources), reinterpret_cast<setter>(RegisterPackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "force_target_app_shutdown", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceTargetAppShutdown), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceTargetAppShutdown), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceAppShutdown), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(RegisterPackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(RegisterPackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(RegisterPackageOptions_get_DeveloperMode), reinterpret_cast<setter>(RegisterPackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "defer_registration_when_packages_are_in_use", reinterpret_cast<getter>(RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse), reinterpret_cast<setter>(RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse), nullptr, nullptr },
        { "app_data_volume", reinterpret_cast<getter>(RegisterPackageOptions_get_AppDataVolume), reinterpret_cast<setter>(RegisterPackageOptions_put_AppDataVolume), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(RegisterPackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(RegisterPackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(RegisterPackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(RegisterPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "expected_digests", reinterpret_cast<getter>(RegisterPackageOptions_get_ExpectedDigests), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegisterPackageOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RegisterPackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RegisterPackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RegisterPackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RegisterPackageOptions) },
        { },
    };

    static PyType_Spec type_spec_RegisterPackageOptions = {
        "winrt._winrt_windows_management_deployment.RegisterPackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegisterPackageOptions};

    // ----- SharedPackageContainer class --------------------

    static PyObject* _new_SharedPackageContainer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::SharedPackageContainer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::SharedPackageContainer>::type_name);
        return nullptr;
    }

    static void _dealloc_SharedPackageContainer(py::wrapper::Windows::Management::Deployment::SharedPackageContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SharedPackageContainer_GetMembers(py::wrapper::Windows::Management::Deployment::SharedPackageContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainer", L"GetMembers", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMembers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainer_RemovePackageFamily(py::wrapper::Windows::Management::Deployment::SharedPackageContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainer", L"RemovePackageFamily", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerOptions>(args, 1);

                return py::convert(self->obj.RemovePackageFamily(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainer_ResetData(py::wrapper::Windows::Management::Deployment::SharedPackageContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainer", L"ResetData", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ResetData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainer_get_Id(py::wrapper::Windows::Management::Deployment::SharedPackageContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.SharedPackageContainer", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainer_get_Name(py::wrapper::Windows::Management::Deployment::SharedPackageContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.SharedPackageContainer", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SharedPackageContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::SharedPackageContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SharedPackageContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::SharedPackageContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedPackageContainer[] = {
        { "get_members", reinterpret_cast<PyCFunction>(SharedPackageContainer_GetMembers), METH_VARARGS, nullptr },
        { "remove_package_family", reinterpret_cast<PyCFunction>(SharedPackageContainer_RemovePackageFamily), METH_VARARGS, nullptr },
        { "reset_data", reinterpret_cast<PyCFunction>(SharedPackageContainer_ResetData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SharedPackageContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SharedPackageContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SharedPackageContainer[] = {
        { "id", reinterpret_cast<getter>(SharedPackageContainer_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(SharedPackageContainer_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SharedPackageContainer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedPackageContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SharedPackageContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedPackageContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedPackageContainer) },
        { },
    };

    static PyType_Spec type_spec_SharedPackageContainer = {
        "winrt._winrt_windows_management_deployment.SharedPackageContainer",
        sizeof(py::wrapper::Windows::Management::Deployment::SharedPackageContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedPackageContainer};

    // ----- SharedPackageContainerManager class --------------------

    static PyObject* _new_SharedPackageContainerManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::SharedPackageContainerManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::SharedPackageContainerManager>::type_name);
        return nullptr;
    }

    static void _dealloc_SharedPackageContainerManager(py::wrapper::Windows::Management::Deployment::SharedPackageContainerManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SharedPackageContainerManager_CreateContainer(py::wrapper::Windows::Management::Deployment::SharedPackageContainerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"CreateContainer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::CreateSharedPackageContainerOptions>(args, 1);

                return py::convert(self->obj.CreateContainer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainerManager_DeleteContainer(py::wrapper::Windows::Management::Deployment::SharedPackageContainerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"DeleteContainer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeleteSharedPackageContainerOptions>(args, 1);

                return py::convert(self->obj.DeleteContainer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainerManager_FindContainers(py::wrapper::Windows::Management::Deployment::SharedPackageContainerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"FindContainers", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindContainers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"FindContainers", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::FindSharedPackageContainerOptions>(args, 0);

                return py::convert(self->obj.FindContainers(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainerManager_GetContainer(py::wrapper::Windows::Management::Deployment::SharedPackageContainerManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"GetContainer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContainer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainerManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Management::Deployment::SharedPackageContainerManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainerManager_GetForProvisioning(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"GetForProvisioning", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Management::Deployment::SharedPackageContainerManager::GetForProvisioning());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedPackageContainerManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Deployment.SharedPackageContainerManager", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Management::Deployment::SharedPackageContainerManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SharedPackageContainerManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::SharedPackageContainerManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SharedPackageContainerManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::SharedPackageContainerManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedPackageContainerManager[] = {
        { "create_container", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_CreateContainer), METH_VARARGS, nullptr },
        { "delete_container", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_DeleteContainer), METH_VARARGS, nullptr },
        { "find_containers", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_FindContainers), METH_VARARGS, nullptr },
        { "get_container", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_GetContainer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SharedPackageContainerManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SharedPackageContainerManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SharedPackageContainerManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SharedPackageContainerManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedPackageContainerManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SharedPackageContainerManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedPackageContainerManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedPackageContainerManager) },
        { },
    };

    static PyType_Spec type_spec_SharedPackageContainerManager = {
        "winrt._winrt_windows_management_deployment.SharedPackageContainerManager",
        sizeof(py::wrapper::Windows::Management::Deployment::SharedPackageContainerManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedPackageContainerManager};

    static PyGetSetDef getset_SharedPackageContainerManager_Static[] = {
        { }
    };

    static PyMethodDef methods_SharedPackageContainerManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_GetDefault), METH_VARARGS, nullptr },
        { "get_for_provisioning", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_GetForProvisioning), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(SharedPackageContainerManager_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SharedPackageContainerManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SharedPackageContainerManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SharedPackageContainerManager_Static) },
        { }
    };

    static PyType_Spec type_spec_SharedPackageContainerManager_Static =
    {
        "winrt._winrt_windows_management_deployment.SharedPackageContainerManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SharedPackageContainerManager_Static
    };

    // ----- SharedPackageContainerMember class --------------------

    static PyObject* _new_SharedPackageContainerMember(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Management::Deployment::SharedPackageContainerMember instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SharedPackageContainerMember(py::wrapper::Windows::Management::Deployment::SharedPackageContainerMember* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SharedPackageContainerMember_get_PackageFamilyName(py::wrapper::Windows::Management::Deployment::SharedPackageContainerMember* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.SharedPackageContainerMember", L"PackageFamilyName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SharedPackageContainerMember(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::SharedPackageContainerMember>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SharedPackageContainerMember(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::SharedPackageContainerMember>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedPackageContainerMember[] = {
        { "_assign_array_", _assign_array_SharedPackageContainerMember, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SharedPackageContainerMember), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SharedPackageContainerMember[] = {
        { "package_family_name", reinterpret_cast<getter>(SharedPackageContainerMember_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SharedPackageContainerMember[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedPackageContainerMember) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SharedPackageContainerMember) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedPackageContainerMember) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedPackageContainerMember) },
        { },
    };

    static PyType_Spec type_spec_SharedPackageContainerMember = {
        "winrt._winrt_windows_management_deployment.SharedPackageContainerMember",
        sizeof(py::wrapper::Windows::Management::Deployment::SharedPackageContainerMember),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedPackageContainerMember};

    // ----- StagePackageOptions class --------------------

    static PyObject* _new_StagePackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::StagePackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StagePackageOptions(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StagePackageOptions_get_TargetVolume(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"TargetVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_TargetVolume(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"TargetVolume"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StubPackageOption(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"StubPackageOption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StubPackageOption(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"StubPackageOption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"StageInPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"StageInPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"RequiredContentGroupOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"RequiredContentGroupOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"InstallAllResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"InstallAllResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"ForceUpdateFromAnyVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"ExternalLocationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"ExternalLocationUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"DeveloperMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"DeveloperMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"AllowUnsigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"AllowUnsigned"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"DependencyPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"OptionalPackageFamilyNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"OptionalPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_RelatedPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"RelatedPackageUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_ExpectedDigests(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.StagePackageOptions", L"ExpectedDigests"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedDigests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StagePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::StagePackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StagePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::StagePackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StagePackageOptions[] = {
        { "_assign_array_", _assign_array_StagePackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StagePackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StagePackageOptions[] = {
        { "target_volume", reinterpret_cast<getter>(StagePackageOptions_get_TargetVolume), reinterpret_cast<setter>(StagePackageOptions_put_TargetVolume), nullptr, nullptr },
        { "stub_package_option", reinterpret_cast<getter>(StagePackageOptions_get_StubPackageOption), reinterpret_cast<setter>(StagePackageOptions_put_StubPackageOption), nullptr, nullptr },
        { "stage_in_place", reinterpret_cast<getter>(StagePackageOptions_get_StageInPlace), reinterpret_cast<setter>(StagePackageOptions_put_StageInPlace), nullptr, nullptr },
        { "required_content_group_only", reinterpret_cast<getter>(StagePackageOptions_get_RequiredContentGroupOnly), reinterpret_cast<setter>(StagePackageOptions_put_RequiredContentGroupOnly), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(StagePackageOptions_get_InstallAllResources), reinterpret_cast<setter>(StagePackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(StagePackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(StagePackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(StagePackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(StagePackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(StagePackageOptions_get_DeveloperMode), reinterpret_cast<setter>(StagePackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(StagePackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(StagePackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(StagePackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "related_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_RelatedPackageUris), nullptr, nullptr, nullptr },
        { "expected_digests", reinterpret_cast<getter>(StagePackageOptions_get_ExpectedDigests), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StagePackageOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StagePackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StagePackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StagePackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StagePackageOptions) },
        { },
    };

    static PyType_Spec type_spec_StagePackageOptions = {
        "winrt._winrt_windows_management_deployment.StagePackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::StagePackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StagePackageOptions};

    // ----- UpdateSharedPackageContainerOptions class --------------------

    static PyObject* _new_UpdateSharedPackageContainerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::UpdateSharedPackageContainerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UpdateSharedPackageContainerOptions(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UpdateSharedPackageContainerOptions_get_RequirePackagesPresent(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.UpdateSharedPackageContainerOptions", L"RequirePackagesPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequirePackagesPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UpdateSharedPackageContainerOptions_put_RequirePackagesPresent(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.UpdateSharedPackageContainerOptions", L"RequirePackagesPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequirePackagesPresent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UpdateSharedPackageContainerOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.UpdateSharedPackageContainerOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UpdateSharedPackageContainerOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.UpdateSharedPackageContainerOptions", L"ForceAppShutdown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UpdateSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UpdateSharedPackageContainerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UpdateSharedPackageContainerOptions[] = {
        { "_assign_array_", _assign_array_UpdateSharedPackageContainerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UpdateSharedPackageContainerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UpdateSharedPackageContainerOptions[] = {
        { "require_packages_present", reinterpret_cast<getter>(UpdateSharedPackageContainerOptions_get_RequirePackagesPresent), reinterpret_cast<setter>(UpdateSharedPackageContainerOptions_put_RequirePackagesPresent), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(UpdateSharedPackageContainerOptions_get_ForceAppShutdown), reinterpret_cast<setter>(UpdateSharedPackageContainerOptions_put_ForceAppShutdown), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UpdateSharedPackageContainerOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UpdateSharedPackageContainerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UpdateSharedPackageContainerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UpdateSharedPackageContainerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UpdateSharedPackageContainerOptions) },
        { },
    };

    static PyType_Spec type_spec_UpdateSharedPackageContainerOptions = {
        "winrt._winrt_windows_management_deployment.UpdateSharedPackageContainerOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UpdateSharedPackageContainerOptions};

    // ----- UpdateSharedPackageContainerResult class --------------------

    static PyObject* _new_UpdateSharedPackageContainerResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerResult>::type_name);
        return nullptr;
    }

    static void _dealloc_UpdateSharedPackageContainerResult(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UpdateSharedPackageContainerResult_get_ExtendedError(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.UpdateSharedPackageContainerResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UpdateSharedPackageContainerResult_get_Status(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Deployment.UpdateSharedPackageContainerResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UpdateSharedPackageContainerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UpdateSharedPackageContainerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::UpdateSharedPackageContainerResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UpdateSharedPackageContainerResult[] = {
        { "_assign_array_", _assign_array_UpdateSharedPackageContainerResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UpdateSharedPackageContainerResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UpdateSharedPackageContainerResult[] = {
        { "extended_error", reinterpret_cast<getter>(UpdateSharedPackageContainerResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(UpdateSharedPackageContainerResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UpdateSharedPackageContainerResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UpdateSharedPackageContainerResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UpdateSharedPackageContainerResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UpdateSharedPackageContainerResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UpdateSharedPackageContainerResult) },
        { },
    };

    static PyType_Spec type_spec_UpdateSharedPackageContainerResult = {
        "winrt._winrt_windows_management_deployment.UpdateSharedPackageContainerResult",
        sizeof(py::wrapper::Windows::Management::Deployment::UpdateSharedPackageContainerResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UpdateSharedPackageContainerResult};

    // ----- DeploymentProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Management::Deployment::DeploymentProgress>* _new_DeploymentProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Management::Deployment::DeploymentProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_DeploymentProgress(winrt_struct_wrapper<winrt::Windows::Management::Deployment::DeploymentProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _state{};
        uint32_t _percentage{};

        static const char* kwlist[] = {"state", "percentage", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iI", const_cast<char**>(kwlist), &_state, &_percentage))
        {
            return -1;
        }

        try
        {
            self->obj = {static_cast<winrt::Windows::Management::Deployment::DeploymentProgressState>(_state), _percentage};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_DeploymentProgress(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DeploymentProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Deployment::DeploymentProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_DeploymentProgress[] = {
        { "_assign_array_", _assign_array_DeploymentProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* DeploymentProgress_get_state(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.state);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentProgress_set_state(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.state = py::converter<winrt::Windows::Management::Deployment::DeploymentProgressState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentProgress_get_percentage(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.percentage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentProgress_set_percentage(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.percentage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DeploymentProgress[] = {
        { "state", reinterpret_cast<getter>(DeploymentProgress_get_state), reinterpret_cast<setter>(DeploymentProgress_set_state), nullptr, nullptr },
        { "percentage", reinterpret_cast<getter>(DeploymentProgress_get_percentage), reinterpret_cast<setter>(DeploymentProgress_set_percentage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_DeploymentProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentProgress) },
        { },
    };

    static PyType_Spec type_spec_DeploymentProgress = {
        "winrt._winrt_windows_management_deployment.DeploymentProgress",
        sizeof(py::wrapper::Windows::Management::Deployment::DeploymentProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentProgress};

    // ----- Windows.Management.Deployment Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Management.Deployment");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_management_deployment",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Management::Deployment

PyMODINIT_FUNC PyInit__winrt_windows_management_deployment(void) noexcept
{
    using namespace py::cpp::Windows::Management::Deployment;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AddPackageOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppInstallerManager_Static{PyType_FromSpec(&type_spec_AppInstallerManager_Static)};
    if (!type_AppInstallerManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppInstallerManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppInstallerManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutoUpdateSettingsOptions_Static{PyType_FromSpec(&type_spec_AutoUpdateSettingsOptions_Static)};
    if (!type_AutoUpdateSettingsOptions_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutoUpdateSettingsOptions, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutoUpdateSettingsOptions_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateSharedPackageContainerOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateSharedPackageContainerResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeleteSharedPackageContainerOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeleteSharedPackageContainerResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeploymentResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FindSharedPackageContainerOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageAllUserProvisioningOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageManagerDebugSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageUserInformation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageVolume, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RegisterPackageOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SharedPackageContainer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SharedPackageContainerManager_Static{PyType_FromSpec(&type_spec_SharedPackageContainerManager_Static)};
    if (!type_SharedPackageContainerManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SharedPackageContainerManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SharedPackageContainerManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SharedPackageContainerMember, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StagePackageOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UpdateSharedPackageContainerOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UpdateSharedPackageContainerResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeploymentProgress, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
