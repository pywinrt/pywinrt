// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Networking.BackgroundTransfer.h"


namespace py::cpp::Windows::Networking::BackgroundTransfer
{
    // ----- BackgroundDownloader class --------------------

    static PyObject* _new_BackgroundDownloader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundDownloader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundDownloader_CreateDownload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CreateDownload", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateDownload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CreateDownload", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 2);

                return py::convert(self->obj.CreateDownload(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_CreateDownloadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CreateDownloadAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 2);

                return py::convert(self->obj.CreateDownloadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"GetCurrentDownloadsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"GetCurrentDownloadsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"GetCurrentDownloadsForTransferGroupAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_RequestUnconstrainedDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"RequestUnconstrainedDownloadsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::RequestUnconstrainedDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SetRequestHeader", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"TransferGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"TransferGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CompletionGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ProxyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ProxyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ServerCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ServerCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BackgroundDownloader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundDownloader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundDownloader[] = {
        { "create_download", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownload), METH_VARARGS, nullptr },
        { "create_download_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownloadAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(BackgroundDownloader_SetRequestHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundDownloader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundDownloader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundDownloader[] = {
        { "failure_toast_notification", reinterpret_cast<getter>(BackgroundDownloader_get_FailureToastNotification), reinterpret_cast<setter>(BackgroundDownloader_put_FailureToastNotification), nullptr, nullptr },
        { "success_tile_notification", reinterpret_cast<getter>(BackgroundDownloader_get_SuccessTileNotification), reinterpret_cast<setter>(BackgroundDownloader_put_SuccessTileNotification), nullptr, nullptr },
        { "success_toast_notification", reinterpret_cast<getter>(BackgroundDownloader_get_SuccessToastNotification), reinterpret_cast<setter>(BackgroundDownloader_put_SuccessToastNotification), nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(BackgroundDownloader_get_TransferGroup), reinterpret_cast<setter>(BackgroundDownloader_put_TransferGroup), nullptr, nullptr },
        { "failure_tile_notification", reinterpret_cast<getter>(BackgroundDownloader_get_FailureTileNotification), reinterpret_cast<setter>(BackgroundDownloader_put_FailureTileNotification), nullptr, nullptr },
        { "completion_group", reinterpret_cast<getter>(BackgroundDownloader_get_CompletionGroup), nullptr, nullptr, nullptr },
        { "cost_policy", reinterpret_cast<getter>(BackgroundDownloader_get_CostPolicy), reinterpret_cast<setter>(BackgroundDownloader_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(BackgroundDownloader_get_Group), reinterpret_cast<setter>(BackgroundDownloader_put_Group), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(BackgroundDownloader_get_Method), reinterpret_cast<setter>(BackgroundDownloader_put_Method), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(BackgroundDownloader_get_ProxyCredential), reinterpret_cast<setter>(BackgroundDownloader_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(BackgroundDownloader_get_ServerCredential), reinterpret_cast<setter>(BackgroundDownloader_put_ServerCredential), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundDownloader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundDownloader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundDownloader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundDownloader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundDownloader) },
        { },
    };

    static PyType_Spec type_spec_BackgroundDownloader = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundDownloader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloader};

    static PyGetSetDef getset_BackgroundDownloader_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundDownloader_Static[] = {
        { "get_current_downloads_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsAsync), METH_VARARGS, nullptr },
        { "get_current_downloads_for_transfer_group_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync), METH_VARARGS, nullptr },
        { "request_unconstrained_downloads_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_RequestUnconstrainedDownloadsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundDownloader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundDownloader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundDownloader_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundDownloader_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundDownloader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundDownloader_Static
    };

    // ----- BackgroundTransferCompletionGroup class --------------------

    static PyObject* _new_BackgroundTransferCompletionGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferCompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferCompletionGroup_Enable(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup", L"Enable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_IsEnabled(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_Trigger(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup", L"Trigger"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferCompletionGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferCompletionGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroup[] = {
        { "enable", reinterpret_cast<PyCFunction>(BackgroundTransferCompletionGroup_Enable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTransferCompletionGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferCompletionGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroup[] = {
        { "is_enabled", reinterpret_cast<getter>(BackgroundTransferCompletionGroup_get_IsEnabled), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(BackgroundTransferCompletionGroup_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferCompletionGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferCompletionGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferCompletionGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferCompletionGroup) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferCompletionGroup = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferCompletionGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroup};

    // ----- BackgroundTransferCompletionGroupTriggerDetails class --------------------

    static PyObject* _new_BackgroundTransferCompletionGroupTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferCompletionGroupTriggerDetails(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Downloads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails", L"Downloads"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Uploads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails", L"Uploads"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uploads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferCompletionGroupTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferCompletionGroupTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "_assign_array_", _assign_array_BackgroundTransferCompletionGroupTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferCompletionGroupTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "downloads", reinterpret_cast<getter>(BackgroundTransferCompletionGroupTriggerDetails_get_Downloads), nullptr, nullptr, nullptr },
        { "uploads", reinterpret_cast<getter>(BackgroundTransferCompletionGroupTriggerDetails_get_Uploads), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroupTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferCompletionGroupTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferCompletionGroupTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferCompletionGroupTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferCompletionGroupTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferCompletionGroupTriggerDetails = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferCompletionGroupTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroupTriggerDetails};

    // ----- BackgroundTransferContentPart class --------------------

    static PyObject* _new_BackgroundTransferContentPart(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferContentPart(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferContentPart_SetFile(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart", L"SetFile", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart", L"SetHeader", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetText(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart", L"SetText", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferContentPart(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferContentPart(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferContentPart[] = {
        { "set_file", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetFile), METH_VARARGS, nullptr },
        { "set_header", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetHeader), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetText), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTransferContentPart, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferContentPart), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferContentPart[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferContentPart[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferContentPart) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferContentPart) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferContentPart) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferContentPart) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferContentPart = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferContentPart",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferContentPart};

    // ----- BackgroundTransferError class --------------------

    static PyObject* _new_BackgroundTransferError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::type_name);
        return nullptr;
    }

    static PyObject* BackgroundTransferError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferError", L"GetStatus", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferError[] = {
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferError[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferError) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferError = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferError};

    static PyGetSetDef getset_BackgroundTransferError_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundTransferError_Static[] = {
        { "get_status", reinterpret_cast<PyCFunction>(BackgroundTransferError_GetStatus), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundTransferError_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundTransferError_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundTransferError_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferError_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferError_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundTransferError_Static
    };

    // ----- BackgroundTransferGroup class --------------------

    static PyObject* _new_BackgroundTransferGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferGroup_CreateGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"CreateGroup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup::CreateGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferGroup_get_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"TransferBehavior"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferGroup_put_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"TransferBehavior"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior>(arg);

            self->obj.TransferBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferGroup_get_Name(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferGroup[] = {
        { "_assign_array_", _assign_array_BackgroundTransferGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferGroup[] = {
        { "transfer_behavior", reinterpret_cast<getter>(BackgroundTransferGroup_get_TransferBehavior), reinterpret_cast<setter>(BackgroundTransferGroup_put_TransferBehavior), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTransferGroup_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferGroup) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferGroup = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferGroup};

    static PyGetSetDef getset_BackgroundTransferGroup_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundTransferGroup_Static[] = {
        { "create_group", reinterpret_cast<PyCFunction>(BackgroundTransferGroup_CreateGroup), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundTransferGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundTransferGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundTransferGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferGroup_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundTransferGroup_Static
    };

    // ----- BackgroundTransferRangesDownloadedEventArgs class --------------------

    static PyObject* _new_BackgroundTransferRangesDownloadedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferRangesDownloadedEventArgs(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_GetDeferral(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs", L"AddedRanges"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AddedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs", L"WasDownloadRestarted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WasDownloadRestarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferRangesDownloadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferRangesDownloadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(BackgroundTransferRangesDownloadedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTransferRangesDownloadedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferRangesDownloadedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "added_ranges", reinterpret_cast<getter>(BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges), nullptr, nullptr, nullptr },
        { "was_download_restarted", reinterpret_cast<getter>(BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferRangesDownloadedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferRangesDownloadedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferRangesDownloadedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferRangesDownloadedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferRangesDownloadedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferRangesDownloadedEventArgs = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferRangesDownloadedEventArgs",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferRangesDownloadedEventArgs};

    // ----- BackgroundUploader class --------------------

    static PyObject* _new_BackgroundUploader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundUploader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundUploader_CreateUpload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUpload", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateUpload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);

                return py::convert(self->obj.CreateUploadAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadFromStreamAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadFromStreamAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.CreateUploadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"GetCurrentUploadsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"GetCurrentUploadsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"GetCurrentUploadsForTransferGroupAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_RequestUnconstrainedUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"RequestUnconstrainedUploadsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::RequestUnconstrainedUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SetRequestHeader", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ServerCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ServerCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ProxyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ProxyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"TransferGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"TransferGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessTileNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureToastNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CompletionGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundUploader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundUploader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundUploader[] = {
        { "create_upload", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUpload), METH_VARARGS, nullptr },
        { "create_upload_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadAsync), METH_VARARGS, nullptr },
        { "create_upload_from_stream_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadFromStreamAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(BackgroundUploader_SetRequestHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundUploader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundUploader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundUploader[] = {
        { "server_credential", reinterpret_cast<getter>(BackgroundUploader_get_ServerCredential), reinterpret_cast<setter>(BackgroundUploader_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(BackgroundUploader_get_ProxyCredential), reinterpret_cast<setter>(BackgroundUploader_put_ProxyCredential), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(BackgroundUploader_get_Method), reinterpret_cast<setter>(BackgroundUploader_put_Method), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(BackgroundUploader_get_Group), reinterpret_cast<setter>(BackgroundUploader_put_Group), nullptr, nullptr },
        { "cost_policy", reinterpret_cast<getter>(BackgroundUploader_get_CostPolicy), reinterpret_cast<setter>(BackgroundUploader_put_CostPolicy), nullptr, nullptr },
        { "failure_tile_notification", reinterpret_cast<getter>(BackgroundUploader_get_FailureTileNotification), reinterpret_cast<setter>(BackgroundUploader_put_FailureTileNotification), nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(BackgroundUploader_get_TransferGroup), reinterpret_cast<setter>(BackgroundUploader_put_TransferGroup), nullptr, nullptr },
        { "success_toast_notification", reinterpret_cast<getter>(BackgroundUploader_get_SuccessToastNotification), reinterpret_cast<setter>(BackgroundUploader_put_SuccessToastNotification), nullptr, nullptr },
        { "success_tile_notification", reinterpret_cast<getter>(BackgroundUploader_get_SuccessTileNotification), reinterpret_cast<setter>(BackgroundUploader_put_SuccessTileNotification), nullptr, nullptr },
        { "failure_toast_notification", reinterpret_cast<getter>(BackgroundUploader_get_FailureToastNotification), reinterpret_cast<setter>(BackgroundUploader_put_FailureToastNotification), nullptr, nullptr },
        { "completion_group", reinterpret_cast<getter>(BackgroundUploader_get_CompletionGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundUploader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundUploader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundUploader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundUploader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundUploader) },
        { },
    };

    static PyType_Spec type_spec_BackgroundUploader = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundUploader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploader};

    static PyGetSetDef getset_BackgroundUploader_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundUploader_Static[] = {
        { "get_current_uploads_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsAsync), METH_VARARGS, nullptr },
        { "get_current_uploads_for_transfer_group_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsForTransferGroupAsync), METH_VARARGS, nullptr },
        { "request_unconstrained_uploads_async", reinterpret_cast<PyCFunction>(BackgroundUploader_RequestUnconstrainedUploadsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundUploader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundUploader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundUploader_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundUploader_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundUploader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundUploader_Static
    };

    // ----- ContentPrefetcher class --------------------

    static PyObject* _new_ContentPrefetcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::type_name);
        return nullptr;
    }

    static PyObject* ContentPrefetcher_get_IndirectContentUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"IndirectContentUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentPrefetcher_put_IndirectContentUri(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"IndirectContentUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentPrefetcher_get_ContentUris(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"ContentUris"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::ContentUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_get_LastSuccessfulPrefetchTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"LastSuccessfulPrefetchTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::LastSuccessfulPrefetchTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetcher[] = {
        { }
    };

    static PyGetSetDef _getset_ContentPrefetcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ContentPrefetcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentPrefetcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentPrefetcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentPrefetcher) },
        { },
    };

    static PyType_Spec type_spec_ContentPrefetcher = {
        "winrt._winrt_windows_networking_backgroundtransfer.ContentPrefetcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetcher};

    static PyGetSetDef getset_ContentPrefetcher_Static[] = {
        { "indirect_content_uri", reinterpret_cast<getter>(ContentPrefetcher_get_IndirectContentUri), reinterpret_cast<setter>(ContentPrefetcher_put_IndirectContentUri), nullptr, nullptr },
        { "content_uris", reinterpret_cast<getter>(ContentPrefetcher_get_ContentUris), nullptr, nullptr, nullptr },
        { "last_successful_prefetch_time", reinterpret_cast<getter>(ContentPrefetcher_get_LastSuccessfulPrefetchTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ContentPrefetcher_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ContentPrefetcher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentPrefetcher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentPrefetcher_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentPrefetcher_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.ContentPrefetcher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContentPrefetcher_Static
    };

    // ----- DownloadOperation class --------------------

    static PyObject* _new_DownloadOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DownloadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DownloadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"AttachAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetDownloadedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetDownloadedRanges", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDownloadedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetResponseInformation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultRandomAccessStreamReference(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetResultRandomAccessStreamReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResultRandomAccessStreamReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetResultStreamAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"MakeCurrentInTransferGroup", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Pause(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Pause", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RemoveRequestHeader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Resume(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Resume", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"SetRequestHeader", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"StartAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RequestedUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RequestedUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RequestedUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Guid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Priority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Priority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_ResultFile(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"ResultFile"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResultFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"TransferGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"IsRandomAccessRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRandomAccessRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"IsRandomAccessRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRandomAccessRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_CurrentWebErrorStatus(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"CurrentWebErrorStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentWebErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_RecoverableWebErrorStatuses(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RecoverableWebErrorStatuses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecoverableWebErrorStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_add_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RangesDownloaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation, winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>>(arg);

            return py::convert(self->obj.RangesDownloaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_remove_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RangesDownloaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RangesDownloaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadOperation[] = {
        { "attach_async", reinterpret_cast<PyCFunction>(DownloadOperation_AttachAsync), METH_VARARGS, nullptr },
        { "get_downloaded_ranges", reinterpret_cast<PyCFunction>(DownloadOperation_GetDownloadedRanges), METH_VARARGS, nullptr },
        { "get_response_information", reinterpret_cast<PyCFunction>(DownloadOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_random_access_stream_reference", reinterpret_cast<PyCFunction>(DownloadOperation_GetResultRandomAccessStreamReference), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(DownloadOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", reinterpret_cast<PyCFunction>(DownloadOperation_MakeCurrentInTransferGroup), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(DownloadOperation_Pause), METH_VARARGS, nullptr },
        { "remove_request_header", reinterpret_cast<PyCFunction>(DownloadOperation_RemoveRequestHeader), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(DownloadOperation_Resume), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(DownloadOperation_SetRequestHeader), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(DownloadOperation_StartAsync), METH_VARARGS, nullptr },
        { "add_ranges_downloaded", reinterpret_cast<PyCFunction>(DownloadOperation_add_RangesDownloaded), METH_O, nullptr },
        { "remove_ranges_downloaded", reinterpret_cast<PyCFunction>(DownloadOperation_remove_RangesDownloaded), METH_O, nullptr },
        { "_assign_array_", _assign_array_DownloadOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DownloadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DownloadOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(DownloadOperation_get_CostPolicy), reinterpret_cast<setter>(DownloadOperation_put_CostPolicy), nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(DownloadOperation_get_RequestedUri), reinterpret_cast<setter>(DownloadOperation_put_RequestedUri), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(DownloadOperation_get_Method), nullptr, nullptr, nullptr },
        { "group", reinterpret_cast<getter>(DownloadOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(DownloadOperation_get_Guid), nullptr, nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(DownloadOperation_get_Priority), reinterpret_cast<setter>(DownloadOperation_put_Priority), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(DownloadOperation_get_Progress), nullptr, nullptr, nullptr },
        { "result_file", reinterpret_cast<getter>(DownloadOperation_get_ResultFile), nullptr, nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(DownloadOperation_get_TransferGroup), nullptr, nullptr, nullptr },
        { "is_random_access_required", reinterpret_cast<getter>(DownloadOperation_get_IsRandomAccessRequired), reinterpret_cast<setter>(DownloadOperation_put_IsRandomAccessRequired), nullptr, nullptr },
        { "current_web_error_status", reinterpret_cast<getter>(DownloadOperation_get_CurrentWebErrorStatus), nullptr, nullptr, nullptr },
        { "recoverable_web_error_statuses", reinterpret_cast<getter>(DownloadOperation_get_RecoverableWebErrorStatuses), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DownloadOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DownloadOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DownloadOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DownloadOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DownloadOperation) },
        { },
    };

    static PyType_Spec type_spec_DownloadOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.DownloadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadOperation};

    // ----- ResponseInformation class --------------------

    static PyObject* _new_ResponseInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_ResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ResponseInformation_get_ActualUri(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"ActualUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_Headers(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_IsResumable(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"IsResumable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsResumable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_StatusCode(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"StatusCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ResponseInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ResponseInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ResponseInformation[] = {
        { "_assign_array_", _assign_array_ResponseInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ResponseInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ResponseInformation[] = {
        { "actual_uri", reinterpret_cast<getter>(ResponseInformation_get_ActualUri), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(ResponseInformation_get_Headers), nullptr, nullptr, nullptr },
        { "is_resumable", reinterpret_cast<getter>(ResponseInformation_get_IsResumable), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(ResponseInformation_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ResponseInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ResponseInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ResponseInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ResponseInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ResponseInformation) },
        { },
    };

    static PyType_Spec type_spec_ResponseInformation = {
        "winrt._winrt_windows_networking_backgroundtransfer.ResponseInformation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ResponseInformation};

    // ----- UnconstrainedTransferRequestResult class --------------------

    static PyObject* _new_UnconstrainedTransferRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_UnconstrainedTransferRequestResult(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnconstrainedTransferRequestResult_get_IsUnconstrained(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult", L"IsUnconstrained"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnconstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnconstrainedTransferRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnconstrainedTransferRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnconstrainedTransferRequestResult[] = {
        { "_assign_array_", _assign_array_UnconstrainedTransferRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnconstrainedTransferRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnconstrainedTransferRequestResult[] = {
        { "is_unconstrained", reinterpret_cast<getter>(UnconstrainedTransferRequestResult_get_IsUnconstrained), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnconstrainedTransferRequestResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnconstrainedTransferRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnconstrainedTransferRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnconstrainedTransferRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnconstrainedTransferRequestResult) },
        { },
    };

    static PyType_Spec type_spec_UnconstrainedTransferRequestResult = {
        "winrt._winrt_windows_networking_backgroundtransfer.UnconstrainedTransferRequestResult",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnconstrainedTransferRequestResult};

    // ----- UploadOperation class --------------------

    static PyObject* _new_UploadOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_UploadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UploadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"AttachAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"GetResponseInformation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"GetResultStreamAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"MakeCurrentInTransferGroup", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"RemoveRequestHeader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"SetRequestHeader", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"StartAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Guid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"RequestedUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Priority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Priority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_SourceFile(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"SourceFile"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"TransferGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UploadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UploadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UploadOperation[] = {
        { "attach_async", reinterpret_cast<PyCFunction>(UploadOperation_AttachAsync), METH_VARARGS, nullptr },
        { "get_response_information", reinterpret_cast<PyCFunction>(UploadOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(UploadOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", reinterpret_cast<PyCFunction>(UploadOperation_MakeCurrentInTransferGroup), METH_VARARGS, nullptr },
        { "remove_request_header", reinterpret_cast<PyCFunction>(UploadOperation_RemoveRequestHeader), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(UploadOperation_SetRequestHeader), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(UploadOperation_StartAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UploadOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UploadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UploadOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(UploadOperation_get_CostPolicy), reinterpret_cast<setter>(UploadOperation_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(UploadOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(UploadOperation_get_Guid), nullptr, nullptr, nullptr },
        { "method", reinterpret_cast<getter>(UploadOperation_get_Method), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(UploadOperation_get_RequestedUri), nullptr, nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(UploadOperation_get_Priority), reinterpret_cast<setter>(UploadOperation_put_Priority), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(UploadOperation_get_Progress), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(UploadOperation_get_SourceFile), nullptr, nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(UploadOperation_get_TransferGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UploadOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UploadOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UploadOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UploadOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UploadOperation) },
        { },
    };

    static PyType_Spec type_spec_UploadOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.UploadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UploadOperation};

    // ----- IBackgroundTransferBase interface --------------------

    static PyObject* _new_IBackgroundTransferBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferBase(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferBase_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"SetRequestHeader", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferBase_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ProxyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ProxyCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ServerCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ServerCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferBase[] = {
        { "set_request_header", reinterpret_cast<PyCFunction>(IBackgroundTransferBase_SetRequestHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTransferBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferBase[] = {
        { "cost_policy", reinterpret_cast<getter>(IBackgroundTransferBase_get_CostPolicy), reinterpret_cast<setter>(IBackgroundTransferBase_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(IBackgroundTransferBase_get_Group), reinterpret_cast<setter>(IBackgroundTransferBase_put_Group), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(IBackgroundTransferBase_get_Method), reinterpret_cast<setter>(IBackgroundTransferBase_put_Method), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IBackgroundTransferBase_get_ProxyCredential), reinterpret_cast<setter>(IBackgroundTransferBase_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IBackgroundTransferBase_get_ServerCredential), reinterpret_cast<setter>(IBackgroundTransferBase_put_ServerCredential), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferBase) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferBase = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferBase",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferBase};

    // ----- IBackgroundTransferContentPartFactory interface --------------------

    static PyObject* _new_IBackgroundTransferContentPartFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferContentPartFactory(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferContentPartFactory", L"CreateWithName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateWithName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithNameAndFileName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferContentPartFactory", L"CreateWithNameAndFileName", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateWithNameAndFileName(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferContentPartFactory[] = {
        { "create_with_name", reinterpret_cast<PyCFunction>(IBackgroundTransferContentPartFactory_CreateWithName), METH_VARARGS, nullptr },
        { "create_with_name_and_file_name", reinterpret_cast<PyCFunction>(IBackgroundTransferContentPartFactory_CreateWithNameAndFileName), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTransferContentPartFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferContentPartFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferContentPartFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferContentPartFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferContentPartFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferContentPartFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferContentPartFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferContentPartFactory) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferContentPartFactory = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferContentPartFactory",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferContentPartFactory};

    // ----- IBackgroundTransferOperation interface --------------------

    static PyObject* _new_IBackgroundTransferOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"GetResponseInformation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"GetResultStreamAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"CostPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"Group"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"Guid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"RequestedUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperation[] = {
        { "get_response_information", reinterpret_cast<PyCFunction>(IBackgroundTransferOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(IBackgroundTransferOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTransferOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(IBackgroundTransferOperation_get_CostPolicy), reinterpret_cast<setter>(IBackgroundTransferOperation_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Guid), nullptr, nullptr, nullptr },
        { "method", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Method), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(IBackgroundTransferOperation_get_RequestedUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferOperation) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperation};

    // ----- IBackgroundTransferOperationPriority interface --------------------

    static PyObject* _new_IBackgroundTransferOperationPriority(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperationPriority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferOperationPriority_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperationPriority", L"Priority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperationPriority_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperationPriority", L"Priority"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperationPriority[] = {
        { "_assign_array_", _assign_array_IBackgroundTransferOperationPriority, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferOperationPriority), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperationPriority[] = {
        { "priority", reinterpret_cast<getter>(IBackgroundTransferOperationPriority_get_Priority), reinterpret_cast<setter>(IBackgroundTransferOperationPriority_put_Priority), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperationPriority[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferOperationPriority) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferOperationPriority) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferOperationPriority) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferOperationPriority) },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferOperationPriority = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferOperationPriority",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperationPriority};

    // ----- BackgroundDownloadProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>* _new_BackgroundDownloadProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BackgroundDownloadProgress(winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _BytesReceived{};
        uint64_t _TotalBytesToReceive{};
        int32_t _Status{};
        bool _HasResponseChanged{};
        bool _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "total_bytes_to_receive", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKipp", const_cast<char**>(kwlist), &_BytesReceived, &_TotalBytesToReceive, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return -1;
        }

        try
        {
            self->obj = {_BytesReceived, _TotalBytesToReceive, static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status), _HasResponseChanged, _HasRestarted};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BackgroundDownloadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BackgroundDownloadProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BackgroundDownloadProgress[] = {
        { "_assign_array_", _assign_array_BackgroundDownloadProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BackgroundDownloadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Status = py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundDownloadProgress[] = {
        { "bytes_received", reinterpret_cast<getter>(BackgroundDownloadProgress_get_BytesReceived), reinterpret_cast<setter>(BackgroundDownloadProgress_set_BytesReceived), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(BackgroundDownloadProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(BackgroundDownloadProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BackgroundDownloadProgress_get_Status), reinterpret_cast<setter>(BackgroundDownloadProgress_set_Status), nullptr, nullptr },
        { "has_response_changed", reinterpret_cast<getter>(BackgroundDownloadProgress_get_HasResponseChanged), reinterpret_cast<setter>(BackgroundDownloadProgress_set_HasResponseChanged), nullptr, nullptr },
        { "has_restarted", reinterpret_cast<getter>(BackgroundDownloadProgress_get_HasRestarted), reinterpret_cast<setter>(BackgroundDownloadProgress_set_HasRestarted), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundDownloadProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundDownloadProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BackgroundDownloadProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundDownloadProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundDownloadProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundDownloadProgress) },
        { },
    };

    static PyType_Spec type_spec_BackgroundDownloadProgress = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundDownloadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloadProgress};

    // ----- BackgroundTransferFileRange struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>* _new_BackgroundTransferFileRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BackgroundTransferFileRange(winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Offset{};
        uint64_t _Length{};

        static const char* kwlist[] = {"offset", "length", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KK", const_cast<char**>(kwlist), &_Offset, &_Length))
        {
            return -1;
        }

        try
        {
            self->obj = {_Offset, _Length};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BackgroundTransferFileRange(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BackgroundTransferFileRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BackgroundTransferFileRange[] = {
        { "_assign_array_", _assign_array_BackgroundTransferFileRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BackgroundTransferFileRange_get_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Offset = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferFileRange_get_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Length = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundTransferFileRange[] = {
        { "offset", reinterpret_cast<getter>(BackgroundTransferFileRange_get_Offset), reinterpret_cast<setter>(BackgroundTransferFileRange_set_Offset), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(BackgroundTransferFileRange_get_Length), reinterpret_cast<setter>(BackgroundTransferFileRange_set_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferFileRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferFileRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BackgroundTransferFileRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferFileRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferFileRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferFileRange) },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferFileRange = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferFileRange",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferFileRange};

    // ----- BackgroundUploadProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>* _new_BackgroundUploadProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BackgroundUploadProgress(winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _BytesReceived{};
        uint64_t _BytesSent{};
        uint64_t _TotalBytesToReceive{};
        uint64_t _TotalBytesToSend{};
        int32_t _Status{};
        bool _HasResponseChanged{};
        bool _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "bytes_sent", "total_bytes_to_receive", "total_bytes_to_send", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKipp", const_cast<char**>(kwlist), &_BytesReceived, &_BytesSent, &_TotalBytesToReceive, &_TotalBytesToSend, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return -1;
        }

        try
        {
            self->obj = {_BytesReceived, _BytesSent, _TotalBytesToReceive, _TotalBytesToSend, static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status), _HasResponseChanged, _HasRestarted};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BackgroundUploadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BackgroundUploadProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BackgroundUploadProgress[] = {
        { "_assign_array_", _assign_array_BackgroundUploadProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BackgroundUploadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesSent = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToSend);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToSend = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Status = py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundUploadProgress[] = {
        { "bytes_received", reinterpret_cast<getter>(BackgroundUploadProgress_get_BytesReceived), reinterpret_cast<setter>(BackgroundUploadProgress_set_BytesReceived), nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(BackgroundUploadProgress_get_BytesSent), reinterpret_cast<setter>(BackgroundUploadProgress_set_BytesSent), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(BackgroundUploadProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(BackgroundUploadProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "total_bytes_to_send", reinterpret_cast<getter>(BackgroundUploadProgress_get_TotalBytesToSend), reinterpret_cast<setter>(BackgroundUploadProgress_set_TotalBytesToSend), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BackgroundUploadProgress_get_Status), reinterpret_cast<setter>(BackgroundUploadProgress_set_Status), nullptr, nullptr },
        { "has_response_changed", reinterpret_cast<getter>(BackgroundUploadProgress_get_HasResponseChanged), reinterpret_cast<setter>(BackgroundUploadProgress_set_HasResponseChanged), nullptr, nullptr },
        { "has_restarted", reinterpret_cast<getter>(BackgroundUploadProgress_get_HasRestarted), reinterpret_cast<setter>(BackgroundUploadProgress_set_HasRestarted), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundUploadProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundUploadProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BackgroundUploadProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundUploadProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundUploadProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundUploadProgress) },
        { },
    };

    static PyType_Spec type_spec_BackgroundUploadProgress = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundUploadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploadProgress};

    // ----- Windows.Networking.BackgroundTransfer Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Networking.BackgroundTransfer");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_networking_backgroundtransfer",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Networking::BackgroundTransfer

PyMODINIT_FUNC PyInit__winrt_windows_networking_backgroundtransfer(void) noexcept
{
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundDownloader_Static{PyType_FromSpec(&type_spec_BackgroundDownloader_Static)};
    if (!type_BackgroundDownloader_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundDownloader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundDownloader_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferCompletionGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferCompletionGroupTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferContentPart, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundTransferError_Static{PyType_FromSpec(&type_spec_BackgroundTransferError_Static)};
    if (!type_BackgroundTransferError_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferError, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundTransferError_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundTransferGroup_Static{PyType_FromSpec(&type_spec_BackgroundTransferGroup_Static)};
    if (!type_BackgroundTransferGroup_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferGroup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundTransferGroup_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferRangesDownloadedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundUploader_Static{PyType_FromSpec(&type_spec_BackgroundUploader_Static)};
    if (!type_BackgroundUploader_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundUploader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundUploader_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentPrefetcher_Static{PyType_FromSpec(&type_spec_ContentPrefetcher_Static)};
    if (!type_ContentPrefetcher_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentPrefetcher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentPrefetcher_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DownloadOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ResponseInformation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UnconstrainedTransferRequestResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UploadOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTransferBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTransferContentPartFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTransferOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBackgroundTransferOperationPriority, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundDownloadProgress, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundTransferFileRange, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BackgroundUploadProgress, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
