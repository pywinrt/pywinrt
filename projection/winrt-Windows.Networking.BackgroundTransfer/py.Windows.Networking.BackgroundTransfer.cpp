// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Networking.BackgroundTransfer.h"

namespace py::cpp::Windows::Networking::BackgroundTransfer
{
    // ----- BackgroundDownloader class --------------------

    static PyObject* _new_BackgroundDownloader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundDownloader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundDownloader_CreateDownload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CreateDownload", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateDownload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_CreateDownloadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CreateDownloadAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 2);

                return py::convert(self->obj.CreateDownloadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_CreateDownloadFromFile(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CreateDownload", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 2);

                return py::convert(self->obj.CreateDownload(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"GetCurrentDownloadsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsForGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"GetCurrentDownloadsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"GetCurrentDownloadsForTransferGroupAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_RequestUnconstrainedDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"RequestUnconstrainedDownloadsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::RequestUnconstrainedDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"SuccessToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"TransferGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"TransferGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"FailureTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CompletionGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundDownloader", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BackgroundDownloader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundDownloader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundDownloader[] = {
        { "create_download", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownload), METH_VARARGS, nullptr },
        { "create_download_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownloadAsync), METH_VARARGS, nullptr },
        { "create_download_from_file", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownloadFromFile), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(BackgroundDownloader_SetRequestHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundDownloader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundDownloader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundDownloader[] = {
        { "failure_toast_notification", reinterpret_cast<getter>(BackgroundDownloader_get_FailureToastNotification), reinterpret_cast<setter>(BackgroundDownloader_put_FailureToastNotification), nullptr, nullptr },
        { "success_tile_notification", reinterpret_cast<getter>(BackgroundDownloader_get_SuccessTileNotification), reinterpret_cast<setter>(BackgroundDownloader_put_SuccessTileNotification), nullptr, nullptr },
        { "success_toast_notification", reinterpret_cast<getter>(BackgroundDownloader_get_SuccessToastNotification), reinterpret_cast<setter>(BackgroundDownloader_put_SuccessToastNotification), nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(BackgroundDownloader_get_TransferGroup), reinterpret_cast<setter>(BackgroundDownloader_put_TransferGroup), nullptr, nullptr },
        { "failure_tile_notification", reinterpret_cast<getter>(BackgroundDownloader_get_FailureTileNotification), reinterpret_cast<setter>(BackgroundDownloader_put_FailureTileNotification), nullptr, nullptr },
        { "completion_group", reinterpret_cast<getter>(BackgroundDownloader_get_CompletionGroup), nullptr, nullptr, nullptr },
        { "cost_policy", reinterpret_cast<getter>(BackgroundDownloader_get_CostPolicy), reinterpret_cast<setter>(BackgroundDownloader_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(BackgroundDownloader_get_Group), reinterpret_cast<setter>(BackgroundDownloader_put_Group), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(BackgroundDownloader_get_Method), reinterpret_cast<setter>(BackgroundDownloader_put_Method), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(BackgroundDownloader_get_ProxyCredential), reinterpret_cast<setter>(BackgroundDownloader_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(BackgroundDownloader_get_ServerCredential), reinterpret_cast<setter>(BackgroundDownloader_put_ServerCredential), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundDownloader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundDownloader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundDownloader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundDownloader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundDownloader) },
        { }
    };

    static PyType_Spec type_spec_BackgroundDownloader = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundDownloader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloader};

    static PyGetSetDef getset_BackgroundDownloader_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundDownloader_Static[] = {
        { "get_current_downloads_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsAsync), METH_VARARGS, nullptr },
        { "get_current_downloads_for_group_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsForGroupAsync), METH_VARARGS, nullptr },
        { "get_current_downloads_for_transfer_group_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync), METH_VARARGS, nullptr },
        { "request_unconstrained_downloads_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_RequestUnconstrainedDownloadsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundDownloader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundDownloader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundDownloader_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundDownloader_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundDownloader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundDownloader_Static
    };

    // ----- BackgroundTransferCompletionGroup class --------------------

    static PyObject* _new_BackgroundTransferCompletionGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferCompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferCompletionGroup_Enable(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup", L"Enable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_IsEnabled(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_Trigger(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup", L"Trigger");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferCompletionGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferCompletionGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroup[] = {
        { "enable", reinterpret_cast<PyCFunction>(BackgroundTransferCompletionGroup_Enable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTransferCompletionGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferCompletionGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroup[] = {
        { "is_enabled", reinterpret_cast<getter>(BackgroundTransferCompletionGroup_get_IsEnabled), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(BackgroundTransferCompletionGroup_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferCompletionGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferCompletionGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferCompletionGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferCompletionGroup) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferCompletionGroup = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferCompletionGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroup};

    // ----- BackgroundTransferCompletionGroupTriggerDetails class --------------------

    static PyObject* _new_BackgroundTransferCompletionGroupTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferCompletionGroupTriggerDetails(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Downloads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails", L"Downloads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Uploads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails", L"Uploads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uploads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferCompletionGroupTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferCompletionGroupTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "_assign_array_", _assign_array_BackgroundTransferCompletionGroupTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferCompletionGroupTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "downloads", reinterpret_cast<getter>(BackgroundTransferCompletionGroupTriggerDetails_get_Downloads), nullptr, nullptr, nullptr },
        { "uploads", reinterpret_cast<getter>(BackgroundTransferCompletionGroupTriggerDetails_get_Uploads), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferCompletionGroupTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferCompletionGroupTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferCompletionGroupTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferCompletionGroupTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferCompletionGroupTriggerDetails = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferCompletionGroupTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroupTriggerDetails};

    // ----- BackgroundTransferContentPart class --------------------

    static PyObject* _new_BackgroundTransferContentPart(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferContentPart(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferContentPart_SetFile(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart", L"SetFile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart", L"SetHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetText(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart", L"SetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferContentPart(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferContentPart(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferContentPart[] = {
        { "set_file", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetFile), METH_VARARGS, nullptr },
        { "set_header", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetHeader), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetText), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTransferContentPart, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferContentPart), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferContentPart[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferContentPart[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferContentPart) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferContentPart) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferContentPart) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferContentPart) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferContentPart = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferContentPart",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferContentPart};

    // ----- BackgroundTransferError class --------------------

    static PyObject* _new_BackgroundTransferError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::type_name);
        return nullptr;
    }

    static PyObject* BackgroundTransferError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferError", L"GetStatus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferError[] = {
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferError[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferError[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferError) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferError = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferError};

    static PyGetSetDef getset_BackgroundTransferError_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundTransferError_Static[] = {
        { "get_status", reinterpret_cast<PyCFunction>(BackgroundTransferError_GetStatus), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundTransferError_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundTransferError_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundTransferError_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferError_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferError_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundTransferError_Static
    };

    // ----- BackgroundTransferGroup class --------------------

    static PyObject* _new_BackgroundTransferGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferGroup_CreateGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"CreateGroup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup::CreateGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferGroup_get_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"TransferBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferGroup_put_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"TransferBehavior");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior>(arg);

            self->obj.TransferBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferGroup_get_Name(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferGroup", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferGroup[] = {
        { "_assign_array_", _assign_array_BackgroundTransferGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferGroup[] = {
        { "transfer_behavior", reinterpret_cast<getter>(BackgroundTransferGroup_get_TransferBehavior), reinterpret_cast<setter>(BackgroundTransferGroup_put_TransferBehavior), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTransferGroup_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferGroup) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferGroup = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferGroup};

    static PyGetSetDef getset_BackgroundTransferGroup_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundTransferGroup_Static[] = {
        { "create_group", reinterpret_cast<PyCFunction>(BackgroundTransferGroup_CreateGroup), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundTransferGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundTransferGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundTransferGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferGroup_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundTransferGroup_Static
    };

    // ----- BackgroundTransferRangesDownloadedEventArgs class --------------------

    static PyObject* _new_BackgroundTransferRangesDownloadedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferRangesDownloadedEventArgs(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_GetDeferral(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs", L"AddedRanges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AddedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs", L"WasDownloadRestarted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WasDownloadRestarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundTransferRangesDownloadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundTransferRangesDownloadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(BackgroundTransferRangesDownloadedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundTransferRangesDownloadedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferRangesDownloadedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "added_ranges", reinterpret_cast<getter>(BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges), nullptr, nullptr, nullptr },
        { "was_download_restarted", reinterpret_cast<getter>(BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferRangesDownloadedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferRangesDownloadedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferRangesDownloadedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferRangesDownloadedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferRangesDownloadedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferRangesDownloadedEventArgs = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferRangesDownloadedEventArgs",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferRangesDownloadedEventArgs};

    // ----- BackgroundUploader class --------------------

    static PyObject* _new_BackgroundUploader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundUploader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundUploader_CreateUpload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUpload", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateUpload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadFromStreamAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadFromStreamAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.CreateUploadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadWithFormDataAndAutoBoundaryAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);

                return py::convert(self->obj.CreateUploadAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadWithSubTypeAndBoundaryAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadWithSubTypeAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CreateUploadAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"GetCurrentUploadsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsForGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"GetCurrentUploadsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"GetCurrentUploadsForTransferGroupAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_RequestUnconstrainedUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"RequestUnconstrainedUploadsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::RequestUnconstrainedUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"TransferGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"TransferGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"SuccessTileNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"FailureToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.BackgroundUploader", L"CompletionGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundUploader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundUploader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundUploader[] = {
        { "create_upload", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUpload), METH_VARARGS, nullptr },
        { "create_upload_from_stream_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadFromStreamAsync), METH_VARARGS, nullptr },
        { "create_upload_with_form_data_and_auto_boundary_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadWithFormDataAndAutoBoundaryAsync), METH_VARARGS, nullptr },
        { "create_upload_with_sub_type_and_boundary_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadWithSubTypeAndBoundaryAsync), METH_VARARGS, nullptr },
        { "create_upload_with_sub_type_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadWithSubTypeAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(BackgroundUploader_SetRequestHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BackgroundUploader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundUploader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundUploader[] = {
        { "server_credential", reinterpret_cast<getter>(BackgroundUploader_get_ServerCredential), reinterpret_cast<setter>(BackgroundUploader_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(BackgroundUploader_get_ProxyCredential), reinterpret_cast<setter>(BackgroundUploader_put_ProxyCredential), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(BackgroundUploader_get_Method), reinterpret_cast<setter>(BackgroundUploader_put_Method), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(BackgroundUploader_get_Group), reinterpret_cast<setter>(BackgroundUploader_put_Group), nullptr, nullptr },
        { "cost_policy", reinterpret_cast<getter>(BackgroundUploader_get_CostPolicy), reinterpret_cast<setter>(BackgroundUploader_put_CostPolicy), nullptr, nullptr },
        { "failure_tile_notification", reinterpret_cast<getter>(BackgroundUploader_get_FailureTileNotification), reinterpret_cast<setter>(BackgroundUploader_put_FailureTileNotification), nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(BackgroundUploader_get_TransferGroup), reinterpret_cast<setter>(BackgroundUploader_put_TransferGroup), nullptr, nullptr },
        { "success_toast_notification", reinterpret_cast<getter>(BackgroundUploader_get_SuccessToastNotification), reinterpret_cast<setter>(BackgroundUploader_put_SuccessToastNotification), nullptr, nullptr },
        { "success_tile_notification", reinterpret_cast<getter>(BackgroundUploader_get_SuccessTileNotification), reinterpret_cast<setter>(BackgroundUploader_put_SuccessTileNotification), nullptr, nullptr },
        { "failure_toast_notification", reinterpret_cast<getter>(BackgroundUploader_get_FailureToastNotification), reinterpret_cast<setter>(BackgroundUploader_put_FailureToastNotification), nullptr, nullptr },
        { "completion_group", reinterpret_cast<getter>(BackgroundUploader_get_CompletionGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundUploader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundUploader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundUploader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundUploader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundUploader) },
        { }
    };

    static PyType_Spec type_spec_BackgroundUploader = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundUploader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploader};

    static PyGetSetDef getset_BackgroundUploader_Static[] = {
        { }
    };

    static PyMethodDef methods_BackgroundUploader_Static[] = {
        { "get_current_uploads_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsAsync), METH_VARARGS, nullptr },
        { "get_current_uploads_for_group_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsForGroupAsync), METH_VARARGS, nullptr },
        { "get_current_uploads_for_transfer_group_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsForTransferGroupAsync), METH_VARARGS, nullptr },
        { "request_unconstrained_uploads_async", reinterpret_cast<PyCFunction>(BackgroundUploader_RequestUnconstrainedUploadsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackgroundUploader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackgroundUploader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BackgroundUploader_Static) },
        { }
    };

    static PyType_Spec type_spec_BackgroundUploader_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundUploader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackgroundUploader_Static
    };

    // ----- ContentPrefetcher class --------------------

    static PyObject* _new_ContentPrefetcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::type_name);
        return nullptr;
    }

    static PyObject* ContentPrefetcher_get_IndirectContentUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"IndirectContentUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentPrefetcher_put_IndirectContentUri(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"IndirectContentUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentPrefetcher_get_ContentUris(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"ContentUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::ContentUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_get_LastSuccessfulPrefetchTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ContentPrefetcher", L"LastSuccessfulPrefetchTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::LastSuccessfulPrefetchTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetcher[] = {
        { }
    };

    static PyGetSetDef _getset_ContentPrefetcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ContentPrefetcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentPrefetcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentPrefetcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentPrefetcher) },
        { }
    };

    static PyType_Spec type_spec_ContentPrefetcher = {
        "winrt._winrt_windows_networking_backgroundtransfer.ContentPrefetcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetcher};

    static PyGetSetDef getset_ContentPrefetcher_Static[] = {
        { "indirect_content_uri", reinterpret_cast<getter>(ContentPrefetcher_get_IndirectContentUri), reinterpret_cast<setter>(ContentPrefetcher_put_IndirectContentUri), nullptr, nullptr },
        { "content_uris", reinterpret_cast<getter>(ContentPrefetcher_get_ContentUris), nullptr, nullptr, nullptr },
        { "last_successful_prefetch_time", reinterpret_cast<getter>(ContentPrefetcher_get_LastSuccessfulPrefetchTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ContentPrefetcher_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ContentPrefetcher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentPrefetcher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentPrefetcher_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentPrefetcher_Static =
    {
        "winrt._winrt_windows_networking_backgroundtransfer.ContentPrefetcher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContentPrefetcher_Static
    };

    // ----- DownloadOperation class --------------------

    static PyObject* _new_DownloadOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DownloadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DownloadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"AttachAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetDownloadedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetDownloadedRanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDownloadedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetResponseInformation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultRandomAccessStreamReference(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetResultRandomAccessStreamReference", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResultRandomAccessStreamReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"GetResultStreamAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"MakeCurrentInTransferGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Pause(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Pause", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RemoveRequestHeader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Resume(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Resume", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"StartAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RequestedUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RequestedUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RequestedUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Guid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_ResultFile(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"ResultFile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResultFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"TransferGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"IsRandomAccessRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRandomAccessRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"IsRandomAccessRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRandomAccessRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_CurrentWebErrorStatus(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"CurrentWebErrorStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentWebErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_RecoverableWebErrorStatuses(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RecoverableWebErrorStatuses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecoverableWebErrorStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_add_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RangesDownloaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation, winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>>(arg);

            return py::convert(self->obj.RangesDownloaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_remove_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.BackgroundTransfer.DownloadOperation", L"RangesDownloaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RangesDownloaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadOperation[] = {
        { "attach_async", reinterpret_cast<PyCFunction>(DownloadOperation_AttachAsync), METH_VARARGS, nullptr },
        { "get_downloaded_ranges", reinterpret_cast<PyCFunction>(DownloadOperation_GetDownloadedRanges), METH_VARARGS, nullptr },
        { "get_response_information", reinterpret_cast<PyCFunction>(DownloadOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_random_access_stream_reference", reinterpret_cast<PyCFunction>(DownloadOperation_GetResultRandomAccessStreamReference), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(DownloadOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", reinterpret_cast<PyCFunction>(DownloadOperation_MakeCurrentInTransferGroup), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(DownloadOperation_Pause), METH_VARARGS, nullptr },
        { "remove_request_header", reinterpret_cast<PyCFunction>(DownloadOperation_RemoveRequestHeader), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(DownloadOperation_Resume), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(DownloadOperation_SetRequestHeader), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(DownloadOperation_StartAsync), METH_VARARGS, nullptr },
        { "add_ranges_downloaded", reinterpret_cast<PyCFunction>(DownloadOperation_add_RangesDownloaded), METH_O, nullptr },
        { "remove_ranges_downloaded", reinterpret_cast<PyCFunction>(DownloadOperation_remove_RangesDownloaded), METH_O, nullptr },
        { "_assign_array_", _assign_array_DownloadOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DownloadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DownloadOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(DownloadOperation_get_CostPolicy), reinterpret_cast<setter>(DownloadOperation_put_CostPolicy), nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(DownloadOperation_get_RequestedUri), reinterpret_cast<setter>(DownloadOperation_put_RequestedUri), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(DownloadOperation_get_Method), nullptr, nullptr, nullptr },
        { "group", reinterpret_cast<getter>(DownloadOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(DownloadOperation_get_Guid), nullptr, nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(DownloadOperation_get_Priority), reinterpret_cast<setter>(DownloadOperation_put_Priority), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(DownloadOperation_get_Progress), nullptr, nullptr, nullptr },
        { "result_file", reinterpret_cast<getter>(DownloadOperation_get_ResultFile), nullptr, nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(DownloadOperation_get_TransferGroup), nullptr, nullptr, nullptr },
        { "is_random_access_required", reinterpret_cast<getter>(DownloadOperation_get_IsRandomAccessRequired), reinterpret_cast<setter>(DownloadOperation_put_IsRandomAccessRequired), nullptr, nullptr },
        { "current_web_error_status", reinterpret_cast<getter>(DownloadOperation_get_CurrentWebErrorStatus), nullptr, nullptr, nullptr },
        { "recoverable_web_error_statuses", reinterpret_cast<getter>(DownloadOperation_get_RecoverableWebErrorStatuses), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DownloadOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DownloadOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DownloadOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DownloadOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DownloadOperation) },
        { }
    };

    static PyType_Spec type_spec_DownloadOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.DownloadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadOperation};

    // ----- ResponseInformation class --------------------

    static PyObject* _new_ResponseInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_ResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ResponseInformation_get_ActualUri(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"ActualUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_Headers(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"Headers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_IsResumable(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"IsResumable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsResumable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_StatusCode(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.ResponseInformation", L"StatusCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ResponseInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ResponseInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ResponseInformation[] = {
        { "_assign_array_", _assign_array_ResponseInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ResponseInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ResponseInformation[] = {
        { "actual_uri", reinterpret_cast<getter>(ResponseInformation_get_ActualUri), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(ResponseInformation_get_Headers), nullptr, nullptr, nullptr },
        { "is_resumable", reinterpret_cast<getter>(ResponseInformation_get_IsResumable), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(ResponseInformation_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ResponseInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ResponseInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ResponseInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ResponseInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ResponseInformation) },
        { }
    };

    static PyType_Spec type_spec_ResponseInformation = {
        "winrt._winrt_windows_networking_backgroundtransfer.ResponseInformation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ResponseInformation};

    // ----- UnconstrainedTransferRequestResult class --------------------

    static PyObject* _new_UnconstrainedTransferRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_UnconstrainedTransferRequestResult(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnconstrainedTransferRequestResult_get_IsUnconstrained(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult", L"IsUnconstrained");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnconstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnconstrainedTransferRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnconstrainedTransferRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnconstrainedTransferRequestResult[] = {
        { "_assign_array_", _assign_array_UnconstrainedTransferRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnconstrainedTransferRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnconstrainedTransferRequestResult[] = {
        { "is_unconstrained", reinterpret_cast<getter>(UnconstrainedTransferRequestResult_get_IsUnconstrained), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnconstrainedTransferRequestResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnconstrainedTransferRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnconstrainedTransferRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnconstrainedTransferRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnconstrainedTransferRequestResult) },
        { }
    };

    static PyType_Spec type_spec_UnconstrainedTransferRequestResult = {
        "winrt._winrt_windows_networking_backgroundtransfer.UnconstrainedTransferRequestResult",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnconstrainedTransferRequestResult};

    // ----- UploadOperation class --------------------

    static PyObject* _new_UploadOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_UploadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UploadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"AttachAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"GetResponseInformation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"GetResultStreamAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"MakeCurrentInTransferGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"RemoveRequestHeader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"StartAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Guid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"RequestedUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_SourceFile(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"SourceFile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.UploadOperation", L"TransferGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UploadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UploadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UploadOperation[] = {
        { "attach_async", reinterpret_cast<PyCFunction>(UploadOperation_AttachAsync), METH_VARARGS, nullptr },
        { "get_response_information", reinterpret_cast<PyCFunction>(UploadOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(UploadOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", reinterpret_cast<PyCFunction>(UploadOperation_MakeCurrentInTransferGroup), METH_VARARGS, nullptr },
        { "remove_request_header", reinterpret_cast<PyCFunction>(UploadOperation_RemoveRequestHeader), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(UploadOperation_SetRequestHeader), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(UploadOperation_StartAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UploadOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UploadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UploadOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(UploadOperation_get_CostPolicy), reinterpret_cast<setter>(UploadOperation_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(UploadOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(UploadOperation_get_Guid), nullptr, nullptr, nullptr },
        { "method", reinterpret_cast<getter>(UploadOperation_get_Method), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(UploadOperation_get_RequestedUri), nullptr, nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(UploadOperation_get_Priority), reinterpret_cast<setter>(UploadOperation_put_Priority), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(UploadOperation_get_Progress), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(UploadOperation_get_SourceFile), nullptr, nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(UploadOperation_get_TransferGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UploadOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UploadOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UploadOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UploadOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UploadOperation) },
        { }
    };

    static PyType_Spec type_spec_UploadOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.UploadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UploadOperation};

    // ----- IBackgroundTransferBase interface --------------------

    static PyObject* _new_IBackgroundTransferBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferBase(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferBase_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"SetRequestHeader", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferBase_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ProxyCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferBase", L"ServerCredential");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferBase[] = {
        { "set_request_header", reinterpret_cast<PyCFunction>(IBackgroundTransferBase_SetRequestHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTransferBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferBase[] = {
        { "cost_policy", reinterpret_cast<getter>(IBackgroundTransferBase_get_CostPolicy), reinterpret_cast<setter>(IBackgroundTransferBase_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(IBackgroundTransferBase_get_Group), reinterpret_cast<setter>(IBackgroundTransferBase_put_Group), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(IBackgroundTransferBase_get_Method), reinterpret_cast<setter>(IBackgroundTransferBase_put_Method), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IBackgroundTransferBase_get_ProxyCredential), reinterpret_cast<setter>(IBackgroundTransferBase_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IBackgroundTransferBase_get_ServerCredential), reinterpret_cast<setter>(IBackgroundTransferBase_put_ServerCredential), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferBase) },
        { }
    };

    static PyType_Spec type_spec_IBackgroundTransferBase = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferBase",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferBase};

    struct ImplementsIBackgroundTransferBase : py::ImplementsInterfaceT<ImplementsIBackgroundTransferBase, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>
    {
        ImplementsIBackgroundTransferBase() = delete;
        ImplementsIBackgroundTransferBase(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIBackgroundTransferBase, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>(py_obj, runtime_class)
        {
        }

        auto SetRequestHeader(winrt::hstring const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_request_header")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CostPolicy()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "cost_policy")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void CostPolicy(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "cost_policy", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Group()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "group")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Group(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "group", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Method()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "method")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Method(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "method", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ProxyCredential()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "proxy_credential")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ProxyCredential(winrt::Windows::Security::Credentials::PasswordCredential const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "proxy_credential", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ServerCredential()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "server_credential")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void ServerCredential(winrt::Windows::Security::Credentials::PasswordCredential const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "server_credential", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIBackgroundTransferBase(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIBackgroundTransferBase(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIBackgroundTransferBase>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIBackgroundTransferBase[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIBackgroundTransferBase), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIBackgroundTransferBase), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIBackgroundTransferBase[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIBackgroundTransferBase) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIBackgroundTransferBase = {
        "winrt._winrt_windows_networking_backgroundtransfer.ImplementsIBackgroundTransferBase",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIBackgroundTransferBase};

    // ----- IBackgroundTransferContentPartFactory interface --------------------

    static PyObject* _new_IBackgroundTransferContentPartFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferContentPartFactory(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferContentPartFactory", L"CreateWithName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateWithName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithNameAndFileName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferContentPartFactory", L"CreateWithNameAndFileName", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateWithNameAndFileName(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferContentPartFactory[] = {
        { "create_with_name", reinterpret_cast<PyCFunction>(IBackgroundTransferContentPartFactory_CreateWithName), METH_VARARGS, nullptr },
        { "create_with_name_and_file_name", reinterpret_cast<PyCFunction>(IBackgroundTransferContentPartFactory_CreateWithNameAndFileName), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTransferContentPartFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferContentPartFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferContentPartFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferContentPartFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferContentPartFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferContentPartFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferContentPartFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferContentPartFactory) },
        { }
    };

    static PyType_Spec type_spec_IBackgroundTransferContentPartFactory = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferContentPartFactory",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferContentPartFactory};

    struct ImplementsIBackgroundTransferContentPartFactory : py::ImplementsInterfaceT<ImplementsIBackgroundTransferContentPartFactory, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>
    {
        ImplementsIBackgroundTransferContentPartFactory() = delete;
        ImplementsIBackgroundTransferContentPartFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIBackgroundTransferContentPartFactory, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>(py_obj, runtime_class)
        {
        }

        auto CreateWithName(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_with_name")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateWithNameAndFileName(winrt::hstring const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_with_name_and_file_name")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIBackgroundTransferContentPartFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIBackgroundTransferContentPartFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIBackgroundTransferContentPartFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIBackgroundTransferContentPartFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIBackgroundTransferContentPartFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIBackgroundTransferContentPartFactory) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIBackgroundTransferContentPartFactory = {
        "winrt._winrt_windows_networking_backgroundtransfer.ImplementsIBackgroundTransferContentPartFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIBackgroundTransferContentPartFactory};

    // ----- IBackgroundTransferOperation interface --------------------

    static PyObject* _new_IBackgroundTransferOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"GetResponseInformation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"GetResultStreamAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"CostPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"Guid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation", L"RequestedUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperation[] = {
        { "get_response_information", reinterpret_cast<PyCFunction>(IBackgroundTransferOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(IBackgroundTransferOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBackgroundTransferOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(IBackgroundTransferOperation_get_CostPolicy), reinterpret_cast<setter>(IBackgroundTransferOperation_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Guid), nullptr, nullptr, nullptr },
        { "method", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Method), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(IBackgroundTransferOperation_get_RequestedUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferOperation) },
        { }
    };

    static PyType_Spec type_spec_IBackgroundTransferOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperation};

    struct ImplementsIBackgroundTransferOperation : py::ImplementsInterfaceT<ImplementsIBackgroundTransferOperation, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>
    {
        ImplementsIBackgroundTransferOperation() = delete;
        ImplementsIBackgroundTransferOperation(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIBackgroundTransferOperation, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>(py_obj, runtime_class)
        {
        }

        auto GetResponseInformation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_response_information")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetResultStreamAt(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_result_stream_at")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CostPolicy()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "cost_policy")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void CostPolicy(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "cost_policy", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Group()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "group")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Guid()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "guid")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::guid>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Method()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "method")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RequestedUri()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "requested_uri")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIBackgroundTransferOperation(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIBackgroundTransferOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIBackgroundTransferOperation>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIBackgroundTransferOperation[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIBackgroundTransferOperation), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIBackgroundTransferOperation), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIBackgroundTransferOperation[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIBackgroundTransferOperation) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIBackgroundTransferOperation = {
        "winrt._winrt_windows_networking_backgroundtransfer.ImplementsIBackgroundTransferOperation",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIBackgroundTransferOperation};

    // ----- IBackgroundTransferOperationPriority interface --------------------

    static PyObject* _new_IBackgroundTransferOperationPriority(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::type_name);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperationPriority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferOperationPriority_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperationPriority", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperationPriority_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.BackgroundTransfer.IBackgroundTransferOperationPriority", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperationPriority[] = {
        { "_assign_array_", _assign_array_IBackgroundTransferOperationPriority, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferOperationPriority), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperationPriority[] = {
        { "priority", reinterpret_cast<getter>(IBackgroundTransferOperationPriority_get_Priority), reinterpret_cast<setter>(IBackgroundTransferOperationPriority_put_Priority), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperationPriority[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBackgroundTransferOperationPriority) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBackgroundTransferOperationPriority) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBackgroundTransferOperationPriority) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBackgroundTransferOperationPriority) },
        { }
    };

    static PyType_Spec type_spec_IBackgroundTransferOperationPriority = {
        "winrt._winrt_windows_networking_backgroundtransfer.IBackgroundTransferOperationPriority",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperationPriority};

    struct ImplementsIBackgroundTransferOperationPriority : py::ImplementsInterfaceT<ImplementsIBackgroundTransferOperationPriority, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>
    {
        ImplementsIBackgroundTransferOperationPriority() = delete;
        ImplementsIBackgroundTransferOperationPriority(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIBackgroundTransferOperationPriority, winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>(py_obj, runtime_class)
        {
        }

        auto Priority()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "priority")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Priority(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "priority", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIBackgroundTransferOperationPriority>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIBackgroundTransferOperationPriority[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIBackgroundTransferOperationPriority), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIBackgroundTransferOperationPriority), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIBackgroundTransferOperationPriority[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIBackgroundTransferOperationPriority) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIBackgroundTransferOperationPriority = {
        "winrt._winrt_windows_networking_backgroundtransfer.ImplementsIBackgroundTransferOperationPriority",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIBackgroundTransferOperationPriority};

    // ----- BackgroundDownloadProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>* _new_BackgroundDownloadProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BackgroundDownloadProgress(winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _BytesReceived{};
        uint64_t _TotalBytesToReceive{};
        int32_t _Status{};
        int _HasResponseChanged{};
        int _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "total_bytes_to_receive", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKipp", const_cast<char**>(kwlist), &_BytesReceived, &_TotalBytesToReceive, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return -1;
        }

        try
        {
            self->obj.BytesReceived = _BytesReceived;
            self->obj.TotalBytesToReceive = _TotalBytesToReceive;
            self->obj.Status = static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status);
            self->obj.HasResponseChanged = _HasResponseChanged;
            self->obj.HasRestarted = _HasRestarted;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BackgroundDownloadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BackgroundDownloadProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BackgroundDownloadProgress[] = {
        { "_assign_array_", _assign_array_BackgroundDownloadProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BackgroundDownloadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Status = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::convert_to<bool>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::convert_to<bool>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundDownloadProgress[] = {
        { "bytes_received", reinterpret_cast<getter>(BackgroundDownloadProgress_get_BytesReceived), reinterpret_cast<setter>(BackgroundDownloadProgress_set_BytesReceived), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(BackgroundDownloadProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(BackgroundDownloadProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BackgroundDownloadProgress_get_Status), reinterpret_cast<setter>(BackgroundDownloadProgress_set_Status), nullptr, nullptr },
        { "has_response_changed", reinterpret_cast<getter>(BackgroundDownloadProgress_get_HasResponseChanged), reinterpret_cast<setter>(BackgroundDownloadProgress_set_HasResponseChanged), nullptr, nullptr },
        { "has_restarted", reinterpret_cast<getter>(BackgroundDownloadProgress_get_HasRestarted), reinterpret_cast<setter>(BackgroundDownloadProgress_set_HasRestarted), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_BackgroundDownloadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_BackgroundDownloadProgress(PyObject* self) noexcept
    {
        py::pyobj_handle BytesReceived{PyObject_GetAttrString(self, "bytes_received")};
        if (!BytesReceived)
        {
            return nullptr;
        }

        py::pyobj_handle TotalBytesToReceive{PyObject_GetAttrString(self, "total_bytes_to_receive")};
        if (!TotalBytesToReceive)
        {
            return nullptr;
        }

        py::pyobj_handle Status{PyObject_GetAttrString(self, "status")};
        if (!Status)
        {
            return nullptr;
        }

        py::pyobj_handle HasResponseChanged{PyObject_GetAttrString(self, "has_response_changed")};
        if (!HasResponseChanged)
        {
            return nullptr;
        }

        py::pyobj_handle HasRestarted{PyObject_GetAttrString(self, "has_restarted")};
        if (!HasRestarted)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("BackgroundDownloadProgress(bytes_received=%R, total_bytes_to_receive=%R, status=%R, has_response_changed=%R, has_restarted=%R)", BytesReceived.get(), TotalBytesToReceive.get(), Status.get(), HasResponseChanged.get(), HasRestarted.get());
    }

    static PyType_Slot _type_slots_BackgroundDownloadProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundDownloadProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BackgroundDownloadProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundDownloadProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundDownloadProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundDownloadProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_BackgroundDownloadProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_BackgroundDownloadProgress) },
        { }
    };

    static PyType_Spec type_spec_BackgroundDownloadProgress = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundDownloadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloadProgress};

    // ----- BackgroundTransferFileRange struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>* _new_BackgroundTransferFileRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BackgroundTransferFileRange(winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Offset{};
        uint64_t _Length{};

        static const char* kwlist[] = {"offset", "length", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KK", const_cast<char**>(kwlist), &_Offset, &_Length))
        {
            return -1;
        }

        try
        {
            self->obj.Offset = _Offset;
            self->obj.Length = _Length;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BackgroundTransferFileRange(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BackgroundTransferFileRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BackgroundTransferFileRange[] = {
        { "_assign_array_", _assign_array_BackgroundTransferFileRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BackgroundTransferFileRange_get_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Offset = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferFileRange_get_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Length = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundTransferFileRange[] = {
        { "offset", reinterpret_cast<getter>(BackgroundTransferFileRange_get_Offset), reinterpret_cast<setter>(BackgroundTransferFileRange_set_Offset), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(BackgroundTransferFileRange_get_Length), reinterpret_cast<setter>(BackgroundTransferFileRange_set_Length), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_BackgroundTransferFileRange(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_BackgroundTransferFileRange(PyObject* self) noexcept
    {
        py::pyobj_handle Offset{PyObject_GetAttrString(self, "offset")};
        if (!Offset)
        {
            return nullptr;
        }

        py::pyobj_handle Length{PyObject_GetAttrString(self, "length")};
        if (!Length)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("BackgroundTransferFileRange(offset=%R, length=%R)", Offset.get(), Length.get());
    }

    static PyType_Slot _type_slots_BackgroundTransferFileRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundTransferFileRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BackgroundTransferFileRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundTransferFileRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundTransferFileRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundTransferFileRange) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_BackgroundTransferFileRange) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_BackgroundTransferFileRange) },
        { }
    };

    static PyType_Spec type_spec_BackgroundTransferFileRange = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundTransferFileRange",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferFileRange};

    // ----- BackgroundUploadProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>* _new_BackgroundUploadProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_BackgroundUploadProgress(winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _BytesReceived{};
        uint64_t _BytesSent{};
        uint64_t _TotalBytesToReceive{};
        uint64_t _TotalBytesToSend{};
        int32_t _Status{};
        int _HasResponseChanged{};
        int _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "bytes_sent", "total_bytes_to_receive", "total_bytes_to_send", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKipp", const_cast<char**>(kwlist), &_BytesReceived, &_BytesSent, &_TotalBytesToReceive, &_TotalBytesToSend, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return -1;
        }

        try
        {
            self->obj.BytesReceived = _BytesReceived;
            self->obj.BytesSent = _BytesSent;
            self->obj.TotalBytesToReceive = _TotalBytesToReceive;
            self->obj.TotalBytesToSend = _TotalBytesToSend;
            self->obj.Status = static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status);
            self->obj.HasResponseChanged = _HasResponseChanged;
            self->obj.HasRestarted = _HasRestarted;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_BackgroundUploadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BackgroundUploadProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_BackgroundUploadProgress[] = {
        { "_assign_array_", _assign_array_BackgroundUploadProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* BackgroundUploadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesSent = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToSend);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToSend = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Status = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::convert_to<bool>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::convert_to<bool>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundUploadProgress[] = {
        { "bytes_received", reinterpret_cast<getter>(BackgroundUploadProgress_get_BytesReceived), reinterpret_cast<setter>(BackgroundUploadProgress_set_BytesReceived), nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(BackgroundUploadProgress_get_BytesSent), reinterpret_cast<setter>(BackgroundUploadProgress_set_BytesSent), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(BackgroundUploadProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(BackgroundUploadProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "total_bytes_to_send", reinterpret_cast<getter>(BackgroundUploadProgress_get_TotalBytesToSend), reinterpret_cast<setter>(BackgroundUploadProgress_set_TotalBytesToSend), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BackgroundUploadProgress_get_Status), reinterpret_cast<setter>(BackgroundUploadProgress_set_Status), nullptr, nullptr },
        { "has_response_changed", reinterpret_cast<getter>(BackgroundUploadProgress_get_HasResponseChanged), reinterpret_cast<setter>(BackgroundUploadProgress_set_HasResponseChanged), nullptr, nullptr },
        { "has_restarted", reinterpret_cast<getter>(BackgroundUploadProgress_get_HasRestarted), reinterpret_cast<setter>(BackgroundUploadProgress_set_HasRestarted), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_BackgroundUploadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_BackgroundUploadProgress(PyObject* self) noexcept
    {
        py::pyobj_handle BytesReceived{PyObject_GetAttrString(self, "bytes_received")};
        if (!BytesReceived)
        {
            return nullptr;
        }

        py::pyobj_handle BytesSent{PyObject_GetAttrString(self, "bytes_sent")};
        if (!BytesSent)
        {
            return nullptr;
        }

        py::pyobj_handle TotalBytesToReceive{PyObject_GetAttrString(self, "total_bytes_to_receive")};
        if (!TotalBytesToReceive)
        {
            return nullptr;
        }

        py::pyobj_handle TotalBytesToSend{PyObject_GetAttrString(self, "total_bytes_to_send")};
        if (!TotalBytesToSend)
        {
            return nullptr;
        }

        py::pyobj_handle Status{PyObject_GetAttrString(self, "status")};
        if (!Status)
        {
            return nullptr;
        }

        py::pyobj_handle HasResponseChanged{PyObject_GetAttrString(self, "has_response_changed")};
        if (!HasResponseChanged)
        {
            return nullptr;
        }

        py::pyobj_handle HasRestarted{PyObject_GetAttrString(self, "has_restarted")};
        if (!HasRestarted)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("BackgroundUploadProgress(bytes_received=%R, bytes_sent=%R, total_bytes_to_receive=%R, total_bytes_to_send=%R, status=%R, has_response_changed=%R, has_restarted=%R)", BytesReceived.get(), BytesSent.get(), TotalBytesToReceive.get(), TotalBytesToSend.get(), Status.get(), HasResponseChanged.get(), HasRestarted.get());
    }

    static PyType_Slot _type_slots_BackgroundUploadProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundUploadProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_BackgroundUploadProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundUploadProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundUploadProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundUploadProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_BackgroundUploadProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_BackgroundUploadProgress) },
        { }
    };

    static PyType_Spec type_spec_BackgroundUploadProgress = {
        "winrt._winrt_windows_networking_backgroundtransfer.BackgroundUploadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploadProgress};

    // ----- Windows.Networking.BackgroundTransfer Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Networking.BackgroundTransfer");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_networking_backgroundtransfer",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Networking::BackgroundTransfer

PyMODINIT_FUNC PyInit__winrt_windows_networking_backgroundtransfer(void) noexcept
{
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundDownloader_Static{PyType_FromSpec(&type_spec_BackgroundDownloader_Static)};
    if (!type_BackgroundDownloader_Static)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundDownloader_type{py::register_python_type(module.get(), &type_spec_BackgroundDownloader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundDownloader_Static.get()))};
    if (!BackgroundDownloader_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferCompletionGroup_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferCompletionGroup, object_bases.get(), nullptr)};
    if (!BackgroundTransferCompletionGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferCompletionGroupTriggerDetails_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferCompletionGroupTriggerDetails, object_bases.get(), nullptr)};
    if (!BackgroundTransferCompletionGroupTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferContentPart_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferContentPart, object_bases.get(), nullptr)};
    if (!BackgroundTransferContentPart_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundTransferError_Static{PyType_FromSpec(&type_spec_BackgroundTransferError_Static)};
    if (!type_BackgroundTransferError_Static)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferError_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferError, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundTransferError_Static.get()))};
    if (!BackgroundTransferError_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundTransferGroup_Static{PyType_FromSpec(&type_spec_BackgroundTransferGroup_Static)};
    if (!type_BackgroundTransferGroup_Static)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferGroup_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferGroup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundTransferGroup_Static.get()))};
    if (!BackgroundTransferGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferRangesDownloadedEventArgs_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferRangesDownloadedEventArgs, object_bases.get(), nullptr)};
    if (!BackgroundTransferRangesDownloadedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_BackgroundUploader_Static{PyType_FromSpec(&type_spec_BackgroundUploader_Static)};
    if (!type_BackgroundUploader_Static)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundUploader_type{py::register_python_type(module.get(), &type_spec_BackgroundUploader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackgroundUploader_Static.get()))};
    if (!BackgroundUploader_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentPrefetcher_Static{PyType_FromSpec(&type_spec_ContentPrefetcher_Static)};
    if (!type_ContentPrefetcher_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentPrefetcher_type{py::register_python_type(module.get(), &type_spec_ContentPrefetcher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentPrefetcher_Static.get()))};
    if (!ContentPrefetcher_type)
    {
        return nullptr;
    }

    py::pytype_handle DownloadOperation_type{py::register_python_type(module.get(), &type_spec_DownloadOperation, object_bases.get(), nullptr)};
    if (!DownloadOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle ResponseInformation_type{py::register_python_type(module.get(), &type_spec_ResponseInformation, object_bases.get(), nullptr)};
    if (!ResponseInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle UnconstrainedTransferRequestResult_type{py::register_python_type(module.get(), &type_spec_UnconstrainedTransferRequestResult, object_bases.get(), nullptr)};
    if (!UnconstrainedTransferRequestResult_type)
    {
        return nullptr;
    }

    py::pytype_handle UploadOperation_type{py::register_python_type(module.get(), &type_spec_UploadOperation, object_bases.get(), nullptr)};
    if (!UploadOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle IBackgroundTransferBase_type{py::register_python_type(module.get(), &type_spec_IBackgroundTransferBase, object_bases.get(), nullptr)};
    if (!IBackgroundTransferBase_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIBackgroundTransferBase_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIBackgroundTransferBase, nullptr))};
    if (!ImplementsIBackgroundTransferBase_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIBackgroundTransferBase_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IBackgroundTransferContentPartFactory_type{py::register_python_type(module.get(), &type_spec_IBackgroundTransferContentPartFactory, object_bases.get(), nullptr)};
    if (!IBackgroundTransferContentPartFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIBackgroundTransferContentPartFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIBackgroundTransferContentPartFactory, nullptr))};
    if (!ImplementsIBackgroundTransferContentPartFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIBackgroundTransferContentPartFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IBackgroundTransferOperation_type{py::register_python_type(module.get(), &type_spec_IBackgroundTransferOperation, object_bases.get(), nullptr)};
    if (!IBackgroundTransferOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIBackgroundTransferOperation_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIBackgroundTransferOperation, nullptr))};
    if (!ImplementsIBackgroundTransferOperation_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIBackgroundTransferOperation_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IBackgroundTransferOperationPriority_type{py::register_python_type(module.get(), &type_spec_IBackgroundTransferOperationPriority, object_bases.get(), nullptr)};
    if (!IBackgroundTransferOperationPriority_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIBackgroundTransferOperationPriority_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIBackgroundTransferOperationPriority, nullptr))};
    if (!ImplementsIBackgroundTransferOperationPriority_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIBackgroundTransferOperationPriority_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundDownloadProgress_type{py::register_python_type(module.get(), &type_spec_BackgroundDownloadProgress, nullptr, nullptr)};
    if (!BackgroundDownloadProgress_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundTransferFileRange_type{py::register_python_type(module.get(), &type_spec_BackgroundTransferFileRange, nullptr, nullptr)};
    if (!BackgroundTransferFileRange_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundUploadProgress_type{py::register_python_type(module.get(), &type_spec_BackgroundUploadProgress, nullptr, nullptr)};
    if (!BackgroundUploadProgress_type)
    {
        return nullptr;
    }


    return module.detach();
}
