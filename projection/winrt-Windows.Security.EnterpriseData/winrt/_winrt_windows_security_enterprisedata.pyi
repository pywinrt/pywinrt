# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.1.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.networking as windows_networking
import winrt.windows.storage as windows_storage
import winrt.windows.storage.streams as windows_storage_streams

from winrt.windows.security.enterprisedata import DataProtectionStatus, EnforcementLevel, FileProtectionStatus, ProtectedImportExportStatus, ProtectionPolicyAuditAction, ProtectionPolicyEvaluationResult, ProtectionPolicyRequestAccessBehavior

Self = typing.TypeVar('Self')

@typing.final
class BufferProtectUnprotectResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BufferProtectUnprotectResult: ...
    @_property
    def buffer(self) -> typing.Optional[windows_storage_streams.IBuffer]: ...
    @_property
    def protection_info(self) -> typing.Optional[DataProtectionInfo]: ...

@typing.final
class DataProtectionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataProtectionInfo: ...
    @_property
    def identity(self) -> str: ...
    @_property
    def status(self) -> DataProtectionStatus: ...

@typing.final
class DataProtectionManager_Static(type):
    def get_protection_info_async(cls, protected_data: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncOperation[DataProtectionInfo]: ...
    def get_stream_protection_info_async(cls, protected_stream: typing.Optional[windows_storage_streams.IInputStream], /) -> windows_foundation.IAsyncOperation[DataProtectionInfo]: ...
    def protect_async(cls, data: typing.Optional[windows_storage_streams.IBuffer], identity: str, /) -> windows_foundation.IAsyncOperation[BufferProtectUnprotectResult]: ...
    def protect_stream_async(cls, unprotected_stream: typing.Optional[windows_storage_streams.IInputStream], identity: str, protected_stream: typing.Optional[windows_storage_streams.IOutputStream], /) -> windows_foundation.IAsyncOperation[DataProtectionInfo]: ...
    def unprotect_async(cls, data: typing.Optional[windows_storage_streams.IBuffer], /) -> windows_foundation.IAsyncOperation[BufferProtectUnprotectResult]: ...
    def unprotect_stream_async(cls, protected_stream: typing.Optional[windows_storage_streams.IInputStream], unprotected_stream: typing.Optional[windows_storage_streams.IOutputStream], /) -> windows_foundation.IAsyncOperation[DataProtectionInfo]: ...

@typing.final
class DataProtectionManager(winrt.system.Object, metaclass=DataProtectionManager_Static):
    pass

@typing.final
class FileProtectionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileProtectionInfo: ...
    @_property
    def identity(self) -> str: ...
    @_property
    def is_roamable(self) -> bool: ...
    @_property
    def status(self) -> FileProtectionStatus: ...
    @_property
    def is_protect_while_open_supported(self) -> bool: ...

@typing.final
class FileProtectionManager_Static(type):
    def copy_protection_async(cls, source: typing.Optional[windows_storage.IStorageItem], target: typing.Optional[windows_storage.IStorageItem], /) -> windows_foundation.IAsyncOperation[bool]: ...
    def create_protected_and_open_async(cls, parent_folder: typing.Optional[windows_storage.IStorageFolder], desired_name: str, identity: str, collision_option: windows_storage.CreationCollisionOption, /) -> windows_foundation.IAsyncOperation[ProtectedFileCreateResult]: ...
    def get_protection_info_async(cls, source: typing.Optional[windows_storage.IStorageItem], /) -> windows_foundation.IAsyncOperation[FileProtectionInfo]: ...
    def is_container_async(cls, file: typing.Optional[windows_storage.IStorageFile], /) -> windows_foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def load_file_from_container_async(cls, container_file: typing.Optional[windows_storage.IStorageFile], /) -> windows_foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @typing.overload
    def load_file_from_container_async(cls, container_file: typing.Optional[windows_storage.IStorageFile], target: typing.Optional[windows_storage.IStorageItem], /) -> windows_foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @typing.overload
    def load_file_from_container_async(cls, container_file: typing.Optional[windows_storage.IStorageFile], target: typing.Optional[windows_storage.IStorageItem], collision_option: windows_storage.NameCollisionOption, /) -> windows_foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    def protect_async(cls, target: typing.Optional[windows_storage.IStorageItem], identity: str, /) -> windows_foundation.IAsyncOperation[FileProtectionInfo]: ...
    @typing.overload
    def save_file_as_container_async(cls, protected_file: typing.Optional[windows_storage.IStorageFile], /) -> windows_foundation.IAsyncOperation[ProtectedContainerExportResult]: ...
    @typing.overload
    def save_file_as_container_async(cls, protected_file: typing.Optional[windows_storage.IStorageFile], shared_with_identities: typing.Iterable[str], /) -> windows_foundation.IAsyncOperation[ProtectedContainerExportResult]: ...
    @typing.overload
    def unprotect_async(cls, target: typing.Optional[windows_storage.IStorageItem], /) -> windows_foundation.IAsyncOperation[FileProtectionInfo]: ...
    @typing.overload
    def unprotect_async(cls, target: typing.Optional[windows_storage.IStorageItem], options: typing.Optional[FileUnprotectOptions], /) -> windows_foundation.IAsyncOperation[FileProtectionInfo]: ...

@typing.final
class FileProtectionManager(winrt.system.Object, metaclass=FileProtectionManager_Static):
    pass

@typing.final
class FileRevocationManager_Static(type):
    def copy_protection_async(cls, source_storage_item: typing.Optional[windows_storage.IStorageItem], target_storage_item: typing.Optional[windows_storage.IStorageItem], /) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_status_async(cls, storage_item: typing.Optional[windows_storage.IStorageItem], /) -> windows_foundation.IAsyncOperation[FileProtectionStatus]: ...
    def protect_async(cls, storage_item: typing.Optional[windows_storage.IStorageItem], enterprise_identity: str, /) -> windows_foundation.IAsyncOperation[FileProtectionStatus]: ...
    def revoke(cls, enterprise_identity: str, /) -> None: ...

@typing.final
class FileRevocationManager(winrt.system.Object, metaclass=FileRevocationManager_Static):
    pass

@typing.final
class FileUnprotectOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileUnprotectOptions: ...
    def __new__(cls: typing.Type[FileUnprotectOptions], audit: bool) -> FileUnprotectOptions: ...
    @_property
    def audit(self) -> bool: ...
    @audit.setter
    def audit(self, value: bool) -> None: ...

@typing.final
class ProtectedAccessResumedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedAccessResumedEventArgs: ...
    @_property
    def identities(self) -> typing.Optional[windows_foundation_collections.IVectorView[str]]: ...

@typing.final
class ProtectedAccessSuspendingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedAccessSuspendingEventArgs: ...
    def get_deferral(self) -> typing.Optional[windows_foundation.Deferral]: ...
    @_property
    def deadline(self) -> datetime.datetime: ...
    @_property
    def identities(self) -> typing.Optional[windows_foundation_collections.IVectorView[str]]: ...

@typing.final
class ProtectedContainerExportResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContainerExportResult: ...
    @_property
    def file(self) -> typing.Optional[windows_storage.StorageFile]: ...
    @_property
    def status(self) -> ProtectedImportExportStatus: ...

@typing.final
class ProtectedContainerImportResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContainerImportResult: ...
    @_property
    def file(self) -> typing.Optional[windows_storage.StorageFile]: ...
    @_property
    def status(self) -> ProtectedImportExportStatus: ...

@typing.final
class ProtectedContentRevokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContentRevokedEventArgs: ...
    @_property
    def identities(self) -> typing.Optional[windows_foundation_collections.IVectorView[str]]: ...

@typing.final
class ProtectedFileCreateResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedFileCreateResult: ...
    @_property
    def file(self) -> typing.Optional[windows_storage.StorageFile]: ...
    @_property
    def protection_info(self) -> typing.Optional[FileProtectionInfo]: ...
    @_property
    def stream(self) -> typing.Optional[windows_storage_streams.IRandomAccessStream]: ...

@typing.final
class ProtectionPolicyAuditInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectionPolicyAuditInfo: ...
    @typing.overload
    def __new__(cls: typing.Type[ProtectionPolicyAuditInfo], action: ProtectionPolicyAuditAction, data_description: str, source_description: str, target_description: str) -> ProtectionPolicyAuditInfo: ...
    @typing.overload
    def __new__(cls: typing.Type[ProtectionPolicyAuditInfo], action: ProtectionPolicyAuditAction, data_description: str) -> ProtectionPolicyAuditInfo: ...
    @_property
    def target_description(self) -> str: ...
    @target_description.setter
    def target_description(self, value: str) -> None: ...
    @_property
    def source_description(self) -> str: ...
    @source_description.setter
    def source_description(self, value: str) -> None: ...
    @_property
    def data_description(self) -> str: ...
    @data_description.setter
    def data_description(self, value: str) -> None: ...
    @_property
    def action(self) -> ProtectionPolicyAuditAction: ...
    @action.setter
    def action(self, value: ProtectionPolicyAuditAction) -> None: ...

@typing.final
class ProtectionPolicyManager_Static(type):
    def check_access(cls, source_identity: str, target_identity: str, /) -> ProtectionPolicyEvaluationResult: ...
    def check_access_for_app(cls, source_identity: str, app_package_family_name: str, /) -> ProtectionPolicyEvaluationResult: ...
    def clear_process_u_i_policy(cls) -> None: ...
    def create_current_thread_network_context(cls, identity: str, /) -> typing.Optional[ThreadNetworkContext]: ...
    def get_enforcement_level(cls, identity: str, /) -> EnforcementLevel: ...
    def get_for_current_view(cls) -> typing.Optional[ProtectionPolicyManager]: ...
    def get_primary_managed_identity_for_identity(cls, identity: str, /) -> str: ...
    def get_primary_managed_identity_for_network_endpoint_async(cls, endpoint_host: typing.Optional[windows_networking.HostName], /) -> windows_foundation.IAsyncOperation[str]: ...
    def has_content_been_revoked_since(cls, identity: str, since: datetime.datetime, /) -> bool: ...
    def is_file_protection_required_async(cls, target: typing.Optional[windows_storage.IStorageItem], identity: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def is_file_protection_required_for_new_file_async(cls, parent_folder: typing.Optional[windows_storage.IStorageFolder], identity: str, desired_name: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def is_identity_managed(cls, identity: str, /) -> bool: ...
    def is_protection_under_lock_required(cls, identity: str, /) -> bool: ...
    def is_roamable_protection_enabled(cls, identity: str, /) -> bool: ...
    def is_user_decryption_allowed(cls, identity: str, /) -> bool: ...
    def log_audit_event(cls, source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> None: ...
    @typing.overload
    def request_access_async(cls, source_identity: str, target_identity: str, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_async(cls, source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_async(cls, source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_async(cls, source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_for_app_async(cls, source_identity: str, app_package_family_name: str, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_for_app_async(cls, source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_for_app_async(cls, source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_for_app_async(cls, source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_to_files_for_app_async(cls, source_item_list: typing.Iterable[windows_storage.IStorageItem], app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_to_files_for_app_async(cls, source_item_list: typing.Iterable[windows_storage.IStorageItem], app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_to_files_for_process_async(cls, source_item_list: typing.Iterable[windows_storage.IStorageItem], process_id: winrt.system.UInt32, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    def request_access_to_files_for_process_async(cls, source_item_list: typing.Iterable[windows_storage.IStorageItem], process_id: winrt.system.UInt32, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> windows_foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    def revoke_content(cls, identity: str, /) -> None: ...
    def try_apply_process_u_i_policy(cls, identity: str, /) -> bool: ...
    def add_policy_changed(cls, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_policy_changed(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_protected_access_resumed(cls, handler: windows_foundation.EventHandler[ProtectedAccessResumedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_protected_access_resumed(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_protected_access_suspending(cls, handler: windows_foundation.EventHandler[ProtectedAccessSuspendingEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_protected_access_suspending(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_protected_content_revoked(cls, handler: windows_foundation.EventHandler[ProtectedContentRevokedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_protected_content_revoked(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_protection_enabled(cls) -> bool: ...
    @_property
    def primary_managed_identity(cls) -> str: ...

@typing.final
class ProtectionPolicyManager(winrt.system.Object, metaclass=ProtectionPolicyManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectionPolicyManager: ...
    @_property
    def identity(self) -> str: ...
    @identity.setter
    def identity(self, value: str) -> None: ...
    @_property
    def show_enterprise_indicator(self) -> bool: ...
    @show_enterprise_indicator.setter
    def show_enterprise_indicator(self, value: bool) -> None: ...

@typing.final
class ThreadNetworkContext(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThreadNetworkContext: ...
    def close(self) -> None: ...

