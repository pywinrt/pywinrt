// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Networking.NetworkOperators.h"


namespace py::cpp::Windows::Networking::NetworkOperators
{
    // ----- ESim class --------------------

    static PyObject* _new_ESim(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESim>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESim>::type_name);
        return nullptr;
    }

    static void _dealloc_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESim* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESim_DeleteProfileAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DeleteProfileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_Discover(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"Discover", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Discover());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"Discover", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Discover(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_DiscoverAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DiscoverAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DiscoverAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DiscoverAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DiscoverAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_DownloadProfileMetadataAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"DownloadProfileMetadataAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadProfileMetadataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_GetProfiles(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"GetProfiles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_ResetAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESim", L"ResetAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_get_AvailableMemoryInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"AvailableMemoryInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableMemoryInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_Eid(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"Eid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Eid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_FirmwareVersion(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"FirmwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_MobileBroadbandModemDeviceId(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"MobileBroadbandModemDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MobileBroadbandModemDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"Policy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_SlotIndex(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESim", L"SlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_add_ProfileChanged(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESim", L"ProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESim, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_remove_ProfileChanged(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESim", L"ProfileChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESim(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESim>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESim(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESim>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESim[] = {
        { "delete_profile_async", reinterpret_cast<PyCFunction>(ESim_DeleteProfileAsync), METH_VARARGS, nullptr },
        { "discover", reinterpret_cast<PyCFunction>(ESim_Discover), METH_VARARGS, nullptr },
        { "discover_async", reinterpret_cast<PyCFunction>(ESim_DiscoverAsync), METH_VARARGS, nullptr },
        { "download_profile_metadata_async", reinterpret_cast<PyCFunction>(ESim_DownloadProfileMetadataAsync), METH_VARARGS, nullptr },
        { "get_profiles", reinterpret_cast<PyCFunction>(ESim_GetProfiles), METH_VARARGS, nullptr },
        { "reset_async", reinterpret_cast<PyCFunction>(ESim_ResetAsync), METH_VARARGS, nullptr },
        { "add_profile_changed", reinterpret_cast<PyCFunction>(ESim_add_ProfileChanged), METH_O, nullptr },
        { "remove_profile_changed", reinterpret_cast<PyCFunction>(ESim_remove_ProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ESim, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESim), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESim[] = {
        { "available_memory_in_bytes", reinterpret_cast<getter>(ESim_get_AvailableMemoryInBytes), nullptr, nullptr, nullptr },
        { "eid", reinterpret_cast<getter>(ESim_get_Eid), nullptr, nullptr, nullptr },
        { "firmware_version", reinterpret_cast<getter>(ESim_get_FirmwareVersion), nullptr, nullptr, nullptr },
        { "mobile_broadband_modem_device_id", reinterpret_cast<getter>(ESim_get_MobileBroadbandModemDeviceId), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESim_get_Policy), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESim_get_State), nullptr, nullptr, nullptr },
        { "slot_index", reinterpret_cast<getter>(ESim_get_SlotIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESim[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESim) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESim) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESim) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESim) },
        { },
    };

    static PyType_Spec type_spec_ESim =
    {
        "_winrt_windows_networking_networkoperators.ESim",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESim),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESim
    };

    // ----- ESimAddedEventArgs class --------------------

    static PyObject* _new_ESimAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimAddedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimAddedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimAddedEventArgs", L"ESim"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimAddedEventArgs[] = {
        { "_assign_array_", _assign_array_ESimAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimAddedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimAddedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ESimAddedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.ESimAddedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimAddedEventArgs
    };

    // ----- ESimDiscoverEvent class --------------------

    static PyObject* _new_ESimDiscoverEvent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimDiscoverEvent(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDiscoverEvent_get_MatchingId(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverEvent", L"MatchingId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MatchingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverEvent_get_RspServerAddress(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverEvent", L"RspServerAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RspServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimDiscoverEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimDiscoverEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDiscoverEvent[] = {
        { "_assign_array_", _assign_array_ESimDiscoverEvent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDiscoverEvent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDiscoverEvent[] = {
        { "matching_id", reinterpret_cast<getter>(ESimDiscoverEvent_get_MatchingId), nullptr, nullptr, nullptr },
        { "rsp_server_address", reinterpret_cast<getter>(ESimDiscoverEvent_get_RspServerAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDiscoverEvent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimDiscoverEvent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimDiscoverEvent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimDiscoverEvent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimDiscoverEvent) },
        { },
    };

    static PyType_Spec type_spec_ESimDiscoverEvent =
    {
        "_winrt_windows_networking_networkoperators.ESimDiscoverEvent",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDiscoverEvent
    };

    // ----- ESimDiscoverResult class --------------------

    static PyObject* _new_ESimDiscoverResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimDiscoverResult(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDiscoverResult_get_Events(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"Events"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Events());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_ProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"ProfileMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_Result(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDiscoverResult", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimDiscoverResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimDiscoverResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDiscoverResult[] = {
        { "_assign_array_", _assign_array_ESimDiscoverResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDiscoverResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDiscoverResult[] = {
        { "events", reinterpret_cast<getter>(ESimDiscoverResult_get_Events), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ESimDiscoverResult_get_Kind), nullptr, nullptr, nullptr },
        { "profile_metadata", reinterpret_cast<getter>(ESimDiscoverResult_get_ProfileMetadata), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(ESimDiscoverResult_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDiscoverResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimDiscoverResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimDiscoverResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimDiscoverResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimDiscoverResult) },
        { },
    };

    static PyType_Spec type_spec_ESimDiscoverResult =
    {
        "_winrt_windows_networking_networkoperators.ESimDiscoverResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDiscoverResult
    };

    // ----- ESimDownloadProfileMetadataResult class --------------------

    static PyObject* _new_ESimDownloadProfileMetadataResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimDownloadProfileMetadataResult(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDownloadProfileMetadataResult_get_ProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDownloadProfileMetadataResult", L"ProfileMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDownloadProfileMetadataResult_get_Result(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimDownloadProfileMetadataResult", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimDownloadProfileMetadataResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimDownloadProfileMetadataResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDownloadProfileMetadataResult[] = {
        { "_assign_array_", _assign_array_ESimDownloadProfileMetadataResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDownloadProfileMetadataResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDownloadProfileMetadataResult[] = {
        { "profile_metadata", reinterpret_cast<getter>(ESimDownloadProfileMetadataResult_get_ProfileMetadata), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(ESimDownloadProfileMetadataResult_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDownloadProfileMetadataResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimDownloadProfileMetadataResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimDownloadProfileMetadataResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimDownloadProfileMetadataResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimDownloadProfileMetadataResult) },
        { },
    };

    static PyType_Spec type_spec_ESimDownloadProfileMetadataResult =
    {
        "_winrt_windows_networking_networkoperators.ESimDownloadProfileMetadataResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDownloadProfileMetadataResult
    };

    // ----- ESimManager class --------------------

    static PyObject* _new_ESimManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimManager>::type_name);
        return nullptr;
    }

    static PyObject* ESimManager_TryCreateESimWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"TryCreateESimWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::TryCreateESimWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimManager_get_ServiceInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"ServiceInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimManager_add_ServiceInfoChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"ServiceInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimManager_remove_ServiceInfoChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimManager", L"ServiceInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimManager[] = {
        { "try_create_e_sim_watcher", reinterpret_cast<PyCFunction>(ESimManager_TryCreateESimWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "add_service_info_changed", reinterpret_cast<PyCFunction>(ESimManager_add_ServiceInfoChanged), METH_O | METH_STATIC, nullptr },
        { "remove_service_info_changed", reinterpret_cast<PyCFunction>(ESimManager_remove_ServiceInfoChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ESimManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimManager) },
        { },
    };

    static PyType_Spec type_spec_ESimManager =
    {
        "_winrt_windows_networking_networkoperators.ESimManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimManager
    };

    static PyGetSetDef getset_ESimManager_Meta[] = {
        { "service_info", reinterpret_cast<getter>(ESimManager_get_ServiceInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ESimManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ESimManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_ESimManager_Meta =
    {
        "_winrt_windows_networking_networkoperators.ESimManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ESimManager_Meta
    };

    // ----- ESimOperationResult class --------------------

    static PyObject* _new_ESimOperationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimOperationResult(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimOperationResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimOperationResult[] = {
        { "_assign_array_", _assign_array_ESimOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimOperationResult[] = {
        { "status", reinterpret_cast<getter>(ESimOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimOperationResult) },
        { },
    };

    static PyType_Spec type_spec_ESimOperationResult =
    {
        "_winrt_windows_networking_networkoperators.ESimOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimOperationResult
    };

    // ----- ESimPolicy class --------------------

    static PyObject* _new_ESimPolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimPolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimPolicy>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimPolicy(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimPolicy_get_ShouldEnableManagingUi(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimPolicy", L"ShouldEnableManagingUi"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldEnableManagingUi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimPolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimPolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimPolicy[] = {
        { "_assign_array_", _assign_array_ESimPolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimPolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimPolicy[] = {
        { "should_enable_managing_ui", reinterpret_cast<getter>(ESimPolicy_get_ShouldEnableManagingUi), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimPolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimPolicy) },
        { },
    };

    static PyType_Spec type_spec_ESimPolicy =
    {
        "_winrt_windows_networking_networkoperators.ESimPolicy",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimPolicy
    };

    // ----- ESimProfile class --------------------

    static PyObject* _new_ESimProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimProfile(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfile_DisableAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"DisableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_EnableAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"EnableAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_SetNicknameAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"SetNicknameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetNicknameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Class(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Class"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Id(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Nickname(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Nickname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"Policy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderIcon(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"ProviderIcon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderName(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"ProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfile", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfile[] = {
        { "disable_async", reinterpret_cast<PyCFunction>(ESimProfile_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ESimProfile_EnableAsync), METH_VARARGS, nullptr },
        { "set_nickname_async", reinterpret_cast<PyCFunction>(ESimProfile_SetNicknameAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ESimProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfile[] = {
        { "class_", reinterpret_cast<getter>(ESimProfile_get_Class), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ESimProfile_get_Id), nullptr, nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(ESimProfile_get_Nickname), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESimProfile_get_Policy), nullptr, nullptr, nullptr },
        { "provider_icon", reinterpret_cast<getter>(ESimProfile_get_ProviderIcon), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ESimProfile_get_ProviderId), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(ESimProfile_get_ProviderName), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESimProfile_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfile) },
        { },
    };

    static PyType_Spec type_spec_ESimProfile =
    {
        "_winrt_windows_networking_networkoperators.ESimProfile",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfile
    };

    // ----- ESimProfileMetadata class --------------------

    static PyObject* _new_ESimProfileMetadata(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfileMetadata_ConfirmInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ConfirmInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ConfirmInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ConfirmInstallAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ConfirmInstallAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_DenyInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"DenyInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DenyInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_PostponeInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"PostponeInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PostponeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_Id(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_IsConfirmationCodeRequired(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"IsConfirmationCodeRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConfirmationCodeRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"Policy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderIcon(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ProviderIcon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderName(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"ProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_add_StateChanged(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_remove_StateChanged(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimProfileMetadata", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimProfileMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimProfileMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfileMetadata[] = {
        { "confirm_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_ConfirmInstallAsync), METH_VARARGS, nullptr },
        { "deny_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_DenyInstallAsync), METH_VARARGS, nullptr },
        { "postpone_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_PostponeInstallAsync), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ESimProfileMetadata_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ESimProfileMetadata_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ESimProfileMetadata, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfileMetadata), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfileMetadata[] = {
        { "id", reinterpret_cast<getter>(ESimProfileMetadata_get_Id), nullptr, nullptr, nullptr },
        { "is_confirmation_code_required", reinterpret_cast<getter>(ESimProfileMetadata_get_IsConfirmationCodeRequired), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESimProfileMetadata_get_Policy), nullptr, nullptr, nullptr },
        { "provider_icon", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderIcon), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderId), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderName), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESimProfileMetadata_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfileMetadata[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfileMetadata) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfileMetadata) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfileMetadata) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfileMetadata) },
        { },
    };

    static PyType_Spec type_spec_ESimProfileMetadata =
    {
        "_winrt_windows_networking_networkoperators.ESimProfileMetadata",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfileMetadata
    };

    // ----- ESimProfilePolicy class --------------------

    static PyObject* _new_ESimProfilePolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimProfilePolicy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfilePolicy_get_CanDelete(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfilePolicy", L"CanDelete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfilePolicy_get_CanDisable(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfilePolicy", L"CanDisable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDisable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfilePolicy_get_IsManagedByEnterprise(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimProfilePolicy", L"IsManagedByEnterprise"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsManagedByEnterprise());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimProfilePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimProfilePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfilePolicy[] = {
        { "_assign_array_", _assign_array_ESimProfilePolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfilePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfilePolicy[] = {
        { "can_delete", reinterpret_cast<getter>(ESimProfilePolicy_get_CanDelete), nullptr, nullptr, nullptr },
        { "can_disable", reinterpret_cast<getter>(ESimProfilePolicy_get_CanDisable), nullptr, nullptr, nullptr },
        { "is_managed_by_enterprise", reinterpret_cast<getter>(ESimProfilePolicy_get_IsManagedByEnterprise), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfilePolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfilePolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfilePolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfilePolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfilePolicy) },
        { },
    };

    static PyType_Spec type_spec_ESimProfilePolicy =
    {
        "_winrt_windows_networking_networkoperators.ESimProfilePolicy",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfilePolicy
    };

    // ----- ESimRemovedEventArgs class --------------------

    static PyObject* _new_ESimRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimRemovedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimRemovedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimRemovedEventArgs", L"ESim"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_ESimRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimRemovedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimRemovedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ESimRemovedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.ESimRemovedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimRemovedEventArgs
    };

    // ----- ESimServiceInfo class --------------------

    static PyObject* _new_ESimServiceInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimServiceInfo(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimServiceInfo_get_AuthenticationPreference(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimServiceInfo", L"AuthenticationPreference"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimServiceInfo_get_IsESimUiEnabled(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimServiceInfo", L"IsESimUiEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsESimUiEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimServiceInfo[] = {
        { "_assign_array_", _assign_array_ESimServiceInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimServiceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimServiceInfo[] = {
        { "authentication_preference", reinterpret_cast<getter>(ESimServiceInfo_get_AuthenticationPreference), nullptr, nullptr, nullptr },
        { "is_e_sim_ui_enabled", reinterpret_cast<getter>(ESimServiceInfo_get_IsESimUiEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimServiceInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimServiceInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimServiceInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimServiceInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimServiceInfo) },
        { },
    };

    static PyType_Spec type_spec_ESimServiceInfo =
    {
        "_winrt_windows_networking_networkoperators.ESimServiceInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimServiceInfo
    };

    // ----- ESimUpdatedEventArgs class --------------------

    static PyObject* _new_ESimUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimUpdatedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimUpdatedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimUpdatedEventArgs", L"ESim"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_ESimUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimUpdatedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimUpdatedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ESimUpdatedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.ESimUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimUpdatedEventArgs
    };

    // ----- ESimWatcher class --------------------

    static PyObject* _new_ESimWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ESimWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_ESimWatcher(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimWatcher_Start(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_Stop(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_get_Status(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Added(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Added(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Removed(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Removed(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Stopped(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Stopped(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Updated(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Updated(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.ESimWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ESimWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ESimWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(ESimWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(ESimWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(ESimWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(ESimWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(ESimWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(ESimWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(ESimWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(ESimWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_ESimWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimWatcher[] = {
        { "status", reinterpret_cast<getter>(ESimWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimWatcher) },
        { },
    };

    static PyType_Spec type_spec_ESimWatcher =
    {
        "_winrt_windows_networking_networkoperators.ESimWatcher",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimWatcher
    };

    // ----- FdnAccessManager class --------------------

    static PyObject* _new_FdnAccessManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::FdnAccessManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::FdnAccessManager>::type_name);
        return nullptr;
    }

    static PyObject* FdnAccessManager_RequestUnlockAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.FdnAccessManager", L"RequestUnlockAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::FdnAccessManager::RequestUnlockAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FdnAccessManager[] = {
        { "request_unlock_async", reinterpret_cast<PyCFunction>(FdnAccessManager_RequestUnlockAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FdnAccessManager[] = {
        { }
    };

    static PyType_Slot _type_slots_FdnAccessManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FdnAccessManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FdnAccessManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FdnAccessManager) },
        { },
    };

    static PyType_Spec type_spec_FdnAccessManager =
    {
        "_winrt_windows_networking_networkoperators.FdnAccessManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FdnAccessManager
    };

    // ----- HotspotAuthenticationContext class --------------------

    static PyObject* _new_HotspotAuthenticationContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>::type_name);
        return nullptr;
    }

    static void _dealloc_HotspotAuthenticationContext(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotAuthenticationContext_AbortAuthentication(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"AbortAuthentication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.AbortAuthentication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_IssueCredentials(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"IssueCredentials", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                self->obj.IssueCredentials(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_IssueCredentialsAsync(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"IssueCredentialsAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.IssueCredentialsAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_SkipAuthentication(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"SkipAuthentication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SkipAuthentication();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_TriggerAttentionRequired(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"TriggerAttentionRequired", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.TriggerAttentionRequired(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_TryGetAuthenticationContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"TryGetAuthenticationContext", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext param1 { nullptr };

                auto return_value = winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext::TryGetAuthenticationContext(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_AuthenticationUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"AuthenticationUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_NetworkAdapter(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"NetworkAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_RedirectMessageUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"RedirectMessageUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedirectMessageUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_RedirectMessageXml(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"RedirectMessageXml"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedirectMessageXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_WirelessNetworkId(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationContext", L"WirelessNetworkId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WirelessNetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HotspotAuthenticationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HotspotAuthenticationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotAuthenticationContext[] = {
        { "abort_authentication", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_AbortAuthentication), METH_VARARGS, nullptr },
        { "issue_credentials", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_IssueCredentials), METH_VARARGS, nullptr },
        { "issue_credentials_async", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_IssueCredentialsAsync), METH_VARARGS, nullptr },
        { "skip_authentication", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_SkipAuthentication), METH_VARARGS, nullptr },
        { "trigger_attention_required", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_TriggerAttentionRequired), METH_VARARGS, nullptr },
        { "try_get_authentication_context", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_TryGetAuthenticationContext), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_HotspotAuthenticationContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotAuthenticationContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotAuthenticationContext[] = {
        { "authentication_url", reinterpret_cast<getter>(HotspotAuthenticationContext_get_AuthenticationUrl), nullptr, nullptr, nullptr },
        { "network_adapter", reinterpret_cast<getter>(HotspotAuthenticationContext_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "redirect_message_url", reinterpret_cast<getter>(HotspotAuthenticationContext_get_RedirectMessageUrl), nullptr, nullptr, nullptr },
        { "redirect_message_xml", reinterpret_cast<getter>(HotspotAuthenticationContext_get_RedirectMessageXml), nullptr, nullptr, nullptr },
        { "wireless_network_id", reinterpret_cast<getter>(HotspotAuthenticationContext_get_WirelessNetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotAuthenticationContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HotspotAuthenticationContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HotspotAuthenticationContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HotspotAuthenticationContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HotspotAuthenticationContext) },
        { },
    };

    static PyType_Spec type_spec_HotspotAuthenticationContext =
    {
        "_winrt_windows_networking_networkoperators.HotspotAuthenticationContext",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotAuthenticationContext
    };

    // ----- HotspotAuthenticationEventDetails class --------------------

    static PyObject* _new_HotspotAuthenticationEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_HotspotAuthenticationEventDetails(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotAuthenticationEventDetails_get_EventToken(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotAuthenticationEventDetails", L"EventToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HotspotAuthenticationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HotspotAuthenticationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotAuthenticationEventDetails[] = {
        { "_assign_array_", _assign_array_HotspotAuthenticationEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotAuthenticationEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotAuthenticationEventDetails[] = {
        { "event_token", reinterpret_cast<getter>(HotspotAuthenticationEventDetails_get_EventToken), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotAuthenticationEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HotspotAuthenticationEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HotspotAuthenticationEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HotspotAuthenticationEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HotspotAuthenticationEventDetails) },
        { },
    };

    static PyType_Spec type_spec_HotspotAuthenticationEventDetails =
    {
        "_winrt_windows_networking_networkoperators.HotspotAuthenticationEventDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotAuthenticationEventDetails
    };

    // ----- HotspotCredentialsAuthenticationResult class --------------------

    static PyObject* _new_HotspotCredentialsAuthenticationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_HotspotCredentialsAuthenticationResult(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_AuthenticationReplyXml(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"AuthenticationReplyXml"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationReplyXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_HasNetworkErrorOccurred(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"HasNetworkErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNetworkErrorOccurred());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_LogoffUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"LogoffUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogoffUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_ResponseCode(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult", L"ResponseCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HotspotCredentialsAuthenticationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HotspotCredentialsAuthenticationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotCredentialsAuthenticationResult[] = {
        { "_assign_array_", _assign_array_HotspotCredentialsAuthenticationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotCredentialsAuthenticationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotCredentialsAuthenticationResult[] = {
        { "authentication_reply_xml", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_AuthenticationReplyXml), nullptr, nullptr, nullptr },
        { "has_network_error_occurred", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_HasNetworkErrorOccurred), nullptr, nullptr, nullptr },
        { "logoff_url", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_LogoffUrl), nullptr, nullptr, nullptr },
        { "response_code", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_ResponseCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotCredentialsAuthenticationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HotspotCredentialsAuthenticationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HotspotCredentialsAuthenticationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HotspotCredentialsAuthenticationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HotspotCredentialsAuthenticationResult) },
        { },
    };

    static PyType_Spec type_spec_HotspotCredentialsAuthenticationResult =
    {
        "_winrt_windows_networking_networkoperators.HotspotCredentialsAuthenticationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotCredentialsAuthenticationResult
    };

    // ----- KnownCSimFilePaths class --------------------

    static PyObject* _new_KnownCSimFilePaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths>::type_name);
        return nullptr;
    }

    static PyObject* KnownCSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownCSimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownCSimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownCSimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownCSimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownCSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownCSimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownCSimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownCSimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownCSimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownCSimFilePaths =
    {
        "_winrt_windows_networking_networkoperators.KnownCSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownCSimFilePaths
    };

    static PyGetSetDef getset_KnownCSimFilePaths_Meta[] = {
        { "e_f_spn", reinterpret_cast<getter>(KnownCSimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownCSimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownCSimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownCSimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownCSimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownCSimFilePaths_Meta =
    {
        "_winrt_windows_networking_networkoperators.KnownCSimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownCSimFilePaths_Meta
    };

    // ----- KnownRuimFilePaths class --------------------

    static PyObject* _new_KnownRuimFilePaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths>::type_name);
        return nullptr;
    }

    static PyObject* KnownRuimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownRuimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRuimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownRuimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRuimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownRuimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRuimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownRuimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRuimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRuimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRuimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRuimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownRuimFilePaths =
    {
        "_winrt_windows_networking_networkoperators.KnownRuimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRuimFilePaths
    };

    static PyGetSetDef getset_KnownRuimFilePaths_Meta[] = {
        { "e_f_spn", reinterpret_cast<getter>(KnownRuimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownRuimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownRuimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownRuimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRuimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownRuimFilePaths_Meta =
    {
        "_winrt_windows_networking_networkoperators.KnownRuimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRuimFilePaths_Meta
    };

    // ----- KnownSimFilePaths class --------------------

    static PyObject* _new_KnownSimFilePaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths>::type_name);
        return nullptr;
    }

    static PyObject* KnownSimFilePaths_get_EFOns(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"EFOns"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::EFOns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownSimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownSimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownSimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownSimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownSimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownSimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownSimFilePaths =
    {
        "_winrt_windows_networking_networkoperators.KnownSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownSimFilePaths
    };

    static PyGetSetDef getset_KnownSimFilePaths_Meta[] = {
        { "e_f_ons", reinterpret_cast<getter>(KnownSimFilePaths_get_EFOns), nullptr, nullptr, nullptr },
        { "e_f_spn", reinterpret_cast<getter>(KnownSimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownSimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownSimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownSimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownSimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownSimFilePaths_Meta =
    {
        "_winrt_windows_networking_networkoperators.KnownSimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownSimFilePaths_Meta
    };

    // ----- KnownUSimFilePaths class --------------------

    static PyObject* _new_KnownUSimFilePaths(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths>::type_name);
        return nullptr;
    }

    static PyObject* KnownUSimFilePaths_get_EFOpl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"EFOpl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFOpl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_EFPnn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"EFPnn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFPnn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"EFSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"Gid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.KnownUSimFilePaths", L"Gid2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownUSimFilePaths[] = {
        { }
    };

    static PyGetSetDef _getset_KnownUSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownUSimFilePaths[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownUSimFilePaths) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownUSimFilePaths) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownUSimFilePaths) },
        { },
    };

    static PyType_Spec type_spec_KnownUSimFilePaths =
    {
        "_winrt_windows_networking_networkoperators.KnownUSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownUSimFilePaths
    };

    static PyGetSetDef getset_KnownUSimFilePaths_Meta[] = {
        { "e_f_opl", reinterpret_cast<getter>(KnownUSimFilePaths_get_EFOpl), nullptr, nullptr, nullptr },
        { "e_f_pnn", reinterpret_cast<getter>(KnownUSimFilePaths_get_EFPnn), nullptr, nullptr, nullptr },
        { "e_f_spn", reinterpret_cast<getter>(KnownUSimFilePaths_get_EFSpn), nullptr, nullptr, nullptr },
        { "gid1", reinterpret_cast<getter>(KnownUSimFilePaths_get_Gid1), nullptr, nullptr, nullptr },
        { "gid2", reinterpret_cast<getter>(KnownUSimFilePaths_get_Gid2), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownUSimFilePaths_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownUSimFilePaths_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownUSimFilePaths_Meta =
    {
        "_winrt_windows_networking_networkoperators.KnownUSimFilePaths_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownUSimFilePaths_Meta
    };

    // ----- MobileBroadbandAccount class --------------------

    static PyObject* _new_MobileBroadbandAccount(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccount_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_GetConnectionProfiles(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"GetConnectionProfiles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_CurrentDeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"CurrentDeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentDeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_CurrentNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"CurrentNetwork"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_ServiceProviderGuid(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"ServiceProviderGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_ServiceProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"ServiceProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_AccountExperienceUrl(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"AccountExperienceUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountExperienceUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_AvailableNetworkAccountIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccount", L"AvailableNetworkAccountIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount::AvailableNetworkAccountIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccount[] = {
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_profiles", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_GetConnectionProfiles), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandAccount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccount[] = {
        { "current_device_information", reinterpret_cast<getter>(MobileBroadbandAccount_get_CurrentDeviceInformation), nullptr, nullptr, nullptr },
        { "current_network", reinterpret_cast<getter>(MobileBroadbandAccount_get_CurrentNetwork), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccount_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "service_provider_guid", reinterpret_cast<getter>(MobileBroadbandAccount_get_ServiceProviderGuid), nullptr, nullptr, nullptr },
        { "service_provider_name", reinterpret_cast<getter>(MobileBroadbandAccount_get_ServiceProviderName), nullptr, nullptr, nullptr },
        { "account_experience_url", reinterpret_cast<getter>(MobileBroadbandAccount_get_AccountExperienceUrl), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccount[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccount) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccount =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandAccount",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccount
    };

    static PyGetSetDef getset_MobileBroadbandAccount_Meta[] = {
        { "available_network_account_ids", reinterpret_cast<getter>(MobileBroadbandAccount_get_AvailableNetworkAccountIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MobileBroadbandAccount_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MobileBroadbandAccount_Meta) },
        { }
    };

    static PyType_Spec type_spec_MobileBroadbandAccount_Meta =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandAccount_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MobileBroadbandAccount_Meta
    };

    // ----- MobileBroadbandAccountEventArgs class --------------------

    static PyObject* _new_MobileBroadbandAccountEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccountEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountEventArgs_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccountEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccountEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandAccountEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountEventArgs[] = {
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccountEventArgs_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccountEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccountEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccountEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccountEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountEventArgs =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandAccountEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountEventArgs
    };

    // ----- MobileBroadbandAccountUpdatedEventArgs class --------------------

    static PyObject* _new_MobileBroadbandAccountUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccountUpdatedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_HasDeviceInformationChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs", L"HasDeviceInformationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasDeviceInformationChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_HasNetworkChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs", L"HasNetworkChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNetworkChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccountUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccountUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandAccountUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountUpdatedEventArgs[] = {
        { "has_device_information_changed", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_HasDeviceInformationChanged), nullptr, nullptr, nullptr },
        { "has_network_changed", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_HasNetworkChanged), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccountUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccountUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccountUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccountUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountUpdatedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandAccountUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountUpdatedEventArgs
    };

    // ----- MobileBroadbandAccountWatcher class --------------------

    static PyObject* _new_MobileBroadbandAccountWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandAccountWatcher(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountWatcher_Start(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_Stop(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountAdded(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>(arg);

            return py::convert(self->obj.AccountAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountAdded(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountRemoved(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>(arg);

            return py::convert(self->obj.AccountRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountRemoved(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountUpdated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>>(arg);

            return py::convert(self->obj.AccountUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountUpdated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"AccountUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_Stopped(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_Stopped(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAccountWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAccountWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_Stop), METH_VARARGS, nullptr },
        { "add_account_added", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountAdded), METH_O, nullptr },
        { "remove_account_added", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountAdded), METH_O, nullptr },
        { "add_account_removed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountRemoved), METH_O, nullptr },
        { "remove_account_removed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountRemoved), METH_O, nullptr },
        { "add_account_updated", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountUpdated), METH_O, nullptr },
        { "remove_account_updated", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountUpdated), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandAccountWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountWatcher[] = {
        { "status", reinterpret_cast<getter>(MobileBroadbandAccountWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAccountWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAccountWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAccountWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAccountWatcher) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountWatcher =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandAccountWatcher",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountWatcher
    };

    // ----- MobileBroadbandAntennaSar class --------------------

    static PyObject* _new_MobileBroadbandAntennaSar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandAntennaSar(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAntennaSar_get_AntennaIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAntennaSar", L"AntennaIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AntennaIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAntennaSar_get_SarBackoffIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandAntennaSar", L"SarBackoffIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SarBackoffIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandAntennaSar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandAntennaSar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAntennaSar[] = {
        { "_assign_array_", _assign_array_MobileBroadbandAntennaSar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAntennaSar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAntennaSar[] = {
        { "antenna_index", reinterpret_cast<getter>(MobileBroadbandAntennaSar_get_AntennaIndex), nullptr, nullptr, nullptr },
        { "sar_backoff_index", reinterpret_cast<getter>(MobileBroadbandAntennaSar_get_SarBackoffIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAntennaSar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandAntennaSar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandAntennaSar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandAntennaSar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandAntennaSar) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAntennaSar =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandAntennaSar",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAntennaSar
    };

    // ----- MobileBroadbandCellCdma class --------------------

    static PyObject* _new_MobileBroadbandCellCdma(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLastBroadcastGpsTime(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationLastBroadcastGpsTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationLastBroadcastGpsTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLatitude(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationLatitude"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationLatitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLongitude(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationLongitude"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationLongitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationPNCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"BaseStationPNCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationPNCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_NetworkId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"NetworkId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_PilotSignalStrengthInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"PilotSignalStrengthInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PilotSignalStrengthInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_SystemId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellCdma", L"SystemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellCdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellCdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellCdma[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellCdma, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellCdma), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellCdma[] = {
        { "base_station_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationId), nullptr, nullptr, nullptr },
        { "base_station_last_broadcast_gps_time", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLastBroadcastGpsTime), nullptr, nullptr, nullptr },
        { "base_station_latitude", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLatitude), nullptr, nullptr, nullptr },
        { "base_station_longitude", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLongitude), nullptr, nullptr, nullptr },
        { "base_station_p_n_code", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationPNCode), nullptr, nullptr, nullptr },
        { "network_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_NetworkId), nullptr, nullptr, nullptr },
        { "pilot_signal_strength_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_PilotSignalStrengthInDB), nullptr, nullptr, nullptr },
        { "system_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_SystemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellCdma[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellCdma) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellCdma) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellCdma) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellCdma) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellCdma =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellCdma",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellCdma
    };

    // ----- MobileBroadbandCellGsm class --------------------

    static PyObject* _new_MobileBroadbandCellGsm(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellGsm_get_BaseStationId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"BaseStationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseStationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"LocationAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ReceivedSignalStrengthInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"ReceivedSignalStrengthInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedSignalStrengthInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellGsm", L"TimingAdvanceInBitPeriods"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellGsm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellGsm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellGsm[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellGsm, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellGsm), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellGsm[] = {
        { "base_station_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_BaseStationId), nullptr, nullptr, nullptr },
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_strength_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ReceivedSignalStrengthInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellGsm[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellGsm) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellGsm) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellGsm) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellGsm) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellGsm =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellGsm",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellGsm
    };

    // ----- MobileBroadbandCellLte class --------------------

    static PyObject* _new_MobileBroadbandCellLte(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellLte_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_PhysicalCellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"PhysicalCellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalCellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ReferenceSignalReceivedPowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ReferenceSignalReceivedPowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedPowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ReferenceSignalReceivedQualityInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"ReferenceSignalReceivedQualityInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedQualityInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"TimingAdvanceInBitPeriods"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_TrackingAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellLte", L"TrackingAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackingAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellLte(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellLte(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellLte[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellLte, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellLte), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellLte[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "physical_cell_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_PhysicalCellId), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ProviderId), nullptr, nullptr, nullptr },
        { "reference_signal_received_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ReferenceSignalReceivedPowerInDBm), nullptr, nullptr, nullptr },
        { "reference_signal_received_quality_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ReferenceSignalReceivedQualityInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellLte_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { "tracking_area_code", reinterpret_cast<getter>(MobileBroadbandCellLte_get_TrackingAreaCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellLte[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellLte) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellLte) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellLte) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellLte) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellLte =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellLte",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellLte
    };

    // ----- MobileBroadbandCellNR class --------------------

    static PyObject* _new_MobileBroadbandCellNR(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellNR_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_PhysicalCellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"PhysicalCellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalCellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ReferenceSignalReceivedPowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ReferenceSignalReceivedPowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedPowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ReferenceSignalReceivedQualityInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"ReferenceSignalReceivedQualityInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedQualityInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_SignalToNoiseRatioInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"SignalToNoiseRatioInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalToNoiseRatioInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_TimingAdvanceInNanoseconds(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"TimingAdvanceInNanoseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInNanoseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_TrackingAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellNR", L"TrackingAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackingAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellNR(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellNR(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellNR[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellNR, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellNR), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellNR[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "physical_cell_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_PhysicalCellId), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ProviderId), nullptr, nullptr, nullptr },
        { "reference_signal_received_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ReferenceSignalReceivedPowerInDBm), nullptr, nullptr, nullptr },
        { "reference_signal_received_quality_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ReferenceSignalReceivedQualityInDBm), nullptr, nullptr, nullptr },
        { "signal_to_noise_ratio_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellNR_get_SignalToNoiseRatioInDB), nullptr, nullptr, nullptr },
        { "timing_advance_in_nanoseconds", reinterpret_cast<getter>(MobileBroadbandCellNR_get_TimingAdvanceInNanoseconds), nullptr, nullptr, nullptr },
        { "tracking_area_code", reinterpret_cast<getter>(MobileBroadbandCellNR_get_TrackingAreaCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellNR[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellNR) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellNR) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellNR) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellNR) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellNR =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellNR",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellNR
    };

    // ----- MobileBroadbandCellTdscdma class --------------------

    static PyObject* _new_MobileBroadbandCellTdscdma(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellTdscdma_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_CellParameterId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"CellParameterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellParameterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"LocationAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_PathLossInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"PathLossInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PathLossInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ReceivedSignalCodePowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"ReceivedSignalCodePowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedSignalCodePowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellTdscdma", L"TimingAdvanceInBitPeriods"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellTdscdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellTdscdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellTdscdma[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellTdscdma, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellTdscdma), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellTdscdma[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_CellId), nullptr, nullptr, nullptr },
        { "cell_parameter_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_CellParameterId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "path_loss_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_PathLossInDB), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_code_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ReceivedSignalCodePowerInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellTdscdma[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellTdscdma) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellTdscdma) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellTdscdma) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellTdscdma) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellTdscdma =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellTdscdma",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellTdscdma
    };

    // ----- MobileBroadbandCellUmts class --------------------

    static PyObject* _new_MobileBroadbandCellUmts(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellUmts_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"CellId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"ChannelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"LocationAreaCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_PathLossInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"PathLossInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PathLossInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_PrimaryScramblingCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"PrimaryScramblingCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryScramblingCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ReceivedSignalCodePowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"ReceivedSignalCodePowerInDBm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedSignalCodePowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_SignalToNoiseRatioInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellUmts", L"SignalToNoiseRatioInDB"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalToNoiseRatioInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellUmts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellUmts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellUmts[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellUmts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellUmts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellUmts[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "path_loss_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_PathLossInDB), nullptr, nullptr, nullptr },
        { "primary_scrambling_code", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_PrimaryScramblingCode), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_code_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ReceivedSignalCodePowerInDBm), nullptr, nullptr, nullptr },
        { "signal_to_noise_ratio_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_SignalToNoiseRatioInDB), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellUmts[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellUmts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellUmts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellUmts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellUmts) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellUmts =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellUmts",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellUmts
    };

    // ----- MobileBroadbandCellsInfo class --------------------

    static PyObject* _new_MobileBroadbandCellsInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellsInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsCdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsCdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsGsm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsGsm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsLte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsLte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsTdscdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsTdscdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsUmts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsUmts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsCdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsCdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsGsm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsGsm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsLte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsLte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsTdscdma"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsTdscdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsUmts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsUmts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"NeighboringCellsNR"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NeighboringCellsNR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCellsInfo", L"ServingCellsNR"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServingCellsNR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCellsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCellsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellsInfo[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCellsInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellsInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellsInfo[] = {
        { "neighboring_cells_cdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsCdma), nullptr, nullptr, nullptr },
        { "neighboring_cells_gsm", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsGsm), nullptr, nullptr, nullptr },
        { "neighboring_cells_lte", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsLte), nullptr, nullptr, nullptr },
        { "neighboring_cells_tdscdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsTdscdma), nullptr, nullptr, nullptr },
        { "neighboring_cells_umts", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsUmts), nullptr, nullptr, nullptr },
        { "serving_cells_cdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsCdma), nullptr, nullptr, nullptr },
        { "serving_cells_gsm", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsGsm), nullptr, nullptr, nullptr },
        { "serving_cells_lte", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsLte), nullptr, nullptr, nullptr },
        { "serving_cells_tdscdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsTdscdma), nullptr, nullptr, nullptr },
        { "serving_cells_umts", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsUmts), nullptr, nullptr, nullptr },
        { "neighboring_cells_n_r", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsNR), nullptr, nullptr, nullptr },
        { "serving_cells_n_r", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsNR), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellsInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCellsInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCellsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCellsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCellsInfo) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellsInfo =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCellsInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellsInfo
    };

    // ----- MobileBroadbandCurrentSlotIndexChangedEventArgs class --------------------

    static PyObject* _new_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCurrentSlotIndexChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCurrentSlotIndexChangedEventArgs_get_CurrentSlotIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandCurrentSlotIndexChangedEventArgs", L"CurrentSlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandCurrentSlotIndexChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCurrentSlotIndexChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = {
        { "current_slot_index", reinterpret_cast<getter>(MobileBroadbandCurrentSlotIndexChangedEventArgs_get_CurrentSlotIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandCurrentSlotIndexChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandCurrentSlotIndexChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCurrentSlotIndexChangedEventArgs
    };

    // ----- MobileBroadbandDeviceInformation class --------------------

    static PyObject* _new_MobileBroadbandDeviceInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CellularClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"CellularClass"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CurrentRadioState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"CurrentRadioState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentRadioState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CustomDataClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"CustomDataClass"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomDataClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DataClasses(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"DataClasses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataClasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DeviceType(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"DeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_FirmwareInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"FirmwareInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Manufacturer(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"Manufacturer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Manufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_MobileEquipmentId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"MobileEquipmentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MobileEquipmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Model(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"Model"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_NetworkDeviceStatus(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"NetworkDeviceStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkDeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimIccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimIccId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SubscriberId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SubscriberId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscriberId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_TelephoneNumbers(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"TelephoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TelephoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_PinManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"PinManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Revision(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"Revision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SerialNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SerialNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimGid1(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimGid1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimGid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimPnn(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimPnn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimPnn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimSpn(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SimSpn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SlotManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation", L"SlotManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceInformation[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceInformation[] = {
        { "cellular_class", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CellularClass), nullptr, nullptr, nullptr },
        { "current_radio_state", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CurrentRadioState), nullptr, nullptr, nullptr },
        { "custom_data_class", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CustomDataClass), nullptr, nullptr, nullptr },
        { "data_classes", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DataClasses), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_type", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DeviceType), nullptr, nullptr, nullptr },
        { "firmware_information", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_FirmwareInformation), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Manufacturer), nullptr, nullptr, nullptr },
        { "mobile_equipment_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_MobileEquipmentId), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Model), nullptr, nullptr, nullptr },
        { "network_device_status", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_NetworkDeviceStatus), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimIccId), nullptr, nullptr, nullptr },
        { "subscriber_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SubscriberId), nullptr, nullptr, nullptr },
        { "telephone_numbers", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_TelephoneNumbers), nullptr, nullptr, nullptr },
        { "pin_manager", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_PinManager), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Revision), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SerialNumber), nullptr, nullptr, nullptr },
        { "sim_gid1", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimGid1), nullptr, nullptr, nullptr },
        { "sim_pnn", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimPnn), nullptr, nullptr, nullptr },
        { "sim_spn", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimSpn), nullptr, nullptr, nullptr },
        { "slot_manager", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SlotManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceInformation) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceInformation =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceInformation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceInformation
    };

    // ----- MobileBroadbandDeviceService class --------------------

    static PyObject* _new_MobileBroadbandDeviceService(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceService(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceService_OpenCommandSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"OpenCommandSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenCommandSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_OpenDataSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"OpenDataSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenDataSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"DeviceServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_get_SupportedCommands(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceService", L"SupportedCommands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceService[] = {
        { "open_command_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceService_OpenCommandSession), METH_VARARGS, nullptr },
        { "open_data_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceService_OpenDataSession), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandDeviceService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceService[] = {
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceService_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "supported_commands", reinterpret_cast<getter>(MobileBroadbandDeviceService_get_SupportedCommands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceService[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceService) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceService =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceService",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceService
    };

    // ----- MobileBroadbandDeviceServiceCommandResult class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceCommandResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceCommandResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceCommandResult_get_ResponseData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult", L"ResponseData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandResult_get_StatusCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult", L"StatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceCommandResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceCommandResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceCommandResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceCommandResult[] = {
        { "response_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceCommandResult_get_ResponseData), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(MobileBroadbandDeviceServiceCommandResult_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceCommandResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceCommandResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceCommandResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceCommandResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceCommandResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceCommandResult =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceServiceCommandResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceCommandResult
    };

    // ----- MobileBroadbandDeviceServiceCommandSession class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceCommandSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceCommandSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_CloseSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession", L"CloseSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CloseSession();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_SendQueryCommandAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession", L"SendQueryCommandAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendQueryCommandAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_SendSetCommandAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession", L"SendSetCommandAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendSetCommandAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceCommandSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceCommandSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceCommandSession[] = {
        { "close_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_CloseSession), METH_VARARGS, nullptr },
        { "send_query_command_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_SendQueryCommandAsync), METH_VARARGS, nullptr },
        { "send_set_command_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_SendSetCommandAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceCommandSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceCommandSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceCommandSession[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceCommandSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceCommandSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceCommandSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceCommandSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceCommandSession) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceCommandSession =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceServiceCommandSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceCommandSession
    };

    // ----- MobileBroadbandDeviceServiceDataReceivedEventArgs class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceDataReceivedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceDataReceivedEventArgs_get_ReceivedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs", L"ReceivedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = {
        { "received_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceDataReceivedEventArgs_get_ReceivedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceDataReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceServiceDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceDataReceivedEventArgs
    };

    // ----- MobileBroadbandDeviceServiceDataSession class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceDataSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceDataSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_CloseSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"CloseSession", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CloseSession();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_WriteDataAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"WriteDataAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_add_DataReceived(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession, winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_remove_DataReceived(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceDataSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceDataSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceDataSession[] = {
        { "close_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_CloseSession), METH_VARARGS, nullptr },
        { "write_data_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_WriteDataAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_remove_DataReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceDataSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceDataSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceDataSession[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceDataSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceDataSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceDataSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceDataSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceDataSession) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceDataSession =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceServiceDataSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceDataSession
    };

    // ----- MobileBroadbandDeviceServiceInformation class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation", L"DeviceServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_IsDataReadSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation", L"IsDataReadSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDataReadSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_IsDataWriteSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation", L"IsDataWriteSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDataWriteSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceInformation[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceInformation[] = {
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "is_data_read_supported", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_IsDataReadSupported), nullptr, nullptr, nullptr },
        { "is_data_write_supported", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_IsDataWriteSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceInformation) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceInformation =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceServiceInformation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceInformation
    };

    // ----- MobileBroadbandDeviceServiceTriggerDetails class --------------------

    static PyObject* _new_MobileBroadbandDeviceServiceTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"DeviceServiceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_ReceivedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"ReceivedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReceivedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_EventId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails", L"EventId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandDeviceServiceTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandDeviceServiceTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "received_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_ReceivedData), nullptr, nullptr, nullptr },
        { "event_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_EventId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandDeviceServiceTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandDeviceServiceTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandDeviceServiceTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandDeviceServiceTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandDeviceServiceTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceTriggerDetails
    };

    // ----- MobileBroadbandModem class --------------------

    static PyObject* _new_MobileBroadbandModem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandModem(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModem_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetCurrentConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetCurrentConfigurationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDeviceService(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetDeviceService", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetDeviceService(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetIsPassthroughEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetIsPassthroughEnabled", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetIsPassthroughEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetIsPassthroughEnabledAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetIsPassthroughEnabledAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsPassthroughEnabledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"GetIsPassthroughEnabledAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetIsPassthroughEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_ResetAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"ResetAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_SetIsPassthroughEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"SetIsPassthroughEnabled", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.SetIsPassthroughEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_SetIsPassthroughEnabledAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"SetIsPassthroughEnabledAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetIsPassthroughEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"SetIsPassthroughEnabledAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.SetIsPassthroughEnabledAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_TryGetPcoAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"TryGetPcoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetPcoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_CurrentAccount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"CurrentAccount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentAccount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_CurrentNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"CurrentNetwork"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_DeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_DeviceServices(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"DeviceServices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_IsResetSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsResetSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsResetSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_MaxDeviceServiceCommandSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"MaxDeviceServiceCommandSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDeviceServiceCommandSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_MaxDeviceServiceDataSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"MaxDeviceServiceDataSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxDeviceServiceDataSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_IsInEmergencyCallMode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsInEmergencyCallMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInEmergencyCallMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_add_IsInEmergencyCallModeChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsInEmergencyCallModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsInEmergencyCallModeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_remove_IsInEmergencyCallModeChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModem", L"IsInEmergencyCallModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsInEmergencyCallModeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandModem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandModem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModem[] = {
        { "from_id", reinterpret_cast<PyCFunction>(MobileBroadbandModem_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetCurrentConfigurationAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_service", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDeviceService), METH_VARARGS, nullptr },
        { "get_is_passthrough_enabled", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetIsPassthroughEnabled), METH_VARARGS, nullptr },
        { "get_is_passthrough_enabled_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetIsPassthroughEnabledAsync), METH_VARARGS, nullptr },
        { "reset_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_ResetAsync), METH_VARARGS, nullptr },
        { "set_is_passthrough_enabled", reinterpret_cast<PyCFunction>(MobileBroadbandModem_SetIsPassthroughEnabled), METH_VARARGS, nullptr },
        { "set_is_passthrough_enabled_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_SetIsPassthroughEnabledAsync), METH_VARARGS, nullptr },
        { "try_get_pco_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_TryGetPcoAsync), METH_VARARGS, nullptr },
        { "add_is_in_emergency_call_mode_changed", reinterpret_cast<PyCFunction>(MobileBroadbandModem_add_IsInEmergencyCallModeChanged), METH_O, nullptr },
        { "remove_is_in_emergency_call_mode_changed", reinterpret_cast<PyCFunction>(MobileBroadbandModem_remove_IsInEmergencyCallModeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandModem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModem[] = {
        { "current_account", reinterpret_cast<getter>(MobileBroadbandModem_get_CurrentAccount), nullptr, nullptr, nullptr },
        { "current_network", reinterpret_cast<getter>(MobileBroadbandModem_get_CurrentNetwork), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(MobileBroadbandModem_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_services", reinterpret_cast<getter>(MobileBroadbandModem_get_DeviceServices), nullptr, nullptr, nullptr },
        { "is_reset_supported", reinterpret_cast<getter>(MobileBroadbandModem_get_IsResetSupported), nullptr, nullptr, nullptr },
        { "max_device_service_command_size_in_bytes", reinterpret_cast<getter>(MobileBroadbandModem_get_MaxDeviceServiceCommandSizeInBytes), nullptr, nullptr, nullptr },
        { "max_device_service_data_size_in_bytes", reinterpret_cast<getter>(MobileBroadbandModem_get_MaxDeviceServiceDataSizeInBytes), nullptr, nullptr, nullptr },
        { "is_in_emergency_call_mode", reinterpret_cast<getter>(MobileBroadbandModem_get_IsInEmergencyCallMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandModem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandModem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandModem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandModem) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModem =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandModem",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModem
    };

    // ----- MobileBroadbandModemConfiguration class --------------------

    static PyObject* _new_MobileBroadbandModemConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandModemConfiguration(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModemConfiguration_get_HomeProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"HomeProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_HomeProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"HomeProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HomeProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_Uicc(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"Uicc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uicc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_SarManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration", L"SarManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SarManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandModemConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandModemConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModemConfiguration[] = {
        { "_assign_array_", _assign_array_MobileBroadbandModemConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModemConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModemConfiguration[] = {
        { "home_provider_id", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_HomeProviderId), nullptr, nullptr, nullptr },
        { "home_provider_name", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_HomeProviderName), nullptr, nullptr, nullptr },
        { "uicc", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_Uicc), nullptr, nullptr, nullptr },
        { "sar_manager", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_SarManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModemConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandModemConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandModemConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandModemConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandModemConfiguration) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModemConfiguration =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandModemConfiguration",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModemConfiguration
    };

    // ----- MobileBroadbandModemIsolation class --------------------

    static PyObject* _new_MobileBroadbandModemIsolation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandModemIsolation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModemIsolation_AddAllowedHost(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"AddAllowedHost", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.AddAllowedHost(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_AddAllowedHostRange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"AddAllowedHostRange", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                self->obj.AddAllowedHostRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_ApplyConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"ApplyConfigurationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ApplyConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_ClearConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandModemIsolation", L"ClearConfigurationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandModemIsolation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandModemIsolation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModemIsolation[] = {
        { "add_allowed_host", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_AddAllowedHost), METH_VARARGS, nullptr },
        { "add_allowed_host_range", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_AddAllowedHostRange), METH_VARARGS, nullptr },
        { "apply_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_ApplyConfigurationAsync), METH_VARARGS, nullptr },
        { "clear_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_ClearConfigurationAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandModemIsolation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModemIsolation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModemIsolation[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModemIsolation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandModemIsolation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandModemIsolation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandModemIsolation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandModemIsolation) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModemIsolation =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandModemIsolation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModemIsolation
    };

    // ----- MobileBroadbandNetwork class --------------------

    static PyObject* _new_MobileBroadbandNetwork(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetwork_GetCellsInfoAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"GetCellsInfoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCellsInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_GetVoiceCallSupportAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"GetVoiceCallSupportAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVoiceCallSupportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_ShowConnectionUI(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"ShowConnectionUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowConnectionUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_AccessPointName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"AccessPointName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_ActivationNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"ActivationNetworkError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivationNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_NetworkAdapter(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"NetworkAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_NetworkRegistrationState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"NetworkRegistrationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_PacketAttachNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"PacketAttachNetworkError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PacketAttachNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredDataClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegisteredDataClass"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegisteredDataClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegisteredProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegisteredProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegisteredProviderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegisteredProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegistrationNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegistrationNetworkError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegistrationUiccApps(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetwork", L"RegistrationUiccApps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationUiccApps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandNetwork(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandNetwork(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetwork[] = {
        { "get_cells_info_async", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_GetCellsInfoAsync), METH_VARARGS, nullptr },
        { "get_voice_call_support_async", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_GetVoiceCallSupportAsync), METH_VARARGS, nullptr },
        { "show_connection_u_i", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_ShowConnectionUI), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandNetwork, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetwork), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetwork[] = {
        { "access_point_name", reinterpret_cast<getter>(MobileBroadbandNetwork_get_AccessPointName), nullptr, nullptr, nullptr },
        { "activation_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_ActivationNetworkError), nullptr, nullptr, nullptr },
        { "network_adapter", reinterpret_cast<getter>(MobileBroadbandNetwork_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "network_registration_state", reinterpret_cast<getter>(MobileBroadbandNetwork_get_NetworkRegistrationState), nullptr, nullptr, nullptr },
        { "packet_attach_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_PacketAttachNetworkError), nullptr, nullptr, nullptr },
        { "registered_data_class", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredDataClass), nullptr, nullptr, nullptr },
        { "registered_provider_id", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredProviderId), nullptr, nullptr, nullptr },
        { "registered_provider_name", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredProviderName), nullptr, nullptr, nullptr },
        { "registration_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegistrationNetworkError), nullptr, nullptr, nullptr },
        { "registration_uicc_apps", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegistrationUiccApps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetwork[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandNetwork) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandNetwork) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandNetwork) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandNetwork) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetwork =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandNetwork",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetwork
    };

    // ----- MobileBroadbandNetworkRegistrationStateChange class --------------------

    static PyObject* _new_MobileBroadbandNetworkRegistrationStateChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetworkRegistrationStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChange_get_Network(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange", L"Network"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Network());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandNetworkRegistrationStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandNetworkRegistrationStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetworkRegistrationStateChange[] = {
        { "_assign_array_", _assign_array_MobileBroadbandNetworkRegistrationStateChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetworkRegistrationStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetworkRegistrationStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "network", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChange_get_Network), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetworkRegistrationStateChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandNetworkRegistrationStateChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandNetworkRegistrationStateChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandNetworkRegistrationStateChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandNetworkRegistrationStateChange) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetworkRegistrationStateChange =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandNetworkRegistrationStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetworkRegistrationStateChange
    };

    // ----- MobileBroadbandNetworkRegistrationStateChangeTriggerDetails class --------------------

    static PyObject* _new_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChangeTriggerDetails_get_NetworkRegistrationStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails", L"NetworkRegistrationStateChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkRegistrationStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = {
        { "network_registration_state_changes", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChangeTriggerDetails_get_NetworkRegistrationStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails
    };

    // ----- MobileBroadbandPco class --------------------

    static PyObject* _new_MobileBroadbandPco(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPco(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPco_get_Data(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPco", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPco_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPco", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPco_get_IsComplete(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPco", L"IsComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPco(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPco(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPco[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPco, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPco), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPco[] = {
        { "data", reinterpret_cast<getter>(MobileBroadbandPco_get_Data), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MobileBroadbandPco_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(MobileBroadbandPco_get_IsComplete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPco[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPco) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPco) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPco) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPco) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPco =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPco",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPco
    };

    // ----- MobileBroadbandPcoDataChangeTriggerDetails class --------------------

    static PyObject* _new_MobileBroadbandPcoDataChangeTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPcoDataChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPcoDataChangeTriggerDetails_get_UpdatedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPcoDataChangeTriggerDetails", L"UpdatedData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdatedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPcoDataChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPcoDataChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPcoDataChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPcoDataChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPcoDataChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPcoDataChangeTriggerDetails[] = {
        { "updated_data", reinterpret_cast<getter>(MobileBroadbandPcoDataChangeTriggerDetails_get_UpdatedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPcoDataChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPcoDataChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPcoDataChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPcoDataChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPcoDataChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPcoDataChangeTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPcoDataChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPcoDataChangeTriggerDetails
    };

    // ----- MobileBroadbandPin class --------------------

    static PyObject* _new_MobileBroadbandPin(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPin(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPin_ChangeAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"ChangeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ChangeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_DisableAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"DisableAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DisableAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_EnableAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"EnableAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.EnableAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_EnterAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"EnterAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.EnterAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_UnblockAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"UnblockAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UnblockAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_AttemptsRemaining(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"AttemptsRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttemptsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Enabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Format(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_LockState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"LockState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LockState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_MaxLength(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"MaxLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_MinLength(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"MinLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Type(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPin", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPin(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPin(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPin[] = {
        { "change_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_ChangeAsync), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_EnableAsync), METH_VARARGS, nullptr },
        { "enter_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_EnterAsync), METH_VARARGS, nullptr },
        { "unblock_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_UnblockAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandPin, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPin), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPin[] = {
        { "attempts_remaining", reinterpret_cast<getter>(MobileBroadbandPin_get_AttemptsRemaining), nullptr, nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(MobileBroadbandPin_get_Enabled), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(MobileBroadbandPin_get_Format), nullptr, nullptr, nullptr },
        { "lock_state", reinterpret_cast<getter>(MobileBroadbandPin_get_LockState), nullptr, nullptr, nullptr },
        { "max_length", reinterpret_cast<getter>(MobileBroadbandPin_get_MaxLength), nullptr, nullptr, nullptr },
        { "min_length", reinterpret_cast<getter>(MobileBroadbandPin_get_MinLength), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MobileBroadbandPin_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPin[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPin) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPin) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPin) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPin) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPin =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPin",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPin
    };

    // ----- MobileBroadbandPinLockStateChange class --------------------

    static PyObject* _new_MobileBroadbandPinLockStateChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinLockStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_PinLockState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange", L"PinLockState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinLockState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_PinType(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange", L"PinType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinLockStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChange[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinLockStateChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "pin_lock_state", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_PinLockState), nullptr, nullptr, nullptr },
        { "pin_type", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_PinType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinLockStateChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinLockStateChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinLockStateChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinLockStateChange) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChange =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPinLockStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChange
    };

    // ----- MobileBroadbandPinLockStateChangeTriggerDetails class --------------------

    static PyObject* _new_MobileBroadbandPinLockStateChangeTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinLockStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinLockStateChangeTriggerDetails_get_PinLockStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChangeTriggerDetails", L"PinLockStateChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PinLockStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinLockStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinLockStateChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChangeTriggerDetails[] = {
        { "pin_lock_state_changes", reinterpret_cast<getter>(MobileBroadbandPinLockStateChangeTriggerDetails_get_PinLockStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinLockStateChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChangeTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPinLockStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChangeTriggerDetails
    };

    // ----- MobileBroadbandPinManager class --------------------

    static PyObject* _new_MobileBroadbandPinManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinManager_GetPin(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinManager", L"GetPin", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType>(args, 0);

                return py::convert(self->obj.GetPin(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinManager_get_SupportedPins(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinManager", L"SupportedPins"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPins());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinManager[] = {
        { "get_pin", reinterpret_cast<PyCFunction>(MobileBroadbandPinManager_GetPin), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandPinManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinManager[] = {
        { "supported_pins", reinterpret_cast<getter>(MobileBroadbandPinManager_get_SupportedPins), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinManager) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinManager =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPinManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinManager
    };

    // ----- MobileBroadbandPinOperationResult class --------------------

    static PyObject* _new_MobileBroadbandPinOperationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinOperationResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinOperationResult_get_AttemptsRemaining(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult", L"AttemptsRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttemptsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinOperationResult_get_IsSuccessful(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult", L"IsSuccessful"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuccessful());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandPinOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandPinOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinOperationResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandPinOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinOperationResult[] = {
        { "attempts_remaining", reinterpret_cast<getter>(MobileBroadbandPinOperationResult_get_AttemptsRemaining), nullptr, nullptr, nullptr },
        { "is_successful", reinterpret_cast<getter>(MobileBroadbandPinOperationResult_get_IsSuccessful), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandPinOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandPinOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandPinOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandPinOperationResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinOperationResult =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandPinOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinOperationResult
    };

    // ----- MobileBroadbandRadioStateChange class --------------------

    static PyObject* _new_MobileBroadbandRadioStateChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandRadioStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandRadioStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandRadioStateChange_get_RadioState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange", L"RadioState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadioState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandRadioStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRadioStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChange[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRadioStateChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandRadioStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "radio_state", reinterpret_cast<getter>(MobileBroadbandRadioStateChange_get_RadioState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRadioStateChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRadioStateChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRadioStateChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRadioStateChange) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChange =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandRadioStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChange
    };

    // ----- MobileBroadbandRadioStateChangeTriggerDetails class --------------------

    static PyObject* _new_MobileBroadbandRadioStateChangeTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandRadioStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandRadioStateChangeTriggerDetails_get_RadioStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChangeTriggerDetails", L"RadioStateChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadioStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandRadioStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandRadioStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_MobileBroadbandRadioStateChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChangeTriggerDetails[] = {
        { "radio_state_changes", reinterpret_cast<getter>(MobileBroadbandRadioStateChangeTriggerDetails_get_RadioStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandRadioStateChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandRadioStateChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandRadioStateChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandRadioStateChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChangeTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandRadioStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChangeTriggerDetails
    };

    // ----- MobileBroadbandSarManager class --------------------

    static PyObject* _new_MobileBroadbandSarManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSarManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSarManager_DisableBackoffAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"DisableBackoffAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DisableBackoffAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_EnableBackoffAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"EnableBackoffAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EnableBackoffAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_GetIsTransmittingAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"GetIsTransmittingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsTransmittingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_RevertSarToHardwareControlAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"RevertSarToHardwareControlAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RevertSarToHardwareControlAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_SetConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"SetConfigurationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>>(args, 0);

                return py::convert(self->obj.SetConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_SetTransmissionStateChangedHysteresisAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"SetTransmissionStateChangedHysteresisAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.SetTransmissionStateChangedHysteresisAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_StartTransmissionStateMonitoring(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"StartTransmissionStateMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartTransmissionStateMonitoring();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_StopTransmissionStateMonitoring(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"StopTransmissionStateMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopTransmissionStateMonitoring();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_Antennas(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"Antennas"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Antennas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_HysteresisTimerPeriod(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"HysteresisTimerPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HysteresisTimerPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsBackoffEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"IsBackoffEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBackoffEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsSarControlledByHardware(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"IsSarControlledByHardware"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSarControlledByHardware());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsWiFiHardwareIntegrated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"IsWiFiHardwareIntegrated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWiFiHardwareIntegrated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_add_TransmissionStateChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"TransmissionStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.TransmissionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_remove_TransmissionStateChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSarManager", L"TransmissionStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransmissionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSarManager[] = {
        { "disable_backoff_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_DisableBackoffAsync), METH_VARARGS, nullptr },
        { "enable_backoff_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_EnableBackoffAsync), METH_VARARGS, nullptr },
        { "get_is_transmitting_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_GetIsTransmittingAsync), METH_VARARGS, nullptr },
        { "revert_sar_to_hardware_control_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_RevertSarToHardwareControlAsync), METH_VARARGS, nullptr },
        { "set_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_SetConfigurationAsync), METH_VARARGS, nullptr },
        { "set_transmission_state_changed_hysteresis_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_SetTransmissionStateChangedHysteresisAsync), METH_VARARGS, nullptr },
        { "start_transmission_state_monitoring", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_StartTransmissionStateMonitoring), METH_VARARGS, nullptr },
        { "stop_transmission_state_monitoring", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_StopTransmissionStateMonitoring), METH_VARARGS, nullptr },
        { "add_transmission_state_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_add_TransmissionStateChanged), METH_O, nullptr },
        { "remove_transmission_state_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_remove_TransmissionStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandSarManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSarManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSarManager[] = {
        { "antennas", reinterpret_cast<getter>(MobileBroadbandSarManager_get_Antennas), nullptr, nullptr, nullptr },
        { "hysteresis_timer_period", reinterpret_cast<getter>(MobileBroadbandSarManager_get_HysteresisTimerPeriod), nullptr, nullptr, nullptr },
        { "is_backoff_enabled", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsBackoffEnabled), nullptr, nullptr, nullptr },
        { "is_sar_controlled_by_hardware", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsSarControlledByHardware), nullptr, nullptr, nullptr },
        { "is_wi_fi_hardware_integrated", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsWiFiHardwareIntegrated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSarManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSarManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSarManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSarManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSarManager) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSarManager =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandSarManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSarManager
    };

    // ----- MobileBroadbandSlotInfo class --------------------

    static PyObject* _new_MobileBroadbandSlotInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotInfo_get_Index(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfo", L"Index"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotInfo_get_State(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfo", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotInfo_get_IccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfo", L"IccId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSlotInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSlotInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotInfo[] = {
        { "_assign_array_", _assign_array_MobileBroadbandSlotInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotInfo[] = {
        { "index", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_Index), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_State), nullptr, nullptr, nullptr },
        { "icc_id", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_IccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSlotInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSlotInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSlotInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSlotInfo) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotInfo =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandSlotInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotInfo
    };

    // ----- MobileBroadbandSlotInfoChangedEventArgs class --------------------

    static PyObject* _new_MobileBroadbandSlotInfoChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotInfoChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotInfoChangedEventArgs_get_SlotInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotInfoChangedEventArgs", L"SlotInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSlotInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSlotInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotInfoChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandSlotInfoChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotInfoChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotInfoChangedEventArgs[] = {
        { "slot_info", reinterpret_cast<getter>(MobileBroadbandSlotInfoChangedEventArgs_get_SlotInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotInfoChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSlotInfoChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSlotInfoChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSlotInfoChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSlotInfoChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotInfoChangedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandSlotInfoChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotInfoChangedEventArgs
    };

    // ----- MobileBroadbandSlotManager class --------------------

    static PyObject* _new_MobileBroadbandSlotManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotManager_SetCurrentSlot(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SetCurrentSlot", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetCurrentSlot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_SetCurrentSlotAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SetCurrentSlotAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetCurrentSlotAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_get_CurrentSlotIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"CurrentSlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_get_SlotInfos(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SlotInfos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SlotInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_add_CurrentSlotIndexChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"CurrentSlotIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>>(arg);

            return py::convert(self->obj.CurrentSlotIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_remove_CurrentSlotIndexChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"CurrentSlotIndexChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentSlotIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_add_SlotInfoChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SlotInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>>(arg);

            return py::convert(self->obj.SlotInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_remove_SlotInfoChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandSlotManager", L"SlotInfoChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SlotInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandSlotManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandSlotManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotManager[] = {
        { "set_current_slot", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_SetCurrentSlot), METH_VARARGS, nullptr },
        { "set_current_slot_async", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_SetCurrentSlotAsync), METH_VARARGS, nullptr },
        { "add_current_slot_index_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_add_CurrentSlotIndexChanged), METH_O, nullptr },
        { "remove_current_slot_index_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_remove_CurrentSlotIndexChanged), METH_O, nullptr },
        { "add_slot_info_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_add_SlotInfoChanged), METH_O, nullptr },
        { "remove_slot_info_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_remove_SlotInfoChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandSlotManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotManager[] = {
        { "current_slot_index", reinterpret_cast<getter>(MobileBroadbandSlotManager_get_CurrentSlotIndex), nullptr, nullptr, nullptr },
        { "slot_infos", reinterpret_cast<getter>(MobileBroadbandSlotManager_get_SlotInfos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandSlotManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandSlotManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandSlotManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandSlotManager) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotManager =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandSlotManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotManager
    };

    // ----- MobileBroadbandTransmissionStateChangedEventArgs class --------------------

    static PyObject* _new_MobileBroadbandTransmissionStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandTransmissionStateChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandTransmissionStateChangedEventArgs_get_IsTransmitting(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandTransmissionStateChangedEventArgs", L"IsTransmitting"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmitting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandTransmissionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandTransmissionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandTransmissionStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MobileBroadbandTransmissionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandTransmissionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandTransmissionStateChangedEventArgs[] = {
        { "is_transmitting", reinterpret_cast<getter>(MobileBroadbandTransmissionStateChangedEventArgs_get_IsTransmitting), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandTransmissionStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandTransmissionStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandTransmissionStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandTransmissionStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandTransmissionStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandTransmissionStateChangedEventArgs =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandTransmissionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandTransmissionStateChangedEventArgs
    };

    // ----- MobileBroadbandUicc class --------------------

    static PyObject* _new_MobileBroadbandUicc(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUicc(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUicc_GetUiccAppsAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUicc", L"GetUiccAppsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUiccAppsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUicc_get_SimIccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUicc", L"SimIccId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUicc(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUicc(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUicc[] = {
        { "get_uicc_apps_async", reinterpret_cast<PyCFunction>(MobileBroadbandUicc_GetUiccAppsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandUicc, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUicc), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUicc[] = {
        { "sim_icc_id", reinterpret_cast<getter>(MobileBroadbandUicc_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUicc[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUicc) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUicc) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUicc) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUicc) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUicc =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandUicc",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUicc
    };

    // ----- MobileBroadbandUiccApp class --------------------

    static PyObject* _new_MobileBroadbandUiccApp(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccApp(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccApp_GetRecordDetailsAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"GetRecordDetailsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.GetRecordDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_ReadRecordAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"ReadRecordAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.ReadRecordAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_get_Id(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccApp", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccApp[] = {
        { "get_record_details_async", reinterpret_cast<PyCFunction>(MobileBroadbandUiccApp_GetRecordDetailsAsync), METH_VARARGS, nullptr },
        { "read_record_async", reinterpret_cast<PyCFunction>(MobileBroadbandUiccApp_ReadRecordAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MobileBroadbandUiccApp, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccApp), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccApp[] = {
        { "id", reinterpret_cast<getter>(MobileBroadbandUiccApp_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(MobileBroadbandUiccApp_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccApp[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccApp) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccApp) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccApp) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccApp) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccApp =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandUiccApp",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccApp
    };

    // ----- MobileBroadbandUiccAppReadRecordResult class --------------------

    static PyObject* _new_MobileBroadbandUiccAppReadRecordResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppReadRecordResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppReadRecordResult_get_Data(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppReadRecordResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccAppReadRecordResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccAppReadRecordResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppReadRecordResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandUiccAppReadRecordResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppReadRecordResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppReadRecordResult[] = {
        { "data", reinterpret_cast<getter>(MobileBroadbandUiccAppReadRecordResult_get_Data), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppReadRecordResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppReadRecordResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccAppReadRecordResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccAppReadRecordResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccAppReadRecordResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccAppReadRecordResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppReadRecordResult =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandUiccAppReadRecordResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppReadRecordResult
    };

    // ----- MobileBroadbandUiccAppRecordDetailsResult class --------------------

    static PyObject* _new_MobileBroadbandUiccAppRecordDetailsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppRecordDetailsResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_ReadAccessCondition(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"ReadAccessCondition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadAccessCondition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_RecordCount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"RecordCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_RecordSize(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"RecordSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecordSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_WriteAccessCondition(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult", L"WriteAccessCondition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteAccessCondition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccAppRecordDetailsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccAppRecordDetailsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppRecordDetailsResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandUiccAppRecordDetailsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppRecordDetailsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppRecordDetailsResult[] = {
        { "kind", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_Kind), nullptr, nullptr, nullptr },
        { "read_access_condition", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_ReadAccessCondition), nullptr, nullptr, nullptr },
        { "record_count", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_RecordCount), nullptr, nullptr, nullptr },
        { "record_size", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_RecordSize), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_Status), nullptr, nullptr, nullptr },
        { "write_access_condition", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_WriteAccessCondition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppRecordDetailsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccAppRecordDetailsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccAppRecordDetailsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccAppRecordDetailsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccAppRecordDetailsResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppRecordDetailsResult =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandUiccAppRecordDetailsResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppRecordDetailsResult
    };

    // ----- MobileBroadbandUiccAppsResult class --------------------

    static PyObject* _new_MobileBroadbandUiccAppsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppsResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppsResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppsResult_get_UiccApps(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult", L"UiccApps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UiccApps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MobileBroadbandUiccAppsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MobileBroadbandUiccAppsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppsResult[] = {
        { "_assign_array_", _assign_array_MobileBroadbandUiccAppsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppsResult[] = {
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppsResult_get_Status), nullptr, nullptr, nullptr },
        { "uicc_apps", reinterpret_cast<getter>(MobileBroadbandUiccAppsResult_get_UiccApps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MobileBroadbandUiccAppsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MobileBroadbandUiccAppsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MobileBroadbandUiccAppsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MobileBroadbandUiccAppsResult) },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppsResult =
    {
        "_winrt_windows_networking_networkoperators.MobileBroadbandUiccAppsResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppsResult
    };

    // ----- NetworkOperatorDataUsageTriggerDetails class --------------------

    static PyObject* _new_NetworkOperatorDataUsageTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorDataUsageTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorDataUsageTriggerDetails_get_NotificationKind(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorDataUsageTriggerDetails", L"NotificationKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorDataUsageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorDataUsageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorDataUsageTriggerDetails[] = {
        { "_assign_array_", _assign_array_NetworkOperatorDataUsageTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorDataUsageTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorDataUsageTriggerDetails[] = {
        { "notification_kind", reinterpret_cast<getter>(NetworkOperatorDataUsageTriggerDetails_get_NotificationKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorDataUsageTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorDataUsageTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorDataUsageTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorDataUsageTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorDataUsageTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorDataUsageTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.NetworkOperatorDataUsageTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorDataUsageTriggerDetails
    };

    // ----- NetworkOperatorNotificationEventDetails class --------------------

    static PyObject* _new_NetworkOperatorNotificationEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorNotificationEventDetails(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorNotificationEventDetails_AuthorizeTethering(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"AuthorizeTethering", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.AuthorizeTethering(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_EncodingType(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"EncodingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_Message(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_NotificationType(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"NotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_RuleId(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"RuleId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RuleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorNotificationEventDetails_get_SmsMessage(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorNotificationEventDetails", L"SmsMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmsMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorNotificationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorNotificationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorNotificationEventDetails[] = {
        { "authorize_tethering", reinterpret_cast<PyCFunction>(NetworkOperatorNotificationEventDetails_AuthorizeTethering), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkOperatorNotificationEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorNotificationEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorNotificationEventDetails[] = {
        { "encoding_type", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_EncodingType), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_Message), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "notification_type", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_NotificationType), nullptr, nullptr, nullptr },
        { "rule_id", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_RuleId), nullptr, nullptr, nullptr },
        { "sms_message", reinterpret_cast<getter>(NetworkOperatorNotificationEventDetails_get_SmsMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorNotificationEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorNotificationEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorNotificationEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorNotificationEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorNotificationEventDetails) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorNotificationEventDetails =
    {
        "_winrt_windows_networking_networkoperators.NetworkOperatorNotificationEventDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorNotificationEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorNotificationEventDetails
    };

    // ----- NetworkOperatorTetheringAccessPointConfiguration class --------------------

    static PyObject* _new_NetworkOperatorTetheringAccessPointConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorTetheringAccessPointConfiguration(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_IsBandSupported(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"IsBandSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(args, 0);

                return py::convert(self->obj.IsBandSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_IsBandSupportedAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"IsBandSupportedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(args, 0);

                return py::convert(self->obj.IsBandSupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Ssid(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Ssid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Ssid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Ssid(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Ssid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Ssid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Passphrase(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Passphrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Passphrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Passphrase(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Passphrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Passphrase(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Band(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Band"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Band());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Band(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration", L"Band"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(arg);

            self->obj.Band(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringAccessPointConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringAccessPointConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringAccessPointConfiguration[] = {
        { "is_band_supported", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringAccessPointConfiguration_IsBandSupported), METH_VARARGS, nullptr },
        { "is_band_supported_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringAccessPointConfiguration_IsBandSupportedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkOperatorTetheringAccessPointConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringAccessPointConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringAccessPointConfiguration[] = {
        { "ssid", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Ssid), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Ssid), nullptr, nullptr },
        { "passphrase", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Passphrase), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Passphrase), nullptr, nullptr },
        { "band", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Band), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Band), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringAccessPointConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringAccessPointConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringAccessPointConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringAccessPointConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringAccessPointConfiguration) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringAccessPointConfiguration =
    {
        "_winrt_windows_networking_networkoperators.NetworkOperatorTetheringAccessPointConfiguration",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringAccessPointConfiguration
    };

    // ----- NetworkOperatorTetheringClient class --------------------

    static PyObject* _new_NetworkOperatorTetheringClient(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringClient(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringClient_get_HostNames(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient", L"HostNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HostNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringClient_get_MacAddress(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient", L"MacAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MacAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringClient[] = {
        { "_assign_array_", _assign_array_NetworkOperatorTetheringClient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringClient), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringClient[] = {
        { "host_names", reinterpret_cast<getter>(NetworkOperatorTetheringClient_get_HostNames), nullptr, nullptr, nullptr },
        { "mac_address", reinterpret_cast<getter>(NetworkOperatorTetheringClient_get_MacAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringClient[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringClient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringClient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringClient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringClient) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringClient =
    {
        "_winrt_windows_networking_networkoperators.NetworkOperatorTetheringClient",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringClient
    };

    // ----- NetworkOperatorTetheringManager class --------------------

    static PyObject* _new_NetworkOperatorTetheringManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringManager(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringManager_ConfigureAccessPointAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"ConfigureAccessPointAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>(args, 0);

                return py::convert(self->obj.ConfigureAccessPointAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_CreateFromConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"CreateFromConnectionProfile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromConnectionProfile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"CreateFromConnectionProfile", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromConnectionProfile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_DisableNoConnectionsTimeout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"DisableNoConnectionsTimeout", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::DisableNoConnectionsTimeout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_DisableNoConnectionsTimeoutAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"DisableNoConnectionsTimeoutAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::DisableNoConnectionsTimeoutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_EnableNoConnectionsTimeout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"EnableNoConnectionsTimeout", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::EnableNoConnectionsTimeout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_EnableNoConnectionsTimeoutAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"EnableNoConnectionsTimeoutAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::EnableNoConnectionsTimeoutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetCurrentAccessPointConfiguration(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetCurrentAccessPointConfiguration", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentAccessPointConfiguration());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringCapability(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetTetheringCapability", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::GetTetheringCapability(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringCapabilityFromConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetTetheringCapabilityFromConnectionProfile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::GetTetheringCapabilityFromConnectionProfile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringClients(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"GetTetheringClients", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetTetheringClients());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_IsNoConnectionsTimeoutEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"IsNoConnectionsTimeoutEnabled", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::IsNoConnectionsTimeoutEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_StartTetheringAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"StartTetheringAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartTetheringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_StopTetheringAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"StopTetheringAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopTetheringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_ClientCount(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"ClientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_MaxClientCount(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"MaxClientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_TetheringOperationalState(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager", L"TetheringOperationalState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringManager[] = {
        { "configure_access_point_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_ConfigureAccessPointAsync), METH_VARARGS, nullptr },
        { "create_from_connection_profile", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_CreateFromConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_no_connections_timeout", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_DisableNoConnectionsTimeout), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_no_connections_timeout_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_DisableNoConnectionsTimeoutAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_no_connections_timeout", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_EnableNoConnectionsTimeout), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_no_connections_timeout_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_EnableNoConnectionsTimeoutAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_access_point_configuration", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetCurrentAccessPointConfiguration), METH_VARARGS, nullptr },
        { "get_tethering_capability", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringCapability), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tethering_capability_from_connection_profile", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringCapabilityFromConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tethering_clients", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringClients), METH_VARARGS, nullptr },
        { "is_no_connections_timeout_enabled", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_IsNoConnectionsTimeoutEnabled), METH_VARARGS | METH_STATIC, nullptr },
        { "start_tethering_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_StartTetheringAsync), METH_VARARGS, nullptr },
        { "stop_tethering_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_StopTetheringAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkOperatorTetheringManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringManager[] = {
        { "client_count", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_ClientCount), nullptr, nullptr, nullptr },
        { "max_client_count", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_MaxClientCount), nullptr, nullptr, nullptr },
        { "tethering_operational_state", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_TetheringOperationalState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringManager) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringManager =
    {
        "_winrt_windows_networking_networkoperators.NetworkOperatorTetheringManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringManager
    };

    // ----- NetworkOperatorTetheringOperationResult class --------------------

    static PyObject* _new_NetworkOperatorTetheringOperationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringOperationResult(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringOperationResult_get_AdditionalErrorMessage(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult", L"AdditionalErrorMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringOperationResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkOperatorTetheringOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkOperatorTetheringOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringOperationResult[] = {
        { "_assign_array_", _assign_array_NetworkOperatorTetheringOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringOperationResult[] = {
        { "additional_error_message", reinterpret_cast<getter>(NetworkOperatorTetheringOperationResult_get_AdditionalErrorMessage), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(NetworkOperatorTetheringOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkOperatorTetheringOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkOperatorTetheringOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkOperatorTetheringOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkOperatorTetheringOperationResult) },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringOperationResult =
    {
        "_winrt_windows_networking_networkoperators.NetworkOperatorTetheringOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringOperationResult
    };

    // ----- ProvisionFromXmlDocumentResults class --------------------

    static PyObject* _new_ProvisionFromXmlDocumentResults(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>::type_name);
        return nullptr;
    }

    static void _dealloc_ProvisionFromXmlDocumentResults(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionFromXmlDocumentResults_get_AllElementsProvisioned(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults", L"AllElementsProvisioned"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllElementsProvisioned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvisionFromXmlDocumentResults_get_ProvisionResultsXml(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults", L"ProvisionResultsXml"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProvisionResultsXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisionFromXmlDocumentResults(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisionFromXmlDocumentResults(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionFromXmlDocumentResults[] = {
        { "_assign_array_", _assign_array_ProvisionFromXmlDocumentResults, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionFromXmlDocumentResults), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionFromXmlDocumentResults[] = {
        { "all_elements_provisioned", reinterpret_cast<getter>(ProvisionFromXmlDocumentResults_get_AllElementsProvisioned), nullptr, nullptr, nullptr },
        { "provision_results_xml", reinterpret_cast<getter>(ProvisionFromXmlDocumentResults_get_ProvisionResultsXml), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProvisionFromXmlDocumentResults[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisionFromXmlDocumentResults) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisionFromXmlDocumentResults) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisionFromXmlDocumentResults) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisionFromXmlDocumentResults) },
        { },
    };

    static PyType_Spec type_spec_ProvisionFromXmlDocumentResults =
    {
        "_winrt_windows_networking_networkoperators.ProvisionFromXmlDocumentResults",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionFromXmlDocumentResults
    };

    // ----- ProvisionedProfile class --------------------

    static PyObject* _new_ProvisionedProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_ProvisionedProfile(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionedProfile_UpdateCost(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisionedProfile", L"UpdateCost", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(args, 0);

                self->obj.UpdateCost(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisionedProfile_UpdateUsage(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisionedProfile", L"UpdateUsage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileUsage>(args, 0);

                self->obj.UpdateUsage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisionedProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisionedProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionedProfile[] = {
        { "update_cost", reinterpret_cast<PyCFunction>(ProvisionedProfile_UpdateCost), METH_VARARGS, nullptr },
        { "update_usage", reinterpret_cast<PyCFunction>(ProvisionedProfile_UpdateUsage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProvisionedProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionedProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionedProfile[] = {
        { }
    };

    static PyType_Slot _type_slots_ProvisionedProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisionedProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisionedProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisionedProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisionedProfile) },
        { },
    };

    static PyType_Spec type_spec_ProvisionedProfile =
    {
        "_winrt_windows_networking_networkoperators.ProvisionedProfile",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionedProfile
    };

    // ----- ProvisioningAgent class --------------------

    static PyObject* _new_ProvisioningAgent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ProvisioningAgent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProvisioningAgent(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisioningAgent_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisioningAgent", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::ProvisioningAgent::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisioningAgent_GetProvisionedProfile(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisioningAgent", L"GetProvisionedProfile", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileMediaType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetProvisionedProfile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisioningAgent_ProvisionFromXmlDocumentAsync(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.ProvisioningAgent", L"ProvisionFromXmlDocumentAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ProvisionFromXmlDocumentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisioningAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisioningAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisioningAgent[] = {
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(ProvisioningAgent_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_provisioned_profile", reinterpret_cast<PyCFunction>(ProvisioningAgent_GetProvisionedProfile), METH_VARARGS, nullptr },
        { "provision_from_xml_document_async", reinterpret_cast<PyCFunction>(ProvisioningAgent_ProvisionFromXmlDocumentAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProvisioningAgent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisioningAgent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisioningAgent[] = {
        { }
    };

    static PyType_Slot _type_slots_ProvisioningAgent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisioningAgent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisioningAgent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisioningAgent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisioningAgent) },
        { },
    };

    static PyType_Spec type_spec_ProvisioningAgent =
    {
        "_winrt_windows_networking_networkoperators.ProvisioningAgent",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisioningAgent
    };

    // ----- TetheringEntitlementCheckTriggerDetails class --------------------

    static PyObject* _new_TetheringEntitlementCheckTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_TetheringEntitlementCheckTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_AllowTethering(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.TetheringEntitlementCheckTriggerDetails", L"AllowTethering", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AllowTethering();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_DenyTethering(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.TetheringEntitlementCheckTriggerDetails", L"DenyTethering", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DenyTethering(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.TetheringEntitlementCheckTriggerDetails", L"NetworkAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TetheringEntitlementCheckTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TetheringEntitlementCheckTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TetheringEntitlementCheckTriggerDetails[] = {
        { "allow_tethering", reinterpret_cast<PyCFunction>(TetheringEntitlementCheckTriggerDetails_AllowTethering), METH_VARARGS, nullptr },
        { "deny_tethering", reinterpret_cast<PyCFunction>(TetheringEntitlementCheckTriggerDetails_DenyTethering), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TetheringEntitlementCheckTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TetheringEntitlementCheckTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TetheringEntitlementCheckTriggerDetails[] = {
        { "network_account_id", reinterpret_cast<getter>(TetheringEntitlementCheckTriggerDetails_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TetheringEntitlementCheckTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TetheringEntitlementCheckTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TetheringEntitlementCheckTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TetheringEntitlementCheckTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TetheringEntitlementCheckTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_TetheringEntitlementCheckTriggerDetails =
    {
        "_winrt_windows_networking_networkoperators.TetheringEntitlementCheckTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TetheringEntitlementCheckTriggerDetails
    };

    // ----- UssdMessage class --------------------

    static PyObject* _new_UssdMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::NetworkOperators::UssdMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UssdMessage(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdMessage_GetPayload(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"GetPayload", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPayload());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdMessage_SetPayload(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"SetPayload", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetPayload(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdMessage_get_PayloadAsText(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"PayloadAsText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayloadAsText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UssdMessage_put_PayloadAsText(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"PayloadAsText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PayloadAsText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UssdMessage_get_DataCodingScheme(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"DataCodingScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataCodingScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UssdMessage_put_DataCodingScheme(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdMessage", L"DataCodingScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.DataCodingScheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_UssdMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::UssdMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UssdMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdMessage[] = {
        { "get_payload", reinterpret_cast<PyCFunction>(UssdMessage_GetPayload), METH_VARARGS, nullptr },
        { "set_payload", reinterpret_cast<PyCFunction>(UssdMessage_SetPayload), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UssdMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdMessage[] = {
        { "payload_as_text", reinterpret_cast<getter>(UssdMessage_get_PayloadAsText), reinterpret_cast<setter>(UssdMessage_put_PayloadAsText), nullptr, nullptr },
        { "data_coding_scheme", reinterpret_cast<getter>(UssdMessage_get_DataCodingScheme), reinterpret_cast<setter>(UssdMessage_put_DataCodingScheme), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UssdMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UssdMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UssdMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UssdMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UssdMessage) },
        { },
    };

    static PyType_Spec type_spec_UssdMessage =
    {
        "_winrt_windows_networking_networkoperators.UssdMessage",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdMessage
    };

    // ----- UssdReply class --------------------

    static PyObject* _new_UssdReply(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::UssdReply>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::UssdReply>::type_name);
        return nullptr;
    }

    static void _dealloc_UssdReply(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdReply_get_Message(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdReply", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UssdReply_get_ResultCode(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.NetworkOperators.UssdReply", L"ResultCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UssdReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::UssdReply>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UssdReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdReply>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdReply[] = {
        { "_assign_array_", _assign_array_UssdReply, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdReply), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdReply[] = {
        { "message", reinterpret_cast<getter>(UssdReply_get_Message), nullptr, nullptr, nullptr },
        { "result_code", reinterpret_cast<getter>(UssdReply_get_ResultCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UssdReply[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UssdReply) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UssdReply) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UssdReply) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UssdReply) },
        { },
    };

    static PyType_Spec type_spec_UssdReply =
    {
        "_winrt_windows_networking_networkoperators.UssdReply",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdReply),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdReply
    };

    // ----- UssdSession class --------------------

    static PyObject* _new_UssdSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::NetworkOperators::UssdSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::NetworkOperators::UssdSession>::type_name);
        return nullptr;
    }

    static void _dealloc_UssdSession(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdSession_Close(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"CreateFromNetworkAccountId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::UssdSession::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_CreateFromNetworkInterfaceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"CreateFromNetworkInterfaceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::UssdSession::CreateFromNetworkInterfaceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_SendMessageAndGetReplyAsync(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.NetworkOperators.UssdSession", L"SendMessageAndGetReplyAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::UssdMessage>(args, 0);

                return py::convert(self->obj.SendMessageAndGetReplyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UssdSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::UssdSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UssdSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdSession[] = {
        { "close", reinterpret_cast<PyCFunction>(UssdSession_Close), METH_VARARGS, nullptr },
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(UssdSession_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_network_interface_id", reinterpret_cast<PyCFunction>(UssdSession_CreateFromNetworkInterfaceId), METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_and_get_reply_async", reinterpret_cast<PyCFunction>(UssdSession_SendMessageAndGetReplyAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UssdSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdSession[] = {
        { }
    };

    static PyType_Slot _type_slots_UssdSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UssdSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UssdSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UssdSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UssdSession) },
        { },
    };

    static PyType_Spec type_spec_UssdSession =
    {
        "_winrt_windows_networking_networkoperators.UssdSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdSession
    };

    // ----- ESimProfileInstallProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>* _new_ESimProfileInstallProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_ESimProfileInstallProgress(winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _TotalSizeInBytes{};
        int32_t _InstalledSizeInBytes{};

        static const char* kwlist[] = {"total_size_in_bytes", "installed_size_in_bytes", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_TotalSizeInBytes, &_InstalledSizeInBytes))
        {
            return -1;
        }

        try
        {
            self->obj = {_TotalSizeInBytes, _InstalledSizeInBytes};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_ESimProfileInstallProgress(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ESimProfileInstallProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ESimProfileInstallProgress[] = {
        { "_assign_array_", _assign_array_ESimProfileInstallProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* ESimProfileInstallProgress_get_TotalSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ESimProfileInstallProgress_set_TotalSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalSizeInBytes = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ESimProfileInstallProgress_get_InstalledSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ESimProfileInstallProgress_set_InstalledSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InstalledSizeInBytes = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ESimProfileInstallProgress[] = {
        { "total_size_in_bytes", reinterpret_cast<getter>(ESimProfileInstallProgress_get_TotalSizeInBytes), reinterpret_cast<setter>(ESimProfileInstallProgress_set_TotalSizeInBytes), nullptr, nullptr },
        { "installed_size_in_bytes", reinterpret_cast<getter>(ESimProfileInstallProgress_get_InstalledSizeInBytes), reinterpret_cast<setter>(ESimProfileInstallProgress_set_InstalledSizeInBytes), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfileInstallProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ESimProfileInstallProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_ESimProfileInstallProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ESimProfileInstallProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ESimProfileInstallProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ESimProfileInstallProgress) },
        { },
    };

    static PyType_Spec type_spec_ESimProfileInstallProgress =
    {
        "_winrt_windows_networking_networkoperators.ESimProfileInstallProgress",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfileInstallProgress
    };

    // ----- ProfileUsage struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ProfileUsage>* _new_ProfileUsage(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ProfileUsage>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_ProfileUsage(winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ProfileUsage>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _UsageInMegabytes{};
        PyObject* _LastSyncTime{};

        static const char* kwlist[] = {"usage_in_megabytes", "last_sync_time", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IO", const_cast<char**>(kwlist), &_UsageInMegabytes, &_LastSyncTime))
        {
            return -1;
        }

        try
        {
            self->obj = {_UsageInMegabytes, py::converter<winrt::Windows::Foundation::DateTime>::convert_to(_LastSyncTime)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_ProfileUsage(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProfileUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::NetworkOperators::ProfileUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ProfileUsage[] = {
        { "_assign_array_", _assign_array_ProfileUsage, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* ProfileUsage_get_UsageInMegabytes(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsageInMegabytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProfileUsage_set_UsageInMegabytes(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.UsageInMegabytes = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProfileUsage_get_LastSyncTime(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSyncTime);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProfileUsage_set_LastSyncTime(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LastSyncTime = py::converter<winrt::Windows::Foundation::DateTime>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ProfileUsage[] = {
        { "usage_in_megabytes", reinterpret_cast<getter>(ProfileUsage_get_UsageInMegabytes), reinterpret_cast<setter>(ProfileUsage_set_UsageInMegabytes), nullptr, nullptr },
        { "last_sync_time", reinterpret_cast<getter>(ProfileUsage_get_LastSyncTime), reinterpret_cast<setter>(ProfileUsage_set_LastSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProfileUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProfileUsage) },
        { Py_tp_init, reinterpret_cast<void*>(_init_ProfileUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProfileUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProfileUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProfileUsage) },
        { },
    };

    static PyType_Spec type_spec_ProfileUsage =
    {
        "_winrt_windows_networking_networkoperators.ProfileUsage",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProfileUsage
    };

    // ----- Windows.Networking.NetworkOperators Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::NetworkOperators");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_networking_networkoperators",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Networking::NetworkOperators

PyMODINIT_FUNC PyInit__winrt_windows_networking_networkoperators(void) noexcept
{
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESim, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESim, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimAddedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimAddedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimDiscoverEvent, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimDiscoverEvent, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimDiscoverResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimDiscoverResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimDownloadProfileMetadataResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimDownloadProfileMetadataResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ESimManager_Meta{PyType_FromSpec(&type_spec_ESimManager_Meta)};
    if (!type_ESimManager_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimManager, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ESimManager_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ESimManager_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimOperationResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimOperationResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimPolicy, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimPolicy, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimProfile, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimProfile, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimProfileMetadata, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimProfileMetadata, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimProfilePolicy, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimProfilePolicy, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimRemovedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimRemovedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimServiceInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimServiceInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimUpdatedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimWatcher, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimWatcher, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_FdnAccessManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_FdnAccessManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_HotspotAuthenticationContext, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_HotspotAuthenticationContext, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_HotspotAuthenticationEventDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_HotspotAuthenticationEventDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_HotspotCredentialsAuthenticationResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_HotspotCredentialsAuthenticationResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownCSimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownCSimFilePaths_Meta)};
    if (!type_KnownCSimFilePaths_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_KnownCSimFilePaths, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownCSimFilePaths_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_KnownCSimFilePaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownCSimFilePaths_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRuimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownRuimFilePaths_Meta)};
    if (!type_KnownRuimFilePaths_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_KnownRuimFilePaths, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRuimFilePaths_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_KnownRuimFilePaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRuimFilePaths_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownSimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownSimFilePaths_Meta)};
    if (!type_KnownSimFilePaths_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_KnownSimFilePaths, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownSimFilePaths_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_KnownSimFilePaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownSimFilePaths_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownUSimFilePaths_Meta{PyType_FromSpec(&type_spec_KnownUSimFilePaths_Meta)};
    if (!type_KnownUSimFilePaths_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_KnownUSimFilePaths, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownUSimFilePaths_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_KnownUSimFilePaths, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownUSimFilePaths_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_MobileBroadbandAccount_Meta{PyType_FromSpec(&type_spec_MobileBroadbandAccount_Meta)};
    if (!type_MobileBroadbandAccount_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccount, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MobileBroadbandAccount_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccount, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MobileBroadbandAccount_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccountEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccountEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccountUpdatedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccountUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccountWatcher, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAccountWatcher, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAntennaSar, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandAntennaSar, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellCdma, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellCdma, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellGsm, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellGsm, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellLte, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellLte, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellNR, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellNR, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellTdscdma, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellTdscdma, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellUmts, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellUmts, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellsInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCellsInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceInformation, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceInformation, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceService, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceService, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceCommandResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceCommandResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceCommandSession, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceCommandSession, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceDataSession, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceDataSession, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceInformation, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceInformation, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandDeviceServiceTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandModem, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandModem, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandModemConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandModemConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandModemIsolation, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandModemIsolation, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandNetwork, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandNetwork, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandNetworkRegistrationStateChange, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandNetworkRegistrationStateChange, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPco, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPco, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPcoDataChangeTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPcoDataChangeTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPin, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPin, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinLockStateChange, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinLockStateChange, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinLockStateChangeTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinLockStateChangeTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinOperationResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandPinOperationResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandRadioStateChange, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandRadioStateChange, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandRadioStateChangeTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandRadioStateChangeTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSarManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSarManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSlotInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSlotInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSlotInfoChangedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSlotInfoChangedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSlotManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandSlotManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandTransmissionStateChangedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandTransmissionStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUicc, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUicc, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccApp, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccApp, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccAppReadRecordResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccAppReadRecordResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccAppRecordDetailsResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccAppRecordDetailsResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccAppsResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MobileBroadbandUiccAppsResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorDataUsageTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorDataUsageTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorNotificationEventDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorNotificationEventDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringAccessPointConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringAccessPointConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringClient, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringClient, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringOperationResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_NetworkOperatorTetheringOperationResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ProvisionFromXmlDocumentResults, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ProvisionFromXmlDocumentResults, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ProvisionedProfile, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ProvisionedProfile, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ProvisioningAgent, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ProvisioningAgent, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_TetheringEntitlementCheckTriggerDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_TetheringEntitlementCheckTriggerDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_UssdMessage, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_UssdMessage, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_UssdReply, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_UssdReply, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_UssdSession, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_UssdSession, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ESimProfileInstallProgress, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ESimProfileInstallProgress, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ProfileUsage, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ProfileUsage, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
