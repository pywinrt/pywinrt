# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.data.xml.dom
import winrt.windows.devices.sms
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.networking.connectivity
import winrt.windows.storage.streams

from winrt.windows.networking.networkoperators import DataClasses, ESimAuthenticationPreference, ESimDiscoverResultKind, ESimOperationStatus, ESimProfileClass, ESimProfileMetadataState, ESimProfileState, ESimState, ESimWatcherStatus, HotspotAuthenticationResponseCode, MobileBroadbandAccountWatcherStatus, MobileBroadbandDeviceType, MobileBroadbandModemStatus, MobileBroadbandPinFormat, MobileBroadbandPinLockState, MobileBroadbandPinType, MobileBroadbandRadioState, MobileBroadbandSlotState, MobileBroadbandUiccAppOperationStatus, NetworkDeviceStatus, NetworkOperatorDataUsageNotificationKind, NetworkOperatorEventMessageType, NetworkRegistrationState, ProfileMediaType, TetheringCapability, TetheringOperationStatus, TetheringOperationalState, TetheringWiFiBand, UiccAccessCondition, UiccAppKind, UiccAppRecordKind, UssdResultCode

Self = typing.TypeVar('Self')

@typing.final
class ESimProfileInstallProgress:
    total_size_in_bytes: winrt.system.Int32
    installed_size_in_bytes: winrt.system.Int32
    def __init__(self, total_size_in_bytes: winrt.system.Int32, installed_size_in_bytes: winrt.system.Int32) -> None: ...

@typing.final
class ProfileUsage:
    usage_in_megabytes: winrt.system.UInt32
    last_sync_time: datetime.datetime
    def __init__(self, usage_in_megabytes: winrt.system.UInt32, last_sync_time: datetime.datetime) -> None: ...

@typing.final
class ESim(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESim: ...
    def delete_profile_async(self, profile_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    @typing.overload
    def discover(self) -> typing.Optional[ESimDiscoverResult]: ...
    @typing.overload
    def discover(self, server_address: str, matching_id: str, /) -> typing.Optional[ESimDiscoverResult]: ...
    @typing.overload
    def discover_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimDiscoverResult]: ...
    @typing.overload
    def discover_async(self, server_address: str, matching_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimDiscoverResult]: ...
    def download_profile_metadata_async(self, activation_code: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimDownloadProfileMetadataResult]: ...
    def get_profiles(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ESimProfile]]: ...
    def reset_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def add_profile_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ESim, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_profile_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def available_memory_in_bytes(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def eid(self) -> str: ...
    @_property
    def firmware_version(self) -> str: ...
    @_property
    def mobile_broadband_modem_device_id(self) -> str: ...
    @_property
    def policy(self) -> typing.Optional[ESimPolicy]: ...
    @_property
    def state(self) -> ESimState: ...
    @_property
    def slot_index(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...

@typing.final
class ESimAddedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimAddedEventArgs: ...
    @_property
    def e_sim(self) -> typing.Optional[ESim]: ...

@typing.final
class ESimDiscoverEvent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimDiscoverEvent: ...
    @_property
    def matching_id(self) -> str: ...
    @_property
    def rsp_server_address(self) -> str: ...

@typing.final
class ESimDiscoverResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimDiscoverResult: ...
    @_property
    def events(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ESimDiscoverEvent]]: ...
    @_property
    def kind(self) -> ESimDiscoverResultKind: ...
    @_property
    def profile_metadata(self) -> typing.Optional[ESimProfileMetadata]: ...
    @_property
    def result(self) -> typing.Optional[ESimOperationResult]: ...

@typing.final
class ESimDownloadProfileMetadataResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimDownloadProfileMetadataResult: ...
    @_property
    def profile_metadata(self) -> typing.Optional[ESimProfileMetadata]: ...
    @_property
    def result(self) -> typing.Optional[ESimOperationResult]: ...

@typing.final
class ESimManager_Static(type):
    def try_create_e_sim_watcher(cls) -> typing.Optional[ESimWatcher]: ...
    def add_service_info_changed(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_service_info_changed(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def service_info(cls) -> typing.Optional[ESimServiceInfo]: ...

@typing.final
class ESimManager(winrt.system.Object, metaclass=ESimManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimManager: ...

@typing.final
class ESimOperationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimOperationResult: ...
    @_property
    def status(self) -> ESimOperationStatus: ...

@typing.final
class ESimPolicy(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimPolicy: ...
    @_property
    def should_enable_managing_ui(self) -> bool: ...

@typing.final
class ESimProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimProfile: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def set_nickname_async(self, new_nickname: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    @_property
    def class_(self) -> ESimProfileClass: ...
    @_property
    def id(self) -> str: ...
    @_property
    def nickname(self) -> str: ...
    @_property
    def policy(self) -> typing.Optional[ESimProfilePolicy]: ...
    @_property
    def provider_icon(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def provider_name(self) -> str: ...
    @_property
    def state(self) -> ESimProfileState: ...

@typing.final
class ESimProfileMetadata(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimProfileMetadata: ...
    @typing.overload
    def confirm_install_async(self) -> winrt.windows.foundation.IAsyncOperationWithProgress[ESimOperationResult, ESimProfileInstallProgress]: ...
    @typing.overload
    def confirm_install_async(self, confirmation_code: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[ESimOperationResult, ESimProfileInstallProgress]: ...
    def deny_install_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def postpone_install_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def add_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ESimProfileMetadata, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_confirmation_code_required(self) -> bool: ...
    @_property
    def policy(self) -> typing.Optional[ESimProfilePolicy]: ...
    @_property
    def provider_icon(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def provider_name(self) -> str: ...
    @_property
    def state(self) -> ESimProfileMetadataState: ...

@typing.final
class ESimProfilePolicy(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimProfilePolicy: ...
    @_property
    def can_delete(self) -> bool: ...
    @_property
    def can_disable(self) -> bool: ...
    @_property
    def is_managed_by_enterprise(self) -> bool: ...

@typing.final
class ESimRemovedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimRemovedEventArgs: ...
    @_property
    def e_sim(self) -> typing.Optional[ESim]: ...

@typing.final
class ESimServiceInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimServiceInfo: ...
    @_property
    def authentication_preference(self) -> ESimAuthenticationPreference: ...
    @_property
    def is_e_sim_ui_enabled(self) -> bool: ...

@typing.final
class ESimUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimUpdatedEventArgs: ...
    @_property
    def e_sim(self) -> typing.Optional[ESim]: ...

@typing.final
class ESimWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, ESimAddedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, ESimRemovedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, ESimUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> ESimWatcherStatus: ...

@typing.final
class FdnAccessManager_Static(type):
    def request_unlock_async(cls, contact_list_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

@typing.final
class FdnAccessManager(winrt.system.Object, metaclass=FdnAccessManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FdnAccessManager: ...

@typing.final
class HotspotAuthenticationContext_Static(type):
    def try_get_authentication_context(cls, even_token: str, /) -> typing.Tuple[bool, typing.Optional[HotspotAuthenticationContext]]: ...

@typing.final
class HotspotAuthenticationContext(winrt.system.Object, metaclass=HotspotAuthenticationContext_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HotspotAuthenticationContext: ...
    def abort_authentication(self, mark_as_manual: bool, /) -> None: ...
    def issue_credentials(self, user_name: str, password: str, extra_parameters: str, mark_as_manual_connect_on_failure: bool, /) -> None: ...
    def issue_credentials_async(self, user_name: str, password: str, extra_parameters: str, mark_as_manual_connect_on_failure: bool, /) -> winrt.windows.foundation.IAsyncOperation[HotspotCredentialsAuthenticationResult]: ...
    def skip_authentication(self) -> None: ...
    def trigger_attention_required(self, package_relative_application_id: str, application_parameters: str, /) -> None: ...
    @_property
    def authentication_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def network_adapter(self) -> typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter]: ...
    @_property
    def redirect_message_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def redirect_message_xml(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...
    @_property
    def wireless_network_id(self) -> winrt.system.UInt8: ...

@typing.final
class HotspotAuthenticationEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HotspotAuthenticationEventDetails: ...
    @_property
    def event_token(self) -> str: ...

@typing.final
class HotspotCredentialsAuthenticationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HotspotCredentialsAuthenticationResult: ...
    @_property
    def authentication_reply_xml(self) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...
    @_property
    def has_network_error_occurred(self) -> bool: ...
    @_property
    def logoff_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @_property
    def response_code(self) -> HotspotAuthenticationResponseCode: ...

@typing.final
class KnownCSimFilePaths_Static(type):
    @_property
    def e_f_spn(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid1(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid2(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

@typing.final
class KnownCSimFilePaths(winrt.system.Object, metaclass=KnownCSimFilePaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownCSimFilePaths: ...

@typing.final
class KnownRuimFilePaths_Static(type):
    @_property
    def e_f_spn(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid1(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid2(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

@typing.final
class KnownRuimFilePaths(winrt.system.Object, metaclass=KnownRuimFilePaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownRuimFilePaths: ...

@typing.final
class KnownSimFilePaths_Static(type):
    @_property
    def e_f_ons(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def e_f_spn(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid1(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid2(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

@typing.final
class KnownSimFilePaths(winrt.system.Object, metaclass=KnownSimFilePaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownSimFilePaths: ...

@typing.final
class KnownUSimFilePaths_Static(type):
    @_property
    def e_f_opl(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def e_f_pnn(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def e_f_spn(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid1(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def gid2(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

@typing.final
class KnownUSimFilePaths(winrt.system.Object, metaclass=KnownUSimFilePaths_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownUSimFilePaths: ...

@typing.final
class MobileBroadbandAccount_Static(type):
    def create_from_network_account_id(cls, network_account_id: str, /) -> typing.Optional[MobileBroadbandAccount]: ...
    @_property
    def available_network_account_ids(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

@typing.final
class MobileBroadbandAccount(winrt.system.Object, metaclass=MobileBroadbandAccount_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccount: ...
    def get_connection_profiles(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.connectivity.ConnectionProfile]]: ...
    @_property
    def current_device_information(self) -> typing.Optional[MobileBroadbandDeviceInformation]: ...
    @_property
    def current_network(self) -> typing.Optional[MobileBroadbandNetwork]: ...
    @_property
    def network_account_id(self) -> str: ...
    @_property
    def service_provider_guid(self) -> _uuid.UUID: ...
    @_property
    def service_provider_name(self) -> str: ...
    @_property
    def account_experience_url(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...

@typing.final
class MobileBroadbandAccountEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccountEventArgs: ...
    @_property
    def network_account_id(self) -> str: ...

@typing.final
class MobileBroadbandAccountUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccountUpdatedEventArgs: ...
    @_property
    def has_device_information_changed(self) -> bool: ...
    @_property
    def has_network_changed(self) -> bool: ...
    @_property
    def network_account_id(self) -> str: ...

@typing.final
class MobileBroadbandAccountWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccountWatcher: ...
    def __new__(cls: typing.Type[MobileBroadbandAccountWatcher]) -> MobileBroadbandAccountWatcher:...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_account_added(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, MobileBroadbandAccountEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_account_added(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_account_removed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, MobileBroadbandAccountEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_account_removed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_account_updated(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, MobileBroadbandAccountUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_account_updated(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> MobileBroadbandAccountWatcherStatus: ...

@typing.final
class MobileBroadbandAntennaSar(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAntennaSar: ...
    def __new__(cls: typing.Type[MobileBroadbandAntennaSar], antenna_index: winrt.system.Int32, sar_backoff_index: winrt.system.Int32) -> MobileBroadbandAntennaSar:...
    @_property
    def antenna_index(self) -> winrt.system.Int32: ...
    @_property
    def sar_backoff_index(self) -> winrt.system.Int32: ...

@typing.final
class MobileBroadbandCellCdma(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellCdma: ...
    @_property
    def base_station_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def base_station_last_broadcast_gps_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def base_station_latitude(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def base_station_longitude(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def base_station_p_n_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def network_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def pilot_signal_strength_in_d_b(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def system_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...

@typing.final
class MobileBroadbandCellGsm(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellGsm: ...
    @_property
    def base_station_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def channel_number(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def location_area_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def received_signal_strength_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def timing_advance_in_bit_periods(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...

@typing.final
class MobileBroadbandCellLte(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellLte: ...
    @_property
    def cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def channel_number(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def physical_cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def reference_signal_received_power_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def reference_signal_received_quality_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def timing_advance_in_bit_periods(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def tracking_area_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...

@typing.final
class MobileBroadbandCellNR(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellNR: ...
    @_property
    def cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int64]]: ...
    @_property
    def channel_number(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def physical_cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def reference_signal_received_power_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def reference_signal_received_quality_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def signal_to_noise_ratio_in_d_b(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def timing_advance_in_nanoseconds(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def tracking_area_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...

@typing.final
class MobileBroadbandCellTdscdma(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellTdscdma: ...
    @_property
    def cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def cell_parameter_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def channel_number(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def location_area_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def path_loss_in_d_b(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def received_signal_code_power_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def timing_advance_in_bit_periods(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...

@typing.final
class MobileBroadbandCellUmts(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellUmts: ...
    @_property
    def cell_id(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def channel_number(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def location_area_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def path_loss_in_d_b(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def primary_scrambling_code(self) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @_property
    def provider_id(self) -> str: ...
    @_property
    def received_signal_code_power_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def signal_to_noise_ratio_in_d_b(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...

@typing.final
class MobileBroadbandCellsInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellsInfo: ...
    @_property
    def neighboring_cells_cdma(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellCdma]]: ...
    @_property
    def neighboring_cells_gsm(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellGsm]]: ...
    @_property
    def neighboring_cells_lte(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellLte]]: ...
    @_property
    def neighboring_cells_tdscdma(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellTdscdma]]: ...
    @_property
    def neighboring_cells_umts(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellUmts]]: ...
    @_property
    def serving_cells_cdma(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellCdma]]: ...
    @_property
    def serving_cells_gsm(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellGsm]]: ...
    @_property
    def serving_cells_lte(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellLte]]: ...
    @_property
    def serving_cells_tdscdma(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellTdscdma]]: ...
    @_property
    def serving_cells_umts(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellUmts]]: ...
    @_property
    def neighboring_cells_n_r(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellNR]]: ...
    @_property
    def serving_cells_n_r(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellNR]]: ...

@typing.final
class MobileBroadbandCurrentSlotIndexChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCurrentSlotIndexChangedEventArgs: ...
    @_property
    def current_slot_index(self) -> winrt.system.Int32: ...

@typing.final
class MobileBroadbandDeviceInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceInformation: ...
    @_property
    def cellular_class(self) -> winrt.windows.devices.sms.CellularClass: ...
    @_property
    def current_radio_state(self) -> MobileBroadbandRadioState: ...
    @_property
    def custom_data_class(self) -> str: ...
    @_property
    def data_classes(self) -> DataClasses: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def device_type(self) -> MobileBroadbandDeviceType: ...
    @_property
    def firmware_information(self) -> str: ...
    @_property
    def manufacturer(self) -> str: ...
    @_property
    def mobile_equipment_id(self) -> str: ...
    @_property
    def model(self) -> str: ...
    @_property
    def network_device_status(self) -> NetworkDeviceStatus: ...
    @_property
    def sim_icc_id(self) -> str: ...
    @_property
    def subscriber_id(self) -> str: ...
    @_property
    def telephone_numbers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def pin_manager(self) -> typing.Optional[MobileBroadbandPinManager]: ...
    @_property
    def revision(self) -> str: ...
    @_property
    def serial_number(self) -> str: ...
    @_property
    def sim_gid1(self) -> str: ...
    @_property
    def sim_pnn(self) -> str: ...
    @_property
    def sim_spn(self) -> str: ...
    @_property
    def slot_manager(self) -> typing.Optional[MobileBroadbandSlotManager]: ...

@typing.final
class MobileBroadbandDeviceService(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceService: ...
    def open_command_session(self) -> typing.Optional[MobileBroadbandDeviceServiceCommandSession]: ...
    def open_data_session(self) -> typing.Optional[MobileBroadbandDeviceServiceDataSession]: ...
    @_property
    def device_service_id(self) -> _uuid.UUID: ...
    @_property
    def supported_commands(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

@typing.final
class MobileBroadbandDeviceServiceCommandResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceCommandResult: ...
    @_property
    def response_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def status_code(self) -> winrt.system.UInt32: ...

@typing.final
class MobileBroadbandDeviceServiceCommandSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceCommandSession: ...
    def close_session(self) -> None: ...
    def send_query_command_async(self, command_id: winrt.system.UInt32, data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandDeviceServiceCommandResult]: ...
    def send_set_command_async(self, command_id: winrt.system.UInt32, data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandDeviceServiceCommandResult]: ...

@typing.final
class MobileBroadbandDeviceServiceDataReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceDataReceivedEventArgs: ...
    @_property
    def received_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...

@typing.final
class MobileBroadbandDeviceServiceDataSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceDataSession: ...
    def close_session(self) -> None: ...
    def write_data_async(self, value: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_data_received(self, event_handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandDeviceServiceDataSession, MobileBroadbandDeviceServiceDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_received(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class MobileBroadbandDeviceServiceInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceInformation: ...
    @_property
    def device_service_id(self) -> _uuid.UUID: ...
    @_property
    def is_data_read_supported(self) -> bool: ...
    @_property
    def is_data_write_supported(self) -> bool: ...

@typing.final
class MobileBroadbandDeviceServiceTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceTriggerDetails: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def device_service_id(self) -> _uuid.UUID: ...
    @_property
    def received_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def event_id(self) -> winrt.system.UInt32: ...

@typing.final
class MobileBroadbandModem_Static(type):
    def from_id(cls, device_id: str, /) -> typing.Optional[MobileBroadbandModem]: ...
    def get_default(cls) -> typing.Optional[MobileBroadbandModem]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class MobileBroadbandModem(winrt.system.Object, metaclass=MobileBroadbandModem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandModem: ...
    def get_current_configuration_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemConfiguration]: ...
    def get_device_service(self, device_service_id: _uuid.UUID, /) -> typing.Optional[MobileBroadbandDeviceService]: ...
    def get_is_passthrough_enabled(self, slotindex: winrt.system.Int32, /) -> bool: ...
    @typing.overload
    def get_is_passthrough_enabled_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def get_is_passthrough_enabled_async(self, slotindex: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def reset_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_is_passthrough_enabled(self, value: bool, slotindex: winrt.system.Int32, /) -> MobileBroadbandModemStatus: ...
    @typing.overload
    def set_is_passthrough_enabled_async(self, value: bool, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemStatus]: ...
    @typing.overload
    def set_is_passthrough_enabled_async(self, value: bool, slotindex: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemStatus]: ...
    def try_get_pco_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPco]: ...
    def add_is_in_emergency_call_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandModem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_in_emergency_call_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def current_account(self) -> typing.Optional[MobileBroadbandAccount]: ...
    @_property
    def current_network(self) -> typing.Optional[MobileBroadbandNetwork]: ...
    @_property
    def device_information(self) -> typing.Optional[MobileBroadbandDeviceInformation]: ...
    @_property
    def device_services(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandDeviceServiceInformation]]: ...
    @_property
    def is_reset_supported(self) -> bool: ...
    @_property
    def max_device_service_command_size_in_bytes(self) -> winrt.system.UInt32: ...
    @_property
    def max_device_service_data_size_in_bytes(self) -> winrt.system.UInt32: ...
    @_property
    def is_in_emergency_call_mode(self) -> bool: ...

@typing.final
class MobileBroadbandModemConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandModemConfiguration: ...
    @_property
    def home_provider_id(self) -> str: ...
    @_property
    def home_provider_name(self) -> str: ...
    @_property
    def uicc(self) -> typing.Optional[MobileBroadbandUicc]: ...
    @_property
    def sar_manager(self) -> typing.Optional[MobileBroadbandSarManager]: ...

@typing.final
class MobileBroadbandModemIsolation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandModemIsolation: ...
    def __new__(cls: typing.Type[MobileBroadbandModemIsolation], modem_device_id: str, rule_group_id: str) -> MobileBroadbandModemIsolation:...
    def add_allowed_host(self, host: typing.Optional[winrt.windows.networking.HostName], /) -> None: ...
    def add_allowed_host_range(self, first: typing.Optional[winrt.windows.networking.HostName], last: typing.Optional[winrt.windows.networking.HostName], /) -> None: ...
    def apply_configuration_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_configuration_async(self) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class MobileBroadbandNetwork(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandNetwork: ...
    def get_cells_info_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandCellsInfo]: ...
    def get_voice_call_support_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def show_connection_u_i(self) -> None: ...
    @_property
    def access_point_name(self) -> str: ...
    @_property
    def activation_network_error(self) -> winrt.system.UInt32: ...
    @_property
    def network_adapter(self) -> typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter]: ...
    @_property
    def network_registration_state(self) -> NetworkRegistrationState: ...
    @_property
    def packet_attach_network_error(self) -> winrt.system.UInt32: ...
    @_property
    def registered_data_class(self) -> DataClasses: ...
    @_property
    def registered_provider_id(self) -> str: ...
    @_property
    def registered_provider_name(self) -> str: ...
    @_property
    def registration_network_error(self) -> winrt.system.UInt32: ...
    @_property
    def registration_uicc_apps(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandUiccApp]]: ...

@typing.final
class MobileBroadbandNetworkRegistrationStateChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandNetworkRegistrationStateChange: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def network(self) -> typing.Optional[MobileBroadbandNetwork]: ...

@typing.final
class MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandNetworkRegistrationStateChangeTriggerDetails: ...
    @_property
    def network_registration_state_changes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandNetworkRegistrationStateChange]]: ...

@typing.final
class MobileBroadbandPco(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPco: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def is_complete(self) -> bool: ...

@typing.final
class MobileBroadbandPcoDataChangeTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPcoDataChangeTriggerDetails: ...
    @_property
    def updated_data(self) -> typing.Optional[MobileBroadbandPco]: ...

@typing.final
class MobileBroadbandPin(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPin: ...
    def change_async(self, current_pin: str, new_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def disable_async(self, current_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def enable_async(self, current_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def enter_async(self, current_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def unblock_async(self, pin_unblock_key: str, new_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    @_property
    def attempts_remaining(self) -> winrt.system.UInt32: ...
    @_property
    def enabled(self) -> bool: ...
    @_property
    def format(self) -> MobileBroadbandPinFormat: ...
    @_property
    def lock_state(self) -> MobileBroadbandPinLockState: ...
    @_property
    def max_length(self) -> winrt.system.UInt32: ...
    @_property
    def min_length(self) -> winrt.system.UInt32: ...
    @_property
    def type(self) -> MobileBroadbandPinType: ...

@typing.final
class MobileBroadbandPinLockStateChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinLockStateChange: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def pin_lock_state(self) -> MobileBroadbandPinLockState: ...
    @_property
    def pin_type(self) -> MobileBroadbandPinType: ...

@typing.final
class MobileBroadbandPinLockStateChangeTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinLockStateChangeTriggerDetails: ...
    @_property
    def pin_lock_state_changes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandPinLockStateChange]]: ...

@typing.final
class MobileBroadbandPinManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinManager: ...
    def get_pin(self, pin_type: MobileBroadbandPinType, /) -> typing.Optional[MobileBroadbandPin]: ...
    @_property
    def supported_pins(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandPinType]]: ...

@typing.final
class MobileBroadbandPinOperationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinOperationResult: ...
    @_property
    def attempts_remaining(self) -> winrt.system.UInt32: ...
    @_property
    def is_successful(self) -> bool: ...

@typing.final
class MobileBroadbandRadioStateChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRadioStateChange: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def radio_state(self) -> MobileBroadbandRadioState: ...

@typing.final
class MobileBroadbandRadioStateChangeTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRadioStateChangeTriggerDetails: ...
    @_property
    def radio_state_changes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandRadioStateChange]]: ...

@typing.final
class MobileBroadbandSarManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSarManager: ...
    def disable_backoff_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_backoff_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_is_transmitting_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def revert_sar_to_hardware_control_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_configuration_async(self, antennas: typing.Iterable[MobileBroadbandAntennaSar], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_transmission_state_changed_hysteresis_async(self, timer_period: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_transmission_state_monitoring(self) -> None: ...
    def stop_transmission_state_monitoring(self) -> None: ...
    def add_transmission_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandSarManager, MobileBroadbandTransmissionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transmission_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def antennas(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandAntennaSar]]: ...
    @_property
    def hysteresis_timer_period(self) -> datetime.timedelta: ...
    @_property
    def is_backoff_enabled(self) -> bool: ...
    @_property
    def is_sar_controlled_by_hardware(self) -> bool: ...
    @_property
    def is_wi_fi_hardware_integrated(self) -> bool: ...

@typing.final
class MobileBroadbandSlotInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSlotInfo: ...
    @_property
    def index(self) -> winrt.system.Int32: ...
    @_property
    def state(self) -> MobileBroadbandSlotState: ...
    @_property
    def icc_id(self) -> str: ...

@typing.final
class MobileBroadbandSlotInfoChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSlotInfoChangedEventArgs: ...
    @_property
    def slot_info(self) -> typing.Optional[MobileBroadbandSlotInfo]: ...

@typing.final
class MobileBroadbandSlotManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSlotManager: ...
    def set_current_slot(self, slot_index: winrt.system.Int32, /) -> MobileBroadbandModemStatus: ...
    def set_current_slot_async(self, slot_index: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemStatus]: ...
    def add_current_slot_index_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandSlotManager, MobileBroadbandCurrentSlotIndexChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_slot_index_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_slot_info_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandSlotManager, MobileBroadbandSlotInfoChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_slot_info_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def current_slot_index(self) -> winrt.system.Int32: ...
    @_property
    def slot_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandSlotInfo]]: ...

@typing.final
class MobileBroadbandTransmissionStateChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandTransmissionStateChangedEventArgs: ...
    @_property
    def is_transmitting(self) -> bool: ...

@typing.final
class MobileBroadbandUicc(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUicc: ...
    def get_uicc_apps_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandUiccAppsResult]: ...
    @_property
    def sim_icc_id(self) -> str: ...

@typing.final
class MobileBroadbandUiccApp(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccApp: ...
    def get_record_details_async(self, uicc_file_path: typing.Iterable[winrt.system.UInt32], /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandUiccAppRecordDetailsResult]: ...
    def read_record_async(self, uicc_file_path: typing.Iterable[winrt.system.UInt32], record_index: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandUiccAppReadRecordResult]: ...
    @_property
    def id(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def kind(self) -> UiccAppKind: ...

@typing.final
class MobileBroadbandUiccAppReadRecordResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccAppReadRecordResult: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def status(self) -> MobileBroadbandUiccAppOperationStatus: ...

@typing.final
class MobileBroadbandUiccAppRecordDetailsResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccAppRecordDetailsResult: ...
    @_property
    def kind(self) -> UiccAppRecordKind: ...
    @_property
    def read_access_condition(self) -> UiccAccessCondition: ...
    @_property
    def record_count(self) -> winrt.system.Int32: ...
    @_property
    def record_size(self) -> winrt.system.Int32: ...
    @_property
    def status(self) -> MobileBroadbandUiccAppOperationStatus: ...
    @_property
    def write_access_condition(self) -> UiccAccessCondition: ...

@typing.final
class MobileBroadbandUiccAppsResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccAppsResult: ...
    @_property
    def status(self) -> MobileBroadbandUiccAppOperationStatus: ...
    @_property
    def uicc_apps(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandUiccApp]]: ...

@typing.final
class NetworkOperatorDataUsageTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorDataUsageTriggerDetails: ...
    @_property
    def notification_kind(self) -> NetworkOperatorDataUsageNotificationKind: ...

@typing.final
class NetworkOperatorNotificationEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorNotificationEventDetails: ...
    def authorize_tethering(self, allow: bool, entitlement_failure_reason: str, /) -> None: ...
    @_property
    def encoding_type(self) -> winrt.system.UInt8: ...
    @_property
    def message(self) -> str: ...
    @_property
    def network_account_id(self) -> str: ...
    @_property
    def notification_type(self) -> NetworkOperatorEventMessageType: ...
    @_property
    def rule_id(self) -> str: ...
    @_property
    def sms_message(self) -> typing.Optional[winrt.windows.devices.sms.ISmsMessage]: ...

@typing.final
class NetworkOperatorTetheringAccessPointConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringAccessPointConfiguration: ...
    def __new__(cls: typing.Type[NetworkOperatorTetheringAccessPointConfiguration]) -> NetworkOperatorTetheringAccessPointConfiguration:...
    def is_band_supported(self, band: TetheringWiFiBand, /) -> bool: ...
    def is_band_supported_async(self, band: TetheringWiFiBand, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def ssid(self) -> str: ...
    @ssid.setter
    def ssid(self, value: str) -> None: ...
    @_property
    def passphrase(self) -> str: ...
    @passphrase.setter
    def passphrase(self, value: str) -> None: ...
    @_property
    def band(self) -> TetheringWiFiBand: ...
    @band.setter
    def band(self, value: TetheringWiFiBand) -> None: ...

@typing.final
class NetworkOperatorTetheringClient(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringClient: ...
    @_property
    def host_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName]]: ...
    @_property
    def mac_address(self) -> str: ...

@typing.final
class NetworkOperatorTetheringManager_Static(type):
    @typing.overload
    def create_from_connection_profile(cls, profile: typing.Optional[winrt.windows.networking.connectivity.ConnectionProfile], /) -> typing.Optional[NetworkOperatorTetheringManager]: ...
    @typing.overload
    def create_from_connection_profile(cls, profile: typing.Optional[winrt.windows.networking.connectivity.ConnectionProfile], adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter], /) -> typing.Optional[NetworkOperatorTetheringManager]: ...
    def create_from_network_account_id(cls, network_account_id: str, /) -> typing.Optional[NetworkOperatorTetheringManager]: ...
    def disable_no_connections_timeout(cls) -> None: ...
    def disable_no_connections_timeout_async(cls) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_no_connections_timeout(cls) -> None: ...
    def enable_no_connections_timeout_async(cls) -> winrt.windows.foundation.IAsyncAction: ...
    def get_tethering_capability(cls, network_account_id: str, /) -> TetheringCapability: ...
    def get_tethering_capability_from_connection_profile(cls, profile: typing.Optional[winrt.windows.networking.connectivity.ConnectionProfile], /) -> TetheringCapability: ...
    def is_no_connections_timeout_enabled(cls) -> bool: ...

@typing.final
class NetworkOperatorTetheringManager(winrt.system.Object, metaclass=NetworkOperatorTetheringManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringManager: ...
    def configure_access_point_async(self, configuration: typing.Optional[NetworkOperatorTetheringAccessPointConfiguration], /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_current_access_point_configuration(self) -> typing.Optional[NetworkOperatorTetheringAccessPointConfiguration]: ...
    def get_tethering_clients(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[NetworkOperatorTetheringClient]]: ...
    def start_tethering_async(self) -> winrt.windows.foundation.IAsyncOperation[NetworkOperatorTetheringOperationResult]: ...
    def stop_tethering_async(self) -> winrt.windows.foundation.IAsyncOperation[NetworkOperatorTetheringOperationResult]: ...
    @_property
    def client_count(self) -> winrt.system.UInt32: ...
    @_property
    def max_client_count(self) -> winrt.system.UInt32: ...
    @_property
    def tethering_operational_state(self) -> TetheringOperationalState: ...

@typing.final
class NetworkOperatorTetheringOperationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringOperationResult: ...
    @_property
    def additional_error_message(self) -> str: ...
    @_property
    def status(self) -> TetheringOperationStatus: ...

@typing.final
class ProvisionFromXmlDocumentResults(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisionFromXmlDocumentResults: ...
    @_property
    def all_elements_provisioned(self) -> bool: ...
    @_property
    def provision_results_xml(self) -> str: ...

@typing.final
class ProvisionedProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisionedProfile: ...
    def update_cost(self, value: winrt.windows.networking.connectivity.NetworkCostType, /) -> None: ...
    def update_usage(self, value: ProfileUsage, /) -> None: ...

@typing.final
class ProvisioningAgent_Static(type):
    def create_from_network_account_id(cls, network_account_id: str, /) -> typing.Optional[ProvisioningAgent]: ...

@typing.final
class ProvisioningAgent(winrt.system.Object, metaclass=ProvisioningAgent_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisioningAgent: ...
    def __new__(cls: typing.Type[ProvisioningAgent]) -> ProvisioningAgent:...
    def get_provisioned_profile(self, media_type: ProfileMediaType, profile_name: str, /) -> typing.Optional[ProvisionedProfile]: ...
    def provision_from_xml_document_async(self, provisioning_xml_document: str, /) -> winrt.windows.foundation.IAsyncOperation[ProvisionFromXmlDocumentResults]: ...

@typing.final
class TetheringEntitlementCheckTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TetheringEntitlementCheckTriggerDetails: ...
    def allow_tethering(self) -> None: ...
    def deny_tethering(self, entitlement_failure_reason: str, /) -> None: ...
    @_property
    def network_account_id(self) -> str: ...

@typing.final
class UssdMessage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UssdMessage: ...
    def __new__(cls: typing.Type[UssdMessage], message_text: str) -> UssdMessage:...
    def get_payload(self) -> winrt.system.UInt8: ...
    def set_payload(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    @_property
    def payload_as_text(self) -> str: ...
    @payload_as_text.setter
    def payload_as_text(self, value: str) -> None: ...
    @_property
    def data_coding_scheme(self) -> winrt.system.UInt8: ...
    @data_coding_scheme.setter
    def data_coding_scheme(self, value: winrt.system.UInt8) -> None: ...

@typing.final
class UssdReply(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UssdReply: ...
    @_property
    def message(self) -> typing.Optional[UssdMessage]: ...
    @_property
    def result_code(self) -> UssdResultCode: ...

@typing.final
class UssdSession_Static(type):
    def create_from_network_account_id(cls, network_account_id: str, /) -> typing.Optional[UssdSession]: ...
    def create_from_network_interface_id(cls, network_interface_id: str, /) -> typing.Optional[UssdSession]: ...

@typing.final
class UssdSession(winrt.system.Object, metaclass=UssdSession_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UssdSession: ...
    def close(self) -> None: ...
    def send_message_and_get_reply_async(self, message: typing.Optional[UssdMessage], /) -> winrt.windows.foundation.IAsyncOperation[UssdReply]: ...

