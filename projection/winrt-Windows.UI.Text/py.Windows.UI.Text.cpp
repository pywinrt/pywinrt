// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Text.h"

namespace py::cpp::Windows::UI::Text
{
    // ----- ContentLinkInfo class --------------------

    static PyObject* _new_ContentLinkInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Text::ContentLinkInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContentLinkInfo(py::wrapper::Windows::UI::Text::ContentLinkInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentLinkInfo_get_Uri(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_Uri(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_SecondaryText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"SecondaryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecondaryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_SecondaryText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"SecondaryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SecondaryText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_LinkContentKind(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"LinkContentKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinkContentKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_LinkContentKind(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"LinkContentKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LinkContentKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_Id(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_Id(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_DisplayText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"DisplayText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_DisplayText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ContentLinkInfo", L"DisplayText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContentLinkInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::ContentLinkInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentLinkInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ContentLinkInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentLinkInfo[] = {
        { "_assign_array_", _assign_array_ContentLinkInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentLinkInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentLinkInfo[] = {
        { "uri", reinterpret_cast<getter>(ContentLinkInfo_get_Uri), reinterpret_cast<setter>(ContentLinkInfo_put_Uri), nullptr, nullptr },
        { "secondary_text", reinterpret_cast<getter>(ContentLinkInfo_get_SecondaryText), reinterpret_cast<setter>(ContentLinkInfo_put_SecondaryText), nullptr, nullptr },
        { "link_content_kind", reinterpret_cast<getter>(ContentLinkInfo_get_LinkContentKind), reinterpret_cast<setter>(ContentLinkInfo_put_LinkContentKind), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContentLinkInfo_get_Id), reinterpret_cast<setter>(ContentLinkInfo_put_Id), nullptr, nullptr },
        { "display_text", reinterpret_cast<getter>(ContentLinkInfo_get_DisplayText), reinterpret_cast<setter>(ContentLinkInfo_put_DisplayText), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentLinkInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentLinkInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentLinkInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentLinkInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentLinkInfo) },
        { }
    };

    static PyType_Spec type_spec_ContentLinkInfo = {
        "winrt._winrt_windows_ui_text.ContentLinkInfo",
        sizeof(py::wrapper::Windows::UI::Text::ContentLinkInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentLinkInfo};

    // ----- FontWeights class --------------------

    static PyObject* _new_FontWeights(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::FontWeights>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::FontWeights>::type_name);
        return nullptr;
    }

    static void _dealloc_FontWeights(py::wrapper::Windows::UI::Text::FontWeights* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FontWeights_get_Black(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"Black");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::Black());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Bold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"Bold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_ExtraBlack(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"ExtraBlack");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::ExtraBlack());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_ExtraBold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"ExtraBold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::ExtraBold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_ExtraLight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"ExtraLight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::ExtraLight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Light(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"Light");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::Light());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Medium(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"Medium");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::Medium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Normal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"Normal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::Normal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_SemiBold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"SemiBold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::SemiBold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_SemiLight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"SemiLight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::SemiLight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Thin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.FontWeights", L"Thin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::FontWeights::Thin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FontWeights(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::FontWeights>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FontWeights(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::FontWeights>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FontWeights[] = {
        { "_assign_array_", _assign_array_FontWeights, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FontWeights), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FontWeights[] = {
        { }
    };

    static PyType_Slot _type_slots_FontWeights[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FontWeights) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FontWeights) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FontWeights) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FontWeights) },
        { }
    };

    static PyType_Spec type_spec_FontWeights = {
        "winrt._winrt_windows_ui_text.FontWeights",
        sizeof(py::wrapper::Windows::UI::Text::FontWeights),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FontWeights};

    static PyGetSetDef getset_FontWeights_Static[] = {
        { "black", reinterpret_cast<getter>(FontWeights_get_Black), nullptr, nullptr, nullptr },
        { "bold", reinterpret_cast<getter>(FontWeights_get_Bold), nullptr, nullptr, nullptr },
        { "extra_black", reinterpret_cast<getter>(FontWeights_get_ExtraBlack), nullptr, nullptr, nullptr },
        { "extra_bold", reinterpret_cast<getter>(FontWeights_get_ExtraBold), nullptr, nullptr, nullptr },
        { "extra_light", reinterpret_cast<getter>(FontWeights_get_ExtraLight), nullptr, nullptr, nullptr },
        { "light", reinterpret_cast<getter>(FontWeights_get_Light), nullptr, nullptr, nullptr },
        { "medium", reinterpret_cast<getter>(FontWeights_get_Medium), nullptr, nullptr, nullptr },
        { "normal", reinterpret_cast<getter>(FontWeights_get_Normal), nullptr, nullptr, nullptr },
        { "semi_bold", reinterpret_cast<getter>(FontWeights_get_SemiBold), nullptr, nullptr, nullptr },
        { "semi_light", reinterpret_cast<getter>(FontWeights_get_SemiLight), nullptr, nullptr, nullptr },
        { "thin", reinterpret_cast<getter>(FontWeights_get_Thin), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FontWeights_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FontWeights_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FontWeights_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FontWeights_Static) },
        { }
    };

    static PyType_Spec type_spec_FontWeights_Static =
    {
        "winrt._winrt_windows_ui_text.FontWeights_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FontWeights_Static
    };

    // ----- RichEditTextDocument class --------------------

    static PyObject* _new_RichEditTextDocument(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::RichEditTextDocument>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::RichEditTextDocument>::type_name);
        return nullptr;
    }

    static void _dealloc_RichEditTextDocument(py::wrapper::Windows::UI::Text::RichEditTextDocument* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RichEditTextDocument_ApplyDisplayUpdates(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"ApplyDisplayUpdates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ApplyDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_BatchDisplayUpdates(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"BatchDisplayUpdates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BatchDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_BeginUndoGroup(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"BeginUndoGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.BeginUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanCopy(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"CanCopy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanCopy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanPaste(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"CanPaste", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanPaste());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanRedo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"CanRedo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanRedo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanUndo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"CanUndo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanUndo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_ClearUndoRedoHistory(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"ClearUndoRedoHistory", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ClearUndoRedoHistory();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_EndUndoGroup(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"EndUndoGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.EndUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"GetDefaultCharacterFormat", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDefaultCharacterFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"GetDefaultParagraphFormat", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDefaultParagraphFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetMath(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"GetMath", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::hstring param0{};

                self->obj.GetMath(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetRange(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"GetRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetRange(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetRangeFromPoint(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"GetRangeFromPoint", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);

                return py::convert(self->obj.GetRangeFromPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetText(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1{};

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_LoadFromStream(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"LoadFromStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.LoadFromStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_Redo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"Redo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Redo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SaveToStream(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"SaveToStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SaveToStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"SetDefaultCharacterFormat", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                self->obj.SetDefaultCharacterFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"SetDefaultParagraphFormat", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                self->obj.SetDefaultParagraphFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetMath(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"SetMath", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetMath(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetMathMode(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"SetMathMode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::RichEditMathMode>(args, 0);

                self->obj.SetMathMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetText(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"SetText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_Undo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextDocument", L"Undo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Undo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_get_UndoLimit(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"UndoLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UndoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_UndoLimit(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"UndoLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.UndoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_DefaultTabStop(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"DefaultTabStop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultTabStop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_DefaultTabStop(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"DefaultTabStop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.DefaultTabStop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_CaretType(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"CaretType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaretType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_CaretType(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"CaretType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::CaretType>(arg);

            self->obj.CaretType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_Selection(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"Selection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_get_IgnoreTrailingCharacterSpacing(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"IgnoreTrailingCharacterSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnoreTrailingCharacterSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_IgnoreTrailingCharacterSpacing(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"IgnoreTrailingCharacterSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTrailingCharacterSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_AlignmentIncludesTrailingWhitespace(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"AlignmentIncludesTrailingWhitespace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlignmentIncludesTrailingWhitespace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_AlignmentIncludesTrailingWhitespace(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextDocument", L"AlignmentIncludesTrailingWhitespace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlignmentIncludesTrailingWhitespace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RichEditTextDocument(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::RichEditTextDocument>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichEditTextDocument(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::RichEditTextDocument>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditTextDocument[] = {
        { "apply_display_updates", reinterpret_cast<PyCFunction>(RichEditTextDocument_ApplyDisplayUpdates), METH_VARARGS, nullptr },
        { "batch_display_updates", reinterpret_cast<PyCFunction>(RichEditTextDocument_BatchDisplayUpdates), METH_VARARGS, nullptr },
        { "begin_undo_group", reinterpret_cast<PyCFunction>(RichEditTextDocument_BeginUndoGroup), METH_VARARGS, nullptr },
        { "can_copy", reinterpret_cast<PyCFunction>(RichEditTextDocument_CanCopy), METH_VARARGS, nullptr },
        { "can_paste", reinterpret_cast<PyCFunction>(RichEditTextDocument_CanPaste), METH_VARARGS, nullptr },
        { "can_redo", reinterpret_cast<PyCFunction>(RichEditTextDocument_CanRedo), METH_VARARGS, nullptr },
        { "can_undo", reinterpret_cast<PyCFunction>(RichEditTextDocument_CanUndo), METH_VARARGS, nullptr },
        { "clear_undo_redo_history", reinterpret_cast<PyCFunction>(RichEditTextDocument_ClearUndoRedoHistory), METH_VARARGS, nullptr },
        { "end_undo_group", reinterpret_cast<PyCFunction>(RichEditTextDocument_EndUndoGroup), METH_VARARGS, nullptr },
        { "get_default_character_format", reinterpret_cast<PyCFunction>(RichEditTextDocument_GetDefaultCharacterFormat), METH_VARARGS, nullptr },
        { "get_default_paragraph_format", reinterpret_cast<PyCFunction>(RichEditTextDocument_GetDefaultParagraphFormat), METH_VARARGS, nullptr },
        { "get_math", reinterpret_cast<PyCFunction>(RichEditTextDocument_GetMath), METH_VARARGS, nullptr },
        { "get_range", reinterpret_cast<PyCFunction>(RichEditTextDocument_GetRange), METH_VARARGS, nullptr },
        { "get_range_from_point", reinterpret_cast<PyCFunction>(RichEditTextDocument_GetRangeFromPoint), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(RichEditTextDocument_GetText), METH_VARARGS, nullptr },
        { "load_from_stream", reinterpret_cast<PyCFunction>(RichEditTextDocument_LoadFromStream), METH_VARARGS, nullptr },
        { "redo", reinterpret_cast<PyCFunction>(RichEditTextDocument_Redo), METH_VARARGS, nullptr },
        { "save_to_stream", reinterpret_cast<PyCFunction>(RichEditTextDocument_SaveToStream), METH_VARARGS, nullptr },
        { "set_default_character_format", reinterpret_cast<PyCFunction>(RichEditTextDocument_SetDefaultCharacterFormat), METH_VARARGS, nullptr },
        { "set_default_paragraph_format", reinterpret_cast<PyCFunction>(RichEditTextDocument_SetDefaultParagraphFormat), METH_VARARGS, nullptr },
        { "set_math", reinterpret_cast<PyCFunction>(RichEditTextDocument_SetMath), METH_VARARGS, nullptr },
        { "set_math_mode", reinterpret_cast<PyCFunction>(RichEditTextDocument_SetMathMode), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(RichEditTextDocument_SetText), METH_VARARGS, nullptr },
        { "undo", reinterpret_cast<PyCFunction>(RichEditTextDocument_Undo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RichEditTextDocument, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichEditTextDocument), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichEditTextDocument[] = {
        { "undo_limit", reinterpret_cast<getter>(RichEditTextDocument_get_UndoLimit), reinterpret_cast<setter>(RichEditTextDocument_put_UndoLimit), nullptr, nullptr },
        { "default_tab_stop", reinterpret_cast<getter>(RichEditTextDocument_get_DefaultTabStop), reinterpret_cast<setter>(RichEditTextDocument_put_DefaultTabStop), nullptr, nullptr },
        { "caret_type", reinterpret_cast<getter>(RichEditTextDocument_get_CaretType), reinterpret_cast<setter>(RichEditTextDocument_put_CaretType), nullptr, nullptr },
        { "selection", reinterpret_cast<getter>(RichEditTextDocument_get_Selection), nullptr, nullptr, nullptr },
        { "ignore_trailing_character_spacing", reinterpret_cast<getter>(RichEditTextDocument_get_IgnoreTrailingCharacterSpacing), reinterpret_cast<setter>(RichEditTextDocument_put_IgnoreTrailingCharacterSpacing), nullptr, nullptr },
        { "alignment_includes_trailing_whitespace", reinterpret_cast<getter>(RichEditTextDocument_get_AlignmentIncludesTrailingWhitespace), reinterpret_cast<setter>(RichEditTextDocument_put_AlignmentIncludesTrailingWhitespace), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RichEditTextDocument[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichEditTextDocument) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichEditTextDocument) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichEditTextDocument) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichEditTextDocument) },
        { }
    };

    static PyType_Spec type_spec_RichEditTextDocument = {
        "winrt._winrt_windows_ui_text.RichEditTextDocument",
        sizeof(py::wrapper::Windows::UI::Text::RichEditTextDocument),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditTextDocument};

    // ----- RichEditTextRange class --------------------

    static PyObject* _new_RichEditTextRange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::RichEditTextRange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::RichEditTextRange>::type_name);
        return nullptr;
    }

    static void _dealloc_RichEditTextRange(py::wrapper::Windows::UI::Text::RichEditTextRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RichEditTextRange_CanPaste(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"CanPaste", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CanPaste(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_ChangeCase(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"ChangeCase", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::LetterCase>(args, 0);

                self->obj.ChangeCase(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Collapse(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Collapse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Collapse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Copy(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Copy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Copy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Cut(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Cut", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cut();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Delete(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Delete", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Delete(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_EndOf(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"EndOf", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Expand(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Expand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.Expand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_FindText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"FindText", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::FindOptions>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetCharacterUtf32(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetCharacterUtf32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                uint32_t param0{};
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.GetCharacterUtf32(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetClone(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetClone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetIndex(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.GetIndex(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetPoint(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::HorizontalCharacterAlignment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 2);
                winrt::Windows::Foundation::Point param3{};

                self->obj.GetPoint(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetRect(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetRect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);
                winrt::Windows::Foundation::Rect param1{};
                int32_t param2{};

                self->obj.GetRect(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1{};

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetTextViaStream(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"GetTextViaStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.GetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_InRange(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"InRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_InStory(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"InStory", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InStory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_InsertImage(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"InsertImage", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 5);

                self->obj.InsertImage(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_IsEqual(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_MatchSelection(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"MatchSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MatchSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Move(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_MoveEnd(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"MoveEnd", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveEnd(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_MoveStart(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"MoveStart", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Paste(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"Paste", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Paste(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_ScrollIntoView(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetIndex(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"SetIndex", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetIndex(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetPoint(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"SetPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetRange(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"SetRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.SetRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"SetText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetTextViaStream(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"SetTextViaStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_StartOf(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.RichEditTextRange", L"StartOf", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StartOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_get_ContentLinkInfo(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"ContentLinkInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentLinkInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_ContentLinkInfo(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"ContentLinkInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ContentLinkInfo>(arg);

            self->obj.ContentLinkInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Text(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Text(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_StartPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_StartPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_ParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"ParagraphFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParagraphFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_ParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"ParagraphFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(arg);

            self->obj.ParagraphFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Link(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Link");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Link());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Link(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Link");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Link(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Gravity(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Gravity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Gravity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Gravity(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Gravity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::RangeGravity>(arg);

            self->obj.Gravity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_FormattedText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"FormattedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FormattedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_FormattedText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"FormattedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(arg);

            self->obj.FormattedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_EndPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"EndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_EndPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"EndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.EndPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_CharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"CharacterFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_CharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"CharacterFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(arg);

            self->obj.CharacterFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Character(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Character(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<char16_t>(arg);

            self->obj.Character(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Length(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_get_StoryLength(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.RichEditTextRange", L"StoryLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StoryLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RichEditTextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::RichEditTextRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichEditTextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::RichEditTextRange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditTextRange[] = {
        { "can_paste", reinterpret_cast<PyCFunction>(RichEditTextRange_CanPaste), METH_VARARGS, nullptr },
        { "change_case", reinterpret_cast<PyCFunction>(RichEditTextRange_ChangeCase), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(RichEditTextRange_Collapse), METH_VARARGS, nullptr },
        { "copy", reinterpret_cast<PyCFunction>(RichEditTextRange_Copy), METH_VARARGS, nullptr },
        { "cut", reinterpret_cast<PyCFunction>(RichEditTextRange_Cut), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(RichEditTextRange_Delete), METH_VARARGS, nullptr },
        { "end_of", reinterpret_cast<PyCFunction>(RichEditTextRange_EndOf), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(RichEditTextRange_Expand), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(RichEditTextRange_FindText), METH_VARARGS, nullptr },
        { "get_character_utf32", reinterpret_cast<PyCFunction>(RichEditTextRange_GetCharacterUtf32), METH_VARARGS, nullptr },
        { "get_clone", reinterpret_cast<PyCFunction>(RichEditTextRange_GetClone), METH_VARARGS, nullptr },
        { "get_index", reinterpret_cast<PyCFunction>(RichEditTextRange_GetIndex), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(RichEditTextRange_GetPoint), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(RichEditTextRange_GetRect), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(RichEditTextRange_GetText), METH_VARARGS, nullptr },
        { "get_text_via_stream", reinterpret_cast<PyCFunction>(RichEditTextRange_GetTextViaStream), METH_VARARGS, nullptr },
        { "in_range", reinterpret_cast<PyCFunction>(RichEditTextRange_InRange), METH_VARARGS, nullptr },
        { "in_story", reinterpret_cast<PyCFunction>(RichEditTextRange_InStory), METH_VARARGS, nullptr },
        { "insert_image", reinterpret_cast<PyCFunction>(RichEditTextRange_InsertImage), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(RichEditTextRange_IsEqual), METH_VARARGS, nullptr },
        { "match_selection", reinterpret_cast<PyCFunction>(RichEditTextRange_MatchSelection), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(RichEditTextRange_Move), METH_VARARGS, nullptr },
        { "move_end", reinterpret_cast<PyCFunction>(RichEditTextRange_MoveEnd), METH_VARARGS, nullptr },
        { "move_start", reinterpret_cast<PyCFunction>(RichEditTextRange_MoveStart), METH_VARARGS, nullptr },
        { "paste", reinterpret_cast<PyCFunction>(RichEditTextRange_Paste), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(RichEditTextRange_ScrollIntoView), METH_VARARGS, nullptr },
        { "set_index", reinterpret_cast<PyCFunction>(RichEditTextRange_SetIndex), METH_VARARGS, nullptr },
        { "set_point", reinterpret_cast<PyCFunction>(RichEditTextRange_SetPoint), METH_VARARGS, nullptr },
        { "set_range", reinterpret_cast<PyCFunction>(RichEditTextRange_SetRange), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(RichEditTextRange_SetText), METH_VARARGS, nullptr },
        { "set_text_via_stream", reinterpret_cast<PyCFunction>(RichEditTextRange_SetTextViaStream), METH_VARARGS, nullptr },
        { "start_of", reinterpret_cast<PyCFunction>(RichEditTextRange_StartOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RichEditTextRange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichEditTextRange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichEditTextRange[] = {
        { "content_link_info", reinterpret_cast<getter>(RichEditTextRange_get_ContentLinkInfo), reinterpret_cast<setter>(RichEditTextRange_put_ContentLinkInfo), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(RichEditTextRange_get_Text), reinterpret_cast<setter>(RichEditTextRange_put_Text), nullptr, nullptr },
        { "start_position", reinterpret_cast<getter>(RichEditTextRange_get_StartPosition), reinterpret_cast<setter>(RichEditTextRange_put_StartPosition), nullptr, nullptr },
        { "paragraph_format", reinterpret_cast<getter>(RichEditTextRange_get_ParagraphFormat), reinterpret_cast<setter>(RichEditTextRange_put_ParagraphFormat), nullptr, nullptr },
        { "link", reinterpret_cast<getter>(RichEditTextRange_get_Link), reinterpret_cast<setter>(RichEditTextRange_put_Link), nullptr, nullptr },
        { "gravity", reinterpret_cast<getter>(RichEditTextRange_get_Gravity), reinterpret_cast<setter>(RichEditTextRange_put_Gravity), nullptr, nullptr },
        { "formatted_text", reinterpret_cast<getter>(RichEditTextRange_get_FormattedText), reinterpret_cast<setter>(RichEditTextRange_put_FormattedText), nullptr, nullptr },
        { "end_position", reinterpret_cast<getter>(RichEditTextRange_get_EndPosition), reinterpret_cast<setter>(RichEditTextRange_put_EndPosition), nullptr, nullptr },
        { "character_format", reinterpret_cast<getter>(RichEditTextRange_get_CharacterFormat), reinterpret_cast<setter>(RichEditTextRange_put_CharacterFormat), nullptr, nullptr },
        { "character", reinterpret_cast<getter>(RichEditTextRange_get_Character), reinterpret_cast<setter>(RichEditTextRange_put_Character), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(RichEditTextRange_get_Length), nullptr, nullptr, nullptr },
        { "story_length", reinterpret_cast<getter>(RichEditTextRange_get_StoryLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RichEditTextRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichEditTextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichEditTextRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichEditTextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichEditTextRange) },
        { }
    };

    static PyType_Spec type_spec_RichEditTextRange = {
        "winrt._winrt_windows_ui_text.RichEditTextRange",
        sizeof(py::wrapper::Windows::UI::Text::RichEditTextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditTextRange};

    // ----- TextConstants class --------------------

    static PyObject* _new_TextConstants(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::TextConstants>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::TextConstants>::type_name);
        return nullptr;
    }

    static PyObject* TextConstants_get_AutoColor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"AutoColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::AutoColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_MaxUnitCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"MaxUnitCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::MaxUnitCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_MinUnitCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"MinUnitCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::MinUnitCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedColor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"UndefinedColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedFloatValue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"UndefinedFloatValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedFloatValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedFontStretch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"UndefinedFontStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedFontStretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedFontStyle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"UndefinedFontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedFontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedInt32Value(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.TextConstants", L"UndefinedInt32Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedInt32Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextConstants[] = {
        { }
    };

    static PyGetSetDef _getset_TextConstants[] = {
        { }
    };

    static PyType_Slot _type_slots_TextConstants[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextConstants) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextConstants) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextConstants) },
        { }
    };

    static PyType_Spec type_spec_TextConstants = {
        "winrt._winrt_windows_ui_text.TextConstants",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextConstants};

    static PyGetSetDef getset_TextConstants_Static[] = {
        { "auto_color", reinterpret_cast<getter>(TextConstants_get_AutoColor), nullptr, nullptr, nullptr },
        { "max_unit_count", reinterpret_cast<getter>(TextConstants_get_MaxUnitCount), nullptr, nullptr, nullptr },
        { "min_unit_count", reinterpret_cast<getter>(TextConstants_get_MinUnitCount), nullptr, nullptr, nullptr },
        { "undefined_color", reinterpret_cast<getter>(TextConstants_get_UndefinedColor), nullptr, nullptr, nullptr },
        { "undefined_float_value", reinterpret_cast<getter>(TextConstants_get_UndefinedFloatValue), nullptr, nullptr, nullptr },
        { "undefined_font_stretch", reinterpret_cast<getter>(TextConstants_get_UndefinedFontStretch), nullptr, nullptr, nullptr },
        { "undefined_font_style", reinterpret_cast<getter>(TextConstants_get_UndefinedFontStyle), nullptr, nullptr, nullptr },
        { "undefined_int32_value", reinterpret_cast<getter>(TextConstants_get_UndefinedInt32Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TextConstants_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextConstants_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextConstants_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextConstants_Static) },
        { }
    };

    static PyType_Spec type_spec_TextConstants_Static =
    {
        "winrt._winrt_windows_ui_text.TextConstants_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TextConstants_Static
    };

    // ----- ITextCharacterFormat interface --------------------

    static PyObject* _new_ITextCharacterFormat(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::ITextCharacterFormat>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::ITextCharacterFormat>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextCharacterFormat(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextCharacterFormat_GetClone(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextCharacterFormat", L"GetClone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_IsEqual(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextCharacterFormat", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_SetClone(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextCharacterFormat", L"SetClone", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                self->obj.SetClone(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_get_AllCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"AllCaps");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllCaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_AllCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"AllCaps");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.AllCaps(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_BackgroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_BackgroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Bold(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Bold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Bold(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Bold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Bold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_FontStretch(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"FontStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontStretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_FontStretch(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"FontStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStretch>(arg);

            self->obj.FontStretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_FontStyle(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_FontStyle(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_ForegroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_ForegroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Hidden(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Hidden");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Hidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Hidden(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Hidden");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Hidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Italic(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Italic");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Italic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Italic(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Italic");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Italic(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Kerning(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Kerning");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kerning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Kerning(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Kerning");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Kerning(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_LanguageTag(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"LanguageTag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LanguageTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_LanguageTag(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"LanguageTag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LanguageTag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_LinkType(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"LinkType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinkType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_get_Name(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Name(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Outline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Outline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Outline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Outline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Outline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Outline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Position(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Position(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_ProtectedText(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"ProtectedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_ProtectedText(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"ProtectedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.ProtectedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Size(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Size(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_SmallCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"SmallCaps");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmallCaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_SmallCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"SmallCaps");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.SmallCaps(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Spacing(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Spacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Spacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Spacing(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Spacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Spacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Strikethrough(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Strikethrough");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Strikethrough());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Strikethrough(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Strikethrough");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Strikethrough(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Subscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Subscript");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Subscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Subscript");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Subscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Superscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Superscript");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Superscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Superscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Superscript");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Superscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_TextScript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"TextScript");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextScript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_TextScript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"TextScript");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::TextScript>(arg);

            self->obj.TextScript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Underline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Underline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Underline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Underline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Underline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::UnderlineType>(arg);

            self->obj.Underline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Weight(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Weight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Weight(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextCharacterFormat", L"Weight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Weight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ITextCharacterFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::ITextCharacterFormat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextCharacterFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextCharacterFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextCharacterFormat[] = {
        { "get_clone", reinterpret_cast<PyCFunction>(ITextCharacterFormat_GetClone), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(ITextCharacterFormat_IsEqual), METH_VARARGS, nullptr },
        { "set_clone", reinterpret_cast<PyCFunction>(ITextCharacterFormat_SetClone), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextCharacterFormat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextCharacterFormat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextCharacterFormat[] = {
        { "all_caps", reinterpret_cast<getter>(ITextCharacterFormat_get_AllCaps), reinterpret_cast<setter>(ITextCharacterFormat_put_AllCaps), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(ITextCharacterFormat_get_BackgroundColor), reinterpret_cast<setter>(ITextCharacterFormat_put_BackgroundColor), nullptr, nullptr },
        { "bold", reinterpret_cast<getter>(ITextCharacterFormat_get_Bold), reinterpret_cast<setter>(ITextCharacterFormat_put_Bold), nullptr, nullptr },
        { "font_stretch", reinterpret_cast<getter>(ITextCharacterFormat_get_FontStretch), reinterpret_cast<setter>(ITextCharacterFormat_put_FontStretch), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(ITextCharacterFormat_get_FontStyle), reinterpret_cast<setter>(ITextCharacterFormat_put_FontStyle), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(ITextCharacterFormat_get_ForegroundColor), reinterpret_cast<setter>(ITextCharacterFormat_put_ForegroundColor), nullptr, nullptr },
        { "hidden", reinterpret_cast<getter>(ITextCharacterFormat_get_Hidden), reinterpret_cast<setter>(ITextCharacterFormat_put_Hidden), nullptr, nullptr },
        { "italic", reinterpret_cast<getter>(ITextCharacterFormat_get_Italic), reinterpret_cast<setter>(ITextCharacterFormat_put_Italic), nullptr, nullptr },
        { "kerning", reinterpret_cast<getter>(ITextCharacterFormat_get_Kerning), reinterpret_cast<setter>(ITextCharacterFormat_put_Kerning), nullptr, nullptr },
        { "language_tag", reinterpret_cast<getter>(ITextCharacterFormat_get_LanguageTag), reinterpret_cast<setter>(ITextCharacterFormat_put_LanguageTag), nullptr, nullptr },
        { "link_type", reinterpret_cast<getter>(ITextCharacterFormat_get_LinkType), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ITextCharacterFormat_get_Name), reinterpret_cast<setter>(ITextCharacterFormat_put_Name), nullptr, nullptr },
        { "outline", reinterpret_cast<getter>(ITextCharacterFormat_get_Outline), reinterpret_cast<setter>(ITextCharacterFormat_put_Outline), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ITextCharacterFormat_get_Position), reinterpret_cast<setter>(ITextCharacterFormat_put_Position), nullptr, nullptr },
        { "protected_text", reinterpret_cast<getter>(ITextCharacterFormat_get_ProtectedText), reinterpret_cast<setter>(ITextCharacterFormat_put_ProtectedText), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ITextCharacterFormat_get_Size), reinterpret_cast<setter>(ITextCharacterFormat_put_Size), nullptr, nullptr },
        { "small_caps", reinterpret_cast<getter>(ITextCharacterFormat_get_SmallCaps), reinterpret_cast<setter>(ITextCharacterFormat_put_SmallCaps), nullptr, nullptr },
        { "spacing", reinterpret_cast<getter>(ITextCharacterFormat_get_Spacing), reinterpret_cast<setter>(ITextCharacterFormat_put_Spacing), nullptr, nullptr },
        { "strikethrough", reinterpret_cast<getter>(ITextCharacterFormat_get_Strikethrough), reinterpret_cast<setter>(ITextCharacterFormat_put_Strikethrough), nullptr, nullptr },
        { "subscript", reinterpret_cast<getter>(ITextCharacterFormat_get_Subscript), reinterpret_cast<setter>(ITextCharacterFormat_put_Subscript), nullptr, nullptr },
        { "superscript", reinterpret_cast<getter>(ITextCharacterFormat_get_Superscript), reinterpret_cast<setter>(ITextCharacterFormat_put_Superscript), nullptr, nullptr },
        { "text_script", reinterpret_cast<getter>(ITextCharacterFormat_get_TextScript), reinterpret_cast<setter>(ITextCharacterFormat_put_TextScript), nullptr, nullptr },
        { "underline", reinterpret_cast<getter>(ITextCharacterFormat_get_Underline), reinterpret_cast<setter>(ITextCharacterFormat_put_Underline), nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(ITextCharacterFormat_get_Weight), reinterpret_cast<setter>(ITextCharacterFormat_put_Weight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextCharacterFormat[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextCharacterFormat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextCharacterFormat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextCharacterFormat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextCharacterFormat) },
        { }
    };

    static PyType_Spec type_spec_ITextCharacterFormat = {
        "winrt._winrt_windows_ui_text.ITextCharacterFormat",
        sizeof(py::wrapper::Windows::UI::Text::ITextCharacterFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextCharacterFormat};

    static PyType_Slot type_slots_ImplementsITextCharacterFormat[] = {
        { }
    };

    static PyType_Spec type_spec_ImplementsITextCharacterFormat = {
        "winrt._winrt_windows_ui_text.ImplementsITextCharacterFormat",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextCharacterFormat};

    // ----- ITextDocument interface --------------------

    static PyObject* _new_ITextDocument(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::ITextDocument>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::ITextDocument>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextDocument(py::wrapper::Windows::UI::Text::ITextDocument* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextDocument_ApplyDisplayUpdates(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"ApplyDisplayUpdates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ApplyDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_BatchDisplayUpdates(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"BatchDisplayUpdates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BatchDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_BeginUndoGroup(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"BeginUndoGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.BeginUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanCopy(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"CanCopy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanCopy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanPaste(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"CanPaste", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanPaste());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanRedo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"CanRedo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanRedo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanUndo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"CanUndo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanUndo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_EndUndoGroup(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"EndUndoGroup", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.EndUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"GetDefaultCharacterFormat", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDefaultCharacterFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"GetDefaultParagraphFormat", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDefaultParagraphFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetRange(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"GetRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetRange(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetRangeFromPoint(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"GetRangeFromPoint", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);

                return py::convert(self->obj.GetRangeFromPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetText(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1{};

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_LoadFromStream(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"LoadFromStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.LoadFromStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_Redo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"Redo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Redo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SaveToStream(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"SaveToStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SaveToStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"SetDefaultCharacterFormat", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                self->obj.SetDefaultCharacterFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"SetDefaultParagraphFormat", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                self->obj.SetDefaultParagraphFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SetText(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"SetText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_Undo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextDocument", L"Undo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Undo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_get_CaretType(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"CaretType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaretType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextDocument_put_CaretType(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"CaretType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::CaretType>(arg);

            self->obj.CaretType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextDocument_get_DefaultTabStop(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"DefaultTabStop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultTabStop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextDocument_put_DefaultTabStop(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"DefaultTabStop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.DefaultTabStop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextDocument_get_Selection(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"Selection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextDocument_get_UndoLimit(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"UndoLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UndoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextDocument_put_UndoLimit(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextDocument", L"UndoLimit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.UndoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ITextDocument(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::ITextDocument>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextDocument(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextDocument>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextDocument[] = {
        { "apply_display_updates", reinterpret_cast<PyCFunction>(ITextDocument_ApplyDisplayUpdates), METH_VARARGS, nullptr },
        { "batch_display_updates", reinterpret_cast<PyCFunction>(ITextDocument_BatchDisplayUpdates), METH_VARARGS, nullptr },
        { "begin_undo_group", reinterpret_cast<PyCFunction>(ITextDocument_BeginUndoGroup), METH_VARARGS, nullptr },
        { "can_copy", reinterpret_cast<PyCFunction>(ITextDocument_CanCopy), METH_VARARGS, nullptr },
        { "can_paste", reinterpret_cast<PyCFunction>(ITextDocument_CanPaste), METH_VARARGS, nullptr },
        { "can_redo", reinterpret_cast<PyCFunction>(ITextDocument_CanRedo), METH_VARARGS, nullptr },
        { "can_undo", reinterpret_cast<PyCFunction>(ITextDocument_CanUndo), METH_VARARGS, nullptr },
        { "end_undo_group", reinterpret_cast<PyCFunction>(ITextDocument_EndUndoGroup), METH_VARARGS, nullptr },
        { "get_default_character_format", reinterpret_cast<PyCFunction>(ITextDocument_GetDefaultCharacterFormat), METH_VARARGS, nullptr },
        { "get_default_paragraph_format", reinterpret_cast<PyCFunction>(ITextDocument_GetDefaultParagraphFormat), METH_VARARGS, nullptr },
        { "get_range", reinterpret_cast<PyCFunction>(ITextDocument_GetRange), METH_VARARGS, nullptr },
        { "get_range_from_point", reinterpret_cast<PyCFunction>(ITextDocument_GetRangeFromPoint), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextDocument_GetText), METH_VARARGS, nullptr },
        { "load_from_stream", reinterpret_cast<PyCFunction>(ITextDocument_LoadFromStream), METH_VARARGS, nullptr },
        { "redo", reinterpret_cast<PyCFunction>(ITextDocument_Redo), METH_VARARGS, nullptr },
        { "save_to_stream", reinterpret_cast<PyCFunction>(ITextDocument_SaveToStream), METH_VARARGS, nullptr },
        { "set_default_character_format", reinterpret_cast<PyCFunction>(ITextDocument_SetDefaultCharacterFormat), METH_VARARGS, nullptr },
        { "set_default_paragraph_format", reinterpret_cast<PyCFunction>(ITextDocument_SetDefaultParagraphFormat), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(ITextDocument_SetText), METH_VARARGS, nullptr },
        { "undo", reinterpret_cast<PyCFunction>(ITextDocument_Undo), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextDocument, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextDocument), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextDocument[] = {
        { "caret_type", reinterpret_cast<getter>(ITextDocument_get_CaretType), reinterpret_cast<setter>(ITextDocument_put_CaretType), nullptr, nullptr },
        { "default_tab_stop", reinterpret_cast<getter>(ITextDocument_get_DefaultTabStop), reinterpret_cast<setter>(ITextDocument_put_DefaultTabStop), nullptr, nullptr },
        { "selection", reinterpret_cast<getter>(ITextDocument_get_Selection), nullptr, nullptr, nullptr },
        { "undo_limit", reinterpret_cast<getter>(ITextDocument_get_UndoLimit), reinterpret_cast<setter>(ITextDocument_put_UndoLimit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextDocument[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextDocument) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextDocument) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextDocument) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextDocument) },
        { }
    };

    static PyType_Spec type_spec_ITextDocument = {
        "winrt._winrt_windows_ui_text.ITextDocument",
        sizeof(py::wrapper::Windows::UI::Text::ITextDocument),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextDocument};

    static PyType_Slot type_slots_ImplementsITextDocument[] = {
        { }
    };

    static PyType_Spec type_spec_ImplementsITextDocument = {
        "winrt._winrt_windows_ui_text.ImplementsITextDocument",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextDocument};

    // ----- ITextParagraphFormat interface --------------------

    static PyObject* _new_ITextParagraphFormat(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::ITextParagraphFormat>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::ITextParagraphFormat>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextParagraphFormat(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextParagraphFormat_AddTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"AddTab", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::TabAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::TabLeader>(args, 2);

                self->obj.AddTab(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_ClearAllTabs(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ClearAllTabs", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ClearAllTabs();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_DeleteTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"DeleteTab", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);

                self->obj.DeleteTab(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_GetClone(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"GetClone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_GetTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"GetTab", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                float param1{};
                winrt::Windows::UI::Text::TabAlignment param2{};
                winrt::Windows::UI::Text::TabLeader param3{};

                self->obj.GetTab(param0, param1, param2, param3);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return PyTuple_Pack(3, out1.get(), out2.get(), out3.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_IsEqual(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_SetClone(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SetClone", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                self->obj.SetClone(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_SetIndents(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SetIndents", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                self->obj.SetIndents(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_SetLineSpacing(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SetLineSpacing", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::LineSpacingRule>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.SetLineSpacing(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_Alignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"Alignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_Alignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"Alignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ParagraphAlignment>(arg);

            self->obj.Alignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_FirstLineIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"FirstLineIndent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstLineIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_KeepTogether(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"KeepTogether");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeepTogether());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_KeepTogether(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"KeepTogether");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.KeepTogether(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_KeepWithNext(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"KeepWithNext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeepWithNext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_KeepWithNext(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"KeepWithNext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.KeepWithNext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_LeftIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"LeftIndent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LeftIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_LineSpacing(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"LineSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_LineSpacingRule(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"LineSpacingRule");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineSpacingRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListAlignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ListAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListAlignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::MarkerAlignment>(arg);

            self->obj.ListAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListLevelIndex(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListLevelIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ListLevelIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListLevelIndex(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListLevelIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ListLevelIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListStart(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ListStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListStart(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ListStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListStyle(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ListStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListStyle(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::MarkerStyle>(arg);

            self->obj.ListStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListTab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ListTab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListTab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.ListTab(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListType(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ListType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListType(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"ListType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::MarkerType>(arg);

            self->obj.ListType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_NoLineNumber(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"NoLineNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NoLineNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_NoLineNumber(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"NoLineNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.NoLineNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_PageBreakBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"PageBreakBefore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PageBreakBefore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_PageBreakBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"PageBreakBefore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.PageBreakBefore(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_RightIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"RightIndent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RightIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_RightIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"RightIndent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RightIndent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_RightToLeft(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"RightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RightToLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_RightToLeft(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"RightToLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.RightToLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_SpaceAfter(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SpaceAfter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SpaceAfter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_SpaceAfter(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SpaceAfter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.SpaceAfter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_SpaceBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SpaceBefore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SpaceBefore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_SpaceBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"SpaceBefore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.SpaceBefore(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_Style(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"Style");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_Style(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"Style");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ParagraphStyle>(arg);

            self->obj.Style(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_TabCount(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"TabCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TabCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_WidowControl(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"WidowControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WidowControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_WidowControl(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextParagraphFormat", L"WidowControl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.WidowControl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ITextParagraphFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::ITextParagraphFormat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextParagraphFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextParagraphFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextParagraphFormat[] = {
        { "add_tab", reinterpret_cast<PyCFunction>(ITextParagraphFormat_AddTab), METH_VARARGS, nullptr },
        { "clear_all_tabs", reinterpret_cast<PyCFunction>(ITextParagraphFormat_ClearAllTabs), METH_VARARGS, nullptr },
        { "delete_tab", reinterpret_cast<PyCFunction>(ITextParagraphFormat_DeleteTab), METH_VARARGS, nullptr },
        { "get_clone", reinterpret_cast<PyCFunction>(ITextParagraphFormat_GetClone), METH_VARARGS, nullptr },
        { "get_tab", reinterpret_cast<PyCFunction>(ITextParagraphFormat_GetTab), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(ITextParagraphFormat_IsEqual), METH_VARARGS, nullptr },
        { "set_clone", reinterpret_cast<PyCFunction>(ITextParagraphFormat_SetClone), METH_VARARGS, nullptr },
        { "set_indents", reinterpret_cast<PyCFunction>(ITextParagraphFormat_SetIndents), METH_VARARGS, nullptr },
        { "set_line_spacing", reinterpret_cast<PyCFunction>(ITextParagraphFormat_SetLineSpacing), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextParagraphFormat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextParagraphFormat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextParagraphFormat[] = {
        { "alignment", reinterpret_cast<getter>(ITextParagraphFormat_get_Alignment), reinterpret_cast<setter>(ITextParagraphFormat_put_Alignment), nullptr, nullptr },
        { "first_line_indent", reinterpret_cast<getter>(ITextParagraphFormat_get_FirstLineIndent), nullptr, nullptr, nullptr },
        { "keep_together", reinterpret_cast<getter>(ITextParagraphFormat_get_KeepTogether), reinterpret_cast<setter>(ITextParagraphFormat_put_KeepTogether), nullptr, nullptr },
        { "keep_with_next", reinterpret_cast<getter>(ITextParagraphFormat_get_KeepWithNext), reinterpret_cast<setter>(ITextParagraphFormat_put_KeepWithNext), nullptr, nullptr },
        { "left_indent", reinterpret_cast<getter>(ITextParagraphFormat_get_LeftIndent), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ITextParagraphFormat_get_LineSpacing), nullptr, nullptr, nullptr },
        { "line_spacing_rule", reinterpret_cast<getter>(ITextParagraphFormat_get_LineSpacingRule), nullptr, nullptr, nullptr },
        { "list_alignment", reinterpret_cast<getter>(ITextParagraphFormat_get_ListAlignment), reinterpret_cast<setter>(ITextParagraphFormat_put_ListAlignment), nullptr, nullptr },
        { "list_level_index", reinterpret_cast<getter>(ITextParagraphFormat_get_ListLevelIndex), reinterpret_cast<setter>(ITextParagraphFormat_put_ListLevelIndex), nullptr, nullptr },
        { "list_start", reinterpret_cast<getter>(ITextParagraphFormat_get_ListStart), reinterpret_cast<setter>(ITextParagraphFormat_put_ListStart), nullptr, nullptr },
        { "list_style", reinterpret_cast<getter>(ITextParagraphFormat_get_ListStyle), reinterpret_cast<setter>(ITextParagraphFormat_put_ListStyle), nullptr, nullptr },
        { "list_tab", reinterpret_cast<getter>(ITextParagraphFormat_get_ListTab), reinterpret_cast<setter>(ITextParagraphFormat_put_ListTab), nullptr, nullptr },
        { "list_type", reinterpret_cast<getter>(ITextParagraphFormat_get_ListType), reinterpret_cast<setter>(ITextParagraphFormat_put_ListType), nullptr, nullptr },
        { "no_line_number", reinterpret_cast<getter>(ITextParagraphFormat_get_NoLineNumber), reinterpret_cast<setter>(ITextParagraphFormat_put_NoLineNumber), nullptr, nullptr },
        { "page_break_before", reinterpret_cast<getter>(ITextParagraphFormat_get_PageBreakBefore), reinterpret_cast<setter>(ITextParagraphFormat_put_PageBreakBefore), nullptr, nullptr },
        { "right_indent", reinterpret_cast<getter>(ITextParagraphFormat_get_RightIndent), reinterpret_cast<setter>(ITextParagraphFormat_put_RightIndent), nullptr, nullptr },
        { "right_to_left", reinterpret_cast<getter>(ITextParagraphFormat_get_RightToLeft), reinterpret_cast<setter>(ITextParagraphFormat_put_RightToLeft), nullptr, nullptr },
        { "space_after", reinterpret_cast<getter>(ITextParagraphFormat_get_SpaceAfter), reinterpret_cast<setter>(ITextParagraphFormat_put_SpaceAfter), nullptr, nullptr },
        { "space_before", reinterpret_cast<getter>(ITextParagraphFormat_get_SpaceBefore), reinterpret_cast<setter>(ITextParagraphFormat_put_SpaceBefore), nullptr, nullptr },
        { "style", reinterpret_cast<getter>(ITextParagraphFormat_get_Style), reinterpret_cast<setter>(ITextParagraphFormat_put_Style), nullptr, nullptr },
        { "tab_count", reinterpret_cast<getter>(ITextParagraphFormat_get_TabCount), nullptr, nullptr, nullptr },
        { "widow_control", reinterpret_cast<getter>(ITextParagraphFormat_get_WidowControl), reinterpret_cast<setter>(ITextParagraphFormat_put_WidowControl), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextParagraphFormat[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextParagraphFormat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextParagraphFormat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextParagraphFormat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextParagraphFormat) },
        { }
    };

    static PyType_Spec type_spec_ITextParagraphFormat = {
        "winrt._winrt_windows_ui_text.ITextParagraphFormat",
        sizeof(py::wrapper::Windows::UI::Text::ITextParagraphFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextParagraphFormat};

    static PyType_Slot type_slots_ImplementsITextParagraphFormat[] = {
        { }
    };

    static PyType_Spec type_spec_ImplementsITextParagraphFormat = {
        "winrt._winrt_windows_ui_text.ImplementsITextParagraphFormat",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextParagraphFormat};

    // ----- ITextRange interface --------------------

    static PyObject* _new_ITextRange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::ITextRange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::ITextRange>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextRange(py::wrapper::Windows::UI::Text::ITextRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextRange_CanPaste(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"CanPaste", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CanPaste(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_ChangeCase(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"ChangeCase", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::LetterCase>(args, 0);

                self->obj.ChangeCase(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Collapse(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Collapse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Collapse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Copy(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Copy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Copy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Cut(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Cut", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cut();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Delete(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Delete", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Delete(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_EndOf(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"EndOf", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Expand(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Expand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.Expand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_FindText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"FindText", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::FindOptions>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetCharacterUtf32(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetCharacterUtf32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                uint32_t param0{};
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.GetCharacterUtf32(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetClone(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetClone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetIndex(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.GetIndex(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetPoint(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::HorizontalCharacterAlignment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 2);
                winrt::Windows::Foundation::Point param3{};

                self->obj.GetPoint(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetRect(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetRect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);
                winrt::Windows::Foundation::Rect param1{};
                int32_t param2{};

                self->obj.GetRect(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1{};

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetTextViaStream(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetTextViaStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.GetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_InRange(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"InRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_InStory(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"InStory", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InStory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_InsertImage(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"InsertImage", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 5);

                self->obj.InsertImage(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_IsEqual(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_MatchSelection(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"MatchSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MatchSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Move(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_MoveEnd(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"MoveEnd", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveEnd(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_MoveStart(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"MoveStart", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Paste(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Paste", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Paste(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_ScrollIntoView(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetIndex(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetIndex", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetIndex(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetPoint(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetRange(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.SetRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetTextViaStream(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetTextViaStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_StartOf(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"StartOf", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StartOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_get_Character(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Character(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<char16_t>(arg);

            self->obj.Character(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_CharacterFormat(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"CharacterFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_CharacterFormat(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"CharacterFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(arg);

            self->obj.CharacterFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_EndPosition(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"EndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_EndPosition(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"EndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.EndPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_FormattedText(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"FormattedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FormattedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_FormattedText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"FormattedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(arg);

            self->obj.FormattedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_Gravity(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Gravity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Gravity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Gravity(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Gravity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::RangeGravity>(arg);

            self->obj.Gravity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_Length(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextRange_get_Link(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Link");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Link());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Link(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Link");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Link(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"ParagraphFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParagraphFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"ParagraphFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(arg);

            self->obj.ParagraphFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_StartPosition(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_StartPosition(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_StoryLength(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"StoryLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StoryLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextRange_get_Text(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Text(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ITextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::ITextRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextRange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextRange[] = {
        { "can_paste", reinterpret_cast<PyCFunction>(ITextRange_CanPaste), METH_VARARGS, nullptr },
        { "change_case", reinterpret_cast<PyCFunction>(ITextRange_ChangeCase), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(ITextRange_Collapse), METH_VARARGS, nullptr },
        { "copy", reinterpret_cast<PyCFunction>(ITextRange_Copy), METH_VARARGS, nullptr },
        { "cut", reinterpret_cast<PyCFunction>(ITextRange_Cut), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(ITextRange_Delete), METH_VARARGS, nullptr },
        { "end_of", reinterpret_cast<PyCFunction>(ITextRange_EndOf), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ITextRange_Expand), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(ITextRange_FindText), METH_VARARGS, nullptr },
        { "get_character_utf32", reinterpret_cast<PyCFunction>(ITextRange_GetCharacterUtf32), METH_VARARGS, nullptr },
        { "get_clone", reinterpret_cast<PyCFunction>(ITextRange_GetClone), METH_VARARGS, nullptr },
        { "get_index", reinterpret_cast<PyCFunction>(ITextRange_GetIndex), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(ITextRange_GetPoint), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(ITextRange_GetRect), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextRange_GetText), METH_VARARGS, nullptr },
        { "get_text_via_stream", reinterpret_cast<PyCFunction>(ITextRange_GetTextViaStream), METH_VARARGS, nullptr },
        { "in_range", reinterpret_cast<PyCFunction>(ITextRange_InRange), METH_VARARGS, nullptr },
        { "in_story", reinterpret_cast<PyCFunction>(ITextRange_InStory), METH_VARARGS, nullptr },
        { "insert_image", reinterpret_cast<PyCFunction>(ITextRange_InsertImage), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(ITextRange_IsEqual), METH_VARARGS, nullptr },
        { "match_selection", reinterpret_cast<PyCFunction>(ITextRange_MatchSelection), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(ITextRange_Move), METH_VARARGS, nullptr },
        { "move_end", reinterpret_cast<PyCFunction>(ITextRange_MoveEnd), METH_VARARGS, nullptr },
        { "move_start", reinterpret_cast<PyCFunction>(ITextRange_MoveStart), METH_VARARGS, nullptr },
        { "paste", reinterpret_cast<PyCFunction>(ITextRange_Paste), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ITextRange_ScrollIntoView), METH_VARARGS, nullptr },
        { "set_index", reinterpret_cast<PyCFunction>(ITextRange_SetIndex), METH_VARARGS, nullptr },
        { "set_point", reinterpret_cast<PyCFunction>(ITextRange_SetPoint), METH_VARARGS, nullptr },
        { "set_range", reinterpret_cast<PyCFunction>(ITextRange_SetRange), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(ITextRange_SetText), METH_VARARGS, nullptr },
        { "set_text_via_stream", reinterpret_cast<PyCFunction>(ITextRange_SetTextViaStream), METH_VARARGS, nullptr },
        { "start_of", reinterpret_cast<PyCFunction>(ITextRange_StartOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextRange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextRange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextRange[] = {
        { "character", reinterpret_cast<getter>(ITextRange_get_Character), reinterpret_cast<setter>(ITextRange_put_Character), nullptr, nullptr },
        { "character_format", reinterpret_cast<getter>(ITextRange_get_CharacterFormat), reinterpret_cast<setter>(ITextRange_put_CharacterFormat), nullptr, nullptr },
        { "end_position", reinterpret_cast<getter>(ITextRange_get_EndPosition), reinterpret_cast<setter>(ITextRange_put_EndPosition), nullptr, nullptr },
        { "formatted_text", reinterpret_cast<getter>(ITextRange_get_FormattedText), reinterpret_cast<setter>(ITextRange_put_FormattedText), nullptr, nullptr },
        { "gravity", reinterpret_cast<getter>(ITextRange_get_Gravity), reinterpret_cast<setter>(ITextRange_put_Gravity), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(ITextRange_get_Length), nullptr, nullptr, nullptr },
        { "link", reinterpret_cast<getter>(ITextRange_get_Link), reinterpret_cast<setter>(ITextRange_put_Link), nullptr, nullptr },
        { "paragraph_format", reinterpret_cast<getter>(ITextRange_get_ParagraphFormat), reinterpret_cast<setter>(ITextRange_put_ParagraphFormat), nullptr, nullptr },
        { "start_position", reinterpret_cast<getter>(ITextRange_get_StartPosition), reinterpret_cast<setter>(ITextRange_put_StartPosition), nullptr, nullptr },
        { "story_length", reinterpret_cast<getter>(ITextRange_get_StoryLength), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ITextRange_get_Text), reinterpret_cast<setter>(ITextRange_put_Text), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextRange) },
        { }
    };

    static PyType_Spec type_spec_ITextRange = {
        "winrt._winrt_windows_ui_text.ITextRange",
        sizeof(py::wrapper::Windows::UI::Text::ITextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextRange};

    static PyType_Slot type_slots_ImplementsITextRange[] = {
        { }
    };

    static PyType_Spec type_spec_ImplementsITextRange = {
        "winrt._winrt_windows_ui_text.ImplementsITextRange",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextRange};

    // ----- ITextSelection interface --------------------

    static PyObject* _new_ITextSelection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::ITextSelection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::ITextSelection>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextSelection(py::wrapper::Windows::UI::Text::ITextSelection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextSelection_CanPaste(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"CanPaste", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CanPaste(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_ChangeCase(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"ChangeCase", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::LetterCase>(args, 0);

                self->obj.ChangeCase(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Collapse(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Collapse", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Collapse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Copy(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Copy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Copy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Cut(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Cut", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cut();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Delete(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Delete", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Delete(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_EndKey(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"EndKey", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_EndOf(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"EndOf", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Expand(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Expand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.Expand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_FindText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"FindText", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::FindOptions>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetCharacterUtf32(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetCharacterUtf32", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                uint32_t param0{};
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.GetCharacterUtf32(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetClone(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetClone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetIndex(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetIndex", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.GetIndex(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetPoint(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::HorizontalCharacterAlignment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 2);
                winrt::Windows::Foundation::Point param3{};

                self->obj.GetPoint(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetRect(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetRect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);
                winrt::Windows::Foundation::Rect param1{};
                int32_t param2{};

                self->obj.GetRect(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1{};

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetTextViaStream(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"GetTextViaStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.GetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_HomeKey(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"HomeKey", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.HomeKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_InRange(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"InRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_InStory(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"InStory", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InStory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_InsertImage(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"InsertImage", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 5);

                self->obj.InsertImage(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_IsEqual(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MatchSelection(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"MatchSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.MatchSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Move(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Move", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveDown(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"MoveDown", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveDown(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveEnd(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"MoveEnd", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveEnd(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveLeft(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"MoveLeft", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveLeft(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveRight(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"MoveRight", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveRight(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveStart(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"MoveStart", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveUp(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"MoveUp", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveUp(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Paste(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"Paste", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Paste(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_ScrollIntoView(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"ScrollIntoView", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetIndex(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetIndex", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetIndex(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetPoint(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetRange(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.SetRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetTextViaStream(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"SetTextViaStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_StartOf(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextRange", L"StartOf", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StartOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_TypeText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.ITextSelection", L"TypeText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TypeText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Options(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextSelection", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Options(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextSelection", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::SelectionOptions>(arg);

            self->obj.Options(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_Type(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextSelection", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Character(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Character(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Character");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<char16_t>(arg);

            self->obj.Character(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_CharacterFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"CharacterFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_CharacterFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"CharacterFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(arg);

            self->obj.CharacterFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_EndPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"EndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_EndPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"EndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.EndPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_FormattedText(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"FormattedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FormattedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_FormattedText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"FormattedText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(arg);

            self->obj.FormattedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_Gravity(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Gravity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Gravity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Gravity(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Gravity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::RangeGravity>(arg);

            self->obj.Gravity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_Length(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Link(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Link");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Link());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Link(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Link");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Link(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"ParagraphFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParagraphFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"ParagraphFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(arg);

            self->obj.ParagraphFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_StartPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_StartPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"StartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_StoryLength(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"StoryLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StoryLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Text(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Text(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.ITextRange", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ITextSelection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::ITextSelection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextSelection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextSelection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextSelection[] = {
        { "can_paste", reinterpret_cast<PyCFunction>(ITextSelection_CanPaste), METH_VARARGS, nullptr },
        { "change_case", reinterpret_cast<PyCFunction>(ITextSelection_ChangeCase), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(ITextSelection_Collapse), METH_VARARGS, nullptr },
        { "copy", reinterpret_cast<PyCFunction>(ITextSelection_Copy), METH_VARARGS, nullptr },
        { "cut", reinterpret_cast<PyCFunction>(ITextSelection_Cut), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(ITextSelection_Delete), METH_VARARGS, nullptr },
        { "end_key", reinterpret_cast<PyCFunction>(ITextSelection_EndKey), METH_VARARGS, nullptr },
        { "end_of", reinterpret_cast<PyCFunction>(ITextSelection_EndOf), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ITextSelection_Expand), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(ITextSelection_FindText), METH_VARARGS, nullptr },
        { "get_character_utf32", reinterpret_cast<PyCFunction>(ITextSelection_GetCharacterUtf32), METH_VARARGS, nullptr },
        { "get_clone", reinterpret_cast<PyCFunction>(ITextSelection_GetClone), METH_VARARGS, nullptr },
        { "get_index", reinterpret_cast<PyCFunction>(ITextSelection_GetIndex), METH_VARARGS, nullptr },
        { "get_point", reinterpret_cast<PyCFunction>(ITextSelection_GetPoint), METH_VARARGS, nullptr },
        { "get_rect", reinterpret_cast<PyCFunction>(ITextSelection_GetRect), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextSelection_GetText), METH_VARARGS, nullptr },
        { "get_text_via_stream", reinterpret_cast<PyCFunction>(ITextSelection_GetTextViaStream), METH_VARARGS, nullptr },
        { "home_key", reinterpret_cast<PyCFunction>(ITextSelection_HomeKey), METH_VARARGS, nullptr },
        { "in_range", reinterpret_cast<PyCFunction>(ITextSelection_InRange), METH_VARARGS, nullptr },
        { "in_story", reinterpret_cast<PyCFunction>(ITextSelection_InStory), METH_VARARGS, nullptr },
        { "insert_image", reinterpret_cast<PyCFunction>(ITextSelection_InsertImage), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(ITextSelection_IsEqual), METH_VARARGS, nullptr },
        { "match_selection", reinterpret_cast<PyCFunction>(ITextSelection_MatchSelection), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(ITextSelection_Move), METH_VARARGS, nullptr },
        { "move_down", reinterpret_cast<PyCFunction>(ITextSelection_MoveDown), METH_VARARGS, nullptr },
        { "move_end", reinterpret_cast<PyCFunction>(ITextSelection_MoveEnd), METH_VARARGS, nullptr },
        { "move_left", reinterpret_cast<PyCFunction>(ITextSelection_MoveLeft), METH_VARARGS, nullptr },
        { "move_right", reinterpret_cast<PyCFunction>(ITextSelection_MoveRight), METH_VARARGS, nullptr },
        { "move_start", reinterpret_cast<PyCFunction>(ITextSelection_MoveStart), METH_VARARGS, nullptr },
        { "move_up", reinterpret_cast<PyCFunction>(ITextSelection_MoveUp), METH_VARARGS, nullptr },
        { "paste", reinterpret_cast<PyCFunction>(ITextSelection_Paste), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ITextSelection_ScrollIntoView), METH_VARARGS, nullptr },
        { "set_index", reinterpret_cast<PyCFunction>(ITextSelection_SetIndex), METH_VARARGS, nullptr },
        { "set_point", reinterpret_cast<PyCFunction>(ITextSelection_SetPoint), METH_VARARGS, nullptr },
        { "set_range", reinterpret_cast<PyCFunction>(ITextSelection_SetRange), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(ITextSelection_SetText), METH_VARARGS, nullptr },
        { "set_text_via_stream", reinterpret_cast<PyCFunction>(ITextSelection_SetTextViaStream), METH_VARARGS, nullptr },
        { "start_of", reinterpret_cast<PyCFunction>(ITextSelection_StartOf), METH_VARARGS, nullptr },
        { "type_text", reinterpret_cast<PyCFunction>(ITextSelection_TypeText), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextSelection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextSelection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextSelection[] = {
        { "options", reinterpret_cast<getter>(ITextSelection_get_Options), reinterpret_cast<setter>(ITextSelection_put_Options), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ITextSelection_get_Type), nullptr, nullptr, nullptr },
        { "character", reinterpret_cast<getter>(ITextSelection_get_Character), reinterpret_cast<setter>(ITextSelection_put_Character), nullptr, nullptr },
        { "character_format", reinterpret_cast<getter>(ITextSelection_get_CharacterFormat), reinterpret_cast<setter>(ITextSelection_put_CharacterFormat), nullptr, nullptr },
        { "end_position", reinterpret_cast<getter>(ITextSelection_get_EndPosition), reinterpret_cast<setter>(ITextSelection_put_EndPosition), nullptr, nullptr },
        { "formatted_text", reinterpret_cast<getter>(ITextSelection_get_FormattedText), reinterpret_cast<setter>(ITextSelection_put_FormattedText), nullptr, nullptr },
        { "gravity", reinterpret_cast<getter>(ITextSelection_get_Gravity), reinterpret_cast<setter>(ITextSelection_put_Gravity), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(ITextSelection_get_Length), nullptr, nullptr, nullptr },
        { "link", reinterpret_cast<getter>(ITextSelection_get_Link), reinterpret_cast<setter>(ITextSelection_put_Link), nullptr, nullptr },
        { "paragraph_format", reinterpret_cast<getter>(ITextSelection_get_ParagraphFormat), reinterpret_cast<setter>(ITextSelection_put_ParagraphFormat), nullptr, nullptr },
        { "start_position", reinterpret_cast<getter>(ITextSelection_get_StartPosition), reinterpret_cast<setter>(ITextSelection_put_StartPosition), nullptr, nullptr },
        { "story_length", reinterpret_cast<getter>(ITextSelection_get_StoryLength), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ITextSelection_get_Text), reinterpret_cast<setter>(ITextSelection_put_Text), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextSelection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextSelection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextSelection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextSelection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextSelection) },
        { }
    };

    static PyType_Spec type_spec_ITextSelection = {
        "winrt._winrt_windows_ui_text.ITextSelection",
        sizeof(py::wrapper::Windows::UI::Text::ITextSelection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextSelection};

    static PyType_Slot type_slots_ImplementsITextSelection[] = {
        { }
    };

    static PyType_Spec type_spec_ImplementsITextSelection = {
        "winrt._winrt_windows_ui_text.ImplementsITextSelection",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsITextSelection};

    // ----- FontWeight struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Text::FontWeight>* _new_FontWeight(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Text::FontWeight>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_FontWeight(winrt_struct_wrapper<winrt::Windows::UI::Text::FontWeight>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint16_t _Weight{};

        static const char* kwlist[] = {"weight", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "H", const_cast<char**>(kwlist), &_Weight))
        {
            return -1;
        }

        try
        {
            self->obj.Weight = _Weight;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_FontWeight(py::wrapper::Windows::UI::Text::FontWeight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FontWeight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::FontWeight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_FontWeight[] = {
        { "_assign_array_", _assign_array_FontWeight, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* FontWeight_get_Weight(py::wrapper::Windows::UI::Text::FontWeight* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontWeight_set_Weight(py::wrapper::Windows::UI::Text::FontWeight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Weight = py::convert_to<uint16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_FontWeight[] = {
        { "weight", reinterpret_cast<getter>(FontWeight_get_Weight), reinterpret_cast<setter>(FontWeight_set_Weight), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_FontWeight(py::wrapper::Windows::UI::Text::FontWeight* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Text::FontWeight>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_FontWeight(PyObject* self) noexcept
    {
        py::pyobj_handle Weight{PyObject_GetAttrString(self, "weight")};
        if (!Weight)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("FontWeight(weight=%R)", Weight.get());
    }

    static PyType_Slot _type_slots_FontWeight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FontWeight) },
        { Py_tp_init, reinterpret_cast<void*>(_init_FontWeight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FontWeight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FontWeight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FontWeight) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_FontWeight) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_FontWeight) },
        { }
    };

    static PyType_Spec type_spec_FontWeight = {
        "winrt._winrt_windows_ui_text.FontWeight",
        sizeof(py::wrapper::Windows::UI::Text::FontWeight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FontWeight};

    // ----- Windows.UI.Text Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Text");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_text",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Text

PyMODINIT_FUNC PyInit__winrt_windows_ui_text(void) noexcept
{
    using namespace py::cpp::Windows::UI::Text;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle ContentLinkInfo_type{py::register_python_type(module.get(), &type_spec_ContentLinkInfo, object_bases.get(), nullptr)};
    if (!ContentLinkInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FontWeights_Static{PyType_FromSpec(&type_spec_FontWeights_Static)};
    if (!type_FontWeights_Static)
    {
        return nullptr;
    }

    py::pytype_handle FontWeights_type{py::register_python_type(module.get(), &type_spec_FontWeights, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FontWeights_Static.get()))};
    if (!FontWeights_type)
    {
        return nullptr;
    }

    py::pytype_handle RichEditTextDocument_type{py::register_python_type(module.get(), &type_spec_RichEditTextDocument, object_bases.get(), nullptr)};
    if (!RichEditTextDocument_type)
    {
        return nullptr;
    }

    py::pytype_handle RichEditTextRange_type{py::register_python_type(module.get(), &type_spec_RichEditTextRange, object_bases.get(), nullptr)};
    if (!RichEditTextRange_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextConstants_Static{PyType_FromSpec(&type_spec_TextConstants_Static)};
    if (!type_TextConstants_Static)
    {
        return nullptr;
    }

    py::pytype_handle TextConstants_type{py::register_python_type(module.get(), &type_spec_TextConstants, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextConstants_Static.get()))};
    if (!TextConstants_type)
    {
        return nullptr;
    }

    py::pytype_handle ITextCharacterFormat_type{py::register_python_type(module.get(), &type_spec_ITextCharacterFormat, object_bases.get(), nullptr)};
    if (!ITextCharacterFormat_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextCharacterFormat_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsITextCharacterFormat, nullptr))};
    if (!ImplementsITextCharacterFormat_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextCharacterFormat_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextDocument_type{py::register_python_type(module.get(), &type_spec_ITextDocument, object_bases.get(), nullptr)};
    if (!ITextDocument_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextDocument_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsITextDocument, nullptr))};
    if (!ImplementsITextDocument_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextDocument_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextParagraphFormat_type{py::register_python_type(module.get(), &type_spec_ITextParagraphFormat, object_bases.get(), nullptr)};
    if (!ITextParagraphFormat_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextParagraphFormat_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsITextParagraphFormat, nullptr))};
    if (!ImplementsITextParagraphFormat_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextParagraphFormat_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextRange_type{py::register_python_type(module.get(), &type_spec_ITextRange, object_bases.get(), nullptr)};
    if (!ITextRange_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextRange_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsITextRange, nullptr))};
    if (!ImplementsITextRange_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextRange_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ITextSelection_type{py::register_python_type(module.get(), &type_spec_ITextSelection, object_bases.get(), nullptr)};
    if (!ITextSelection_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsITextSelection_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsITextSelection, nullptr))};
    if (!ImplementsITextSelection_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsITextSelection_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle FontWeight_type{py::register_python_type(module.get(), &type_spec_FontWeight, nullptr, nullptr)};
    if (!FontWeight_type)
    {
        return nullptr;
    }


    return module.detach();
}
