// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Controls.h"


namespace py::cpp::Windows::UI::Xaml::Controls
{
    // ----- AppBarButton class --------------------

    static PyObject* _new_AppBarButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::AppBarButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButton(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButton_get_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"TemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompact"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompact"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarButton_put_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflow(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsInOverflow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IconProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsCompactProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"DynamicOverflowOrderProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"IsInOverflowProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"LabelPositionProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarButton", L"KeyboardAcceleratorTextOverrideProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::AppBarButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::AppBarButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButton[] = {
        { "_assign_array_", _assign_array_AppBarButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButton[] = {
        { "label", reinterpret_cast<getter>(AppBarButton_get_Label), reinterpret_cast<setter>(AppBarButton_put_Label), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarButton_get_Icon), reinterpret_cast<setter>(AppBarButton_put_Icon), nullptr, nullptr },
        { "label_position", reinterpret_cast<getter>(AppBarButton_get_LabelPosition), reinterpret_cast<setter>(AppBarButton_put_LabelPosition), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarButton_get_IsCompact), reinterpret_cast<setter>(AppBarButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButton) },
        { },
    };

    static PyType_Spec type_spec_AppBarButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.AppBarButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::AppBarButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButton
    };

    static PyGetSetDef getset_AppBarButton_Static[] = {
        { "icon_property", reinterpret_cast<getter>(AppBarButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.AppBarButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarButton_Static
    };

    // ----- AppBarToggleButton class --------------------

    static PyObject* _new_AppBarToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::AppBarToggleButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButton(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButton_get_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Label(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_Icon(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LabelPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_LabelPosition(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CommandBarLabelPosition>(arg);

            self->obj.LabelPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_KeyboardAcceleratorTextOverride(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyboardAcceleratorTextOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"TemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCompact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_IsCompact(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompact"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DynamicOverflowOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppBarToggleButton_put_DynamicOverflowOrder(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DynamicOverflowOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflow(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInOverflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IconProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsCompactProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsCompactProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IsCompactProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::LabelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_DynamicOverflowOrderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"DynamicOverflowOrderProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::DynamicOverflowOrderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_IsInOverflowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"IsInOverflowProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::IsInOverflowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_LabelPositionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"LabelPositionProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::LabelPositionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.AppBarToggleButton", L"KeyboardAcceleratorTextOverrideProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::AppBarToggleButton::KeyboardAcceleratorTextOverrideProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButton[] = {
        { "_assign_array_", _assign_array_AppBarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButton[] = {
        { "label", reinterpret_cast<getter>(AppBarToggleButton_get_Label), reinterpret_cast<setter>(AppBarToggleButton_put_Label), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppBarToggleButton_get_Icon), reinterpret_cast<setter>(AppBarToggleButton_put_Icon), nullptr, nullptr },
        { "label_position", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPosition), reinterpret_cast<setter>(AppBarToggleButton_put_LabelPosition), nullptr, nullptr },
        { "keyboard_accelerator_text_override", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverride), reinterpret_cast<setter>(AppBarToggleButton_put_KeyboardAcceleratorTextOverride), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(AppBarToggleButton_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "is_compact", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompact), reinterpret_cast<setter>(AppBarToggleButton_put_IsCompact), nullptr, nullptr },
        { "dynamic_overflow_order", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrder), reinterpret_cast<setter>(AppBarToggleButton_put_DynamicOverflowOrder), nullptr, nullptr },
        { "is_in_overflow", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButton) },
        { },
    };

    static PyType_Spec type_spec_AppBarToggleButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.AppBarToggleButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::AppBarToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButton
    };

    static PyGetSetDef getset_AppBarToggleButton_Static[] = {
        { "icon_property", reinterpret_cast<getter>(AppBarToggleButton_get_IconProperty), nullptr, nullptr, nullptr },
        { "is_compact_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsCompactProperty), nullptr, nullptr, nullptr },
        { "label_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelProperty), nullptr, nullptr, nullptr },
        { "dynamic_overflow_order_property", reinterpret_cast<getter>(AppBarToggleButton_get_DynamicOverflowOrderProperty), nullptr, nullptr, nullptr },
        { "is_in_overflow_property", reinterpret_cast<getter>(AppBarToggleButton_get_IsInOverflowProperty), nullptr, nullptr, nullptr },
        { "label_position_property", reinterpret_cast<getter>(AppBarToggleButton_get_LabelPositionProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_text_override_property", reinterpret_cast<getter>(AppBarToggleButton_get_KeyboardAcceleratorTextOverrideProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AppBarToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.AppBarToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarToggleButton_Static
    };

    // ----- Button class --------------------

    static PyObject* _new_Button(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Button instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Button(py::wrapper::Windows::UI::Xaml::Controls::Button* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Button_get_Flyout(py::wrapper::Windows::UI::Xaml::Controls::Button* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"Flyout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Flyout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Button_put_Flyout(py::wrapper::Windows::UI::Xaml::Controls::Button* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"Flyout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            self->obj.Flyout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Button_get_FlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Button", L"FlyoutProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Button::FlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Button>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Button(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Button>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Button[] = {
        { "_assign_array_", _assign_array_Button, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Button), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Button[] = {
        { "flyout", reinterpret_cast<getter>(Button_get_Flyout), reinterpret_cast<setter>(Button_put_Flyout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Button[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Button) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Button) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Button) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Button) },
        { },
    };

    static PyType_Spec type_spec_Button =
    {
        "winrt._winrt_windows_ui_xaml_controls_.Button",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Button),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Button
    };

    static PyGetSetDef getset_Button_Static[] = {
        { "flyout_property", reinterpret_cast<getter>(Button_get_FlyoutProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Button_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Button_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Button_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Button_Static) },
        { }
    };

    static PyType_Spec type_spec_Button_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.Button_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Button_Static
    };

    // ----- CheckBox class --------------------

    static PyObject* _new_CheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::CheckBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBox(py::wrapper::Windows::UI::Xaml::Controls::CheckBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::CheckBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::CheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBox[] = {
        { "_assign_array_", _assign_array_CheckBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBox[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBox) },
        { },
    };

    static PyType_Spec type_spec_CheckBox =
    {
        "winrt._winrt_windows_ui_xaml_controls_.CheckBox",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::CheckBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CheckBox
    };

    // ----- ComboBox class --------------------

    static PyObject* _new_ComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ComboBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBox(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBox_get_MaxDropDownHeight(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxDropDownHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_MaxDropDownHeight(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxDropDownHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsEditable(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEditable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsEditable(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEditable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpen(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDropDownOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsDropDownOpen(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDropDownOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsSelectionBoxHighlighted(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsSelectionBoxHighlighted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionBoxHighlighted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItem(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionBoxItem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionBoxItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionBoxItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionBoxItemTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionBoxItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderText(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderText(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderText"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Header(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Header"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Header(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Header"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayMode(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_LightDismissOverlayMode(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabled(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTextSearchEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_IsTextSearchEnabled(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextSearchEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTrigger(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionChangedTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_SelectionChangedTrigger(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTrigger"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBoxSelectionChangedTrigger>(arg);

            self->obj.SelectionChangedTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForeground(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlaceholderForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_PlaceholderForeground(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForeground"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.PlaceholderForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyle(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextBoxStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_TextBoxStyle(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.TextBoxStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Text(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Text(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_Description(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ComboBox_put_Description(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ComboBox_get_IsDropDownOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsDropDownOpenProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsDropDownOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_MaxDropDownHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"MaxDropDownHeightProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::MaxDropDownHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"HeaderTemplateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderTextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderTextProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::PlaceholderTextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsTextSearchEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsTextSearchEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsTextSearchEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"LightDismissOverlayModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_SelectionChangedTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"SelectionChangedTriggerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::SelectionChangedTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_PlaceholderForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"PlaceholderForegroundProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::PlaceholderForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_DescriptionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DescriptionProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::DescriptionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_IsEditableProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"IsEditableProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::IsEditableProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextBoxStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextBoxStyleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::TextBoxStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ComboBox::TextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownClosed(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DropDownClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownClosed(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DropDownClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_DropDownOpened(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownOpened"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DropDownOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_DropDownOpened(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"DropDownOpened"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DropDownOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_add_TextSubmitted(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextSubmitted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ComboBox, winrt::Windows::UI::Xaml::Controls::ComboBoxTextSubmittedEventArgs>>(arg);

            return py::convert(self->obj.TextSubmitted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBox_remove_TextSubmitted(py::wrapper::Windows::UI::Xaml::Controls::ComboBox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ComboBox", L"TextSubmitted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextSubmitted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBox[] = {
        { "add_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownClosed), METH_O, nullptr },
        { "remove_drop_down_closed", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownClosed), METH_O, nullptr },
        { "add_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_add_DropDownOpened), METH_O, nullptr },
        { "remove_drop_down_opened", reinterpret_cast<PyCFunction>(ComboBox_remove_DropDownOpened), METH_O, nullptr },
        { "add_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_add_TextSubmitted), METH_O, nullptr },
        { "remove_text_submitted", reinterpret_cast<PyCFunction>(ComboBox_remove_TextSubmitted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBox[] = {
        { "max_drop_down_height", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeight), reinterpret_cast<setter>(ComboBox_put_MaxDropDownHeight), nullptr, nullptr },
        { "is_editable", reinterpret_cast<getter>(ComboBox_get_IsEditable), reinterpret_cast<setter>(ComboBox_put_IsEditable), nullptr, nullptr },
        { "is_drop_down_open", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpen), reinterpret_cast<setter>(ComboBox_put_IsDropDownOpen), nullptr, nullptr },
        { "is_selection_box_highlighted", reinterpret_cast<getter>(ComboBox_get_IsSelectionBoxHighlighted), nullptr, nullptr, nullptr },
        { "selection_box_item", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItem), nullptr, nullptr, nullptr },
        { "selection_box_item_template", reinterpret_cast<getter>(ComboBox_get_SelectionBoxItemTemplate), nullptr, nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ComboBox_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(ComboBox_get_PlaceholderText), reinterpret_cast<setter>(ComboBox_put_PlaceholderText), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ComboBox_get_HeaderTemplate), reinterpret_cast<setter>(ComboBox_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ComboBox_get_Header), reinterpret_cast<setter>(ComboBox_put_Header), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayMode), reinterpret_cast<setter>(ComboBox_put_LightDismissOverlayMode), nullptr, nullptr },
        { "is_text_search_enabled", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabled), reinterpret_cast<setter>(ComboBox_put_IsTextSearchEnabled), nullptr, nullptr },
        { "selection_changed_trigger", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTrigger), reinterpret_cast<setter>(ComboBox_put_SelectionChangedTrigger), nullptr, nullptr },
        { "placeholder_foreground", reinterpret_cast<getter>(ComboBox_get_PlaceholderForeground), reinterpret_cast<setter>(ComboBox_put_PlaceholderForeground), nullptr, nullptr },
        { "text_box_style", reinterpret_cast<getter>(ComboBox_get_TextBoxStyle), reinterpret_cast<setter>(ComboBox_put_TextBoxStyle), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ComboBox_get_Text), reinterpret_cast<setter>(ComboBox_put_Text), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ComboBox_get_Description), reinterpret_cast<setter>(ComboBox_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBox) },
        { },
    };

    static PyType_Spec type_spec_ComboBox =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ComboBox",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBox
    };

    static PyGetSetDef getset_ComboBox_Static[] = {
        { "is_drop_down_open_property", reinterpret_cast<getter>(ComboBox_get_IsDropDownOpenProperty), nullptr, nullptr, nullptr },
        { "max_drop_down_height_property", reinterpret_cast<getter>(ComboBox_get_MaxDropDownHeightProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ComboBox_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ComboBox_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "placeholder_text_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderTextProperty), nullptr, nullptr, nullptr },
        { "is_text_search_enabled_property", reinterpret_cast<getter>(ComboBox_get_IsTextSearchEnabledProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(ComboBox_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "selection_changed_trigger_property", reinterpret_cast<getter>(ComboBox_get_SelectionChangedTriggerProperty), nullptr, nullptr, nullptr },
        { "placeholder_foreground_property", reinterpret_cast<getter>(ComboBox_get_PlaceholderForegroundProperty), nullptr, nullptr, nullptr },
        { "description_property", reinterpret_cast<getter>(ComboBox_get_DescriptionProperty), nullptr, nullptr, nullptr },
        { "is_editable_property", reinterpret_cast<getter>(ComboBox_get_IsEditableProperty), nullptr, nullptr, nullptr },
        { "text_box_style_property", reinterpret_cast<getter>(ComboBox_get_TextBoxStyleProperty), nullptr, nullptr, nullptr },
        { "text_property", reinterpret_cast<getter>(ComboBox_get_TextProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ComboBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ComboBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBox_Static
    };

    // ----- ComboBoxItem class --------------------

    static PyObject* _new_ComboBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ComboBoxItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItem(py::wrapper::Windows::UI::Xaml::Controls::ComboBoxItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItem[] = {
        { "_assign_array_", _assign_array_ComboBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItem) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ComboBoxItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ComboBoxItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItem
    };

    // ----- CommandBarFlyout class --------------------

    static PyObject* _new_CommandBarFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::CommandBarFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyout(py::wrapper::Windows::UI::Xaml::Controls::CommandBarFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyout_get_PrimaryCommands(py::wrapper::Windows::UI::Xaml::Controls::CommandBarFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.CommandBarFlyout", L"PrimaryCommands"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrimaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyout_get_SecondaryCommands(py::wrapper::Windows::UI::Xaml::Controls::CommandBarFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.CommandBarFlyout", L"SecondaryCommands"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SecondaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::CommandBarFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyout[] = {
        { "_assign_array_", _assign_array_CommandBarFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyout[] = {
        { "primary_commands", reinterpret_cast<getter>(CommandBarFlyout_get_PrimaryCommands), nullptr, nullptr, nullptr },
        { "secondary_commands", reinterpret_cast<getter>(CommandBarFlyout_get_SecondaryCommands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyout) },
        { },
    };

    static PyType_Spec type_spec_CommandBarFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.CommandBarFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::CommandBarFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyout
    };

    // ----- DatePickerFlyout class --------------------

    static PyObject* _new_DatePickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::DatePickerFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatePickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DatePickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"ShowAtAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_YearVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YearVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_YearVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.YearVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MonthVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MonthVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MonthVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MinYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MinYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MinYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MinYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.MinYear(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MaxYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MaxYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxYear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MaxYear(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MaxYear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.MaxYear(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_DayVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DayVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_DayVisible(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DayVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_Date(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_Date(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.Date(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_CalendarIdentifier(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"CalendarIdentifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CalendarIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_CalendarIdentifier(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"CalendarIdentifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CalendarIdentifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_YearFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YearFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_YearFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YearFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MonthFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_MonthFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MonthFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_DayFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DayFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatePickerFlyout_put_DayFormat(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DayFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatePickerFlyout_get_CalendarIdentifierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"CalendarIdentifierProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::CalendarIdentifierProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_DateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::DateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_DayVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::DayVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MaxYearProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MaxYearProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MaxYearProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MinYearProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MinYearProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MinYearProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MonthVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_YearVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::YearVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_DayFormatProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DayFormatProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::DayFormatProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_MonthFormatProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"MonthFormatProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::MonthFormatProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_get_YearFormatProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"YearFormatProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::DatePickerFlyout::YearFormatProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_add_DatePicked(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DatePicked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::DatePickerFlyout, winrt::Windows::UI::Xaml::Controls::DatePickedEventArgs>>(arg);

            return py::convert(self->obj.DatePicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatePickerFlyout_remove_DatePicked(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.DatePickerFlyout", L"DatePicked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DatePicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DatePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::DatePickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::DatePickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(DatePickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_date_picked", reinterpret_cast<PyCFunction>(DatePickerFlyout_add_DatePicked), METH_O, nullptr },
        { "remove_date_picked", reinterpret_cast<PyCFunction>(DatePickerFlyout_remove_DatePicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_DatePickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerFlyout[] = {
        { "year_visible", reinterpret_cast<getter>(DatePickerFlyout_get_YearVisible), reinterpret_cast<setter>(DatePickerFlyout_put_YearVisible), nullptr, nullptr },
        { "month_visible", reinterpret_cast<getter>(DatePickerFlyout_get_MonthVisible), reinterpret_cast<setter>(DatePickerFlyout_put_MonthVisible), nullptr, nullptr },
        { "min_year", reinterpret_cast<getter>(DatePickerFlyout_get_MinYear), reinterpret_cast<setter>(DatePickerFlyout_put_MinYear), nullptr, nullptr },
        { "max_year", reinterpret_cast<getter>(DatePickerFlyout_get_MaxYear), reinterpret_cast<setter>(DatePickerFlyout_put_MaxYear), nullptr, nullptr },
        { "day_visible", reinterpret_cast<getter>(DatePickerFlyout_get_DayVisible), reinterpret_cast<setter>(DatePickerFlyout_put_DayVisible), nullptr, nullptr },
        { "date", reinterpret_cast<getter>(DatePickerFlyout_get_Date), reinterpret_cast<setter>(DatePickerFlyout_put_Date), nullptr, nullptr },
        { "calendar_identifier", reinterpret_cast<getter>(DatePickerFlyout_get_CalendarIdentifier), reinterpret_cast<setter>(DatePickerFlyout_put_CalendarIdentifier), nullptr, nullptr },
        { "year_format", reinterpret_cast<getter>(DatePickerFlyout_get_YearFormat), reinterpret_cast<setter>(DatePickerFlyout_put_YearFormat), nullptr, nullptr },
        { "month_format", reinterpret_cast<getter>(DatePickerFlyout_get_MonthFormat), reinterpret_cast<setter>(DatePickerFlyout_put_MonthFormat), nullptr, nullptr },
        { "day_format", reinterpret_cast<getter>(DatePickerFlyout_get_DayFormat), reinterpret_cast<setter>(DatePickerFlyout_put_DayFormat), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatePickerFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerFlyout) },
        { },
    };

    static PyType_Spec type_spec_DatePickerFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.DatePickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::DatePickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerFlyout
    };

    static PyGetSetDef getset_DatePickerFlyout_Static[] = {
        { "calendar_identifier_property", reinterpret_cast<getter>(DatePickerFlyout_get_CalendarIdentifierProperty), nullptr, nullptr, nullptr },
        { "date_property", reinterpret_cast<getter>(DatePickerFlyout_get_DateProperty), nullptr, nullptr, nullptr },
        { "day_visible_property", reinterpret_cast<getter>(DatePickerFlyout_get_DayVisibleProperty), nullptr, nullptr, nullptr },
        { "max_year_property", reinterpret_cast<getter>(DatePickerFlyout_get_MaxYearProperty), nullptr, nullptr, nullptr },
        { "min_year_property", reinterpret_cast<getter>(DatePickerFlyout_get_MinYearProperty), nullptr, nullptr, nullptr },
        { "month_visible_property", reinterpret_cast<getter>(DatePickerFlyout_get_MonthVisibleProperty), nullptr, nullptr, nullptr },
        { "year_visible_property", reinterpret_cast<getter>(DatePickerFlyout_get_YearVisibleProperty), nullptr, nullptr, nullptr },
        { "day_format_property", reinterpret_cast<getter>(DatePickerFlyout_get_DayFormatProperty), nullptr, nullptr, nullptr },
        { "month_format_property", reinterpret_cast<getter>(DatePickerFlyout_get_MonthFormatProperty), nullptr, nullptr, nullptr },
        { "year_format_property", reinterpret_cast<getter>(DatePickerFlyout_get_YearFormatProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DatePickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DatePickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DatePickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DatePickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_DatePickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.DatePickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DatePickerFlyout_Static
    };

    // ----- DropDownButton class --------------------

    static PyObject* _new_DropDownButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::DropDownButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButton(py::wrapper::Windows::UI::Xaml::Controls::DropDownButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::DropDownButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::DropDownButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButton[] = {
        { "_assign_array_", _assign_array_DropDownButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropDownButton[] = {
        { }
    };

    static PyType_Slot _type_slots_DropDownButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButton) },
        { },
    };

    static PyType_Spec type_spec_DropDownButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.DropDownButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::DropDownButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropDownButton
    };

    // ----- FlipView class --------------------

    static PyObject* _new_FlipView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::FlipView instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipView(py::wrapper::Windows::UI::Xaml::Controls::FlipView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigation(py::wrapper::Windows::UI::Xaml::Controls::FlipView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UseTouchAnimationsForAllNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlipView_put_UseTouchAnimationsForAllNavigation(py::wrapper::Windows::UI::Xaml::Controls::FlipView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseTouchAnimationsForAllNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlipView_get_UseTouchAnimationsForAllNavigationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.FlipView", L"UseTouchAnimationsForAllNavigationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::FlipView::UseTouchAnimationsForAllNavigationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::FlipView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::FlipView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipView[] = {
        { "_assign_array_", _assign_array_FlipView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipView[] = {
        { "use_touch_animations_for_all_navigation", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigation), reinterpret_cast<setter>(FlipView_put_UseTouchAnimationsForAllNavigation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlipView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipView) },
        { },
    };

    static PyType_Spec type_spec_FlipView =
    {
        "winrt._winrt_windows_ui_xaml_controls_.FlipView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::FlipView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipView
    };

    static PyGetSetDef getset_FlipView_Static[] = {
        { "use_touch_animations_for_all_navigation_property", reinterpret_cast<getter>(FlipView_get_UseTouchAnimationsForAllNavigationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlipView_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipView_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipView_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.FlipView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipView_Static
    };

    // ----- FlipViewItem class --------------------

    static PyObject* _new_FlipViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::FlipViewItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItem(py::wrapper::Windows::UI::Xaml::Controls::FlipViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::FlipViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::FlipViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItem[] = {
        { "_assign_array_", _assign_array_FlipViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItem[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItem) },
        { },
    };

    static PyType_Spec type_spec_FlipViewItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.FlipViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::FlipViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItem
    };

    // ----- Flyout class --------------------

    static PyObject* _new_Flyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Flyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Flyout(py::wrapper::Windows::UI::Xaml::Controls::Flyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Flyout_get_FlyoutPresenterStyle(py::wrapper::Windows::UI::Xaml::Controls::Flyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"FlyoutPresenterStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlyoutPresenterStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Flyout_put_FlyoutPresenterStyle(py::wrapper::Windows::UI::Xaml::Controls::Flyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"FlyoutPresenterStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.FlyoutPresenterStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Flyout_get_Content(py::wrapper::Windows::UI::Xaml::Controls::Flyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Flyout_put_Content(py::wrapper::Windows::UI::Xaml::Controls::Flyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Flyout_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"ContentProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Flyout::ContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Flyout_get_FlyoutPresenterStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Flyout", L"FlyoutPresenterStyleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Flyout::FlyoutPresenterStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Flyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Flyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Flyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Flyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Flyout[] = {
        { "_assign_array_", _assign_array_Flyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Flyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Flyout[] = {
        { "flyout_presenter_style", reinterpret_cast<getter>(Flyout_get_FlyoutPresenterStyle), reinterpret_cast<setter>(Flyout_put_FlyoutPresenterStyle), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(Flyout_get_Content), reinterpret_cast<setter>(Flyout_put_Content), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Flyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Flyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Flyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Flyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Flyout) },
        { },
    };

    static PyType_Spec type_spec_Flyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.Flyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Flyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Flyout
    };

    static PyGetSetDef getset_Flyout_Static[] = {
        { "content_property", reinterpret_cast<getter>(Flyout_get_ContentProperty), nullptr, nullptr, nullptr },
        { "flyout_presenter_style_property", reinterpret_cast<getter>(Flyout_get_FlyoutPresenterStyleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Flyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Flyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Flyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Flyout_Static) },
        { }
    };

    static PyType_Spec type_spec_Flyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.Flyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Flyout_Static
    };

    // ----- GridView class --------------------

    static PyObject* _new_GridView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::GridView instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridView(py::wrapper::Windows::UI::Xaml::Controls::GridView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::GridView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::GridView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridView[] = {
        { "_assign_array_", _assign_array_GridView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridView[] = {
        { }
    };

    static PyType_Slot _type_slots_GridView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridView) },
        { },
    };

    static PyType_Spec type_spec_GridView =
    {
        "winrt._winrt_windows_ui_xaml_controls_.GridView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::GridView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridView
    };

    // ----- GridViewItem class --------------------

    static PyObject* _new_GridViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::GridViewItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItem(py::wrapper::Windows::UI::Xaml::Controls::GridViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItem_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::GridViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.GridViewItem", L"TemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::GridViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::GridViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItem[] = {
        { "_assign_array_", _assign_array_GridViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(GridViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItem) },
        { },
    };

    static PyType_Spec type_spec_GridViewItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.GridViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::GridViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItem
    };

    // ----- HyperlinkButton class --------------------

    static PyObject* _new_HyperlinkButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::HyperlinkButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButton(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButton_get_NavigateUri(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NavigateUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HyperlinkButton_put_NavigateUri(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.NavigateUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HyperlinkButton_get_NavigateUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.HyperlinkButton", L"NavigateUriProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::HyperlinkButton::NavigateUriProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButton[] = {
        { "_assign_array_", _assign_array_HyperlinkButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButton[] = {
        { "navigate_uri", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUri), reinterpret_cast<setter>(HyperlinkButton_put_NavigateUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButton) },
        { },
    };

    static PyType_Spec type_spec_HyperlinkButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.HyperlinkButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::HyperlinkButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkButton
    };

    static PyGetSetDef getset_HyperlinkButton_Static[] = {
        { "navigate_uri_property", reinterpret_cast<getter>(HyperlinkButton_get_NavigateUriProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HyperlinkButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HyperlinkButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HyperlinkButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HyperlinkButton_Static) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.HyperlinkButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HyperlinkButton_Static
    };

    // ----- InkToolbarBallpointPenButton class --------------------

    static PyObject* _new_InkToolbarBallpointPenButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarBallpointPenButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarBallpointPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarBallpointPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarBallpointPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarBallpointPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarBallpointPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarBallpointPenButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarBallpointPenButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarBallpointPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarBallpointPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarBallpointPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarBallpointPenButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarBallpointPenButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarBallpointPenButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarBallpointPenButton
    };

    // ----- InkToolbarCustomPenButton class --------------------

    static PyObject* _new_InkToolbarCustomPenButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomPenButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarCustomPenButton_get_CustomPen(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomPen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomPenButton_put_CustomPen(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPen>(arg);

            self->obj.CustomPen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConfigurationContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomPenButton_put_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.ConfigurationContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_ConfigurationContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"ConfigurationContentProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton::ConfigurationContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarCustomPenButton_get_CustomPenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomPenButton", L"CustomPenProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton::CustomPenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarCustomPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomPenButton[] = {
        { "custom_pen", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_CustomPen), reinterpret_cast<setter>(InkToolbarCustomPenButton_put_CustomPen), nullptr, nullptr },
        { "configuration_content", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_ConfigurationContent), reinterpret_cast<setter>(InkToolbarCustomPenButton_put_ConfigurationContent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomPenButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomPenButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarCustomPenButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarCustomPenButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomPenButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarCustomPenButton
    };

    static PyGetSetDef getset_InkToolbarCustomPenButton_Static[] = {
        { "configuration_content_property", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_ConfigurationContentProperty), nullptr, nullptr, nullptr },
        { "custom_pen_property", reinterpret_cast<getter>(InkToolbarCustomPenButton_get_CustomPenProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarCustomPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarCustomPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarCustomPenButton_Static
    };

    // ----- InkToolbarCustomToggleButton class --------------------

    static PyObject* _new_InkToolbarCustomToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomToggleButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarCustomToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomToggleButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomToggleButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomToggleButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomToggleButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarCustomToggleButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarCustomToggleButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarCustomToggleButton
    };

    // ----- InkToolbarCustomToolButton class --------------------

    static PyObject* _new_InkToolbarCustomToolButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarCustomToolButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarCustomToolButton_get_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConfigurationContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarCustomToolButton_put_ConfigurationContent(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.ConfigurationContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarCustomToolButton_get_ConfigurationContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarCustomToolButton", L"ConfigurationContentProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton::ConfigurationContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarCustomToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarCustomToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarCustomToolButton[] = {
        { "_assign_array_", _assign_array_InkToolbarCustomToolButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarCustomToolButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarCustomToolButton[] = {
        { "configuration_content", reinterpret_cast<getter>(InkToolbarCustomToolButton_get_ConfigurationContent), reinterpret_cast<setter>(InkToolbarCustomToolButton_put_ConfigurationContent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarCustomToolButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarCustomToolButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarCustomToolButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarCustomToolButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarCustomToolButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarCustomToolButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarCustomToolButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarCustomToolButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarCustomToolButton
    };

    static PyGetSetDef getset_InkToolbarCustomToolButton_Static[] = {
        { "configuration_content_property", reinterpret_cast<getter>(InkToolbarCustomToolButton_get_ConfigurationContentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarCustomToolButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarCustomToolButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarCustomToolButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarCustomToolButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarCustomToolButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarCustomToolButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarCustomToolButton_Static
    };

    // ----- InkToolbarEraserButton class --------------------

    static PyObject* _new_InkToolbarEraserButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarEraserButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarEraserButton_get_IsClearAllVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsClearAllVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarEraserButton_put_IsClearAllVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsClearAllVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarEraserButton_get_IsClearAllVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarEraserButton", L"IsClearAllVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton::IsClearAllVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarEraserButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarEraserButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarEraserButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarEraserButton[] = {
        { "_assign_array_", _assign_array_InkToolbarEraserButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarEraserButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarEraserButton[] = {
        { "is_clear_all_visible", reinterpret_cast<getter>(InkToolbarEraserButton_get_IsClearAllVisible), reinterpret_cast<setter>(InkToolbarEraserButton_put_IsClearAllVisible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarEraserButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarEraserButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarEraserButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarEraserButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarEraserButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarEraserButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarEraserButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarEraserButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarEraserButton
    };

    static PyGetSetDef getset_InkToolbarEraserButton_Static[] = {
        { "is_clear_all_visible_property", reinterpret_cast<getter>(InkToolbarEraserButton_get_IsClearAllVisibleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarEraserButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarEraserButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarEraserButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarEraserButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarEraserButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarEraserButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarEraserButton_Static
    };

    // ----- InkToolbarFlyoutItem class --------------------

    static PyObject* _new_InkToolbarFlyoutItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarFlyoutItem(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarFlyoutItem_get_Kind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarFlyoutItem_put_Kind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItemKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_IsChecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsChecked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarFlyoutItem_put_IsChecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsChecked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChecked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"IsCheckedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem::IsCheckedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_get_KindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"KindProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem::KindProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_add_Checked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Checked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Checked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_remove_Checked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Checked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Checked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_add_Unchecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Unchecked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Unchecked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarFlyoutItem_remove_Unchecked(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.InkToolbarFlyoutItem", L"Unchecked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Unchecked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarFlyoutItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarFlyoutItem[] = {
        { "add_checked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_add_Checked), METH_O, nullptr },
        { "remove_checked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_remove_Checked), METH_O, nullptr },
        { "add_unchecked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_add_Unchecked), METH_O, nullptr },
        { "remove_unchecked", reinterpret_cast<PyCFunction>(InkToolbarFlyoutItem_remove_Unchecked), METH_O, nullptr },
        { "_assign_array_", _assign_array_InkToolbarFlyoutItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarFlyoutItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarFlyoutItem[] = {
        { "kind", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_Kind), reinterpret_cast<setter>(InkToolbarFlyoutItem_put_Kind), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_IsChecked), reinterpret_cast<setter>(InkToolbarFlyoutItem_put_IsChecked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarFlyoutItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarFlyoutItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarFlyoutItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarFlyoutItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarFlyoutItem) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarFlyoutItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarFlyoutItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarFlyoutItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarFlyoutItem
    };

    static PyGetSetDef getset_InkToolbarFlyoutItem_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "kind_property", reinterpret_cast<getter>(InkToolbarFlyoutItem_get_KindProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarFlyoutItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarFlyoutItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarFlyoutItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarFlyoutItem_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarFlyoutItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarFlyoutItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarFlyoutItem_Static
    };

    // ----- InkToolbarHighlighterButton class --------------------

    static PyObject* _new_InkToolbarHighlighterButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarHighlighterButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarHighlighterButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarHighlighterButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarHighlighterButton[] = {
        { "_assign_array_", _assign_array_InkToolbarHighlighterButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarHighlighterButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarHighlighterButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarHighlighterButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarHighlighterButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarHighlighterButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarHighlighterButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarHighlighterButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarHighlighterButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarHighlighterButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarHighlighterButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarHighlighterButton
    };

    // ----- InkToolbarMenuButton class --------------------

    static PyObject* _new_InkToolbarMenuButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarMenuButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarMenuButton_get_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExtensionGlyphShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarMenuButton_put_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExtensionGlyphShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarMenuButton_get_MenuKind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"MenuKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MenuKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarMenuButton_get_IsExtensionGlyphShownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarMenuButton", L"IsExtensionGlyphShownProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton::IsExtensionGlyphShownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarMenuButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarMenuButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarMenuButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarMenuButton[] = {
        { "_assign_array_", _assign_array_InkToolbarMenuButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarMenuButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarMenuButton[] = {
        { "is_extension_glyph_shown", reinterpret_cast<getter>(InkToolbarMenuButton_get_IsExtensionGlyphShown), reinterpret_cast<setter>(InkToolbarMenuButton_put_IsExtensionGlyphShown), nullptr, nullptr },
        { "menu_kind", reinterpret_cast<getter>(InkToolbarMenuButton_get_MenuKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarMenuButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarMenuButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarMenuButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarMenuButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarMenuButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarMenuButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarMenuButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarMenuButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarMenuButton
    };

    static PyGetSetDef getset_InkToolbarMenuButton_Static[] = {
        { "is_extension_glyph_shown_property", reinterpret_cast<getter>(InkToolbarMenuButton_get_IsExtensionGlyphShownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarMenuButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarMenuButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarMenuButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarMenuButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarMenuButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarMenuButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarMenuButton_Static
    };

    // ----- InkToolbarPenButton class --------------------

    static PyObject* _new_InkToolbarPenButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarPenButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarPenButton_get_SelectedStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_SelectedStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.SelectedStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushIndex(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedBrushIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_SelectedBrushIndex(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedBrushIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_Palette(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"Palette"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Palette());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_Palette(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"Palette"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Media::Brush>>(arg);

            self->obj.Palette(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_MinStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_MinStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MinStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_MaxStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxStrokeWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarPenButton_put_MaxStrokeWidth(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxStrokeWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrush(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_MaxStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MaxStrokeWidthProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::MaxStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_MinStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"MinStrokeWidthProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::MinStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_PaletteProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"PaletteProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::PaletteProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedBrushIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedBrushProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarPenButton_get_SelectedStrokeWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarPenButton", L"SelectedStrokeWidthProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton::SelectedStrokeWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarPenButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarPenButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarPenButton[] = {
        { "_assign_array_", _assign_array_InkToolbarPenButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarPenButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarPenButton[] = {
        { "selected_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_SelectedStrokeWidth), nullptr, nullptr },
        { "selected_brush_index", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushIndex), reinterpret_cast<setter>(InkToolbarPenButton_put_SelectedBrushIndex), nullptr, nullptr },
        { "palette", reinterpret_cast<getter>(InkToolbarPenButton_get_Palette), reinterpret_cast<setter>(InkToolbarPenButton_put_Palette), nullptr, nullptr },
        { "min_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_MinStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_MinStrokeWidth), nullptr, nullptr },
        { "max_stroke_width", reinterpret_cast<getter>(InkToolbarPenButton_get_MaxStrokeWidth), reinterpret_cast<setter>(InkToolbarPenButton_put_MaxStrokeWidth), nullptr, nullptr },
        { "selected_brush", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrush), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarPenButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarPenButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarPenButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarPenButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarPenButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarPenButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarPenButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPenButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarPenButton
    };

    static PyGetSetDef getset_InkToolbarPenButton_Static[] = {
        { "max_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_MaxStrokeWidthProperty), nullptr, nullptr, nullptr },
        { "min_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_MinStrokeWidthProperty), nullptr, nullptr, nullptr },
        { "palette_property", reinterpret_cast<getter>(InkToolbarPenButton_get_PaletteProperty), nullptr, nullptr, nullptr },
        { "selected_brush_index_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushIndexProperty), nullptr, nullptr, nullptr },
        { "selected_brush_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedBrushProperty), nullptr, nullptr, nullptr },
        { "selected_stroke_width_property", reinterpret_cast<getter>(InkToolbarPenButton_get_SelectedStrokeWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarPenButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarPenButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarPenButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarPenButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarPenButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarPenButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarPenButton_Static
    };

    // ----- InkToolbarPencilButton class --------------------

    static PyObject* _new_InkToolbarPencilButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarPencilButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPencilButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarPencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarPencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarPencilButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarPencilButton[] = {
        { "_assign_array_", _assign_array_InkToolbarPencilButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarPencilButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarPencilButton[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarPencilButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarPencilButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarPencilButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarPencilButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarPencilButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarPencilButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarPencilButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarPencilButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarPencilButton
    };

    // ----- InkToolbarRulerButton class --------------------

    static PyObject* _new_InkToolbarRulerButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarRulerButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarRulerButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarRulerButton_get_Ruler(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarRulerButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarRulerButton", L"Ruler"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ruler());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarRulerButton_get_RulerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarRulerButton", L"RulerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton::RulerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarRulerButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarRulerButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarRulerButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarRulerButton[] = {
        { "_assign_array_", _assign_array_InkToolbarRulerButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarRulerButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarRulerButton[] = {
        { "ruler", reinterpret_cast<getter>(InkToolbarRulerButton_get_Ruler), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarRulerButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarRulerButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarRulerButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarRulerButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarRulerButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarRulerButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarRulerButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarRulerButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarRulerButton
    };

    static PyGetSetDef getset_InkToolbarRulerButton_Static[] = {
        { "ruler_property", reinterpret_cast<getter>(InkToolbarRulerButton_get_RulerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarRulerButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarRulerButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarRulerButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarRulerButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarRulerButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarRulerButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarRulerButton_Static
    };

    // ----- InkToolbarStencilButton class --------------------

    static PyObject* _new_InkToolbarStencilButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkToolbarStencilButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarStencilButton_get_SelectedStencil(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencil"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedStencil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_SelectedStencil(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencil"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilKind>(arg);

            self->obj.SelectedStencil(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsRulerItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRulerItemVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_IsRulerItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRulerItemVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsProtractorItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsProtractorItemVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarStencilButton_put_IsProtractorItemVisible(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsProtractorItemVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarStencilButton_get_Protractor(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"Protractor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Protractor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_Ruler(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"Ruler"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Ruler());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsProtractorItemVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsProtractorItemVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::IsProtractorItemVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_IsRulerItemVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"IsRulerItemVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::IsRulerItemVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_ProtractorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"ProtractorProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::ProtractorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_RulerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"RulerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::RulerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarStencilButton_get_SelectedStencilProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarStencilButton", L"SelectedStencilProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton::SelectedStencilProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarStencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarStencilButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarStencilButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarStencilButton[] = {
        { "_assign_array_", _assign_array_InkToolbarStencilButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarStencilButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarStencilButton[] = {
        { "selected_stencil", reinterpret_cast<getter>(InkToolbarStencilButton_get_SelectedStencil), reinterpret_cast<setter>(InkToolbarStencilButton_put_SelectedStencil), nullptr, nullptr },
        { "is_ruler_item_visible", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsRulerItemVisible), reinterpret_cast<setter>(InkToolbarStencilButton_put_IsRulerItemVisible), nullptr, nullptr },
        { "is_protractor_item_visible", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsProtractorItemVisible), reinterpret_cast<setter>(InkToolbarStencilButton_put_IsProtractorItemVisible), nullptr, nullptr },
        { "protractor", reinterpret_cast<getter>(InkToolbarStencilButton_get_Protractor), nullptr, nullptr, nullptr },
        { "ruler", reinterpret_cast<getter>(InkToolbarStencilButton_get_Ruler), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarStencilButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarStencilButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarStencilButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarStencilButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarStencilButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarStencilButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarStencilButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarStencilButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarStencilButton
    };

    static PyGetSetDef getset_InkToolbarStencilButton_Static[] = {
        { "is_protractor_item_visible_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsProtractorItemVisibleProperty), nullptr, nullptr, nullptr },
        { "is_ruler_item_visible_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_IsRulerItemVisibleProperty), nullptr, nullptr, nullptr },
        { "protractor_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_ProtractorProperty), nullptr, nullptr, nullptr },
        { "ruler_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_RulerProperty), nullptr, nullptr, nullptr },
        { "selected_stencil_property", reinterpret_cast<getter>(InkToolbarStencilButton_get_SelectedStencilProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarStencilButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarStencilButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarStencilButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarStencilButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarStencilButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarStencilButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarStencilButton_Static
    };

    // ----- InkToolbarToggleButton class --------------------

    static PyObject* _new_InkToolbarToggleButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarToggleButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarToggleButton_get_ToggleKind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToggleButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToggleButton", L"ToggleKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarToggleButton[] = {
        { "_assign_array_", _assign_array_InkToolbarToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarToggleButton[] = {
        { "toggle_kind", reinterpret_cast<getter>(InkToolbarToggleButton_get_ToggleKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarToggleButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarToggleButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarToggleButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarToggleButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarToggleButton
    };

    // ----- InkToolbarToolButton class --------------------

    static PyObject* _new_InkToolbarToolButton(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>::type_name);
        return nullptr;
    }

    static void _dealloc_InkToolbarToolButton(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkToolbarToolButton_get_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExtensionGlyphShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkToolbarToolButton_put_IsExtensionGlyphShown(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExtensionGlyphShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkToolbarToolButton_get_ToolKind(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"ToolKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToolKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkToolbarToolButton_get_IsExtensionGlyphShownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.InkToolbarToolButton", L"IsExtensionGlyphShownProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton::IsExtensionGlyphShownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkToolbarToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarToolButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::InkToolbarToolButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarToolButton[] = {
        { "_assign_array_", _assign_array_InkToolbarToolButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarToolButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarToolButton[] = {
        { "is_extension_glyph_shown", reinterpret_cast<getter>(InkToolbarToolButton_get_IsExtensionGlyphShown), reinterpret_cast<setter>(InkToolbarToolButton_put_IsExtensionGlyphShown), nullptr, nullptr },
        { "tool_kind", reinterpret_cast<getter>(InkToolbarToolButton_get_ToolKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkToolbarToolButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarToolButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarToolButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarToolButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarToolButton) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarToolButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarToolButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::InkToolbarToolButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarToolButton
    };

    static PyGetSetDef getset_InkToolbarToolButton_Static[] = {
        { "is_extension_glyph_shown_property", reinterpret_cast<getter>(InkToolbarToolButton_get_IsExtensionGlyphShownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InkToolbarToolButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InkToolbarToolButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkToolbarToolButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkToolbarToolButton_Static) },
        { }
    };

    static PyType_Spec type_spec_InkToolbarToolButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.InkToolbarToolButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkToolbarToolButton_Static
    };

    // ----- ListBox class --------------------

    static PyObject* _new_ListBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBox(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBox_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListBox", L"ScrollIntoView", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_SelectAll(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectAll", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectedItems(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectedItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListBox_put_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListBox_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SelectionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListBox::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListBox_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListBox", L"SingleSelectionFollowsFocusProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListBox::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBox[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBox_ScrollIntoView), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListBox_SelectAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBox[] = {
        { "selection_mode", reinterpret_cast<getter>(ListBox_get_SelectionMode), reinterpret_cast<setter>(ListBox_put_SelectionMode), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListBox_get_SelectedItems), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListBox_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBox) },
        { },
    };

    static PyType_Spec type_spec_ListBox =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListBox",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBox
    };

    static PyGetSetDef getset_ListBox_Static[] = {
        { "selection_mode_property", reinterpret_cast<getter>(ListBox_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListBox_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListBox_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBox_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBox_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBox_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBox_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListBox_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBox_Static
    };

    // ----- ListBoxItem class --------------------

    static PyObject* _new_ListBoxItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListBoxItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItem(py::wrapper::Windows::UI::Xaml::Controls::ListBoxItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListBoxItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListBoxItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItem[] = {
        { "_assign_array_", _assign_array_ListBoxItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItem[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItem) },
        { },
    };

    static PyType_Spec type_spec_ListBoxItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListBoxItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListBoxItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItem
    };

    // ----- ListPickerFlyout class --------------------

    static PyObject* _new_ListPickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListPickerFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListPickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListPickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ShowAtAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListPickerFlyoutSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValuePath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValuePath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedValuePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedValuePath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValuePath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SelectedValuePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValue(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedValue(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedItem(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedItem(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItem"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedIndex(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_SelectedIndex(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.ItemTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_DisplayMemberPath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"DisplayMemberPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayMemberPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListPickerFlyout_put_DisplayMemberPath(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"DisplayMemberPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayMemberPath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedItems(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_DisplayMemberPathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"DisplayMemberPathProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::DisplayMemberPathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemTemplateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::ItemTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsSourceProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedItemProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValuePathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValuePathProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedValuePathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectedValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectedValueProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectedValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"SelectionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListPickerFlyout::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_add_ItemsPicked(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsPicked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListPickerFlyout, winrt::Windows::UI::Xaml::Controls::ItemsPickedEventArgs>>(arg);

            return py::convert(self->obj.ItemsPicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListPickerFlyout_remove_ItemsPicked(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListPickerFlyout", L"ItemsPicked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemsPicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListPickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListPickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListPickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListPickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListPickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(ListPickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_items_picked", reinterpret_cast<PyCFunction>(ListPickerFlyout_add_ItemsPicked), METH_O, nullptr },
        { "remove_items_picked", reinterpret_cast<PyCFunction>(ListPickerFlyout_remove_ItemsPicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_ListPickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListPickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListPickerFlyout[] = {
        { "selection_mode", reinterpret_cast<getter>(ListPickerFlyout_get_SelectionMode), reinterpret_cast<setter>(ListPickerFlyout_put_SelectionMode), nullptr, nullptr },
        { "selected_value_path", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValuePath), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedValuePath), nullptr, nullptr },
        { "selected_value", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValue), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedValue), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedItem), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedIndex), reinterpret_cast<setter>(ListPickerFlyout_put_SelectedIndex), nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(ListPickerFlyout_get_ItemsSource), reinterpret_cast<setter>(ListPickerFlyout_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(ListPickerFlyout_get_ItemTemplate), reinterpret_cast<setter>(ListPickerFlyout_put_ItemTemplate), nullptr, nullptr },
        { "display_member_path", reinterpret_cast<getter>(ListPickerFlyout_get_DisplayMemberPath), reinterpret_cast<setter>(ListPickerFlyout_put_DisplayMemberPath), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListPickerFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListPickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListPickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListPickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListPickerFlyout) },
        { },
    };

    static PyType_Spec type_spec_ListPickerFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListPickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListPickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListPickerFlyout
    };

    static PyGetSetDef getset_ListPickerFlyout_Static[] = {
        { "display_member_path_property", reinterpret_cast<getter>(ListPickerFlyout_get_DisplayMemberPathProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(ListPickerFlyout_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(ListPickerFlyout_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "selected_value_path_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValuePathProperty), nullptr, nullptr, nullptr },
        { "selected_value_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectedValueProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(ListPickerFlyout_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListPickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListPickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListPickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListPickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_ListPickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListPickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListPickerFlyout_Static
    };

    // ----- ListView class --------------------

    static PyObject* _new_ListView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListView instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListView(py::wrapper::Windows::UI::Xaml::Controls::ListView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListView[] = {
        { "_assign_array_", _assign_array_ListView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListView[] = {
        { }
    };

    static PyType_Slot _type_slots_ListView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListView) },
        { },
    };

    static PyType_Spec type_spec_ListView =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListView
    };

    // ----- ListViewBase class --------------------

    static PyObject* _new_ListViewBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::ListViewBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::ListViewBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBase(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBase_CompleteViewChange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChange", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CompleteViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeFrom(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeFrom", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.CompleteViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_CompleteViewChangeTo(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CompleteViewChangeTo", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.CompleteViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_DeselectRange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DeselectRange", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.DeselectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_InitializeViewChange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"InitializeViewChange", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.InitializeViewChange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_IsDragSource(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsDragSource", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsDragSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_LoadMoreItemsAsync(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"LoadMoreItemsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.LoadMoreItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_MakeVisible(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"MakeVisible", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);

                self->obj.MakeVisible(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_PrepareConnectedAnimation(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"PrepareConnectedAnimation", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.PrepareConnectedAnimation(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ScrollIntoView", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollIntoViewAlignment>(args, 1);

                self->obj.ScrollIntoView(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectAll(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectAll", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SelectRange(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectRange", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::ItemIndexRange>(args, 0);

                self->obj.SelectRange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_SetDesiredContainerUpdateDuration(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SetDesiredContainerUpdateDuration", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetDesiredContainerUpdateDuration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeFrom(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"StartViewChangeFrom", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.StartViewChangeFrom(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_StartViewChangeTo(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"StartViewChangeTo", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoomLocation>(args, 1);

                self->obj.StartViewChangeTo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_TryStartConnectedAnimationAsync(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"TryStartConnectedAnimationAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.TryStartConnectedAnimationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SelectionMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSwipeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsSwipeEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSwipeEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItemClickEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsItemClickEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsItemClickEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTrigger(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncrementalLoadingTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingTrigger(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTrigger"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IncrementalLoadingTrigger>(arg);

            self->obj.IncrementalLoadingTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThreshold(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IncrementalLoadingThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IncrementalLoadingThreshold(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.IncrementalLoadingThreshold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.HeaderTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Header(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Header"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Header(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Header"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSize(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataFetchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_DataFetchSize(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.DataFetchSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanReorderItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanReorderItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanReorderItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanDragItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_CanDragItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanDragItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedItems(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectedItems"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholders(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowsScrollingPlaceholders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ShowsScrollingPlaceholders(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowsScrollingPlaceholders(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FooterTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTransitions(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.FooterTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FooterTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_FooterTemplate(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.FooterTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_Footer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Footer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Footer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_Footer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"Footer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Footer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_ReorderMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReorderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_ReorderMode(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewReorderMode>(arg);

            self->obj.ReorderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMultiSelectCheckBoxEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsMultiSelectCheckBoxEnabled(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMultiSelectCheckBoxEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SelectedRanges(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectedRanges"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SingleSelectionFollowsFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SingleSelectionFollowsFocus(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SingleSelectionFollowsFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwner(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SemanticZoomOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_SemanticZoomOwner(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoom>(arg);

            self->obj.SemanticZoomOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsZoomedInView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsZoomedInView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZoomedInView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_IsActiveView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsActiveView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewBase_put_IsActiveView(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsActiveView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewBase_get_CanDragItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanDragItemsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::CanDragItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_CanReorderItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"CanReorderItemsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::CanReorderItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_DataFetchSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DataFetchSizeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::DataFetchSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTemplateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_HeaderTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"HeaderTransitionsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::HeaderTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingThresholdProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingThresholdProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IncrementalLoadingThresholdProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IncrementalLoadingTriggerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IncrementalLoadingTriggerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IncrementalLoadingTriggerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsActiveViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsActiveViewProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsActiveViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsItemClickEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsItemClickEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsItemClickEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsSwipeEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsSwipeEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsSwipeEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsZoomedInViewProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsZoomedInViewProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsZoomedInViewProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SelectionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SelectionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SelectionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SemanticZoomOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SemanticZoomOwnerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SemanticZoomOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTemplateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_FooterTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"FooterTransitionsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::FooterTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ShowsScrollingPlaceholdersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ShowsScrollingPlaceholdersProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::ShowsScrollingPlaceholdersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_ReorderModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ReorderModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::ReorderModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"IsMultiSelectCheckBoxEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::IsMultiSelectCheckBoxEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_get_SingleSelectionFollowsFocusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"SingleSelectionFollowsFocusProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ListViewBase::SingleSelectionFollowsFocusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsStarting(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DragItemsStartingEventHandler>(arg);

            return py::convert(self->obj.DragItemsStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsStarting(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragItemsStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ItemClick(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ItemClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ItemClickEventHandler>(arg);

            return py::convert(self->obj.ItemClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ItemClick(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ItemClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ContainerContentChanging(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ContainerContentChangingEventArgs>>(arg);

            return py::convert(self->obj.ContainerContentChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ContainerContentChanging(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ContainerContentChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContainerContentChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingGroupHeaderContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ChoosingGroupHeaderContainerEventArgs>>(arg);

            return py::convert(self->obj.ChoosingGroupHeaderContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingGroupHeaderContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingGroupHeaderContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ChoosingGroupHeaderContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_ChoosingItemContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::ChoosingItemContainerEventArgs>>(arg);

            return py::convert(self->obj.ChoosingItemContainer(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_ChoosingItemContainer(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"ChoosingItemContainer"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ChoosingItemContainer(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_add_DragItemsCompleted(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::ListViewBase, winrt::Windows::UI::Xaml::Controls::DragItemsCompletedEventArgs>>(arg);

            return py::convert(self->obj.DragItemsCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBase_remove_DragItemsCompleted(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.ListViewBase", L"DragItemsCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragItemsCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListViewBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListViewBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBase[] = {
        { "complete_view_change", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChange), METH_VARARGS, nullptr },
        { "complete_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeFrom), METH_VARARGS, nullptr },
        { "complete_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_CompleteViewChangeTo), METH_VARARGS, nullptr },
        { "deselect_range", reinterpret_cast<PyCFunction>(ListViewBase_DeselectRange), METH_VARARGS, nullptr },
        { "initialize_view_change", reinterpret_cast<PyCFunction>(ListViewBase_InitializeViewChange), METH_VARARGS, nullptr },
        { "is_drag_source", reinterpret_cast<PyCFunction>(ListViewBase_IsDragSource), METH_VARARGS, nullptr },
        { "load_more_items_async", reinterpret_cast<PyCFunction>(ListViewBase_LoadMoreItemsAsync), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(ListViewBase_MakeVisible), METH_VARARGS, nullptr },
        { "prepare_connected_animation", reinterpret_cast<PyCFunction>(ListViewBase_PrepareConnectedAnimation), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewBase_ScrollIntoView), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(ListViewBase_SelectAll), METH_VARARGS, nullptr },
        { "select_range", reinterpret_cast<PyCFunction>(ListViewBase_SelectRange), METH_VARARGS, nullptr },
        { "set_desired_container_update_duration", reinterpret_cast<PyCFunction>(ListViewBase_SetDesiredContainerUpdateDuration), METH_VARARGS, nullptr },
        { "start_view_change_from", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeFrom), METH_VARARGS, nullptr },
        { "start_view_change_to", reinterpret_cast<PyCFunction>(ListViewBase_StartViewChangeTo), METH_VARARGS, nullptr },
        { "try_start_connected_animation_async", reinterpret_cast<PyCFunction>(ListViewBase_TryStartConnectedAnimationAsync), METH_VARARGS, nullptr },
        { "add_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsStarting), METH_O, nullptr },
        { "remove_drag_items_starting", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsStarting), METH_O, nullptr },
        { "add_item_click", reinterpret_cast<PyCFunction>(ListViewBase_add_ItemClick), METH_O, nullptr },
        { "remove_item_click", reinterpret_cast<PyCFunction>(ListViewBase_remove_ItemClick), METH_O, nullptr },
        { "add_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_add_ContainerContentChanging), METH_O, nullptr },
        { "remove_container_content_changing", reinterpret_cast<PyCFunction>(ListViewBase_remove_ContainerContentChanging), METH_O, nullptr },
        { "add_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "remove_choosing_group_header_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingGroupHeaderContainer), METH_O, nullptr },
        { "add_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_add_ChoosingItemContainer), METH_O, nullptr },
        { "remove_choosing_item_container", reinterpret_cast<PyCFunction>(ListViewBase_remove_ChoosingItemContainer), METH_O, nullptr },
        { "add_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_add_DragItemsCompleted), METH_O, nullptr },
        { "remove_drag_items_completed", reinterpret_cast<PyCFunction>(ListViewBase_remove_DragItemsCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ListViewBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBase[] = {
        { "selection_mode", reinterpret_cast<getter>(ListViewBase_get_SelectionMode), reinterpret_cast<setter>(ListViewBase_put_SelectionMode), nullptr, nullptr },
        { "is_swipe_enabled", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabled), reinterpret_cast<setter>(ListViewBase_put_IsSwipeEnabled), nullptr, nullptr },
        { "is_item_click_enabled", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabled), reinterpret_cast<setter>(ListViewBase_put_IsItemClickEnabled), nullptr, nullptr },
        { "incremental_loading_trigger", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTrigger), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingTrigger), nullptr, nullptr },
        { "incremental_loading_threshold", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThreshold), reinterpret_cast<setter>(ListViewBase_put_IncrementalLoadingThreshold), nullptr, nullptr },
        { "header_transitions", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitions), reinterpret_cast<setter>(ListViewBase_put_HeaderTransitions), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplate), reinterpret_cast<setter>(ListViewBase_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(ListViewBase_get_Header), reinterpret_cast<setter>(ListViewBase_put_Header), nullptr, nullptr },
        { "data_fetch_size", reinterpret_cast<getter>(ListViewBase_get_DataFetchSize), reinterpret_cast<setter>(ListViewBase_put_DataFetchSize), nullptr, nullptr },
        { "can_reorder_items", reinterpret_cast<getter>(ListViewBase_get_CanReorderItems), reinterpret_cast<setter>(ListViewBase_put_CanReorderItems), nullptr, nullptr },
        { "can_drag_items", reinterpret_cast<getter>(ListViewBase_get_CanDragItems), reinterpret_cast<setter>(ListViewBase_put_CanDragItems), nullptr, nullptr },
        { "selected_items", reinterpret_cast<getter>(ListViewBase_get_SelectedItems), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholders), reinterpret_cast<setter>(ListViewBase_put_ShowsScrollingPlaceholders), nullptr, nullptr },
        { "footer_transitions", reinterpret_cast<getter>(ListViewBase_get_FooterTransitions), reinterpret_cast<setter>(ListViewBase_put_FooterTransitions), nullptr, nullptr },
        { "footer_template", reinterpret_cast<getter>(ListViewBase_get_FooterTemplate), reinterpret_cast<setter>(ListViewBase_put_FooterTemplate), nullptr, nullptr },
        { "footer", reinterpret_cast<getter>(ListViewBase_get_Footer), reinterpret_cast<setter>(ListViewBase_put_Footer), nullptr, nullptr },
        { "reorder_mode", reinterpret_cast<getter>(ListViewBase_get_ReorderMode), reinterpret_cast<setter>(ListViewBase_put_ReorderMode), nullptr, nullptr },
        { "is_multi_select_check_box_enabled", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabled), reinterpret_cast<setter>(ListViewBase_put_IsMultiSelectCheckBoxEnabled), nullptr, nullptr },
        { "selected_ranges", reinterpret_cast<getter>(ListViewBase_get_SelectedRanges), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocus), reinterpret_cast<setter>(ListViewBase_put_SingleSelectionFollowsFocus), nullptr, nullptr },
        { "semantic_zoom_owner", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwner), reinterpret_cast<setter>(ListViewBase_put_SemanticZoomOwner), nullptr, nullptr },
        { "is_zoomed_in_view", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInView), reinterpret_cast<setter>(ListViewBase_put_IsZoomedInView), nullptr, nullptr },
        { "is_active_view", reinterpret_cast<getter>(ListViewBase_get_IsActiveView), reinterpret_cast<setter>(ListViewBase_put_IsActiveView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBase) },
        { },
    };

    static PyType_Spec type_spec_ListViewBase =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListViewBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListViewBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBase
    };

    static PyGetSetDef getset_ListViewBase_Static[] = {
        { "can_drag_items_property", reinterpret_cast<getter>(ListViewBase_get_CanDragItemsProperty), nullptr, nullptr, nullptr },
        { "can_reorder_items_property", reinterpret_cast<getter>(ListViewBase_get_CanReorderItemsProperty), nullptr, nullptr, nullptr },
        { "data_fetch_size_property", reinterpret_cast<getter>(ListViewBase_get_DataFetchSizeProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(ListViewBase_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { "header_transitions_property", reinterpret_cast<getter>(ListViewBase_get_HeaderTransitionsProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_threshold_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingThresholdProperty), nullptr, nullptr, nullptr },
        { "incremental_loading_trigger_property", reinterpret_cast<getter>(ListViewBase_get_IncrementalLoadingTriggerProperty), nullptr, nullptr, nullptr },
        { "is_active_view_property", reinterpret_cast<getter>(ListViewBase_get_IsActiveViewProperty), nullptr, nullptr, nullptr },
        { "is_item_click_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsItemClickEnabledProperty), nullptr, nullptr, nullptr },
        { "is_swipe_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsSwipeEnabledProperty), nullptr, nullptr, nullptr },
        { "is_zoomed_in_view_property", reinterpret_cast<getter>(ListViewBase_get_IsZoomedInViewProperty), nullptr, nullptr, nullptr },
        { "selection_mode_property", reinterpret_cast<getter>(ListViewBase_get_SelectionModeProperty), nullptr, nullptr, nullptr },
        { "semantic_zoom_owner_property", reinterpret_cast<getter>(ListViewBase_get_SemanticZoomOwnerProperty), nullptr, nullptr, nullptr },
        { "footer_property", reinterpret_cast<getter>(ListViewBase_get_FooterProperty), nullptr, nullptr, nullptr },
        { "footer_template_property", reinterpret_cast<getter>(ListViewBase_get_FooterTemplateProperty), nullptr, nullptr, nullptr },
        { "footer_transitions_property", reinterpret_cast<getter>(ListViewBase_get_FooterTransitionsProperty), nullptr, nullptr, nullptr },
        { "shows_scrolling_placeholders_property", reinterpret_cast<getter>(ListViewBase_get_ShowsScrollingPlaceholdersProperty), nullptr, nullptr, nullptr },
        { "reorder_mode_property", reinterpret_cast<getter>(ListViewBase_get_ReorderModeProperty), nullptr, nullptr, nullptr },
        { "is_multi_select_check_box_enabled_property", reinterpret_cast<getter>(ListViewBase_get_IsMultiSelectCheckBoxEnabledProperty), nullptr, nullptr, nullptr },
        { "single_selection_follows_focus_property", reinterpret_cast<getter>(ListViewBase_get_SingleSelectionFollowsFocusProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListViewBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewBase_Static
    };

    // ----- ListViewItem class --------------------

    static PyObject* _new_ListViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ListViewItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItem(py::wrapper::Windows::UI::Xaml::Controls::ListViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItem_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::ListViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ListViewItem", L"TemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ListViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ListViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItem[] = {
        { "_assign_array_", _assign_array_ListViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItem[] = {
        { "template_settings", reinterpret_cast<getter>(ListViewItem_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItem) },
        { },
    };

    static PyType_Spec type_spec_ListViewItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ListViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ListViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItem
    };

    // ----- MenuBarItemFlyout class --------------------

    static PyObject* _new_MenuBarItemFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemFlyout(py::wrapper::Windows::UI::Xaml::Controls::MenuBarItemFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarItemFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::MenuBarItemFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemFlyout[] = {
        { "_assign_array_", _assign_array_MenuBarItemFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarItemFlyout[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuBarItemFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemFlyout) },
        { },
    };

    static PyType_Spec type_spec_MenuBarItemFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.MenuBarItemFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::MenuBarItemFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarItemFlyout
    };

    // ----- MenuFlyout class --------------------

    static PyObject* _new_MenuFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::MenuFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyout(py::wrapper::Windows::UI::Xaml::Controls::MenuFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyout_ShowAt(py::wrapper::Windows::UI::Xaml::Controls::MenuFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"ShowAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.ShowAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuFlyout_get_MenuFlyoutPresenterStyle(py::wrapper::Windows::UI::Xaml::Controls::MenuFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"MenuFlyoutPresenterStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MenuFlyoutPresenterStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MenuFlyout_put_MenuFlyoutPresenterStyle(py::wrapper::Windows::UI::Xaml::Controls::MenuFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"MenuFlyoutPresenterStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.MenuFlyoutPresenterStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MenuFlyout_get_Items(py::wrapper::Windows::UI::Xaml::Controls::MenuFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"Items"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MenuFlyout_get_MenuFlyoutPresenterStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.MenuFlyout", L"MenuFlyoutPresenterStyleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::MenuFlyout::MenuFlyoutPresenterStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::MenuFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::MenuFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyout[] = {
        { "show_at", reinterpret_cast<PyCFunction>(MenuFlyout_ShowAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyout[] = {
        { "menu_flyout_presenter_style", reinterpret_cast<getter>(MenuFlyout_get_MenuFlyoutPresenterStyle), reinterpret_cast<setter>(MenuFlyout_put_MenuFlyoutPresenterStyle), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(MenuFlyout_get_Items), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyout) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.MenuFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::MenuFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyout
    };

    static PyGetSetDef getset_MenuFlyout_Static[] = {
        { "menu_flyout_presenter_style_property", reinterpret_cast<getter>(MenuFlyout_get_MenuFlyoutPresenterStyleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MenuFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.MenuFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MenuFlyout_Static
    };

    // ----- NavigationViewItem class --------------------

    static PyObject* _new_NavigationViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItem(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItem_get_Icon(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_Icon(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLength(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompactPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvoked(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectsOnInvoked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItem_put_SelectsOnInvoked(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvoked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SelectsOnInvoked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItem_get_CompactPaneLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"CompactPaneLengthProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::CompactPaneLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"IconProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItem_get_SelectsOnInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.NavigationViewItem", L"SelectsOnInvokedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::NavigationViewItem::SelectsOnInvokedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItem[] = {
        { "_assign_array_", _assign_array_NavigationViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItem[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItem_get_Icon), reinterpret_cast<setter>(NavigationViewItem_put_Icon), nullptr, nullptr },
        { "compact_pane_length", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLength), nullptr, nullptr, nullptr },
        { "selects_on_invoked", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvoked), reinterpret_cast<setter>(NavigationViewItem_put_SelectsOnInvoked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItem) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.NavigationViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItem
    };

    static PyGetSetDef getset_NavigationViewItem_Static[] = {
        { "compact_pane_length_property", reinterpret_cast<getter>(NavigationViewItem_get_CompactPaneLengthProperty), nullptr, nullptr, nullptr },
        { "icon_property", reinterpret_cast<getter>(NavigationViewItem_get_IconProperty), nullptr, nullptr, nullptr },
        { "selects_on_invoked_property", reinterpret_cast<getter>(NavigationViewItem_get_SelectsOnInvokedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.NavigationViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItem_Static
    };

    // ----- NavigationViewItemBase class --------------------

    static PyObject* _new_NavigationViewItemBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>::type_name);
        return nullptr;
    }

    static void _dealloc_NavigationViewItemBase(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemBase[] = {
        { "_assign_array_", _assign_array_NavigationViewItemBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemBase[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemBase) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemBase =
    {
        "winrt._winrt_windows_ui_xaml_controls_.NavigationViewItemBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemBase
    };

    // ----- NavigationViewItemHeader class --------------------

    static PyObject* _new_NavigationViewItemHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemHeader(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemHeader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemHeader[] = {
        { "_assign_array_", _assign_array_NavigationViewItemHeader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemHeader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemHeader[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemHeader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemHeader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemHeader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemHeader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemHeader) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemHeader =
    {
        "winrt._winrt_windows_ui_xaml_controls_.NavigationViewItemHeader",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemHeader
    };

    // ----- NavigationViewItemSeparator class --------------------

    static PyObject* _new_NavigationViewItemSeparator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemSeparator(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemSeparator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemSeparator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewItemSeparator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemSeparator[] = {
        { "_assign_array_", _assign_array_NavigationViewItemSeparator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemSeparator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemSeparator[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemSeparator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemSeparator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemSeparator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemSeparator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemSeparator) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemSeparator =
    {
        "winrt._winrt_windows_ui_xaml_controls_.NavigationViewItemSeparator",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewItemSeparator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemSeparator
    };

    // ----- NavigationViewList class --------------------

    static PyObject* _new_NavigationViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::NavigationViewList instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewList(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::NavigationViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::NavigationViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewList[] = {
        { "_assign_array_", _assign_array_NavigationViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewList) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewList =
    {
        "winrt._winrt_windows_ui_xaml_controls_.NavigationViewList",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::NavigationViewList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewList
    };

    // ----- PickerFlyout class --------------------

    static PyObject* _new_PickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::PickerFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ShowAtAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_get_Content(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PickerFlyout_put_Content(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PickerFlyout_get_ConfirmationButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ConfirmationButtonsVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConfirmationButtonsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PickerFlyout_put_ConfirmationButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ConfirmationButtonsVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConfirmationButtonsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PickerFlyout_get_ConfirmationButtonsVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ConfirmationButtonsVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::PickerFlyout::ConfirmationButtonsVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"ContentProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::PickerFlyout::ContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_add_Confirmed(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Confirmed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::PickerFlyout, winrt::Windows::UI::Xaml::Controls::PickerConfirmedEventArgs>>(arg);

            return py::convert(self->obj.Confirmed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerFlyout_remove_Confirmed(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.PickerFlyout", L"Confirmed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Confirmed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::PickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::PickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(PickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_confirmed", reinterpret_cast<PyCFunction>(PickerFlyout_add_Confirmed), METH_O, nullptr },
        { "remove_confirmed", reinterpret_cast<PyCFunction>(PickerFlyout_remove_Confirmed), METH_O, nullptr },
        { "_assign_array_", _assign_array_PickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyout[] = {
        { "content", reinterpret_cast<getter>(PickerFlyout_get_Content), reinterpret_cast<setter>(PickerFlyout_put_Content), nullptr, nullptr },
        { "confirmation_buttons_visible", reinterpret_cast<getter>(PickerFlyout_get_ConfirmationButtonsVisible), reinterpret_cast<setter>(PickerFlyout_put_ConfirmationButtonsVisible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PickerFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyout) },
        { },
    };

    static PyType_Spec type_spec_PickerFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.PickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::PickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyout
    };

    static PyGetSetDef getset_PickerFlyout_Static[] = {
        { "confirmation_buttons_visible_property", reinterpret_cast<getter>(PickerFlyout_get_ConfirmationButtonsVisibleProperty), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(PickerFlyout_get_ContentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.PickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PickerFlyout_Static
    };

    // ----- ProgressBar class --------------------

    static PyObject* _new_ProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::ProgressBar instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBar(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBar_get_ShowPaused(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPaused"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowPaused(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPaused"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_ShowError(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_ShowError(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminate(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsIndeterminate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProgressBar_put_IsIndeterminate(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIndeterminate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProgressBar_get_TemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"TemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_IsIndeterminateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"IsIndeterminateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::IsIndeterminateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowErrorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowErrorProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::ShowErrorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBar_get_ShowPausedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.ProgressBar", L"ShowPausedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::ProgressBar::ShowPausedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::ProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::ProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBar[] = {
        { "_assign_array_", _assign_array_ProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBar[] = {
        { "show_paused", reinterpret_cast<getter>(ProgressBar_get_ShowPaused), reinterpret_cast<setter>(ProgressBar_put_ShowPaused), nullptr, nullptr },
        { "show_error", reinterpret_cast<getter>(ProgressBar_get_ShowError), reinterpret_cast<setter>(ProgressBar_put_ShowError), nullptr, nullptr },
        { "is_indeterminate", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminate), reinterpret_cast<setter>(ProgressBar_put_IsIndeterminate), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(ProgressBar_get_TemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBar) },
        { },
    };

    static PyType_Spec type_spec_ProgressBar =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ProgressBar",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::ProgressBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBar
    };

    static PyGetSetDef getset_ProgressBar_Static[] = {
        { "is_indeterminate_property", reinterpret_cast<getter>(ProgressBar_get_IsIndeterminateProperty), nullptr, nullptr, nullptr },
        { "show_error_property", reinterpret_cast<getter>(ProgressBar_get_ShowErrorProperty), nullptr, nullptr, nullptr },
        { "show_paused_property", reinterpret_cast<getter>(ProgressBar_get_ShowPausedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ProgressBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBar_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.ProgressBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProgressBar_Static
    };

    // ----- RadioButton class --------------------

    static PyObject* _new_RadioButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::RadioButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButton(py::wrapper::Windows::UI::Xaml::Controls::RadioButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButton_get_GroupName(py::wrapper::Windows::UI::Xaml::Controls::RadioButton* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadioButton_put_GroupName(py::wrapper::Windows::UI::Xaml::Controls::RadioButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GroupName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadioButton_get_GroupNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.RadioButton", L"GroupNameProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::RadioButton::GroupNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::RadioButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::RadioButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButton[] = {
        { "_assign_array_", _assign_array_RadioButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButton[] = {
        { "group_name", reinterpret_cast<getter>(RadioButton_get_GroupName), reinterpret_cast<setter>(RadioButton_put_GroupName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButton) },
        { },
    };

    static PyType_Spec type_spec_RadioButton =
    {
        "winrt._winrt_windows_ui_xaml_controls_.RadioButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::RadioButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButton
    };

    static PyGetSetDef getset_RadioButton_Static[] = {
        { "group_name_property", reinterpret_cast<getter>(RadioButton_get_GroupNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RadioButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.RadioButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadioButton_Static
    };

    // ----- Slider class --------------------

    static PyObject* _new_Slider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Slider instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Slider(py::wrapper::Windows::UI::Xaml::Controls::Slider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Slider_get_TickPlacement(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TickPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickPlacement(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::TickPlacement>(arg);

            self->obj.TickPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_TickFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TickFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_TickFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.TickFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverter(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ThumbToolTipValueConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_ThumbToolTipValueConverter(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Data::IValueConverter>(arg);

            self->obj.ThumbToolTipValueConverter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_StepFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_StepFrequency(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.StepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_SnapsTo(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SnapsTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_SnapsTo(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SliderSnapsTo>(arg);

            self->obj.SnapsTo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabled(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsThumbToolTipEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsThumbToolTipEnabled(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsThumbToolTipEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IsDirectionReversed(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDirectionReversed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IsDirectionReversed(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDirectionReversed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValue(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IntermediateValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_IntermediateValue(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.IntermediateValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_HeaderTemplate(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.HeaderTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_Header(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Header"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Slider_put_Header(py::wrapper::Windows::UI::Xaml::Controls::Slider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"Header"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Header(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Slider_get_IntermediateValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IntermediateValueProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IntermediateValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsDirectionReversedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsDirectionReversedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IsDirectionReversedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_IsThumbToolTipEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"IsThumbToolTipEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::IsThumbToolTipEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"OrientationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_SnapsToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"SnapsToProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::SnapsToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_StepFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"StepFrequencyProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::StepFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_ThumbToolTipValueConverterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"ThumbToolTipValueConverterProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::ThumbToolTipValueConverterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickFrequencyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickFrequencyProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::TickFrequencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_TickPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"TickPlacementProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::TickPlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::HeaderProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Slider_get_HeaderTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Slider", L"HeaderTemplateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Slider::HeaderTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Slider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Slider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Slider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Slider[] = {
        { "_assign_array_", _assign_array_Slider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Slider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Slider[] = {
        { "tick_placement", reinterpret_cast<getter>(Slider_get_TickPlacement), reinterpret_cast<setter>(Slider_put_TickPlacement), nullptr, nullptr },
        { "tick_frequency", reinterpret_cast<getter>(Slider_get_TickFrequency), reinterpret_cast<setter>(Slider_put_TickFrequency), nullptr, nullptr },
        { "thumb_tool_tip_value_converter", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverter), reinterpret_cast<setter>(Slider_put_ThumbToolTipValueConverter), nullptr, nullptr },
        { "step_frequency", reinterpret_cast<getter>(Slider_get_StepFrequency), reinterpret_cast<setter>(Slider_put_StepFrequency), nullptr, nullptr },
        { "snaps_to", reinterpret_cast<getter>(Slider_get_SnapsTo), reinterpret_cast<setter>(Slider_put_SnapsTo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(Slider_get_Orientation), reinterpret_cast<setter>(Slider_put_Orientation), nullptr, nullptr },
        { "is_thumb_tool_tip_enabled", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabled), reinterpret_cast<setter>(Slider_put_IsThumbToolTipEnabled), nullptr, nullptr },
        { "is_direction_reversed", reinterpret_cast<getter>(Slider_get_IsDirectionReversed), reinterpret_cast<setter>(Slider_put_IsDirectionReversed), nullptr, nullptr },
        { "intermediate_value", reinterpret_cast<getter>(Slider_get_IntermediateValue), reinterpret_cast<setter>(Slider_put_IntermediateValue), nullptr, nullptr },
        { "header_template", reinterpret_cast<getter>(Slider_get_HeaderTemplate), reinterpret_cast<setter>(Slider_put_HeaderTemplate), nullptr, nullptr },
        { "header", reinterpret_cast<getter>(Slider_get_Header), reinterpret_cast<setter>(Slider_put_Header), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Slider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Slider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Slider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Slider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Slider) },
        { },
    };

    static PyType_Spec type_spec_Slider =
    {
        "winrt._winrt_windows_ui_xaml_controls_.Slider",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Slider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Slider
    };

    static PyGetSetDef getset_Slider_Static[] = {
        { "intermediate_value_property", reinterpret_cast<getter>(Slider_get_IntermediateValueProperty), nullptr, nullptr, nullptr },
        { "is_direction_reversed_property", reinterpret_cast<getter>(Slider_get_IsDirectionReversedProperty), nullptr, nullptr, nullptr },
        { "is_thumb_tool_tip_enabled_property", reinterpret_cast<getter>(Slider_get_IsThumbToolTipEnabledProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(Slider_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "snaps_to_property", reinterpret_cast<getter>(Slider_get_SnapsToProperty), nullptr, nullptr, nullptr },
        { "step_frequency_property", reinterpret_cast<getter>(Slider_get_StepFrequencyProperty), nullptr, nullptr, nullptr },
        { "thumb_tool_tip_value_converter_property", reinterpret_cast<getter>(Slider_get_ThumbToolTipValueConverterProperty), nullptr, nullptr, nullptr },
        { "tick_frequency_property", reinterpret_cast<getter>(Slider_get_TickFrequencyProperty), nullptr, nullptr, nullptr },
        { "tick_placement_property", reinterpret_cast<getter>(Slider_get_TickPlacementProperty), nullptr, nullptr, nullptr },
        { "header_property", reinterpret_cast<getter>(Slider_get_HeaderProperty), nullptr, nullptr, nullptr },
        { "header_template_property", reinterpret_cast<getter>(Slider_get_HeaderTemplateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Slider_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Slider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Slider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Slider_Static) },
        { }
    };

    static PyType_Spec type_spec_Slider_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.Slider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Slider_Static
    };

    // ----- TextCommandBarFlyout class --------------------

    static PyObject* _new_TextCommandBarFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextCommandBarFlyout(py::wrapper::Windows::UI::Xaml::Controls::TextCommandBarFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextCommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextCommandBarFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TextCommandBarFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextCommandBarFlyout[] = {
        { "_assign_array_", _assign_array_TextCommandBarFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextCommandBarFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextCommandBarFlyout[] = {
        { }
    };

    static PyType_Slot _type_slots_TextCommandBarFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextCommandBarFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextCommandBarFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextCommandBarFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextCommandBarFlyout) },
        { },
    };

    static PyType_Spec type_spec_TextCommandBarFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.TextCommandBarFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TextCommandBarFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextCommandBarFlyout
    };

    // ----- TimePickerFlyout class --------------------

    static PyObject* _new_TimePickerFlyout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TimePickerFlyout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimePickerFlyout(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimePickerFlyout_ShowAtAsync(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ShowAtAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(self->obj.ShowAtAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_get_Time(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"Time"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimePickerFlyout_put_Time(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"Time"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Time(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimePickerFlyout_get_MinuteIncrement(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"MinuteIncrement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinuteIncrement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimePickerFlyout_put_MinuteIncrement(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"MinuteIncrement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MinuteIncrement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimePickerFlyout_get_ClockIdentifier(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ClockIdentifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClockIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimePickerFlyout_put_ClockIdentifier(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ClockIdentifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ClockIdentifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimePickerFlyout_get_ClockIdentifierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"ClockIdentifierProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TimePickerFlyout::ClockIdentifierProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_get_MinuteIncrementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"MinuteIncrementProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TimePickerFlyout::MinuteIncrementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_get_TimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"TimeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TimePickerFlyout::TimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_add_TimePicked(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"TimePicked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::TimePickerFlyout, winrt::Windows::UI::Xaml::Controls::TimePickedEventArgs>>(arg);

            return py::convert(self->obj.TimePicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimePickerFlyout_remove_TimePicked(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.TimePickerFlyout", L"TimePicked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimePicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TimePickerFlyout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerFlyout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TimePickerFlyout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerFlyout[] = {
        { "show_at_async", reinterpret_cast<PyCFunction>(TimePickerFlyout_ShowAtAsync), METH_VARARGS, nullptr },
        { "add_time_picked", reinterpret_cast<PyCFunction>(TimePickerFlyout_add_TimePicked), METH_O, nullptr },
        { "remove_time_picked", reinterpret_cast<PyCFunction>(TimePickerFlyout_remove_TimePicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_TimePickerFlyout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerFlyout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerFlyout[] = {
        { "time", reinterpret_cast<getter>(TimePickerFlyout_get_Time), reinterpret_cast<setter>(TimePickerFlyout_put_Time), nullptr, nullptr },
        { "minute_increment", reinterpret_cast<getter>(TimePickerFlyout_get_MinuteIncrement), reinterpret_cast<setter>(TimePickerFlyout_put_MinuteIncrement), nullptr, nullptr },
        { "clock_identifier", reinterpret_cast<getter>(TimePickerFlyout_get_ClockIdentifier), reinterpret_cast<setter>(TimePickerFlyout_put_ClockIdentifier), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimePickerFlyout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerFlyout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerFlyout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerFlyout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerFlyout) },
        { },
    };

    static PyType_Spec type_spec_TimePickerFlyout =
    {
        "winrt._winrt_windows_ui_xaml_controls_.TimePickerFlyout",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TimePickerFlyout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerFlyout
    };

    static PyGetSetDef getset_TimePickerFlyout_Static[] = {
        { "clock_identifier_property", reinterpret_cast<getter>(TimePickerFlyout_get_ClockIdentifierProperty), nullptr, nullptr, nullptr },
        { "minute_increment_property", reinterpret_cast<getter>(TimePickerFlyout_get_MinuteIncrementProperty), nullptr, nullptr, nullptr },
        { "time_property", reinterpret_cast<getter>(TimePickerFlyout_get_TimeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TimePickerFlyout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TimePickerFlyout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimePickerFlyout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimePickerFlyout_Static) },
        { }
    };

    static PyType_Spec type_spec_TimePickerFlyout_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.TimePickerFlyout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimePickerFlyout_Static
    };

    // ----- TreeViewItem class --------------------

    static PyObject* _new_TreeViewItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TreeViewItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItem(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItem_get_IsExpanded(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpanded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExpanded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_IsExpanded(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpanded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExpanded(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSize(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlyphSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphSize(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlyphSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacity(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlyphOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphOpacity(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlyphOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrush(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlyphBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_GlyphBrush(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.GlyphBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ExpandedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyph"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExpandedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CollapsedGlyph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_CollapsedGlyph(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyph"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CollapsedGlyph(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TreeViewItemTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildren(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasUnrealizedChildren());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TreeViewItem_put_HasUnrealizedChildren(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildren"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.HasUnrealizedChildren(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TreeViewItem_get_CollapsedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"CollapsedGlyphProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::CollapsedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ExpandedGlyphProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ExpandedGlyphProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::ExpandedGlyphProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphBrushProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphOpacityProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_GlyphSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"GlyphSizeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::GlyphSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_IsExpandedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"IsExpandedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::IsExpandedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_TreeViewItemTemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"TreeViewItemTemplateSettingsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::TreeViewItemTemplateSettingsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_HasUnrealizedChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"HasUnrealizedChildrenProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::HasUnrealizedChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TreeViewItem_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.TreeViewItem", L"ItemsSourceProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::TreeViewItem::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TreeViewItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TreeViewItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItem[] = {
        { "_assign_array_", _assign_array_TreeViewItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItem[] = {
        { "is_expanded", reinterpret_cast<getter>(TreeViewItem_get_IsExpanded), reinterpret_cast<setter>(TreeViewItem_put_IsExpanded), nullptr, nullptr },
        { "glyph_size", reinterpret_cast<getter>(TreeViewItem_get_GlyphSize), reinterpret_cast<setter>(TreeViewItem_put_GlyphSize), nullptr, nullptr },
        { "glyph_opacity", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacity), reinterpret_cast<setter>(TreeViewItem_put_GlyphOpacity), nullptr, nullptr },
        { "glyph_brush", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrush), reinterpret_cast<setter>(TreeViewItem_put_GlyphBrush), nullptr, nullptr },
        { "expanded_glyph", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyph), reinterpret_cast<setter>(TreeViewItem_put_ExpandedGlyph), nullptr, nullptr },
        { "collapsed_glyph", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyph), reinterpret_cast<setter>(TreeViewItem_put_CollapsedGlyph), nullptr, nullptr },
        { "tree_view_item_template_settings", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettings), nullptr, nullptr, nullptr },
        { "items_source", reinterpret_cast<getter>(TreeViewItem_get_ItemsSource), reinterpret_cast<setter>(TreeViewItem_put_ItemsSource), nullptr, nullptr },
        { "has_unrealized_children", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildren), reinterpret_cast<setter>(TreeViewItem_put_HasUnrealizedChildren), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItem) },
        { },
    };

    static PyType_Spec type_spec_TreeViewItem =
    {
        "winrt._winrt_windows_ui_xaml_controls_.TreeViewItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TreeViewItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItem
    };

    static PyGetSetDef getset_TreeViewItem_Static[] = {
        { "collapsed_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_CollapsedGlyphProperty), nullptr, nullptr, nullptr },
        { "expanded_glyph_property", reinterpret_cast<getter>(TreeViewItem_get_ExpandedGlyphProperty), nullptr, nullptr, nullptr },
        { "glyph_brush_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphBrushProperty), nullptr, nullptr, nullptr },
        { "glyph_opacity_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphOpacityProperty), nullptr, nullptr, nullptr },
        { "glyph_size_property", reinterpret_cast<getter>(TreeViewItem_get_GlyphSizeProperty), nullptr, nullptr, nullptr },
        { "is_expanded_property", reinterpret_cast<getter>(TreeViewItem_get_IsExpandedProperty), nullptr, nullptr, nullptr },
        { "tree_view_item_template_settings_property", reinterpret_cast<getter>(TreeViewItem_get_TreeViewItemTemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "has_unrealized_children_property", reinterpret_cast<getter>(TreeViewItem_get_HasUnrealizedChildrenProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(TreeViewItem_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TreeViewItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItem_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.TreeViewItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewItem_Static
    };

    // ----- TreeViewList class --------------------

    static PyObject* _new_TreeViewList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::TreeViewList instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewList(py::wrapper::Windows::UI::Xaml::Controls::TreeViewList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::TreeViewList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::TreeViewList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewList[] = {
        { "_assign_array_", _assign_array_TreeViewList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewList[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewList) },
        { },
    };

    static PyType_Spec type_spec_TreeViewList =
    {
        "winrt._winrt_windows_ui_xaml_controls_.TreeViewList",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::TreeViewList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewList
    };

    // ----- VirtualizingStackPanel class --------------------

    static PyObject* _new_VirtualizingStackPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualizingStackPanel(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VirtualizingStackPanel_GetIsVirtualizing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"GetIsVirtualizing", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::GetIsVirtualizing(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_GetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"GetVirtualizationMode", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::GetVirtualizationMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_SetVirtualizationMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"SetVirtualizationMode", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::VirtualizationMode>(args, 1);

                winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::SetVirtualizationMode(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreScrollSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VirtualizingStackPanel_put_AreScrollSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegular"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreScrollSnapPointsRegular(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"AreScrollSnapPointsRegularProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::AreScrollSnapPointsRegularProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_IsVirtualizingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"IsVirtualizingProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::IsVirtualizingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"OrientationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_get_VirtualizationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"VirtualizationModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel::VirtualizationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CleanUpVirtualizedItemEventHandler>(arg);

            return py::convert(self->obj.CleanUpVirtualizedItemEvent(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.VirtualizingStackPanel", L"CleanUpVirtualizedItemEvent"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CleanUpVirtualizedItemEvent(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualizingStackPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::VirtualizingStackPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualizingStackPanel[] = {
        { "add_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_add_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "remove_clean_up_virtualized_item_event", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_remove_CleanUpVirtualizedItemEvent), METH_O, nullptr },
        { "_assign_array_", _assign_array_VirtualizingStackPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualizingStackPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VirtualizingStackPanel[] = {
        { "orientation", reinterpret_cast<getter>(VirtualizingStackPanel_get_Orientation), reinterpret_cast<setter>(VirtualizingStackPanel_put_Orientation), nullptr, nullptr },
        { "are_scroll_snap_points_regular", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegular), reinterpret_cast<setter>(VirtualizingStackPanel_put_AreScrollSnapPointsRegular), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VirtualizingStackPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualizingStackPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualizingStackPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualizingStackPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualizingStackPanel) },
        { },
    };

    static PyType_Spec type_spec_VirtualizingStackPanel =
    {
        "winrt._winrt_windows_ui_xaml_controls_.VirtualizingStackPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::VirtualizingStackPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VirtualizingStackPanel
    };

    static PyGetSetDef getset_VirtualizingStackPanel_Static[] = {
        { "are_scroll_snap_points_regular_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_AreScrollSnapPointsRegularProperty), nullptr, nullptr, nullptr },
        { "is_virtualizing_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_IsVirtualizingProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "virtualization_mode_property", reinterpret_cast<getter>(VirtualizingStackPanel_get_VirtualizationModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_VirtualizingStackPanel_Static[] = {
        { "get_is_virtualizing", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetIsVirtualizing), METH_VARARGS, nullptr },
        { "get_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_GetVirtualizationMode), METH_VARARGS, nullptr },
        { "set_virtualization_mode", reinterpret_cast<PyCFunction>(VirtualizingStackPanel_SetVirtualizationMode), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VirtualizingStackPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VirtualizingStackPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VirtualizingStackPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_VirtualizingStackPanel_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.VirtualizingStackPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VirtualizingStackPanel_Static
    };

    // ----- WrapGrid class --------------------

    static PyObject* _new_WrapGrid(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::WrapGrid instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WrapGrid(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_VerticalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumns(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaximumRowsOrColumns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_MaximumRowsOrColumns(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumns"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaximumRowsOrColumns(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ItemHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalChildrenAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WrapGrid_put_HorizontalChildrenAlignment(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalChildrenAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WrapGrid_get_HorizontalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"HorizontalChildrenAlignmentProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::HorizontalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemHeightProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::ItemHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"ItemWidthProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::ItemWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_MaximumRowsOrColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"MaximumRowsOrColumnsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::MaximumRowsOrColumnsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"OrientationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WrapGrid_get_VerticalChildrenAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.WrapGrid", L"VerticalChildrenAlignmentProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::WrapGrid::VerticalChildrenAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::WrapGrid>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WrapGrid(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::WrapGrid>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WrapGrid[] = {
        { "_assign_array_", _assign_array_WrapGrid, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WrapGrid), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WrapGrid[] = {
        { "vertical_children_alignment", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_VerticalChildrenAlignment), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(WrapGrid_get_Orientation), reinterpret_cast<setter>(WrapGrid_put_Orientation), nullptr, nullptr },
        { "maximum_rows_or_columns", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumns), reinterpret_cast<setter>(WrapGrid_put_MaximumRowsOrColumns), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(WrapGrid_get_ItemWidth), reinterpret_cast<setter>(WrapGrid_put_ItemWidth), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(WrapGrid_get_ItemHeight), reinterpret_cast<setter>(WrapGrid_put_ItemHeight), nullptr, nullptr },
        { "horizontal_children_alignment", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignment), reinterpret_cast<setter>(WrapGrid_put_HorizontalChildrenAlignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WrapGrid[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WrapGrid) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WrapGrid) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WrapGrid) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WrapGrid) },
        { },
    };

    static PyType_Spec type_spec_WrapGrid =
    {
        "winrt._winrt_windows_ui_xaml_controls_.WrapGrid",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::WrapGrid),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WrapGrid
    };

    static PyGetSetDef getset_WrapGrid_Static[] = {
        { "horizontal_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_HorizontalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { "item_height_property", reinterpret_cast<getter>(WrapGrid_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(WrapGrid_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "maximum_rows_or_columns_property", reinterpret_cast<getter>(WrapGrid_get_MaximumRowsOrColumnsProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(WrapGrid_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "vertical_children_alignment_property", reinterpret_cast<getter>(WrapGrid_get_VerticalChildrenAlignmentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WrapGrid_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WrapGrid_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WrapGrid_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WrapGrid_Static) },
        { }
    };

    static PyType_Spec type_spec_WrapGrid_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_.WrapGrid_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WrapGrid_Static
    };

    // ----- Windows.UI.Xaml.Controls Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Controls");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_controls_",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Controls

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_controls_(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Controls;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBar_Static{PyType_FromSpec(&type_spec_ProgressBar_Static)};
    if (!type_ProgressBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBar_type{py::register_python_type(module.get(), &type_spec_ProgressBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBar_Static.get()))};
    if (!ProgressBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Slider_Static{PyType_FromSpec(&type_spec_Slider_Static)};
    if (!type_Slider_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Slider_type{py::register_python_type(module.get(), &type_spec_Slider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Slider_Static.get()))};
    if (!Slider_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuFlyout_Static{PyType_FromSpec(&type_spec_MenuFlyout_Static)};
    if (!type_MenuFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyout_type{py::register_python_type(module.get(), &type_spec_MenuFlyout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuFlyout_Static.get()))};
    if (!MenuFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuBarItemFlyout_type{py::register_python_type(module.get(), &type_spec_MenuBarItemFlyout, object_bases.get(), nullptr)};
    if (!MenuBarItemFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItem_type{py::register_python_type(module.get(), &type_spec_ListViewItem, object_bases.get(), nullptr)};
    if (!ListViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItem_Static{PyType_FromSpec(&type_spec_TreeViewItem_Static)};
    if (!type_TreeViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewItem_type{py::register_python_type(module.get(), &type_spec_TreeViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItem_Static.get()))};
    if (!TreeViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemBase_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemBase, object_bases.get(), nullptr)};
    if (!NavigationViewItemBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemSeparator_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemSeparator, object_bases.get(), nullptr)};
    if (!NavigationViewItemSeparator_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemHeader_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemHeader, object_bases.get(), nullptr)};
    if (!NavigationViewItemHeader_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItem_Static{PyType_FromSpec(&type_spec_NavigationViewItem_Static)};
    if (!type_NavigationViewItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItem_type{py::register_python_type(module.get(), &type_spec_NavigationViewItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItem_Static.get()))};
    if (!NavigationViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListBoxItem_type{py::register_python_type(module.get(), &type_spec_ListBoxItem, object_bases.get(), nullptr)};
    if (!ListBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBox_Static{PyType_FromSpec(&type_spec_ListBox_Static)};
    if (!type_ListBox_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListBox_type{py::register_python_type(module.get(), &type_spec_ListBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBox_Static.get()))};
    if (!ListBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarMenuButton_Static{PyType_FromSpec(&type_spec_InkToolbarMenuButton_Static)};
    if (!type_InkToolbarMenuButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarMenuButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarMenuButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarMenuButton_Static.get()))};
    if (!InkToolbarMenuButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarStencilButton_Static{PyType_FromSpec(&type_spec_InkToolbarStencilButton_Static)};
    if (!type_InkToolbarStencilButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarStencilButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarStencilButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarStencilButton_Static.get()))};
    if (!InkToolbarStencilButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarFlyoutItem_Static{PyType_FromSpec(&type_spec_InkToolbarFlyoutItem_Static)};
    if (!type_InkToolbarFlyoutItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarFlyoutItem_type{py::register_python_type(module.get(), &type_spec_InkToolbarFlyoutItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarFlyoutItem_Static.get()))};
    if (!InkToolbarFlyoutItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButton_Static{PyType_FromSpec(&type_spec_RadioButton_Static)};
    if (!type_RadioButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RadioButton_type{py::register_python_type(module.get(), &type_spec_RadioButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButton_Static.get()))};
    if (!RadioButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarToolButton_Static{PyType_FromSpec(&type_spec_InkToolbarToolButton_Static)};
    if (!type_InkToolbarToolButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarToolButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarToolButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarToolButton_Static.get()))};
    if (!InkToolbarToolButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarPenButton_Static{PyType_FromSpec(&type_spec_InkToolbarPenButton_Static)};
    if (!type_InkToolbarPenButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarPenButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarPenButton_Static.get()))};
    if (!InkToolbarPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarPencilButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarPencilButton, object_bases.get(), nullptr)};
    if (!InkToolbarPencilButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarHighlighterButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarHighlighterButton, object_bases.get(), nullptr)};
    if (!InkToolbarHighlighterButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomPenButton_Static{PyType_FromSpec(&type_spec_InkToolbarCustomPenButton_Static)};
    if (!type_InkToolbarCustomPenButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomPenButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomPenButton_Static.get()))};
    if (!InkToolbarCustomPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarBallpointPenButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarBallpointPenButton, object_bases.get(), nullptr)};
    if (!InkToolbarBallpointPenButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarEraserButton_Static{PyType_FromSpec(&type_spec_InkToolbarEraserButton_Static)};
    if (!type_InkToolbarEraserButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarEraserButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarEraserButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarEraserButton_Static.get()))};
    if (!InkToolbarEraserButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarCustomToolButton_Static{PyType_FromSpec(&type_spec_InkToolbarCustomToolButton_Static)};
    if (!type_InkToolbarCustomToolButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomToolButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomToolButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarCustomToolButton_Static.get()))};
    if (!InkToolbarCustomToolButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_HyperlinkButton_Static{PyType_FromSpec(&type_spec_HyperlinkButton_Static)};
    if (!type_HyperlinkButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkButton_type{py::register_python_type(module.get(), &type_spec_HyperlinkButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HyperlinkButton_Static.get()))};
    if (!HyperlinkButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItem_type{py::register_python_type(module.get(), &type_spec_GridViewItem, object_bases.get(), nullptr)};
    if (!GridViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBase_Static{PyType_FromSpec(&type_spec_ListViewBase_Static)};
    if (!type_ListViewBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewBase_type{py::register_python_type(module.get(), &type_spec_ListViewBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBase_Static.get()))};
    if (!ListViewBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListView_type{py::register_python_type(module.get(), &type_spec_ListView, object_bases.get(), nullptr)};
    if (!ListView_type)
    {
        return nullptr;
    }

    py::pyobj_handle TreeViewList_type{py::register_python_type(module.get(), &type_spec_TreeViewList, object_bases.get(), nullptr)};
    if (!TreeViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewList_type{py::register_python_type(module.get(), &type_spec_NavigationViewList, object_bases.get(), nullptr)};
    if (!NavigationViewList_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridView_type{py::register_python_type(module.get(), &type_spec_GridView, object_bases.get(), nullptr)};
    if (!GridView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Flyout_Static{PyType_FromSpec(&type_spec_Flyout_Static)};
    if (!type_Flyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Flyout_type{py::register_python_type(module.get(), &type_spec_Flyout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Flyout_Static.get()))};
    if (!Flyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlipViewItem_type{py::register_python_type(module.get(), &type_spec_FlipViewItem, object_bases.get(), nullptr)};
    if (!FlipViewItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipView_Static{PyType_FromSpec(&type_spec_FlipView_Static)};
    if (!type_FlipView_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlipView_type{py::register_python_type(module.get(), &type_spec_FlipView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipView_Static.get()))};
    if (!FlipView_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyout_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyout, object_bases.get(), nullptr)};
    if (!CommandBarFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextCommandBarFlyout_type{py::register_python_type(module.get(), &type_spec_TextCommandBarFlyout, object_bases.get(), nullptr)};
    if (!TextCommandBarFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxItem_type{py::register_python_type(module.get(), &type_spec_ComboBoxItem, object_bases.get(), nullptr)};
    if (!ComboBoxItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBox_Static{PyType_FromSpec(&type_spec_ComboBox_Static)};
    if (!type_ComboBox_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBox_type{py::register_python_type(module.get(), &type_spec_ComboBox, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBox_Static.get()))};
    if (!ComboBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle CheckBox_type{py::register_python_type(module.get(), &type_spec_CheckBox, object_bases.get(), nullptr)};
    if (!CheckBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarToggleButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarToggleButton, object_bases.get(), nullptr)};
    if (!InkToolbarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkToolbarRulerButton_Static{PyType_FromSpec(&type_spec_InkToolbarRulerButton_Static)};
    if (!type_InkToolbarRulerButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarRulerButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarRulerButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkToolbarRulerButton_Static.get()))};
    if (!InkToolbarRulerButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle InkToolbarCustomToggleButton_type{py::register_python_type(module.get(), &type_spec_InkToolbarCustomToggleButton, object_bases.get(), nullptr)};
    if (!InkToolbarCustomToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarToggleButton_Static{PyType_FromSpec(&type_spec_AppBarToggleButton_Static)};
    if (!type_AppBarToggleButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButton_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarToggleButton_Static.get()))};
    if (!AppBarToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Button_Static{PyType_FromSpec(&type_spec_Button_Static)};
    if (!type_Button_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Button_type{py::register_python_type(module.get(), &type_spec_Button, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Button_Static.get()))};
    if (!Button_type)
    {
        return nullptr;
    }

    py::pyobj_handle DropDownButton_type{py::register_python_type(module.get(), &type_spec_DropDownButton, object_bases.get(), nullptr)};
    if (!DropDownButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarButton_Static{PyType_FromSpec(&type_spec_AppBarButton_Static)};
    if (!type_AppBarButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButton_type{py::register_python_type(module.get(), &type_spec_AppBarButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarButton_Static.get()))};
    if (!AppBarButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DatePickerFlyout_Static{PyType_FromSpec(&type_spec_DatePickerFlyout_Static)};
    if (!type_DatePickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DatePickerFlyout_type{py::register_python_type(module.get(), &type_spec_DatePickerFlyout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DatePickerFlyout_Static.get()))};
    if (!DatePickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListPickerFlyout_Static{PyType_FromSpec(&type_spec_ListPickerFlyout_Static)};
    if (!type_ListPickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListPickerFlyout_type{py::register_python_type(module.get(), &type_spec_ListPickerFlyout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListPickerFlyout_Static.get()))};
    if (!ListPickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PickerFlyout_Static{PyType_FromSpec(&type_spec_PickerFlyout_Static)};
    if (!type_PickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyout_type{py::register_python_type(module.get(), &type_spec_PickerFlyout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PickerFlyout_Static.get()))};
    if (!PickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimePickerFlyout_Static{PyType_FromSpec(&type_spec_TimePickerFlyout_Static)};
    if (!type_TimePickerFlyout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TimePickerFlyout_type{py::register_python_type(module.get(), &type_spec_TimePickerFlyout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimePickerFlyout_Static.get()))};
    if (!TimePickerFlyout_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_VirtualizingStackPanel_Static{PyType_FromSpec(&type_spec_VirtualizingStackPanel_Static)};
    if (!type_VirtualizingStackPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualizingStackPanel_type{py::register_python_type(module.get(), &type_spec_VirtualizingStackPanel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VirtualizingStackPanel_Static.get()))};
    if (!VirtualizingStackPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WrapGrid_Static{PyType_FromSpec(&type_spec_WrapGrid_Static)};
    if (!type_WrapGrid_Static)
    {
        return nullptr;
    }

    py::pyobj_handle WrapGrid_type{py::register_python_type(module.get(), &type_spec_WrapGrid, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WrapGrid_Static.get()))};
    if (!WrapGrid_type)
    {
        return nullptr;
    }


    return module.detach();
}
